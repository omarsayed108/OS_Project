
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 70 19 00 	lgdtl  0x197018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 70 19 f0       	mov    $0xf0197000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 10 00 00 00       	call   f010004d <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	8b 45 08             	mov    0x8(%ebp),%eax
f0100045:	a3 88 51 96 f1       	mov    %eax,0xf1965188
f010004a:	90                   	nop
f010004b:	5d                   	pop    %ebp
f010004c:	c3                   	ret    

f010004d <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
extern bool __autograde__ ;
void FOS_initialize()
{
f010004d:	55                   	push   %ebp
f010004e:	89 e5                	mov    %esp,%ebp
f0100050:	57                   	push   %edi
f0100051:	56                   	push   %esi
f0100052:	53                   	push   %ebx
f0100053:	81 ec 2c 20 00 00    	sub    $0x202c,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100059:	ba d0 85 9a f1       	mov    $0xf19a85d0,%edx
f010005e:	b8 c8 3d 92 f0       	mov    $0xf0923dc8,%eax
f0100063:	29 c2                	sub    %eax,%edx
f0100065:	89 d0                	mov    %edx,%eax
f0100067:	83 ec 04             	sub    $0x4,%esp
f010006a:	50                   	push   %eax
f010006b:	6a 00                	push   $0x0
f010006d:	68 c8 3d 92 f0       	push   $0xf0923dc8
f0100072:	e8 a6 2f 02 00       	call   f012301d <memset>
f0100077:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f010007a:	e8 5d 19 00 00       	call   f01019dc <cons_init>
		//print welcome message
		print_welcome_message();
f010007f:	e8 b2 0d 00 00       	call   f0100e36 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100084:	83 ec 0c             	sub    $0xc,%esp
f0100087:	68 a0 4a 12 f0       	push   $0xf0124aa0
f010008c:	e8 bc 1a 00 00       	call   f0101b4d <cprintf>
f0100091:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f0100094:	83 ec 0c             	sub    $0xc,%esp
f0100097:	68 e7 4a 12 f0       	push   $0xf0124ae7
f010009c:	e8 ac 1a 00 00       	call   f0101b4d <cprintf>
f01000a1:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000a4:	83 ec 0c             	sub    $0xc,%esp
f01000a7:	68 fb 4a 12 f0       	push   $0xf0124afb
f01000ac:	e8 9c 1a 00 00       	call   f0101b4d <cprintf>
f01000b1:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000b4:	83 ec 0c             	sub    $0xc,%esp
f01000b7:	68 0f 4b 12 f0       	push   $0xf0124b0f
f01000bc:	e8 8c 1a 00 00       	call   f0101b4d <cprintf>
f01000c1:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000c4:	83 ec 0c             	sub    $0xc,%esp
f01000c7:	6a 00                	push   $0x0
f01000c9:	e8 3b 84 00 00       	call   f0108509 <cpu_init>
f01000ce:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000d1:	83 ec 0c             	sub    $0xc,%esp
f01000d4:	68 1b 4b 12 f0       	push   $0xf0124b1b
f01000d9:	e8 6f 1a 00 00       	call   f0101b4d <cprintf>
f01000de:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000e1:	83 ec 0c             	sub    $0xc,%esp
f01000e4:	68 23 4b 12 f0       	push   $0xf0124b23
f01000e9:	e8 5f 1a 00 00       	call   f0101b4d <cprintf>
f01000ee:	83 c4 10             	add    $0x10,%esp
	{
		detect_memory();
f01000f1:	e8 88 8d 00 00       	call   f0108e7e <detect_memory>
		initialize_kernel_VM();
f01000f6:	e8 21 89 00 00       	call   f0108a1c <initialize_kernel_VM>
		initialize_paging();
f01000fb:	e8 ef 90 00 00       	call   f01091ef <initialize_paging>
#if USE_KHEAP
		kheap_init();
f0100100:	e8 5d ac 00 00       	call   f010ad62 <kheap_init>
		sharing_init();
f0100105:	e8 c7 9d 00 00       	call   f0109ed1 <sharing_init>
#endif
		fault_handler_init();
f010010a:	e8 6f 16 01 00       	call   f011177e <fault_handler_init>
		set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f010010f:	83 ec 0c             	sub    $0xc,%esp
f0100112:	6a 05                	push   $0x5
f0100114:	e8 26 ff ff ff       	call   f010003f <set_uheap_strategy>
f0100119:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) DISK...");
f010011c:	83 ec 0c             	sub    $0xc,%esp
f010011f:	68 31 4b 12 f0       	push   $0xf0124b31
f0100124:	e8 24 1a 00 00       	call   f0101b4d <cprintf>
f0100129:	83 c4 10             	add    $0x10,%esp
	{
		ide_init();
f010012c:	e8 2c 35 02 00       	call   f012365d <ide_init>
	}
	cprintf("[DONE]\n");
f0100131:	83 ec 0c             	sub    $0xc,%esp
f0100134:	68 1b 4b 12 f0       	push   $0xf0124b1b
f0100139:	e8 0f 1a 00 00       	call   f0101b4d <cprintf>
f010013e:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) USER ENVs...");
f0100141:	83 ec 0c             	sub    $0xc,%esp
f0100144:	68 3e 4b 12 f0       	push   $0xf0124b3e
f0100149:	e8 ff 19 00 00       	call   f0101b4d <cprintf>
f010014e:	83 c4 10             	add    $0x10,%esp
	{
		env_init();
f0100151:	e8 a0 c7 00 00       	call   f010c8f6 <env_init>
		ts_init();
f0100156:	e8 2e eb 00 00       	call   f010ec89 <ts_init>
	}
	cprintf("[DONE]\n");
f010015b:	83 ec 0c             	sub    $0xc,%esp
f010015e:	68 1b 4b 12 f0       	push   $0xf0124b1b
f0100163:	e8 e5 19 00 00       	call   f0101b4d <cprintf>
f0100168:	83 c4 10             	add    $0x10,%esp

	cprintf("* 5) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f010016b:	83 ec 0c             	sub    $0xc,%esp
f010016e:	68 50 4b 12 f0       	push   $0xf0124b50
f0100173:	e8 d5 19 00 00       	call   f0101b4d <cprintf>
f0100178:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f010017b:	e8 75 80 00 00       	call   f01081f5 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100180:	83 ec 0c             	sub    $0xc,%esp
f0100183:	68 79 4b 12 f0       	push   $0xf0124b79
f0100188:	e8 c0 19 00 00       	call   f0101b4d <cprintf>
f010018d:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100190:	83 ec 0c             	sub    $0xc,%esp
f0100193:	6a 00                	push   $0x0
f0100195:	e8 4d 82 00 00       	call   f01083e7 <irq_clear_mask>
f010019a:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f010019d:	83 ec 0c             	sub    $0xc,%esp
f01001a0:	68 8f 4b 12 f0       	push   $0xf0124b8f
f01001a5:	e8 a3 19 00 00       	call   f0101b4d <cprintf>
f01001aa:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001ad:	83 ec 0c             	sub    $0xc,%esp
f01001b0:	6a 01                	push   $0x1
f01001b2:	e8 30 82 00 00       	call   f01083e7 <irq_clear_mask>
f01001b7:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001ba:	83 ec 0c             	sub    $0xc,%esp
f01001bd:	68 ac 4b 12 f0       	push   $0xf0124bac
f01001c2:	e8 86 19 00 00       	call   f0101b4d <cprintf>
f01001c7:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001ca:	83 ec 0c             	sub    $0xc,%esp
f01001cd:	6a 04                	push   $0x4
f01001cf:	e8 13 82 00 00       	call   f01083e7 <irq_clear_mask>
f01001d4:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001d7:	83 ec 0c             	sub    $0xc,%esp
f01001da:	68 cb 4b 12 f0       	push   $0xf0124bcb
f01001df:	e8 69 19 00 00       	call   f0101b4d <cprintf>
f01001e4:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
		irq_clear_mask(14);
f01001e7:	83 ec 0c             	sub    $0xc,%esp
f01001ea:	6a 0e                	push   $0xe
f01001ec:	e8 f6 81 00 00       	call   f01083e7 <irq_clear_mask>
f01001f1:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
f01001f4:	83 ec 0c             	sub    $0xc,%esp
f01001f7:	68 e8 4b 12 f0       	push   $0xf0124be8
f01001fc:	e8 4c 19 00 00       	call   f0101b4d <cprintf>
f0100201:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("* 6) SCHEDULER & MULTI-TASKING:\n");
f0100204:	83 ec 0c             	sub    $0xc,%esp
f0100207:	68 18 4c 12 f0       	push   $0xf0124c18
f010020c:	e8 3c 19 00 00       	call   f0101b4d <cprintf>
f0100211:	83 c4 10             	add    $0x10,%esp
	{
		kclock_init();
f0100214:	e8 4a 5a 00 00       	call   f0105c63 <kclock_init>
		sched_init() ;
f0100219:	e8 81 76 00 00       	call   f010789f <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 7) ESP to SCHED KERN STACK:\n");
f010021e:	83 ec 0c             	sub    $0xc,%esp
f0100221:	68 3c 4c 12 f0       	push   $0xf0124c3c
f0100226:	e8 22 19 00 00       	call   f0101b4d <cprintf>
f010022b:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010022e:	89 e0                	mov    %esp,%eax
f0100230:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return esp;
f0100233:	8b 45 d8             	mov    -0x28(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100236:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100239:	b8 00 70 19 f0       	mov    $0xf0197000,%eax
f010023e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0100241:	89 45 e0             	mov    %eax,-0x20(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100244:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100249:	2b 45 e0             	sub    -0x20(%ebp),%eax
f010024c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010024f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100252:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100255:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100258:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010025a:	89 e0                	mov    %esp,%eax
f010025c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return esp;
f010025f:	8b 45 d0             	mov    -0x30(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f0100262:	83 ec 04             	sub    $0x4,%esp
f0100265:	50                   	push   %eax
f0100266:	ff 75 e4             	pushl  -0x1c(%ebp)
f0100269:	68 5c 4c 12 f0       	push   $0xf0124c5c
f010026e:	e8 da 18 00 00       	call   f0101b4d <cprintf>
f0100273:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");
	cprintf("********************************************************************\n");
f0100276:	83 ec 0c             	sub    $0xc,%esp
f0100279:	68 80 4c 12 f0       	push   $0xf0124c80
f010027e:	e8 ca 18 00 00       	call   f0101b4d <cprintf>
f0100283:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f0100286:	83 ec 0c             	sub    $0xc,%esp
f0100289:	68 c8 4c 12 f0       	push   $0xf0124cc8
f010028e:	e8 ba 18 00 00       	call   f0101b4d <cprintf>
f0100293:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f0100296:	83 ec 0c             	sub    $0xc,%esp
f0100299:	68 f4 4c 12 f0       	push   $0xf0124cf4
f010029e:	e8 aa 18 00 00       	call   f0101b4d <cprintf>
f01002a3:	83 c4 10             	add    $0x10,%esp
		if (__autograde__)
f01002a6:	a1 20 70 19 f0       	mov    0xf0197020,%eax
f01002ab:	85 c0                	test   %eax,%eax
f01002ad:	0f 84 7e 0b 00 00    	je     f0100e31 <FOS_initialize+0xde4>
			/*CHECK THE FOLLOWING:
			 * 1) time of each test
			 * 2) "unhandled trap in" message
			 */

			cprintf("\nPROJECT Automatic testing is STARTED...\n") ;
f01002b3:	83 ec 0c             	sub    $0xc,%esp
f01002b6:	68 1c 4d 12 f0       	push   $0xf0124d1c
f01002bb:	e8 8d 18 00 00       	call   f0101b4d <cprintf>
f01002c0:	83 c4 10             	add    $0x10,%esp

			//TEST#1: DYNAMIC ALLOCATOR
			{
				char cmd1[BUFLEN] = "tst dynalloc init";
f01002c3:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01002c9:	bb 6c 4d 12 f0       	mov    $0xf0124d6c,%ebx
f01002ce:	ba 12 00 00 00       	mov    $0x12,%edx
f01002d3:	89 c7                	mov    %eax,%edi
f01002d5:	89 de                	mov    %ebx,%esi
f01002d7:	89 d1                	mov    %edx,%ecx
f01002d9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01002db:	8d 95 e2 ef ff ff    	lea    -0x101e(%ebp),%edx
f01002e1:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f01002e6:	b0 00                	mov    $0x0,%al
f01002e8:	89 d7                	mov    %edx,%edi
f01002ea:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst dynalloc alloc";
f01002ec:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01002f2:	bb 6c 51 12 f0       	mov    $0xf012516c,%ebx
f01002f7:	ba 13 00 00 00       	mov    $0x13,%edx
f01002fc:	89 c7                	mov    %eax,%edi
f01002fe:	89 de                	mov    %ebx,%esi
f0100300:	89 d1                	mov    %edx,%ecx
f0100302:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100304:	8d 95 e3 f3 ff ff    	lea    -0xc1d(%ebp),%edx
f010030a:	b9 ed 03 00 00       	mov    $0x3ed,%ecx
f010030f:	b0 00                	mov    $0x0,%al
f0100311:	89 d7                	mov    %edx,%edi
f0100313:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst dynalloc free";
f0100315:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f010031b:	bb 6c 55 12 f0       	mov    $0xf012556c,%ebx
f0100320:	ba 12 00 00 00       	mov    $0x12,%edx
f0100325:	89 c7                	mov    %eax,%edi
f0100327:	89 de                	mov    %ebx,%esi
f0100329:	89 d1                	mov    %edx,%ecx
f010032b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010032d:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100333:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100338:	b0 00                	mov    $0x0,%al
f010033a:	89 d7                	mov    %edx,%edi
f010033c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst dynalloc realloc";
f010033e:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100344:	bb 6c 59 12 f0       	mov    $0xf012596c,%ebx
f0100349:	ba 15 00 00 00       	mov    $0x15,%edx
f010034e:	89 c7                	mov    %eax,%edi
f0100350:	89 de                	mov    %ebx,%esi
f0100352:	89 d1                	mov    %edx,%ecx
f0100354:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100356:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f010035c:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100361:	b0 00                	mov    $0x0,%al
f0100363:	89 d7                	mov    %edx,%edi
f0100365:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd4);
			}
			//TEST#2: KERNEL HEAP [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "tst kheap CF kmalloc blk";
f0100367:	8d 85 d0 df ff ff    	lea    -0x2030(%ebp),%eax
f010036d:	bb 6c 5d 12 f0       	mov    $0xf0125d6c,%ebx
f0100372:	ba 19 00 00 00       	mov    $0x19,%edx
f0100377:	89 c7                	mov    %eax,%edi
f0100379:	89 de                	mov    %ebx,%esi
f010037b:	89 d1                	mov    %edx,%ecx
f010037d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010037f:	8d 95 e9 df ff ff    	lea    -0x2017(%ebp),%edx
f0100385:	b9 e7 03 00 00       	mov    $0x3e7,%ecx
f010038a:	b0 00                	mov    $0x0,%al
f010038c:	89 d7                	mov    %edx,%edi
f010038e:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF kmalloc page";
f0100390:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100396:	bb 6c 61 12 f0       	mov    $0xf012616c,%ebx
f010039b:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003a0:	89 c7                	mov    %eax,%edi
f01003a2:	89 de                	mov    %ebx,%esi
f01003a4:	89 d1                	mov    %edx,%ecx
f01003a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003a8:	8d 95 ea e3 ff ff    	lea    -0x1c16(%ebp),%edx
f01003ae:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003b3:	b0 00                	mov    $0x0,%al
f01003b5:	89 d7                	mov    %edx,%edi
f01003b7:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF kmalloc both";
f01003b9:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f01003bf:	bb 6c 65 12 f0       	mov    $0xf012656c,%ebx
f01003c4:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003c9:	89 c7                	mov    %eax,%edi
f01003cb:	89 de                	mov    %ebx,%esi
f01003cd:	89 d1                	mov    %edx,%ecx
f01003cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003d1:	8d 95 ea e7 ff ff    	lea    -0x1816(%ebp),%edx
f01003d7:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003dc:	b0 00                	mov    $0x0,%al
f01003de:	89 d7                	mov    %edx,%edi
f01003e0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst kheap CF kfree blk";
f01003e2:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f01003e8:	bb 6c 69 12 f0       	mov    $0xf012696c,%ebx
f01003ed:	ba 17 00 00 00       	mov    $0x17,%edx
f01003f2:	89 c7                	mov    %eax,%edi
f01003f4:	89 de                	mov    %ebx,%esi
f01003f6:	89 d1                	mov    %edx,%ecx
f01003f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003fa:	8d 95 e7 eb ff ff    	lea    -0x1419(%ebp),%edx
f0100400:	b9 e9 03 00 00       	mov    $0x3e9,%ecx
f0100405:	b0 00                	mov    $0x0,%al
f0100407:	89 d7                	mov    %edx,%edi
f0100409:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "tst kheap CF kfree page";
f010040b:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100411:	bb 6c 6d 12 f0       	mov    $0xf0126d6c,%ebx
f0100416:	ba 06 00 00 00       	mov    $0x6,%edx
f010041b:	89 c7                	mov    %eax,%edi
f010041d:	89 de                	mov    %ebx,%esi
f010041f:	89 d1                	mov    %edx,%ecx
f0100421:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100423:	8d 95 e8 ef ff ff    	lea    -0x1018(%ebp),%edx
f0100429:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010042e:	b8 00 00 00 00       	mov    $0x0,%eax
f0100433:	89 d7                	mov    %edx,%edi
f0100435:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd6[BUFLEN] = "tst kheap CF kfree both";
f0100437:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010043d:	bb 6c 71 12 f0       	mov    $0xf012716c,%ebx
f0100442:	ba 06 00 00 00       	mov    $0x6,%edx
f0100447:	89 c7                	mov    %eax,%edi
f0100449:	89 de                	mov    %ebx,%esi
f010044b:	89 d1                	mov    %edx,%ecx
f010044d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010044f:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100455:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010045a:	b8 00 00 00 00       	mov    $0x0,%eax
f010045f:	89 d7                	mov    %edx,%edi
f0100461:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd7[BUFLEN] = "tst kheap kvirtaddr";
f0100463:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100469:	bb 6c 75 12 f0       	mov    $0xf012756c,%ebx
f010046e:	ba 05 00 00 00       	mov    $0x5,%edx
f0100473:	89 c7                	mov    %eax,%edi
f0100475:	89 de                	mov    %ebx,%esi
f0100477:	89 d1                	mov    %edx,%ecx
f0100479:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010047b:	8d 95 e4 f7 ff ff    	lea    -0x81c(%ebp),%edx
f0100481:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100486:	b8 00 00 00 00       	mov    $0x0,%eax
f010048b:	89 d7                	mov    %edx,%edi
f010048d:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd8[BUFLEN] = "tst kheap kphysaddr";
f010048f:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100495:	bb 6c 79 12 f0       	mov    $0xf012796c,%ebx
f010049a:	ba 05 00 00 00       	mov    $0x5,%edx
f010049f:	89 c7                	mov    %eax,%edi
f01004a1:	89 de                	mov    %ebx,%esi
f01004a3:	89 d1                	mov    %edx,%ecx
f01004a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01004a7:	8d 95 e4 fb ff ff    	lea    -0x41c(%ebp),%edx
f01004ad:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f01004b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01004b7:	89 d7                	mov    %edx,%edi
f01004b9:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd8);
			}
			//TEST#3: FAULT HANDLER I [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "run tia 15";
f01004bb:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01004c1:	bb 6c 7d 12 f0       	mov    $0xf0127d6c,%ebx
f01004c6:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004cb:	89 c7                	mov    %eax,%edi
f01004cd:	89 de                	mov    %ebx,%esi
f01004cf:	89 d1                	mov    %edx,%ecx
f01004d1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004d3:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01004d9:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01004de:	b0 00                	mov    $0x0,%al
f01004e0:	89 d7                	mov    %edx,%edi
f01004e2:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tpp 20";
f01004e4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01004ea:	bb 6c 81 12 f0       	mov    $0xf012816c,%ebx
f01004ef:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004f4:	89 c7                	mov    %eax,%edi
f01004f6:	89 de                	mov    %ebx,%esi
f01004f8:	89 d1                	mov    %edx,%ecx
f01004fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004fc:	8d 95 db fb ff ff    	lea    -0x425(%ebp),%edx
f0100502:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100507:	b0 00                	mov    $0x0,%al
f0100509:	89 d7                	mov    %edx,%edi
f010050b:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd2);
			}
			//TEST: FAULT HANDLER II [OPTIMAL] 	[10 sec]
			{
				char cmd0[BUFLEN] = "optimal";
f010050d:	c7 85 d0 ef ff ff 6f 	movl   $0x6974706f,-0x1030(%ebp)
f0100514:	70 74 69 
f0100517:	c7 85 d4 ef ff ff 6d 	movl   $0x6c616d,-0x102c(%ebp)
f010051e:	61 6c 00 
f0100521:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f0100527:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f010052c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100531:	89 d7                	mov    %edx,%edi
f0100533:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run toptimal1 11";
f0100535:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010053b:	bb 6c 85 12 f0       	mov    $0xf012856c,%ebx
f0100540:	ba 11 00 00 00       	mov    $0x11,%edx
f0100545:	89 c7                	mov    %eax,%edi
f0100547:	89 de                	mov    %ebx,%esi
f0100549:	89 d1                	mov    %edx,%ecx
f010054b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010054d:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100553:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100558:	b0 00                	mov    $0x0,%al
f010055a:	89 d7                	mov    %edx,%edi
f010055c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run toptimal2 11";
f010055e:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100564:	bb 6c 89 12 f0       	mov    $0xf012896c,%ebx
f0100569:	ba 11 00 00 00       	mov    $0x11,%edx
f010056e:	89 c7                	mov    %eax,%edi
f0100570:	89 de                	mov    %ebx,%esi
f0100572:	89 d1                	mov    %edx,%ecx
f0100574:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100576:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f010057c:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100581:	b0 00                	mov    $0x0,%al
f0100583:	89 d7                	mov    %edx,%edi
f0100585:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run toptimal3 11";
f0100587:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010058d:	bb 6c 8d 12 f0       	mov    $0xf0128d6c,%ebx
f0100592:	ba 11 00 00 00       	mov    $0x11,%edx
f0100597:	89 c7                	mov    %eax,%edi
f0100599:	89 de                	mov    %ebx,%esi
f010059b:	89 d1                	mov    %edx,%ecx
f010059d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010059f:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f01005a5:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f01005aa:	b0 00                	mov    $0x0,%al
f01005ac:	89 d7                	mov    %edx,%edi
f01005ae:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: FAULT HANDLER II [CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "clock";
f01005b0:	c7 85 d0 eb ff ff 63 	movl   $0x636f6c63,-0x1430(%ebp)
f01005b7:	6c 6f 63 
f01005ba:	c7 85 d4 eb ff ff 6b 	movl   $0x6b,-0x142c(%ebp)
f01005c1:	00 00 00 
f01005c4:	8d 95 d8 eb ff ff    	lea    -0x1428(%ebp),%edx
f01005ca:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f01005cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01005d4:	89 d7                	mov    %edx,%edi
f01005d6:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01005d8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01005de:	bb 6c 91 12 f0       	mov    $0xf012916c,%ebx
f01005e3:	ba 03 00 00 00       	mov    $0x3,%edx
f01005e8:	89 c7                	mov    %eax,%edi
f01005ea:	89 de                	mov    %ebx,%esi
f01005ec:	89 d1                	mov    %edx,%ecx
f01005ee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01005f0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01005f6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01005fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100600:	89 d7                	mov    %edx,%edi
f0100602:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f0100604:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010060a:	bb 6c 95 12 f0       	mov    $0xf012956c,%ebx
f010060f:	ba 0b 00 00 00       	mov    $0xb,%edx
f0100614:	89 c7                	mov    %eax,%edi
f0100616:	89 de                	mov    %ebx,%esi
f0100618:	89 d1                	mov    %edx,%ecx
f010061a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010061c:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f0100622:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100627:	b0 00                	mov    $0x0,%al
f0100629:	89 d7                	mov    %edx,%edi
f010062b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tclock1 11";
f010062d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100633:	bb 6c 99 12 f0       	mov    $0xf012996c,%ebx
f0100638:	ba 0f 00 00 00       	mov    $0xf,%edx
f010063d:	89 c7                	mov    %eax,%edi
f010063f:	89 de                	mov    %ebx,%esi
f0100641:	89 d1                	mov    %edx,%ecx
f0100643:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100645:	8d 95 df f7 ff ff    	lea    -0x821(%ebp),%edx
f010064b:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100650:	b0 00                	mov    $0x0,%al
f0100652:	89 d7                	mov    %edx,%edi
f0100654:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tclock2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100656:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010065c:	bb 6c 9d 12 f0       	mov    $0xf0129d6c,%ebx
f0100661:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100666:	89 c7                	mov    %eax,%edi
f0100668:	89 de                	mov    %ebx,%esi
f010066a:	89 d1                	mov    %edx,%ecx
f010066c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010066e:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100674:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100679:	b0 00                	mov    $0x0,%al
f010067b:	89 d7                	mov    %edx,%edi
f010067d:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [MODIFIED CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "modclock";
f010067f:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100685:	bb 6c a1 12 f0       	mov    $0xf012a16c,%ebx
f010068a:	ba 09 00 00 00       	mov    $0x9,%edx
f010068f:	89 c7                	mov    %eax,%edi
f0100691:	89 de                	mov    %ebx,%esi
f0100693:	89 d1                	mov    %edx,%ecx
f0100695:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100697:	8d 95 d9 eb ff ff    	lea    -0x1427(%ebp),%edx
f010069d:	b9 f7 03 00 00       	mov    $0x3f7,%ecx
f01006a2:	b0 00                	mov    $0x0,%al
f01006a4:	89 d7                	mov    %edx,%edi
f01006a6:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01006a8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01006ae:	bb 6c 91 12 f0       	mov    $0xf012916c,%ebx
f01006b3:	ba 03 00 00 00       	mov    $0x3,%edx
f01006b8:	89 c7                	mov    %eax,%edi
f01006ba:	89 de                	mov    %ebx,%esi
f01006bc:	89 d1                	mov    %edx,%ecx
f01006be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01006c0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01006c6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01006cb:	b8 00 00 00 00       	mov    $0x0,%eax
f01006d0:	89 d7                	mov    %edx,%edi
f01006d2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01006d4:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01006da:	bb 6c 95 12 f0       	mov    $0xf012956c,%ebx
f01006df:	ba 0b 00 00 00       	mov    $0xb,%edx
f01006e4:	89 c7                	mov    %eax,%edi
f01006e6:	89 de                	mov    %ebx,%esi
f01006e8:	89 d1                	mov    %edx,%ecx
f01006ea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01006ec:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f01006f2:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01006f7:	b0 00                	mov    $0x0,%al
f01006f9:	89 d7                	mov    %edx,%edi
f01006fb:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tmodclk1 11";
f01006fd:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100703:	bb 6c a5 12 f0       	mov    $0xf012a56c,%ebx
f0100708:	ba 04 00 00 00       	mov    $0x4,%edx
f010070d:	89 c7                	mov    %eax,%edi
f010070f:	89 de                	mov    %ebx,%esi
f0100711:	89 d1                	mov    %edx,%ecx
f0100713:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100715:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f010071b:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100720:	b8 00 00 00 00       	mov    $0x0,%eax
f0100725:	89 d7                	mov    %edx,%edi
f0100727:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd4[BUFLEN] = "run tmodclk2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100729:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010072f:	bb 6c a9 12 f0       	mov    $0xf012a96c,%ebx
f0100734:	ba 04 00 00 00       	mov    $0x4,%edx
f0100739:	89 c7                	mov    %eax,%edi
f010073b:	89 de                	mov    %ebx,%esi
f010073d:	89 d1                	mov    %edx,%ecx
f010073f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100741:	8d 95 e0 fb ff ff    	lea    -0x420(%ebp),%edx
f0100747:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f010074c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100751:	89 d7                	mov    %edx,%edi
f0100753:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [LRU] 	[10 sec]
			{
				char cmd0[BUFLEN] = "lru 1";
f0100755:	c7 85 d0 ef ff ff 6c 	movl   $0x2075726c,-0x1030(%ebp)
f010075c:	72 75 20 
f010075f:	c7 85 d4 ef ff ff 31 	movl   $0x31,-0x102c(%ebp)
f0100766:	00 00 00 
f0100769:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f010076f:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100774:	b8 00 00 00 00       	mov    $0x0,%eax
f0100779:	89 d7                	mov    %edx,%edi
f010077b:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f010077d:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100783:	bb 6c 91 12 f0       	mov    $0xf012916c,%ebx
f0100788:	ba 03 00 00 00       	mov    $0x3,%edx
f010078d:	89 c7                	mov    %eax,%edi
f010078f:	89 de                	mov    %ebx,%esi
f0100791:	89 d1                	mov    %edx,%ecx
f0100793:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100795:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f010079b:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007a0:	b8 00 00 00 00       	mov    $0x0,%eax
f01007a5:	89 d7                	mov    %edx,%edi
f01007a7:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01007a9:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01007af:	bb 6c 95 12 f0       	mov    $0xf012956c,%ebx
f01007b4:	ba 0b 00 00 00       	mov    $0xb,%edx
f01007b9:	89 c7                	mov    %eax,%edi
f01007bb:	89 de                	mov    %ebx,%esi
f01007bd:	89 d1                	mov    %edx,%ecx
f01007bf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01007c1:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01007c7:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01007cc:	b0 00                	mov    $0x0,%al
f01007ce:	89 d7                	mov    %edx,%edi
f01007d0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tlru 11";
f01007d2:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01007d8:	bb 6c ad 12 f0       	mov    $0xf012ad6c,%ebx
f01007dd:	ba 03 00 00 00       	mov    $0x3,%edx
f01007e2:	89 c7                	mov    %eax,%edi
f01007e4:	89 de                	mov    %ebx,%esi
f01007e6:	89 d1                	mov    %edx,%ecx
f01007e8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01007ea:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
f01007f0:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01007fa:	89 d7                	mov    %edx,%edi
f01007fc:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: USER HEAP	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f01007fe:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100804:	bb 6c b1 12 f0       	mov    $0xf012b16c,%ebx
f0100809:	ba 03 00 00 00       	mov    $0x3,%edx
f010080e:	89 c7                	mov    %eax,%edi
f0100810:	89 de                	mov    %ebx,%esi
f0100812:	89 d1                	mov    %edx,%ecx
f0100814:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100816:	8d 95 dc e3 ff ff    	lea    -0x1c24(%ebp),%edx
f010081c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100821:	b8 00 00 00 00       	mov    $0x0,%eax
f0100826:	89 d7                	mov    %edx,%edi
f0100828:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tm1 3000";
f010082a:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100830:	bb 6c b5 12 f0       	mov    $0xf012b56c,%ebx
f0100835:	ba 0d 00 00 00       	mov    $0xd,%edx
f010083a:	89 c7                	mov    %eax,%edi
f010083c:	89 de                	mov    %ebx,%esi
f010083e:	89 d1                	mov    %edx,%ecx
f0100840:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100842:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100848:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010084d:	b0 00                	mov    $0x0,%al
f010084f:	89 d7                	mov    %edx,%edi
f0100851:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tm2 3000";
f0100853:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100859:	bb 6c b9 12 f0       	mov    $0xf012b96c,%ebx
f010085e:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100863:	89 c7                	mov    %eax,%edi
f0100865:	89 de                	mov    %ebx,%esi
f0100867:	89 d1                	mov    %edx,%ecx
f0100869:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010086b:	8d 95 dd eb ff ff    	lea    -0x1423(%ebp),%edx
f0100871:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100876:	b0 00                	mov    $0x0,%al
f0100878:	89 d7                	mov    %edx,%edi
f010087a:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tf1 3000";
f010087c:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100882:	bb 6c bd 12 f0       	mov    $0xf012bd6c,%ebx
f0100887:	ba 0d 00 00 00       	mov    $0xd,%edx
f010088c:	89 c7                	mov    %eax,%edi
f010088e:	89 de                	mov    %ebx,%esi
f0100890:	89 d1                	mov    %edx,%ecx
f0100892:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100894:	8d 95 dd ef ff ff    	lea    -0x1023(%ebp),%edx
f010089a:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010089f:	b0 00                	mov    $0x0,%al
f01008a1:	89 d7                	mov    %edx,%edi
f01008a3:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tf2 3000";
f01008a5:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01008ab:	bb 6c c1 12 f0       	mov    $0xf012c16c,%ebx
f01008b0:	ba 0d 00 00 00       	mov    $0xd,%edx
f01008b5:	89 c7                	mov    %eax,%edi
f01008b7:	89 de                	mov    %ebx,%esi
f01008b9:	89 d1                	mov    %edx,%ecx
f01008bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008bd:	8d 95 dd f3 ff ff    	lea    -0xc23(%ebp),%edx
f01008c3:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f01008c8:	b0 00                	mov    $0x0,%al
f01008ca:	89 d7                	mov    %edx,%edi
f01008cc:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tcf1 3000";
f01008ce:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01008d4:	bb 6c c5 12 f0       	mov    $0xf012c56c,%ebx
f01008d9:	ba 0e 00 00 00       	mov    $0xe,%edx
f01008de:	89 c7                	mov    %eax,%edi
f01008e0:	89 de                	mov    %ebx,%esi
f01008e2:	89 d1                	mov    %edx,%ecx
f01008e4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008e6:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01008ec:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01008f1:	b0 00                	mov    $0x0,%al
f01008f3:	89 d7                	mov    %edx,%edi
f01008f5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd6[BUFLEN] = "run tcf2 10000";
f01008f7:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01008fd:	bb 6c c9 12 f0       	mov    $0xf012c96c,%ebx
f0100902:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100907:	89 c7                	mov    %eax,%edi
f0100909:	89 de                	mov    %ebx,%esi
f010090b:	89 d1                	mov    %edx,%ecx
f010090d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010090f:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100915:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010091a:	b0 00                	mov    $0x0,%al
f010091c:	89 d7                	mov    %edx,%edi
f010091e:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd6);
			}
			//TEST: SHARED MEMORY	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f0100920:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100926:	bb 6c b1 12 f0       	mov    $0xf012b16c,%ebx
f010092b:	ba 03 00 00 00       	mov    $0x3,%edx
f0100930:	89 c7                	mov    %eax,%edi
f0100932:	89 de                	mov    %ebx,%esi
f0100934:	89 d1                	mov    %edx,%ecx
f0100936:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100938:	8d 95 dc e7 ff ff    	lea    -0x1824(%ebp),%edx
f010093e:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100943:	b8 00 00 00 00       	mov    $0x0,%eax
f0100948:	89 d7                	mov    %edx,%edi
f010094a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tshr1 3000";
f010094c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100952:	bb 6c cd 12 f0       	mov    $0xf012cd6c,%ebx
f0100957:	ba 0f 00 00 00       	mov    $0xf,%edx
f010095c:	89 c7                	mov    %eax,%edi
f010095e:	89 de                	mov    %ebx,%esi
f0100960:	89 d1                	mov    %edx,%ecx
f0100962:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100964:	8d 95 df eb ff ff    	lea    -0x1421(%ebp),%edx
f010096a:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010096f:	b0 00                	mov    $0x0,%al
f0100971:	89 d7                	mov    %edx,%edi
f0100973:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tshr2 3000";
f0100975:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f010097b:	bb 6c d1 12 f0       	mov    $0xf012d16c,%ebx
f0100980:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100985:	89 c7                	mov    %eax,%edi
f0100987:	89 de                	mov    %ebx,%esi
f0100989:	89 d1                	mov    %edx,%ecx
f010098b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010098d:	8d 95 df ef ff ff    	lea    -0x1021(%ebp),%edx
f0100993:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100998:	b0 00                	mov    $0x0,%al
f010099a:	89 d7                	mov    %edx,%edi
f010099c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tshr3 3000";
f010099e:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01009a4:	bb 6c d5 12 f0       	mov    $0xf012d56c,%ebx
f01009a9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01009ae:	89 c7                	mov    %eax,%edi
f01009b0:	89 de                	mov    %ebx,%esi
f01009b2:	89 d1                	mov    %edx,%ecx
f01009b4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009b6:	8d 95 df f3 ff ff    	lea    -0xc21(%ebp),%edx
f01009bc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f01009c1:	b0 00                	mov    $0x0,%al
f01009c3:	89 d7                	mov    %edx,%edi
f01009c5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tcf3 3000";	//depend on USER HEAP (malloc, free)
f01009c7:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01009cd:	bb 6c d9 12 f0       	mov    $0xf012d96c,%ebx
f01009d2:	ba 0e 00 00 00       	mov    $0xe,%edx
f01009d7:	89 c7                	mov    %eax,%edi
f01009d9:	89 de                	mov    %ebx,%esi
f01009db:	89 d1                	mov    %edx,%ecx
f01009dd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009df:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01009e5:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01009ea:	b0 00                	mov    $0x0,%al
f01009ec:	89 d7                	mov    %edx,%edi
f01009ee:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_protection 5000"; //[0/1 GRADING] [time limit: 3 mins]
f01009f0:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01009f6:	bb 6c dd 12 f0       	mov    $0xf012dd6c,%ebx
f01009fb:	ba 06 00 00 00       	mov    $0x6,%edx
f0100a00:	89 c7                	mov    %eax,%edi
f0100a02:	89 de                	mov    %ebx,%esi
f0100a04:	89 d1                	mov    %edx,%ecx
f0100a06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a08:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100a0e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100a13:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a18:	89 d7                	mov    %edx,%edi
f0100a1a:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);
			}
			//TEST: PRIORITY RR SCHEDULER
			{
				char cmd01[BUFLEN] = "schedPRIRR 10 40 1000";
f0100a1c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100a22:	bb 6c e1 12 f0       	mov    $0xf012e16c,%ebx
f0100a27:	ba 16 00 00 00       	mov    $0x16,%edx
f0100a2c:	89 c7                	mov    %eax,%edi
f0100a2e:	89 de                	mov    %ebx,%esi
f0100a30:	89 d1                	mov    %edx,%ecx
f0100a32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a34:	8d 95 e6 eb ff ff    	lea    -0x141a(%ebp),%edx
f0100a3a:	b9 ea 03 00 00       	mov    $0x3ea,%ecx
f0100a3f:	b0 00                	mov    $0x0,%al
f0100a41:	89 d7                	mov    %edx,%edi
f0100a43:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd03[BUFLEN] = "schedPRIRR 10 40 20";
f0100a45:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100a4b:	bb 6c e5 12 f0       	mov    $0xf012e56c,%ebx
f0100a50:	ba 05 00 00 00       	mov    $0x5,%edx
f0100a55:	89 c7                	mov    %eax,%edi
f0100a57:	89 de                	mov    %ebx,%esi
f0100a59:	89 d1                	mov    %edx,%ecx
f0100a5b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a5d:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100a63:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100a68:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a6d:	89 d7                	mov    %edx,%edi
f0100a6f:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd03);
				char cmdU1_1[BUFLEN] = "tst priorityRR 0";	//52 sec
f0100a71:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100a77:	bb 6c e9 12 f0       	mov    $0xf012e96c,%ebx
f0100a7c:	ba 11 00 00 00       	mov    $0x11,%edx
f0100a81:	89 c7                	mov    %eax,%edi
f0100a83:	89 de                	mov    %ebx,%esi
f0100a85:	89 d1                	mov    %edx,%ecx
f0100a87:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a89:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100a8f:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100a94:	b0 00                	mov    $0x0,%al
f0100a96:	89 d7                	mov    %edx,%edi
f0100a98:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU2_1[BUFLEN] = "tst priorityRR 1";	//58 sec
f0100a9a:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100aa0:	bb 6c ed 12 f0       	mov    $0xf012ed6c,%ebx
f0100aa5:	ba 11 00 00 00       	mov    $0x11,%edx
f0100aaa:	89 c7                	mov    %eax,%edi
f0100aac:	89 de                	mov    %ebx,%esi
f0100aae:	89 d1                	mov    %edx,%ecx
f0100ab0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100ab2:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f0100ab8:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100abd:	b0 00                	mov    $0x0,%al
f0100abf:	89 d7                	mov    %edx,%edi
f0100ac1:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU3_1[BUFLEN] = "tst priorityRR 2";	//90 sec
f0100ac3:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100ac9:	bb 6c f1 12 f0       	mov    $0xf012f16c,%ebx
f0100ace:	ba 11 00 00 00       	mov    $0x11,%edx
f0100ad3:	89 c7                	mov    %eax,%edi
f0100ad5:	89 de                	mov    %ebx,%esi
f0100ad7:	89 d1                	mov    %edx,%ecx
f0100ad9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100adb:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f0100ae1:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100ae6:	b0 00                	mov    $0x0,%al
f0100ae8:	89 d7                	mov    %edx,%edi
f0100aea:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmdU3_1);
			}
			//TEST: PROTECTION
			{
				char cmd1[BUFLEN] = "run tst_chan_all 20";
f0100aec:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100af2:	bb 6c f5 12 f0       	mov    $0xf012f56c,%ebx
f0100af7:	ba 05 00 00 00       	mov    $0x5,%edx
f0100afc:	89 c7                	mov    %eax,%edi
f0100afe:	89 de                	mov    %ebx,%esi
f0100b00:	89 d1                	mov    %edx,%ecx
f0100b02:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b04:	8d 95 e4 eb ff ff    	lea    -0x141c(%ebp),%edx
f0100b0a:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b14:	89 d7                	mov    %edx,%edi
f0100b16:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tst_chan_one 20";
f0100b18:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100b1e:	bb 6c f9 12 f0       	mov    $0xf012f96c,%ebx
f0100b23:	ba 05 00 00 00       	mov    $0x5,%edx
f0100b28:	89 c7                	mov    %eax,%edi
f0100b2a:	89 de                	mov    %ebx,%esi
f0100b2c:	89 d1                	mov    %edx,%ecx
f0100b2e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b30:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100b36:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b40:	89 d7                	mov    %edx,%edi
f0100b42:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "run tst_sleeplock 20";
f0100b44:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100b4a:	bb 6c fd 12 f0       	mov    $0xf012fd6c,%ebx
f0100b4f:	ba 15 00 00 00       	mov    $0x15,%edx
f0100b54:	89 c7                	mov    %eax,%edi
f0100b56:	89 de                	mov    %ebx,%esi
f0100b58:	89 d1                	mov    %edx,%ecx
f0100b5a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b5c:	8d 95 e5 f3 ff ff    	lea    -0xc1b(%ebp),%edx
f0100b62:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100b67:	b0 00                	mov    $0x0,%al
f0100b69:	89 d7                	mov    %edx,%edi
f0100b6b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tst_ksem1 500";	//5 sec
f0100b6d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100b73:	bb 6c 01 13 f0       	mov    $0xf013016c,%ebx
f0100b78:	ba 12 00 00 00       	mov    $0x12,%edx
f0100b7d:	89 c7                	mov    %eax,%edi
f0100b7f:	89 de                	mov    %ebx,%esi
f0100b81:	89 d1                	mov    %edx,%ecx
f0100b83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b85:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100b8b:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100b90:	b0 00                	mov    $0x0,%al
f0100b92:	89 d7                	mov    %edx,%edi
f0100b94:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_ksem2 500";	//20 sec
f0100b96:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100b9c:	bb 6c 05 13 f0       	mov    $0xf013056c,%ebx
f0100ba1:	ba 12 00 00 00       	mov    $0x12,%edx
f0100ba6:	89 c7                	mov    %eax,%edi
f0100ba8:	89 de                	mov    %ebx,%esi
f0100baa:	89 d1                	mov    %edx,%ecx
f0100bac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bae:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100bb4:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100bb9:	b0 00                	mov    $0x0,%al
f0100bbb:	89 d7                	mov    %edx,%edi
f0100bbd:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd5);
			}
			//TEST#X: BONUS - DA: BLOCK IF NO BLOCK
			{
				char cmd1[BUFLEN] = "run tst_da_block 500";
f0100bbf:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100bc5:	bb 6c 09 13 f0       	mov    $0xf013096c,%ebx
f0100bca:	ba 15 00 00 00       	mov    $0x15,%edx
f0100bcf:	89 c7                	mov    %eax,%edi
f0100bd1:	89 de                	mov    %ebx,%esi
f0100bd3:	89 d1                	mov    %edx,%ecx
f0100bd5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bd7:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f0100bdd:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100be2:	b0 00                	mov    $0x0,%al
f0100be4:	89 d7                	mov    %edx,%edi
f0100be6:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - KREALLOC
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100be8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100bee:	bb 6c 0d 13 f0       	mov    $0xf0130d6c,%ebx
f0100bf3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100bf8:	89 c7                	mov    %eax,%edi
f0100bfa:	89 de                	mov    %ebx,%esi
f0100bfc:	89 d1                	mov    %edx,%ecx
f0100bfe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c00:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100c06:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100c0b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c10:	89 d7                	mov    %edx,%edi
f0100c12:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF krealloc 1";
f0100c14:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100c1a:	bb 6c 11 13 f0       	mov    $0xf013116c,%ebx
f0100c1f:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c24:	89 c7                	mov    %eax,%edi
f0100c26:	89 de                	mov    %ebx,%esi
f0100c28:	89 d1                	mov    %edx,%ecx
f0100c2a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c2c:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100c32:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c37:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c3c:	89 d7                	mov    %edx,%edi
f0100c3e:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF krealloc 2";
f0100c40:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c46:	bb 6c 15 13 f0       	mov    $0xf013156c,%ebx
f0100c4b:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c50:	89 c7                	mov    %eax,%edi
f0100c52:	89 de                	mov    %ebx,%esi
f0100c54:	89 d1                	mov    %edx,%ecx
f0100c56:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c58:	8d 95 e8 f7 ff ff    	lea    -0x818(%ebp),%edx
f0100c5e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c63:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c68:	89 d7                	mov    %edx,%edi
f0100c6a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF krealloc 3";
f0100c6c:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100c72:	bb 6c 19 13 f0       	mov    $0xf013196c,%ebx
f0100c77:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c7c:	89 c7                	mov    %eax,%edi
f0100c7e:	89 de                	mov    %ebx,%esi
f0100c80:	89 d1                	mov    %edx,%ecx
f0100c82:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c84:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100c8a:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c94:	89 d7                	mov    %edx,%edi
f0100c96:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - FAST PAGE ALLOCATOR
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100c98:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c9e:	bb 6c 0d 13 f0       	mov    $0xf0130d6c,%ebx
f0100ca3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100ca8:	89 c7                	mov    %eax,%edi
f0100caa:	89 de                	mov    %ebx,%esi
f0100cac:	89 d1                	mov    %edx,%ecx
f0100cae:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100cb0:	8d 95 dc f7 ff ff    	lea    -0x824(%ebp),%edx
f0100cb6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100cbb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100cc0:	89 d7                	mov    %edx,%edi
f0100cc2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF fast"; //[0/1 GRADING] [time limit: 10 secs]
f0100cc4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100cca:	bb 6c 1d 13 f0       	mov    $0xf0131d6c,%ebx
f0100ccf:	ba 12 00 00 00       	mov    $0x12,%edx
f0100cd4:	89 c7                	mov    %eax,%edi
f0100cd6:	89 de                	mov    %ebx,%esi
f0100cd8:	89 d1                	mov    %edx,%ecx
f0100cda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100cdc:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100ce2:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100ce7:	b0 00                	mov    $0x0,%al
f0100ce9:	89 d7                	mov    %edx,%edi
f0100ceb:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - EXIT
			{
				char cmd0[BUFLEN] = "fifo";
f0100ced:	c7 85 d0 e3 ff ff 66 	movl   $0x6f666966,-0x1c30(%ebp)
f0100cf4:	69 66 6f 
f0100cf7:	c7 85 d4 e3 ff ff 00 	movl   $0x0,-0x1c2c(%ebp)
f0100cfe:	00 00 00 
f0100d01:	8d 95 d8 e3 ff ff    	lea    -0x1c28(%ebp),%edx
f0100d07:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d11:	89 d7                	mov    %edx,%edi
f0100d13:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 1: without using dynamic allocation/de-allocation [PLACEMENT]
				char cmd1[BUFLEN] = "run tef1 100";
f0100d15:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100d1b:	bb 6c 21 13 f0       	mov    $0xf013216c,%ebx
f0100d20:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100d25:	89 c7                	mov    %eax,%edi
f0100d27:	89 de                	mov    %ebx,%esi
f0100d29:	89 d1                	mov    %edx,%ecx
f0100d2b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100d2d:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100d33:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100d38:	b0 00                	mov    $0x0,%al
f0100d3a:	89 d7                	mov    %edx,%edi
f0100d3c:	f3 aa                	rep stos %al,%es:(%edi)
				//Scenario 2: using dynamic allocation and free [REPLACEMENT]
				char cmd2[BUFLEN] = "run tef2 20";
f0100d3e:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100d44:	bb 6c 25 13 f0       	mov    $0xf013256c,%ebx
f0100d49:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d4e:	89 c7                	mov    %eax,%edi
f0100d50:	89 de                	mov    %ebx,%esi
f0100d52:	89 d1                	mov    %edx,%ecx
f0100d54:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d56:	8d 95 dc eb ff ff    	lea    -0x1424(%ebp),%edx
f0100d5c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d61:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d66:	89 d7                	mov    %edx,%edi
f0100d68:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario3: using dynamic allocation and free [process kill itself] [REPLACEMENT]
				char cmd3[BUFLEN] = "run tef3 20";
f0100d6a:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100d70:	bb 6c 29 13 f0       	mov    $0xf013296c,%ebx
f0100d75:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d7a:	89 c7                	mov    %eax,%edi
f0100d7c:	89 de                	mov    %ebx,%esi
f0100d7e:	89 d1                	mov    %edx,%ecx
f0100d80:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d82:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100d88:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d92:	89 d7                	mov    %edx,%edi
f0100d94:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 4: using create & get of shared variables [REPLACEMENT]
				char cmd4[BUFLEN] = "run tef4 10";
f0100d96:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100d9c:	bb 6c 2d 13 f0       	mov    $0xf0132d6c,%ebx
f0100da1:	ba 03 00 00 00       	mov    $0x3,%edx
f0100da6:	89 c7                	mov    %eax,%edi
f0100da8:	89 de                	mov    %ebx,%esi
f0100daa:	89 d1                	mov    %edx,%ecx
f0100dac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dae:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f0100db4:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100db9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dbe:	89 d7                	mov    %edx,%edi
f0100dc0:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 5: using create, get and free shared variables by the created environment itself before calling env_free [PLACEMENT]
				char cmd5[BUFLEN] = "run tef5_2 3000";
f0100dc2:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100dc8:	bb 6c 31 13 f0       	mov    $0xf013316c,%ebx
f0100dcd:	ba 04 00 00 00       	mov    $0x4,%edx
f0100dd2:	89 c7                	mov    %eax,%edi
f0100dd4:	89 de                	mov    %ebx,%esi
f0100dd6:	89 d1                	mov    %edx,%ecx
f0100dd8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dda:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f0100de0:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100de5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dea:	89 d7                	mov    %edx,%edi
f0100dec:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 6: using shared variables and semaphores together [PLACEMENT]
				char cmd6[BUFLEN] = "run tef6 3000";
f0100dee:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100df4:	bb 6c 35 13 f0       	mov    $0xf013356c,%ebx
f0100df9:	ba 0e 00 00 00       	mov    $0xe,%edx
f0100dfe:	89 c7                	mov    %eax,%edi
f0100e00:	89 de                	mov    %ebx,%esi
f0100e02:	89 d1                	mov    %edx,%ecx
f0100e04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100e06:	8d 95 de fb ff ff    	lea    -0x422(%ebp),%edx
f0100e0c:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f0100e11:	b0 00                	mov    $0x0,%al
f0100e13:	89 d7                	mov    %edx,%edi
f0100e15:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);

			}

			cprintf("PROJECT Automatic testing is ENDED\n") ;
f0100e17:	83 ec 0c             	sub    $0xc,%esp
f0100e1a:	68 48 4d 12 f0       	push   $0xf0124d48
f0100e1f:	e8 29 0d 00 00       	call   f0101b4d <cprintf>
f0100e24:	83 c4 10             	add    $0x10,%esp
			__autograde__ = 0;
f0100e27:	c7 05 20 70 19 f0 00 	movl   $0x0,0xf0197020
f0100e2e:	00 00 00 
		}
		get_into_prompt();
f0100e31:	e8 9d 0e 00 00       	call   f0101cd3 <get_into_prompt>

f0100e36 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f0100e36:	55                   	push   %ebp
f0100e37:	89 e5                	mov    %esp,%ebp
f0100e39:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f0100e3c:	83 ec 0c             	sub    $0xc,%esp
f0100e3f:	68 6c 39 13 f0       	push   $0xf013396c
f0100e44:	e8 04 0d 00 00       	call   f0101b4d <cprintf>
f0100e49:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e4c:	83 ec 0c             	sub    $0xc,%esp
f0100e4f:	68 70 39 13 f0       	push   $0xf0133970
f0100e54:	e8 f4 0c 00 00       	call   f0101b4d <cprintf>
f0100e59:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100e5c:	83 ec 0c             	sub    $0xc,%esp
f0100e5f:	68 b8 39 13 f0       	push   $0xf01339b8
f0100e64:	e8 e4 0c 00 00       	call   f0101b4d <cprintf>
f0100e69:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f0100e6c:	83 ec 0c             	sub    $0xc,%esp
f0100e6f:	68 00 3a 13 f0       	push   $0xf0133a00
f0100e74:	e8 d4 0c 00 00       	call   f0101b4d <cprintf>
f0100e79:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100e7c:	83 ec 0c             	sub    $0xc,%esp
f0100e7f:	68 b8 39 13 f0       	push   $0xf01339b8
f0100e84:	e8 c4 0c 00 00       	call   f0101b4d <cprintf>
f0100e89:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e8c:	83 ec 0c             	sub    $0xc,%esp
f0100e8f:	68 70 39 13 f0       	push   $0xf0133970
f0100e94:	e8 b4 0c 00 00       	call   f0101b4d <cprintf>
f0100e99:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100e9c:	83 ec 0c             	sub    $0xc,%esp
f0100e9f:	68 45 3a 13 f0       	push   $0xf0133a45
f0100ea4:	e8 a4 0c 00 00       	call   f0101b4d <cprintf>
f0100ea9:	83 c4 10             	add    $0x10,%esp
}
f0100eac:	90                   	nop
f0100ead:	c9                   	leave  
f0100eae:	c3                   	ret    

f0100eaf <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100eaf:	55                   	push   %ebp
f0100eb0:	89 e5                	mov    %esp,%ebp
f0100eb2:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100eb5:	e8 8e c7 00 00       	call   f010d648 <get_cpu_proc>
f0100eba:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100ebd:	8b 45 10             	mov    0x10(%ebp),%eax
f0100ec0:	a3 e0 3d 92 f0       	mov    %eax,0xf0923de0

	va_start(ap, fmt);
f0100ec5:	8d 45 10             	lea    0x10(%ebp),%eax
f0100ec8:	83 c0 04             	add    $0x4,%eax
f0100ecb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf_colored(TEXT_PANIC_CLR, "\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100ece:	ff 75 0c             	pushl  0xc(%ebp)
f0100ed1:	ff 75 08             	pushl  0x8(%ebp)
f0100ed4:	68 4c 3a 13 f0       	push   $0xf0133a4c
f0100ed9:	6a 74                	push   $0x74
f0100edb:	e8 9d 0c 00 00       	call   f0101b7d <cprintf_colored>
f0100ee0:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100ee3:	8b 45 10             	mov    0x10(%ebp),%eax
f0100ee6:	83 ec 08             	sub    $0x8,%esp
f0100ee9:	ff 75 f0             	pushl  -0x10(%ebp)
f0100eec:	50                   	push   %eax
f0100eed:	e8 32 0c 00 00       	call   f0101b24 <vcprintf>
f0100ef2:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100ef5:	83 ec 0c             	sub    $0xc,%esp
f0100ef8:	68 71 3a 13 f0       	push   $0xf0133a71
f0100efd:	e8 4b 0c 00 00       	call   f0101b4d <cprintf>
f0100f02:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100f05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f09:	74 10                	je     f0100f1b <_panic+0x6c>
f0100f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0e:	8b 40 18             	mov    0x18(%eax),%eax
f0100f11:	83 f8 02             	cmp    $0x2,%eax
f0100f14:	75 05                	jne    f0100f1b <_panic+0x6c>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100f16:	e8 eb c6 00 00       	call   f010d606 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100f1b:	89 e0                	mov    %esp,%eax
f0100f1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f0100f20:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f0100f23:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100f26:	83 ec 08             	sub    $0x8,%esp
f0100f29:	ff 75 ec             	pushl  -0x14(%ebp)
f0100f2c:	68 73 3a 13 f0       	push   $0xf0133a73
f0100f31:	e8 17 0c 00 00       	call   f0101b4d <cprintf>
f0100f36:	83 c4 10             	add    $0x10,%esp
		//			//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
		//			assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//					(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
f0100f39:	e8 95 0d 00 00       	call   f0101cd3 <get_into_prompt>

f0100f3e <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 28             	sub    $0x28,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100f44:	8b 45 10             	mov    0x10(%ebp),%eax
f0100f47:	a3 e0 3d 92 f0       	mov    %eax,0xf0923de0

	va_start(ap, fmt);
f0100f4c:	8d 45 10             	lea    0x10(%ebp),%eax
f0100f4f:	83 c0 04             	add    $0x4,%eax
f0100f52:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_PANIC_CLR, "\nkernel panic at %s:%d: ", file, line);
f0100f55:	ff 75 0c             	pushl  0xc(%ebp)
f0100f58:	ff 75 08             	pushl  0x8(%ebp)
f0100f5b:	68 7d 3a 13 f0       	push   $0xf0133a7d
f0100f60:	6a 74                	push   $0x74
f0100f62:	e8 16 0c 00 00       	call   f0101b7d <cprintf_colored>
f0100f67:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100f6a:	8b 45 10             	mov    0x10(%ebp),%eax
f0100f6d:	83 ec 08             	sub    $0x8,%esp
f0100f70:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f73:	50                   	push   %eax
f0100f74:	e8 ab 0b 00 00       	call   f0101b24 <vcprintf>
f0100f79:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100f7c:	83 ec 0c             	sub    $0xc,%esp
f0100f7f:	68 71 3a 13 f0       	push   $0xf0133a71
f0100f84:	e8 c4 0b 00 00       	call   f0101b4d <cprintf>
f0100f89:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100f8c:	e8 31 76 00 00       	call   f01085c2 <pushcli>
	struct cpu *c = mycpu();
f0100f91:	e8 69 75 00 00       	call   f01084ff <mycpu>
f0100f96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100f99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100f9c:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0100fa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100fa5:	e8 6a 76 00 00       	call   f0108614 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100faa:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f0100fae:	74 23                	je     f0100fd3 <_panic_all+0x95>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f0100fb0:	e8 ab 65 00 00       	call   f0107560 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100fb5:	e8 8e c6 00 00       	call   f010d648 <get_cpu_proc>
f0100fba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100fbd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0100fc1:	74 10                	je     f0100fd3 <_panic_all+0x95>
f0100fc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100fc6:	8b 40 18             	mov    0x18(%eax),%eax
f0100fc9:	83 f8 02             	cmp    $0x2,%eax
f0100fcc:	75 05                	jne    f0100fd3 <_panic_all+0x95>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100fce:	e8 33 c6 00 00       	call   f010d606 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100fd3:	89 e0                	mov    %esp,%eax
f0100fd5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f0100fd8:	8b 45 e0             	mov    -0x20(%ebp),%eax
		//		fos_scheduler();
	}
	//else //2024: panic from Kernel and no current running env
	{
		//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
		char* esp = (char*)read_esp();
f0100fdb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//		assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//				(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
f0100fde:	e8 f0 0c 00 00       	call   f0101cd3 <get_into_prompt>

f0100fe3 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100fe3:	55                   	push   %ebp
f0100fe4:	89 e5                	mov    %esp,%ebp
f0100fe6:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100fe9:	8b 45 10             	mov    0x10(%ebp),%eax
f0100fec:	a3 e0 3d 92 f0       	mov    %eax,0xf0923de0

	va_start(ap, fmt);
f0100ff1:	8d 45 10             	lea    0x10(%ebp),%eax
f0100ff4:	83 c0 04             	add    $0x4,%eax
f0100ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_PANIC_CLR,"\nkernel panic at %s:%d: ", file, line);
f0100ffa:	ff 75 0c             	pushl  0xc(%ebp)
f0100ffd:	ff 75 08             	pushl  0x8(%ebp)
f0101000:	68 7d 3a 13 f0       	push   $0xf0133a7d
f0101005:	6a 74                	push   $0x74
f0101007:	e8 71 0b 00 00       	call   f0101b7d <cprintf_colored>
f010100c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010100f:	8b 45 10             	mov    0x10(%ebp),%eax
f0101012:	83 ec 08             	sub    $0x8,%esp
f0101015:	ff 75 f4             	pushl  -0xc(%ebp)
f0101018:	50                   	push   %eax
f0101019:	e8 06 0b 00 00       	call   f0101b24 <vcprintf>
f010101e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0101021:	83 ec 0c             	sub    $0xc,%esp
f0101024:	68 71 3a 13 f0       	push   $0xf0133a71
f0101029:	e8 1f 0b 00 00       	call   f0101b4d <cprintf>
f010102e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0101031:	e8 12 c6 00 00       	call   f010d648 <get_cpu_proc>
f0101036:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0101039:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010103d:	74 10                	je     f010104f <_panic_into_prompt+0x6c>
f010103f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101042:	8b 40 18             	mov    0x18(%eax),%eax
f0101045:	83 f8 02             	cmp    $0x2,%eax
f0101048:	75 05                	jne    f010104f <_panic_into_prompt+0x6c>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010104a:	e8 b7 c5 00 00       	call   f010d606 <env_exit>
	}

	get_into_prompt();
f010104f:	e8 7f 0c 00 00       	call   f0101cd3 <get_into_prompt>

f0101054 <_warn>:

}

/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f0101054:	55                   	push   %ebp
f0101055:	89 e5                	mov    %esp,%ebp
f0101057:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f010105a:	8d 45 10             	lea    0x10(%ebp),%eax
f010105d:	83 c0 04             	add    $0x4,%eax
f0101060:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_WARN_CLR, "\nkernel warning at %s:%d: ", file, line);
f0101063:	ff 75 0c             	pushl  0xc(%ebp)
f0101066:	ff 75 08             	pushl  0x8(%ebp)
f0101069:	68 96 3a 13 f0       	push   $0xf0133a96
f010106e:	6a 7e                	push   $0x7e
f0101070:	e8 08 0b 00 00       	call   f0101b7d <cprintf_colored>
f0101075:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0101078:	8b 45 10             	mov    0x10(%ebp),%eax
f010107b:	83 ec 08             	sub    $0x8,%esp
f010107e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101081:	50                   	push   %eax
f0101082:	e8 9d 0a 00 00       	call   f0101b24 <vcprintf>
f0101087:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010108a:	83 ec 0c             	sub    $0xc,%esp
f010108d:	68 71 3a 13 f0       	push   $0xf0133a71
f0101092:	e8 b6 0a 00 00       	call   f0101b4d <cprintf>
f0101097:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010109a:	90                   	nop
f010109b:	c9                   	leave  
f010109c:	c3                   	ret    

f010109d <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f010109d:	55                   	push   %ebp
f010109e:	89 e5                	mov    %esp,%ebp
f01010a0:	83 ec 10             	sub    $0x10,%esp
f01010a3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01010ad:	89 c2                	mov    %eax,%edx
f01010af:	ec                   	in     (%dx),%al
f01010b0:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f01010b3:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f01010b6:	0f b6 c0             	movzbl %al,%eax
f01010b9:	83 e0 01             	and    $0x1,%eax
f01010bc:	85 c0                	test   %eax,%eax
f01010be:	75 07                	jne    f01010c7 <serial_proc_data+0x2a>
		return -1;
f01010c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01010c5:	eb 16                	jmp    f01010dd <serial_proc_data+0x40>
f01010c7:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01010d1:	89 c2                	mov    %eax,%edx
f01010d3:	ec                   	in     (%dx),%al
f01010d4:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f01010d7:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f01010da:	0f b6 c0             	movzbl %al,%eax
}
f01010dd:	c9                   	leave  
f01010de:	c3                   	ret    

f01010df <serial_intr>:

void
serial_intr(void)
{
f01010df:	55                   	push   %ebp
f01010e0:	89 e5                	mov    %esp,%ebp
f01010e2:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f01010e5:	a1 04 3e 92 f0       	mov    0xf0923e04,%eax
f01010ea:	85 c0                	test   %eax,%eax
f01010ec:	74 10                	je     f01010fe <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f01010ee:	83 ec 0c             	sub    $0xc,%esp
f01010f1:	68 9d 10 10 f0       	push   $0xf010109d
f01010f6:	e8 c5 07 00 00       	call   f01018c0 <cons_intr>
f01010fb:	83 c4 10             	add    $0x10,%esp
}
f01010fe:	90                   	nop
f01010ff:	c9                   	leave  
f0101100:	c3                   	ret    

f0101101 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0101101:	55                   	push   %ebp
f0101102:	89 e5                	mov    %esp,%ebp
f0101104:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f0101107:	83 ec 0c             	sub    $0xc,%esp
f010110a:	68 b1 3a 13 f0       	push   $0xf0133ab1
f010110f:	e8 39 0a 00 00       	call   f0101b4d <cprintf>
f0101114:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f0101117:	e8 c3 ff ff ff       	call   f01010df <serial_intr>
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <serial_init>:

void
serial_init(void)
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 48             	sub    $0x48,%esp
f0101125:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f010112c:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101130:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0101133:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101136:	ee                   	out    %al,(%dx)
f0101137:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f010113e:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f0101142:	8a 45 c7             	mov    -0x39(%ebp),%al
f0101145:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101148:	ee                   	out    %al,(%dx)
f0101149:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f0101150:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f0101154:	8a 45 c8             	mov    -0x38(%ebp),%al
f0101157:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010115a:	ee                   	out    %al,(%dx)
f010115b:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f0101162:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f0101166:	8a 45 c9             	mov    -0x37(%ebp),%al
f0101169:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010116c:	ee                   	out    %al,(%dx)
f010116d:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f0101174:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f0101178:	8a 45 ca             	mov    -0x36(%ebp),%al
f010117b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010117e:	ee                   	out    %al,(%dx)
f010117f:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0101186:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010118a:	8a 45 cb             	mov    -0x35(%ebp),%al
f010118d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0101190:	ee                   	out    %al,(%dx)
f0101191:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f0101198:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010119c:	8a 45 cc             	mov    -0x34(%ebp),%al
f010119f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01011a2:	ee                   	out    %al,(%dx)
f01011a3:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01011ad:	89 c2                	mov    %eax,%edx
f01011af:	ec                   	in     (%dx),%al
f01011b0:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f01011b3:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f01011b6:	3c ff                	cmp    $0xff,%al
f01011b8:	0f 95 c0             	setne  %al
f01011bb:	0f b6 c0             	movzbl %al,%eax
f01011be:	a3 04 3e 92 f0       	mov    %eax,0xf0923e04
f01011c3:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01011cd:	89 c2                	mov    %eax,%edx
f01011cf:	ec                   	in     (%dx),%al
f01011d0:	88 45 ce             	mov    %al,-0x32(%ebp)
f01011d3:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f01011da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01011dd:	89 c2                	mov    %eax,%edx
f01011df:	ec                   	in     (%dx),%al
f01011e0:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f01011e3:	83 ec 08             	sub    $0x8,%esp
f01011e6:	68 01 11 10 f0       	push   $0xf0101101
f01011eb:	6a 04                	push   $0x4
f01011ed:	e8 9b ed 00 00       	call   f010ff8d <irq_install_handler>
f01011f2:	83 c4 10             	add    $0x10,%esp

}
f01011f5:	90                   	nop
f01011f6:	c9                   	leave  
f01011f7:	c3                   	ret    

f01011f8 <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f01011f8:	55                   	push   %ebp
f01011f9:	89 e5                	mov    %esp,%ebp
f01011fb:	83 ec 20             	sub    $0x20,%esp
f01011fe:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0101205:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101208:	89 c2                	mov    %eax,%edx
f010120a:	ec                   	in     (%dx),%al
f010120b:	88 45 ec             	mov    %al,-0x14(%ebp)
f010120e:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0101215:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101218:	89 c2                	mov    %eax,%edx
f010121a:	ec                   	in     (%dx),%al
f010121b:	88 45 ed             	mov    %al,-0x13(%ebp)
f010121e:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0101225:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101228:	89 c2                	mov    %eax,%edx
f010122a:	ec                   	in     (%dx),%al
f010122b:	88 45 ee             	mov    %al,-0x12(%ebp)
f010122e:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0101235:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101238:	89 c2                	mov    %eax,%edx
f010123a:	ec                   	in     (%dx),%al
f010123b:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f010123e:	90                   	nop
f010123f:	c9                   	leave  
f0101240:	c3                   	ret    

f0101241 <lpt_putc>:

static void
lpt_putc(int c)
{
f0101241:	55                   	push   %ebp
f0101242:	89 e5                	mov    %esp,%ebp
f0101244:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101247:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010124e:	eb 08                	jmp    f0101258 <lpt_putc+0x17>
		delay();
f0101250:	e8 a3 ff ff ff       	call   f01011f8 <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101255:	ff 45 fc             	incl   -0x4(%ebp)
f0101258:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f010125f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101262:	89 c2                	mov    %eax,%edx
f0101264:	ec                   	in     (%dx),%al
f0101265:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f0101268:	8a 45 eb             	mov    -0x15(%ebp),%al
f010126b:	84 c0                	test   %al,%al
f010126d:	78 09                	js     f0101278 <lpt_putc+0x37>
f010126f:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f0101276:	7e d8                	jle    f0101250 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f0101278:	8b 45 08             	mov    0x8(%ebp),%eax
f010127b:	0f b6 c0             	movzbl %al,%eax
f010127e:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0101285:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101288:	8a 45 e8             	mov    -0x18(%ebp),%al
f010128b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010128e:	ee                   	out    %al,(%dx)
f010128f:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0101296:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010129a:	8a 45 e9             	mov    -0x17(%ebp),%al
f010129d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01012a0:	ee                   	out    %al,(%dx)
f01012a1:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f01012a8:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f01012ac:	8a 45 ea             	mov    -0x16(%ebp),%al
f01012af:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01012b2:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f01012b3:	90                   	nop
f01012b4:	c9                   	leave  
f01012b5:	c3                   	ret    

f01012b6 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f01012b6:	55                   	push   %ebp
f01012b7:	89 e5                	mov    %esp,%ebp
f01012b9:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f01012bc:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f01012c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012c6:	66 8b 00             	mov    (%eax),%ax
f01012c9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f01012cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012d0:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f01012d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012d8:	66 8b 00             	mov    (%eax),%ax
f01012db:	66 3d 5a a5          	cmp    $0xa55a,%ax
f01012df:	74 13                	je     f01012f4 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f01012e1:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f01012e8:	c7 05 08 3e 92 f0 b4 	movl   $0x3b4,0xf0923e08
f01012ef:	03 00 00 
f01012f2:	eb 14                	jmp    f0101308 <cga_init+0x52>
	} else {
		*cp = was;
f01012f4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01012f7:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f01012fb:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f01012fe:	c7 05 08 3e 92 f0 d4 	movl   $0x3d4,0xf0923e08
f0101305:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f0101308:	a1 08 3e 92 f0       	mov    0xf0923e08,%eax
f010130d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101310:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0101314:	8a 45 e0             	mov    -0x20(%ebp),%al
f0101317:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010131a:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010131b:	a1 08 3e 92 f0       	mov    0xf0923e08,%eax
f0101320:	40                   	inc    %eax
f0101321:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101324:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101327:	89 c2                	mov    %eax,%edx
f0101329:	ec                   	in     (%dx),%al
f010132a:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f010132d:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0101330:	0f b6 c0             	movzbl %al,%eax
f0101333:	c1 e0 08             	shl    $0x8,%eax
f0101336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f0101339:	a1 08 3e 92 f0       	mov    0xf0923e08,%eax
f010133e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101341:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101345:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0101348:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010134b:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f010134c:	a1 08 3e 92 f0       	mov    0xf0923e08,%eax
f0101351:	40                   	inc    %eax
f0101352:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101355:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101358:	89 c2                	mov    %eax,%edx
f010135a:	ec                   	in     (%dx),%al
f010135b:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f010135e:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101361:	0f b6 c0             	movzbl %al,%eax
f0101364:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f0101367:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010136a:	a3 0c 3e 92 f0       	mov    %eax,0xf0923e0c
	crt_pos = pos;
f010136f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101372:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
}
f0101378:	90                   	nop
f0101379:	c9                   	leave  
f010137a:	c3                   	ret    

f010137b <cga_putc>:

//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.
void
cga_putc(int c)
{
f010137b:	55                   	push   %ebp
f010137c:	89 e5                	mov    %esp,%ebp
f010137e:	53                   	push   %ebx
f010137f:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use the text color
	if (!(c & ~0xFF))
f0101382:	8b 45 08             	mov    0x8(%ebp),%eax
f0101385:	b0 00                	mov    $0x0,%al
f0101387:	85 c0                	test   %eax,%eax
f0101389:	75 18                	jne    f01013a3 <cga_putc+0x28>
	{
		c |= current_text_color == 0? 0x700 : current_text_color;
f010138b:	a1 90 51 96 f1       	mov    0xf1965190,%eax
f0101390:	85 c0                	test   %eax,%eax
f0101392:	74 07                	je     f010139b <cga_putc+0x20>
f0101394:	a1 90 51 96 f1       	mov    0xf1965190,%eax
f0101399:	eb 05                	jmp    f01013a0 <cga_putc+0x25>
f010139b:	b8 00 07 00 00       	mov    $0x700,%eax
f01013a0:	09 45 08             	or     %eax,0x8(%ebp)
		//c |= 0x700; /*black and white*/
	}
	switch (c & 0xff) {
f01013a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01013a6:	0f b6 c0             	movzbl %al,%eax
f01013a9:	83 f8 0a             	cmp    $0xa,%eax
f01013ac:	74 77                	je     f0101425 <cga_putc+0xaa>
f01013ae:	83 f8 0a             	cmp    $0xa,%eax
f01013b1:	7f 13                	jg     f01013c6 <cga_putc+0x4b>
f01013b3:	83 f8 08             	cmp    $0x8,%eax
f01013b6:	74 2e                	je     f01013e6 <cga_putc+0x6b>
f01013b8:	83 f8 09             	cmp    $0x9,%eax
f01013bb:	0f 84 a8 00 00 00    	je     f0101469 <cga_putc+0xee>
f01013c1:	e9 22 01 00 00       	jmp    f01014e8 <cga_putc+0x16d>
f01013c6:	3d e4 00 00 00       	cmp    $0xe4,%eax
f01013cb:	0f 84 de 00 00 00    	je     f01014af <cga_putc+0x134>
f01013d1:	3d e5 00 00 00       	cmp    $0xe5,%eax
f01013d6:	0f 84 f1 00 00 00    	je     f01014cd <cga_putc+0x152>
f01013dc:	83 f8 0d             	cmp    $0xd,%eax
f01013df:	74 5d                	je     f010143e <cga_putc+0xc3>
f01013e1:	e9 02 01 00 00       	jmp    f01014e8 <cga_putc+0x16d>
	case '\b':
		if (crt_pos > 0) {
f01013e6:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01013ec:	66 85 c0             	test   %ax,%ax
f01013ef:	0f 84 4f 01 00 00    	je     f0101544 <cga_putc+0x1c9>
			crt_pos--;
f01013f5:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01013fb:	48                   	dec    %eax
f01013fc:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0101402:	8b 15 0c 3e 92 f0    	mov    0xf0923e0c,%edx
f0101408:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f010140e:	0f b7 c0             	movzwl %ax,%eax
f0101411:	01 c0                	add    %eax,%eax
f0101413:	01 c2                	add    %eax,%edx
f0101415:	8b 45 08             	mov    0x8(%ebp),%eax
f0101418:	b0 00                	mov    $0x0,%al
f010141a:	83 c8 20             	or     $0x20,%eax
f010141d:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0101420:	e9 1f 01 00 00       	jmp    f0101544 <cga_putc+0x1c9>
	case '\n':
		crt_pos += CRT_COLS;
f0101425:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f010142b:	83 c0 50             	add    $0x50,%eax
f010142e:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
		text_length = 0;
f0101434:	c7 05 00 3e 92 f0 00 	movl   $0x0,0xf0923e00
f010143b:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f010143e:	66 8b 0d 10 3e 92 f0 	mov    0xf0923e10,%cx
f0101445:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f010144b:	bb 50 00 00 00       	mov    $0x50,%ebx
f0101450:	ba 00 00 00 00       	mov    $0x0,%edx
f0101455:	66 f7 f3             	div    %bx
f0101458:	89 d0                	mov    %edx,%eax
f010145a:	29 c1                	sub    %eax,%ecx
f010145c:	89 c8                	mov    %ecx,%eax
f010145e:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
		break;
f0101464:	e9 e5 00 00 00       	jmp    f010154e <cga_putc+0x1d3>
	case '\t':
		cons_putc(' ');
f0101469:	83 ec 0c             	sub    $0xc,%esp
f010146c:	6a 20                	push   $0x20
f010146e:	e8 47 05 00 00       	call   f01019ba <cons_putc>
f0101473:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101476:	83 ec 0c             	sub    $0xc,%esp
f0101479:	6a 20                	push   $0x20
f010147b:	e8 3a 05 00 00       	call   f01019ba <cons_putc>
f0101480:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101483:	83 ec 0c             	sub    $0xc,%esp
f0101486:	6a 20                	push   $0x20
f0101488:	e8 2d 05 00 00       	call   f01019ba <cons_putc>
f010148d:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101490:	83 ec 0c             	sub    $0xc,%esp
f0101493:	6a 20                	push   $0x20
f0101495:	e8 20 05 00 00       	call   f01019ba <cons_putc>
f010149a:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010149d:	83 ec 0c             	sub    $0xc,%esp
f01014a0:	6a 20                	push   $0x20
f01014a2:	e8 13 05 00 00       	call   f01019ba <cons_putc>
f01014a7:	83 c4 10             	add    $0x10,%esp
		break;
f01014aa:	e9 9f 00 00 00       	jmp    f010154e <cga_putc+0x1d3>
	case KEY_LF:
		if(crt_pos>0)
f01014af:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01014b5:	66 85 c0             	test   %ax,%ax
f01014b8:	0f 84 89 00 00 00    	je     f0101547 <cga_putc+0x1cc>
			crt_pos--;
f01014be:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01014c4:	48                   	dec    %eax
f01014c5:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
		break;
f01014cb:	eb 7a                	jmp    f0101547 <cga_putc+0x1cc>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
f01014cd:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01014d3:	66 3d cf 07          	cmp    $0x7cf,%ax
f01014d7:	77 71                	ja     f010154a <cga_putc+0x1cf>
			crt_pos++;
f01014d9:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01014df:	40                   	inc    %eax
f01014e0:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
		break;
f01014e6:	eb 62                	jmp    f010154a <cga_putc+0x1cf>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f01014e8:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f01014ef:	74 5c                	je     f010154d <cga_putc+0x1d2>
f01014f1:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f01014f8:	74 53                	je     f010154d <cga_putc+0x1d2>
			crt_buf[crt_pos++] = c;		/* write the character */
f01014fa:	8b 0d 0c 3e 92 f0    	mov    0xf0923e0c,%ecx
f0101500:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f0101506:	8d 50 01             	lea    0x1(%eax),%edx
f0101509:	66 89 15 10 3e 92 f0 	mov    %dx,0xf0923e10
f0101510:	0f b7 c0             	movzwl %ax,%eax
f0101513:	01 c0                	add    %eax,%eax
f0101515:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0101518:	8b 45 08             	mov    0x8(%ebp),%eax
f010151b:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f010151e:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f0101524:	0f b7 c0             	movzwl %ax,%eax
f0101527:	8b 15 00 3e 92 f0    	mov    0xf0923e00,%edx
f010152d:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101533:	39 d0                	cmp    %edx,%eax
f0101535:	7e 16                	jle    f010154d <cga_putc+0x1d2>
				text_length++;
f0101537:	a1 00 3e 92 f0       	mov    0xf0923e00,%eax
f010153c:	40                   	inc    %eax
f010153d:	a3 00 3e 92 f0       	mov    %eax,0xf0923e00
		}
		break;
f0101542:	eb 09                	jmp    f010154d <cga_putc+0x1d2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0101544:	90                   	nop
f0101545:	eb 07                	jmp    f010154e <cga_putc+0x1d3>
		cons_putc(' ');
		break;
	case KEY_LF:
		if(crt_pos>0)
			crt_pos--;
		break;
f0101547:	90                   	nop
f0101548:	eb 04                	jmp    f010154e <cga_putc+0x1d3>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010154a:	90                   	nop
f010154b:	eb 01                	jmp    f010154e <cga_putc+0x1d3>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f010154d:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f010154e:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f0101554:	66 3d cf 07          	cmp    $0x7cf,%ax
f0101558:	76 58                	jbe    f01015b2 <cga_putc+0x237>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f010155a:	a1 0c 3e 92 f0       	mov    0xf0923e0c,%eax
f010155f:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f0101565:	a1 0c 3e 92 f0       	mov    0xf0923e0c,%eax
f010156a:	83 ec 04             	sub    $0x4,%esp
f010156d:	68 00 0f 00 00       	push   $0xf00
f0101572:	52                   	push   %edx
f0101573:	50                   	push   %eax
f0101574:	e8 47 1b 02 00       	call   f01230c0 <memcpy>
f0101579:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f010157c:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f0101583:	eb 15                	jmp    f010159a <cga_putc+0x21f>
			crt_buf[i] = 0x0700 | ' ';
f0101585:	8b 15 0c 3e 92 f0    	mov    0xf0923e0c,%edx
f010158b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010158e:	01 c0                	add    %eax,%eax
f0101590:	01 d0                	add    %edx,%eax
f0101592:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0101597:	ff 45 f4             	incl   -0xc(%ebp)
f010159a:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01015a1:	7e e2                	jle    f0101585 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01015a3:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01015a9:	83 e8 50             	sub    $0x50,%eax
f01015ac:	66 a3 10 3e 92 f0    	mov    %ax,0xf0923e10
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f01015b2:	a1 08 3e 92 f0       	mov    0xf0923e08,%eax
f01015b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01015ba:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01015be:	8a 45 e0             	mov    -0x20(%ebp),%al
f01015c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01015c4:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f01015c5:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01015cb:	66 c1 e8 08          	shr    $0x8,%ax
f01015cf:	0f b6 c0             	movzbl %al,%eax
f01015d2:	8b 15 08 3e 92 f0    	mov    0xf0923e08,%edx
f01015d8:	42                   	inc    %edx
f01015d9:	89 55 ec             	mov    %edx,-0x14(%ebp)
f01015dc:	88 45 e1             	mov    %al,-0x1f(%ebp)
f01015df:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01015e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01015e5:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f01015e6:	a1 08 3e 92 f0       	mov    0xf0923e08,%eax
f01015eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01015ee:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f01015f2:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01015f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01015f8:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f01015f9:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f01015ff:	0f b6 c0             	movzbl %al,%eax
f0101602:	8b 15 08 3e 92 f0    	mov    0xf0923e08,%edx
f0101608:	42                   	inc    %edx
f0101609:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010160c:	88 45 e3             	mov    %al,-0x1d(%ebp)
f010160f:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101612:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0101615:	ee                   	out    %al,(%dx)
}
f0101616:	90                   	nop
f0101617:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010161a:	c9                   	leave  
f010161b:	c3                   	ret    

f010161c <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f010161c:	55                   	push   %ebp
f010161d:	89 e5                	mov    %esp,%ebp
f010161f:	83 ec 28             	sub    $0x28,%esp
f0101622:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101629:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010162c:	89 c2                	mov    %eax,%edx
f010162e:	ec                   	in     (%dx),%al
f010162f:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0101632:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0101635:	0f b6 c0             	movzbl %al,%eax
f0101638:	83 e0 01             	and    $0x1,%eax
f010163b:	85 c0                	test   %eax,%eax
f010163d:	75 0a                	jne    f0101649 <kbd_proc_data+0x2d>
		return -1;
f010163f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0101644:	e9 2a 02 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
f0101649:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101650:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101653:	89 c2                	mov    %eax,%edx
f0101655:	ec                   	in     (%dx),%al
f0101656:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0101659:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f010165c:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f010165f:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0101663:	75 17                	jne    f010167c <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0101665:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f010166a:	83 c8 40             	or     $0x40,%eax
f010166d:	a3 28 40 92 f0       	mov    %eax,0xf0924028
		return 0;
f0101672:	b8 00 00 00 00       	mov    $0x0,%eax
f0101677:	e9 f7 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f010167c:	8a 45 f3             	mov    -0xd(%ebp),%al
f010167f:	84 c0                	test   %al,%al
f0101681:	79 44                	jns    f01016c7 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0101683:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f0101688:	83 e0 40             	and    $0x40,%eax
f010168b:	85 c0                	test   %eax,%eax
f010168d:	75 08                	jne    f0101697 <kbd_proc_data+0x7b>
f010168f:	8a 45 f3             	mov    -0xd(%ebp),%al
f0101692:	83 e0 7f             	and    $0x7f,%eax
f0101695:	eb 03                	jmp    f010169a <kbd_proc_data+0x7e>
f0101697:	8a 45 f3             	mov    -0xd(%ebp),%al
f010169a:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f010169d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01016a1:	8a 80 40 70 19 f0    	mov    -0xfe68fc0(%eax),%al
f01016a7:	83 c8 40             	or     $0x40,%eax
f01016aa:	0f b6 c0             	movzbl %al,%eax
f01016ad:	f7 d0                	not    %eax
f01016af:	89 c2                	mov    %eax,%edx
f01016b1:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f01016b6:	21 d0                	and    %edx,%eax
f01016b8:	a3 28 40 92 f0       	mov    %eax,0xf0924028
		return 0;
f01016bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01016c2:	e9 ac 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f01016c7:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f01016cc:	83 e0 40             	and    $0x40,%eax
f01016cf:	85 c0                	test   %eax,%eax
f01016d1:	74 11                	je     f01016e4 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f01016d3:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f01016d7:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f01016dc:	83 e0 bf             	and    $0xffffffbf,%eax
f01016df:	a3 28 40 92 f0       	mov    %eax,0xf0924028
	}

	shift |= shiftcode[data];
f01016e4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01016e8:	8a 80 40 70 19 f0    	mov    -0xfe68fc0(%eax),%al
f01016ee:	0f b6 d0             	movzbl %al,%edx
f01016f1:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f01016f6:	09 d0                	or     %edx,%eax
f01016f8:	a3 28 40 92 f0       	mov    %eax,0xf0924028
	shift ^= togglecode[data];
f01016fd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101701:	8a 80 40 71 19 f0    	mov    -0xfe68ec0(%eax),%al
f0101707:	0f b6 d0             	movzbl %al,%edx
f010170a:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f010170f:	31 d0                	xor    %edx,%eax
f0101711:	a3 28 40 92 f0       	mov    %eax,0xf0924028

	c = charcode[shift & (CTL | SHIFT)][data];
f0101716:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f010171b:	83 e0 03             	and    $0x3,%eax
f010171e:	8b 14 85 40 75 19 f0 	mov    -0xfe68ac0(,%eax,4),%edx
f0101725:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101729:	01 d0                	add    %edx,%eax
f010172b:	8a 00                	mov    (%eax),%al
f010172d:	0f b6 c0             	movzbl %al,%eax
f0101730:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0101733:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010173a:	0f 85 9c 00 00 00    	jne    f01017dc <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0101740:	a1 00 3e 92 f0       	mov    0xf0923e00,%eax
f0101745:	85 c0                	test   %eax,%eax
f0101747:	0f 8e 85 00 00 00    	jle    f01017d2 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f010174d:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f0101753:	0f b7 c0             	movzwl %ax,%eax
f0101756:	8b 15 00 3e 92 f0    	mov    0xf0923e00,%edx
f010175c:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101762:	39 d0                	cmp    %edx,%eax
f0101764:	75 0a                	jne    f0101770 <kbd_proc_data+0x154>
				return 0;
f0101766:	b8 00 00 00 00       	mov    $0x0,%eax
f010176b:	e9 03 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
			else {
				text_length--;
f0101770:	a1 00 3e 92 f0       	mov    0xf0923e00,%eax
f0101775:	48                   	dec    %eax
f0101776:	a3 00 3e 92 f0       	mov    %eax,0xf0923e00
				int crt_pos_Length = crt_pos - 1925;
f010177b:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f0101781:	0f b7 c0             	movzwl %ax,%eax
f0101784:	2d 85 07 00 00       	sub    $0x785,%eax
f0101789:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f010178c:	66 a1 10 3e 92 f0    	mov    0xf0923e10,%ax
f0101792:	0f b7 c0             	movzwl %ax,%eax
f0101795:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101798:	eb 26                	jmp    f01017c0 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f010179a:	8b 15 0c 3e 92 f0    	mov    0xf0923e0c,%edx
f01017a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01017a3:	01 c0                	add    %eax,%eax
f01017a5:	01 c2                	add    %eax,%edx
f01017a7:	a1 0c 3e 92 f0       	mov    0xf0923e0c,%eax
f01017ac:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f01017af:	41                   	inc    %ecx
f01017b0:	01 c9                	add    %ecx,%ecx
f01017b2:	01 c8                	add    %ecx,%eax
f01017b4:	66 8b 00             	mov    (%eax),%ax
f01017b7:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f01017ba:	ff 45 e8             	incl   -0x18(%ebp)
f01017bd:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f01017c0:	a1 00 3e 92 f0       	mov    0xf0923e00,%eax
f01017c5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01017c8:	7e d0                	jle    f010179a <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f01017ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01017cd:	e9 a1 00 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
			}
		}
		return 0;
f01017d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01017d7:	e9 97 00 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f01017dc:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f01017e1:	83 e0 08             	and    $0x8,%eax
f01017e4:	85 c0                	test   %eax,%eax
f01017e6:	74 22                	je     f010180a <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f01017e8:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f01017ec:	7e 0c                	jle    f01017fa <kbd_proc_data+0x1de>
f01017ee:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f01017f2:	7f 06                	jg     f01017fa <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f01017f4:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f01017f8:	eb 10                	jmp    f010180a <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f01017fa:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f01017fe:	7e 0a                	jle    f010180a <kbd_proc_data+0x1ee>
f0101800:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0101804:	7f 04                	jg     f010180a <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0101806:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f010180a:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f010180f:	83 f8 10             	cmp    $0x10,%eax
f0101812:	75 13                	jne    f0101827 <kbd_proc_data+0x20b>
f0101814:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0101818:	7e 0d                	jle    f0101827 <kbd_proc_data+0x20b>
f010181a:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f010181e:	7f 07                	jg     f0101827 <kbd_proc_data+0x20b>
		return 0;
f0101820:	b8 00 00 00 00       	mov    $0x0,%eax
f0101825:	eb 4c                	jmp    f0101873 <kbd_proc_data+0x257>
	if (c == 255)
f0101827:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010182e:	75 07                	jne    f0101837 <kbd_proc_data+0x21b>
		return 0;
f0101830:	b8 00 00 00 00       	mov    $0x0,%eax
f0101835:	eb 3c                	jmp    f0101873 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0101837:	a1 28 40 92 f0       	mov    0xf0924028,%eax
f010183c:	f7 d0                	not    %eax
f010183e:	83 e0 06             	and    $0x6,%eax
f0101841:	85 c0                	test   %eax,%eax
f0101843:	75 2b                	jne    f0101870 <kbd_proc_data+0x254>
f0101845:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010184c:	75 22                	jne    f0101870 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f010184e:	83 ec 0c             	sub    $0xc,%esp
f0101851:	68 c4 3a 13 f0       	push   $0xf0133ac4
f0101856:	e8 f2 02 00 00       	call   f0101b4d <cprintf>
f010185b:	83 c4 10             	add    $0x10,%esp
f010185e:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0101865:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101869:	8a 45 d9             	mov    -0x27(%ebp),%al
f010186c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010186f:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0101870:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101873:	c9                   	leave  
f0101874:	c3                   	ret    

f0101875 <kbd_intr>:

void
kbd_intr(void)
{
f0101875:	55                   	push   %ebp
f0101876:	89 e5                	mov    %esp,%ebp
f0101878:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f010187b:	83 ec 0c             	sub    $0xc,%esp
f010187e:	68 1c 16 10 f0       	push   $0xf010161c
f0101883:	e8 38 00 00 00       	call   f01018c0 <cons_intr>
f0101888:	83 c4 10             	add    $0x10,%esp
}
f010188b:	90                   	nop
f010188c:	c9                   	leave  
f010188d:	c3                   	ret    

f010188e <kbd_init>:

void
kbd_init(void)
{
f010188e:	55                   	push   %ebp
f010188f:	89 e5                	mov    %esp,%ebp
f0101891:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0101894:	83 ec 08             	sub    $0x8,%esp
f0101897:	68 a1 1a 10 f0       	push   $0xf0101aa1
f010189c:	6a 01                	push   $0x1
f010189e:	e8 ea e6 00 00       	call   f010ff8d <irq_install_handler>
f01018a3:	83 c4 10             	add    $0x10,%esp
		init_channel(&KBDchannel, "keyboard channel");
		init_kspinlock(&KBDlock, "keyboard channel lock");
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
f01018a6:	83 ec 04             	sub    $0x4,%esp
f01018a9:	68 d0 3a 13 f0       	push   $0xf0133ad0
f01018ae:	6a 00                	push   $0x0
f01018b0:	68 c0 51 96 f1       	push   $0xf19651c0
f01018b5:	e8 68 22 01 00       	call   f0113b22 <init_ksemaphore>
f01018ba:	83 c4 10             	add    $0x10,%esp
	}
}
f01018bd:	90                   	nop
f01018be:	c9                   	leave  
f01018bf:	c3                   	ret    

f01018c0 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f01018c0:	55                   	push   %ebp
f01018c1:	89 e5                	mov    %esp,%ebp
f01018c3:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f01018c6:	eb 35                	jmp    f01018fd <cons_intr+0x3d>
		if (c == 0)
f01018c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01018cc:	75 02                	jne    f01018d0 <cons_intr+0x10>
			continue;
f01018ce:	eb 2d                	jmp    f01018fd <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f01018d0:	a1 24 40 92 f0       	mov    0xf0924024,%eax
f01018d5:	8d 50 01             	lea    0x1(%eax),%edx
f01018d8:	89 15 24 40 92 f0    	mov    %edx,0xf0924024
f01018de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01018e1:	88 90 20 3e 92 f0    	mov    %dl,-0xf6dc1e0(%eax)
		if (cons.wpos == CONSBUFSIZE)
f01018e7:	a1 24 40 92 f0       	mov    0xf0924024,%eax
f01018ec:	3d 00 02 00 00       	cmp    $0x200,%eax
f01018f1:	75 0a                	jne    f01018fd <cons_intr+0x3d>
			cons.wpos = 0;
f01018f3:	c7 05 24 40 92 f0 00 	movl   $0x0,0xf0924024
f01018fa:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f01018fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0101900:	ff d0                	call   *%eax
f0101902:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101905:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0101909:	75 bd                	jne    f01018c8 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f010190b:	90                   	nop
f010190c:	c9                   	leave  
f010190d:	c3                   	ret    

f010190e <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f010190e:	55                   	push   %ebp
f010190f:	89 e5                	mov    %esp,%ebp
f0101911:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0101914:	e8 c6 f7 ff ff       	call   f01010df <serial_intr>
	kbd_intr();
f0101919:	e8 57 ff ff ff       	call   f0101875 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f010191e:	8b 15 20 40 92 f0    	mov    0xf0924020,%edx
f0101924:	a1 24 40 92 f0       	mov    0xf0924024,%eax
f0101929:	39 c2                	cmp    %eax,%edx
f010192b:	74 35                	je     f0101962 <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f010192d:	a1 20 40 92 f0       	mov    0xf0924020,%eax
f0101932:	8d 50 01             	lea    0x1(%eax),%edx
f0101935:	89 15 20 40 92 f0    	mov    %edx,0xf0924020
f010193b:	8a 80 20 3e 92 f0    	mov    -0xf6dc1e0(%eax),%al
f0101941:	0f b6 c0             	movzbl %al,%eax
f0101944:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101947:	a1 20 40 92 f0       	mov    0xf0924020,%eax
f010194c:	3d 00 02 00 00       	cmp    $0x200,%eax
f0101951:	75 0a                	jne    f010195d <cons_getc+0x4f>
			cons.rpos = 0;
f0101953:	c7 05 20 40 92 f0 00 	movl   $0x0,0xf0924020
f010195a:	00 00 00 
		return c;
f010195d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101960:	eb 05                	jmp    f0101967 <cons_getc+0x59>
	}
	return 0;
f0101962:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101967:	c9                   	leave  
f0101968:	c3                   	ret    

f0101969 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0101969:	55                   	push   %ebp
f010196a:	89 e5                	mov    %esp,%ebp
f010196c:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f010196f:	8b 15 20 40 92 f0    	mov    0xf0924020,%edx
f0101975:	a1 24 40 92 f0       	mov    0xf0924024,%eax
f010197a:	39 c2                	cmp    %eax,%edx
f010197c:	74 35                	je     f01019b3 <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f010197e:	a1 20 40 92 f0       	mov    0xf0924020,%eax
f0101983:	8d 50 01             	lea    0x1(%eax),%edx
f0101986:	89 15 20 40 92 f0    	mov    %edx,0xf0924020
f010198c:	8a 80 20 3e 92 f0    	mov    -0xf6dc1e0(%eax),%al
f0101992:	0f b6 c0             	movzbl %al,%eax
f0101995:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101998:	a1 20 40 92 f0       	mov    0xf0924020,%eax
f010199d:	3d 00 02 00 00       	cmp    $0x200,%eax
f01019a2:	75 0a                	jne    f01019ae <cons_getc2+0x45>
			cons.rpos = 0;
f01019a4:	c7 05 20 40 92 f0 00 	movl   $0x0,0xf0924020
f01019ab:	00 00 00 
		return c;
f01019ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01019b1:	eb 05                	jmp    f01019b8 <cons_getc2+0x4f>
	}
	return 0;
f01019b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01019b8:	c9                   	leave  
f01019b9:	c3                   	ret    

f01019ba <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f01019ba:	55                   	push   %ebp
f01019bb:	89 e5                	mov    %esp,%ebp
f01019bd:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f01019c0:	ff 75 08             	pushl  0x8(%ebp)
f01019c3:	e8 79 f8 ff ff       	call   f0101241 <lpt_putc>
f01019c8:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f01019cb:	83 ec 0c             	sub    $0xc,%esp
f01019ce:	ff 75 08             	pushl  0x8(%ebp)
f01019d1:	e8 a5 f9 ff ff       	call   f010137b <cga_putc>
f01019d6:	83 c4 10             	add    $0x10,%esp
}
f01019d9:	90                   	nop
f01019da:	c9                   	leave  
f01019db:	c3                   	ret    

f01019dc <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f01019dc:	55                   	push   %ebp
f01019dd:	89 e5                	mov    %esp,%ebp
f01019df:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f01019e2:	e8 cf f8 ff ff       	call   f01012b6 <cga_init>
	kbd_init();
f01019e7:	e8 a2 fe ff ff       	call   f010188e <kbd_init>
	serial_init();
f01019ec:	e8 2e f7 ff ff       	call   f010111f <serial_init>

	if (!serial_exists)
f01019f1:	a1 04 3e 92 f0       	mov    0xf0923e04,%eax
f01019f6:	85 c0                	test   %eax,%eax
f01019f8:	75 10                	jne    f0101a0a <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f01019fa:	83 ec 0c             	sub    $0xc,%esp
f01019fd:	68 e3 3a 13 f0       	push   $0xf0133ae3
f0101a02:	e8 46 01 00 00       	call   f0101b4d <cprintf>
f0101a07:	83 c4 10             	add    $0x10,%esp
	{
		init_sleeplock(&conslock, "console sleep lock");
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
f0101a0a:	83 ec 04             	sub    $0x4,%esp
f0101a0d:	68 00 3b 13 f0       	push   $0xf0133b00
f0101a12:	6a 01                	push   $0x1
f0101a14:	68 80 50 96 f1       	push   $0xf1965080
f0101a19:	e8 04 21 01 00       	call   f0113b22 <init_ksemaphore>
f0101a1e:	83 c4 10             	add    $0x10,%esp
	}
}
f0101a21:	90                   	nop
f0101a22:	c9                   	leave  
f0101a23:	c3                   	ret    

f0101a24 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0101a24:	55                   	push   %ebp
f0101a25:	89 e5                	mov    %esp,%ebp
f0101a27:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0101a2a:	83 ec 0c             	sub    $0xc,%esp
f0101a2d:	ff 75 08             	pushl  0x8(%ebp)
f0101a30:	e8 85 ff ff ff       	call   f01019ba <cons_putc>
f0101a35:	83 c4 10             	add    $0x10,%esp
}
f0101a38:	90                   	nop
f0101a39:	c9                   	leave  
f0101a3a:	c3                   	ret    

f0101a3b <getchar>:

int
getchar(void)
{
f0101a3b:	55                   	push   %ebp
f0101a3c:	89 e5                	mov    %esp,%ebp
f0101a3e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0101a41:	e8 c8 fe ff ff       	call   f010190e <cons_getc>
f0101a46:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101a49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101a4d:	74 f2                	je     f0101a41 <getchar+0x6>
		/* do nothing */;
	return c;
f0101a4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101a52:	c9                   	leave  
f0101a53:	c3                   	ret    

f0101a54 <iscons>:

int
iscons(int fdnum)
{
f0101a54:	55                   	push   %ebp
f0101a55:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0101a57:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0101a5c:	5d                   	pop    %ebp
f0101a5d:	c3                   	ret    

f0101a5e <clear_screen_buffer>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
void
clear_screen_buffer(void)
{
f0101a5e:	55                   	push   %ebp
f0101a5f:	89 e5                	mov    %esp,%ebp
f0101a61:	83 ec 10             	sub    $0x10,%esp
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
f0101a64:	c7 45 f8 00 80 0b f0 	movl   $0xf00b8000,-0x8(%ebp)
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101a6b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0101a72:	eb 18                	jmp    f0101a8c <clear_screen_buffer+0x2e>
		crt_buf[i] = 0x0700 | ' ';
f0101a74:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101a77:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0101a7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101a81:	01 d0                	add    %edx,%eax
f0101a83:	c7 00 20 07 00 00    	movl   $0x720,(%eax)
clear_screen_buffer(void)
{
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101a89:	ff 45 fc             	incl   -0x4(%ebp)
f0101a8c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
f0101a93:	7e df                	jle    f0101a74 <clear_screen_buffer+0x16>
		crt_buf[i] = 0x0700 | ' ';
	crt_pos = 0; // reset_cursor_position
f0101a95:	66 c7 05 10 3e 92 f0 	movw   $0x0,0xf0923e10
f0101a9c:	00 00 
}
f0101a9e:	90                   	nop
f0101a9f:	c9                   	leave  
f0101aa0:	c3                   	ret    

f0101aa1 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0101aa1:	55                   	push   %ebp
f0101aa2:	89 e5                	mov    %esp,%ebp
f0101aa4:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0101aa7:	e8 c9 fd ff ff       	call   f0101875 <kbd_intr>

	//If there's a received char in the cons.buf, wakeup a waiting process (if any)
	if (cons.rpos != cons.wpos)
f0101aac:	8b 15 20 40 92 f0    	mov    0xf0924020,%edx
f0101ab2:	a1 24 40 92 f0       	mov    0xf0924024,%eax
f0101ab7:	39 c2                	cmp    %eax,%edx
f0101ab9:	74 10                	je     f0101acb <keyboard_interrupt_handler+0x2a>
		{
			wakeup_one(&KBDchannel);
		}
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
f0101abb:	83 ec 0c             	sub    $0xc,%esp
f0101abe:	68 c0 51 96 f1       	push   $0xf19651c0
f0101ac3:	e8 0c 21 01 00       	call   f0113bd4 <signal_ksemaphore>
f0101ac8:	83 c4 10             	add    $0x10,%esp
		}
	}
}
f0101acb:	90                   	nop
f0101acc:	c9                   	leave  
f0101acd:	c3                   	ret    

f0101ace <cons_lock>:

void cons_lock(void)
{
f0101ace:	55                   	push   %ebp
f0101acf:	89 e5                	mov    %esp,%ebp
f0101ad1:	83 ec 08             	sub    $0x8,%esp
	{
		acquire_sleeplock(&conslock);
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
f0101ad4:	83 ec 0c             	sub    $0xc,%esp
f0101ad7:	68 80 50 96 f1       	push   $0xf1965080
f0101adc:	e8 97 20 01 00       	call   f0113b78 <wait_ksemaphore>
f0101ae1:	83 c4 10             	add    $0x10,%esp
	}

}
f0101ae4:	90                   	nop
f0101ae5:	c9                   	leave  
f0101ae6:	c3                   	ret    

f0101ae7 <cons_unlock>:

void cons_unlock(void)
{
f0101ae7:	55                   	push   %ebp
f0101ae8:	89 e5                	mov    %esp,%ebp
f0101aea:	83 ec 08             	sub    $0x8,%esp
	{
		release_sleeplock(&conslock);
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
f0101aed:	83 ec 0c             	sub    $0xc,%esp
f0101af0:	68 80 50 96 f1       	push   $0xf1965080
f0101af5:	e8 da 20 01 00       	call   f0113bd4 <signal_ksemaphore>
f0101afa:	83 c4 10             	add    $0x10,%esp
	}

}
f0101afd:	90                   	nop
f0101afe:	c9                   	leave  
f0101aff:	c3                   	ret    

f0101b00 <putch>:
#include <kern/cons/console.h>


static void
putch(int ch, int *cnt)
{
f0101b00:	55                   	push   %ebp
f0101b01:	89 e5                	mov    %esp,%ebp
f0101b03:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0101b06:	83 ec 0c             	sub    $0xc,%esp
f0101b09:	ff 75 08             	pushl  0x8(%ebp)
f0101b0c:	e8 13 ff ff ff       	call   f0101a24 <cputchar>
f0101b11:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0101b14:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b17:	8b 00                	mov    (%eax),%eax
f0101b19:	8d 50 01             	lea    0x1(%eax),%edx
f0101b1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b1f:	89 10                	mov    %edx,(%eax)
}
f0101b21:	90                   	nop
f0101b22:	c9                   	leave  
f0101b23:	c3                   	ret    

f0101b24 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0101b24:	55                   	push   %ebp
f0101b25:	89 e5                	mov    %esp,%ebp
f0101b27:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0101b2a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0101b31:	ff 75 0c             	pushl  0xc(%ebp)
f0101b34:	ff 75 08             	pushl  0x8(%ebp)
f0101b37:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101b3a:	50                   	push   %eax
f0101b3b:	68 00 1b 10 f0       	push   $0xf0101b00
f0101b40:	e8 28 0c 02 00       	call   f012276d <vprintfmt>
f0101b45:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0101b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101b4b:	c9                   	leave  
f0101b4c:	c3                   	ret    

f0101b4d <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0101b4d:	55                   	push   %ebp
f0101b4e:	89 e5                	mov    %esp,%ebp
f0101b50:	83 ec 18             	sub    $0x18,%esp
	int cnt;
	pushcli();	//disable interrupts
f0101b53:	e8 6a 6a 00 00       	call   f01085c2 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101b58:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101b5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101b5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101b61:	83 ec 08             	sub    $0x8,%esp
f0101b64:	ff 75 f4             	pushl  -0xc(%ebp)
f0101b67:	50                   	push   %eax
f0101b68:	e8 b7 ff ff ff       	call   f0101b24 <vcprintf>
f0101b6d:	83 c4 10             	add    $0x10,%esp
f0101b70:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101b73:	e8 9c 6a 00 00       	call   f0108614 <popcli>

	return cnt;
f0101b78:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101b7b:	c9                   	leave  
f0101b7c:	c3                   	ret    

f0101b7d <cprintf_colored>:

// *************** This text coloring feature is implemented by *************
// ********** Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int
cprintf_colored(int textClr, const char *fmt, ...)
{
f0101b7d:	55                   	push   %ebp
f0101b7e:	89 e5                	mov    %esp,%ebp
f0101b80:	83 ec 18             	sub    $0x18,%esp
	current_text_color = (textClr << 8) ;
f0101b83:	8b 45 08             	mov    0x8(%ebp),%eax
f0101b86:	c1 e0 08             	shl    $0x8,%eax
f0101b89:	a3 90 51 96 f1       	mov    %eax,0xf1965190
	int cnt;
	pushcli();	//disable interrupts
f0101b8e:	e8 2f 6a 00 00       	call   f01085c2 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101b93:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101b96:	83 c0 04             	add    $0x4,%eax
f0101b99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101b9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b9f:	83 ec 08             	sub    $0x8,%esp
f0101ba2:	ff 75 f4             	pushl  -0xc(%ebp)
f0101ba5:	50                   	push   %eax
f0101ba6:	e8 79 ff ff ff       	call   f0101b24 <vcprintf>
f0101bab:	83 c4 10             	add    $0x10,%esp
f0101bae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101bb1:	e8 5e 6a 00 00       	call   f0108614 <popcli>
	current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f0101bb6:	c7 05 90 51 96 f1 00 	movl   $0x700,0xf1965190
f0101bbd:	07 00 00 

	return cnt;
f0101bc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101bc3:	c9                   	leave  
f0101bc4:	c3                   	ret    

f0101bc5 <run_command_prompt>:
#include "commands.h"

extern bool __autograde__ ;
extern void command_prompt_readline(const char *prompt, char* buf);
void run_command_prompt()
{
f0101bc5:	55                   	push   %ebp
f0101bc6:	89 e5                	mov    %esp,%ebp
f0101bc8:	57                   	push   %edi
f0101bc9:	56                   	push   %esi
f0101bca:	53                   	push   %ebx
f0101bcb:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (__autograde__)
f0101bd1:	a1 20 70 19 f0       	mov    0xf0197020,%eax
f0101bd6:	85 c0                	test   %eax,%eax
f0101bd8:	0f 84 85 00 00 00    	je     f0101c63 <run_command_prompt+0x9e>
	{
		char cmdU1_2[BUFLEN] = "tst priorityRR 0";	//
f0101bde:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101be4:	bb 1a 3b 13 f0       	mov    $0xf0133b1a,%ebx
f0101be9:	ba 11 00 00 00       	mov    $0x11,%edx
f0101bee:	89 c7                	mov    %eax,%edi
f0101bf0:	89 de                	mov    %ebx,%esi
f0101bf2:	89 d1                	mov    %edx,%ecx
f0101bf4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101bf6:	8d 95 f9 ef ff ff    	lea    -0x1007(%ebp),%edx
f0101bfc:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c01:	b0 00                	mov    $0x0,%al
f0101c03:	89 d7                	mov    %edx,%edi
f0101c05:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU2_2[BUFLEN] = "tst priorityRR 1";	//
f0101c07:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101c0d:	bb 1a 3f 13 f0       	mov    $0xf0133f1a,%ebx
f0101c12:	ba 11 00 00 00       	mov    $0x11,%edx
f0101c17:	89 c7                	mov    %eax,%edi
f0101c19:	89 de                	mov    %ebx,%esi
f0101c1b:	89 d1                	mov    %edx,%ecx
f0101c1d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c1f:	8d 95 f9 f3 ff ff    	lea    -0xc07(%ebp),%edx
f0101c25:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c2a:	b0 00                	mov    $0x0,%al
f0101c2c:	89 d7                	mov    %edx,%edi
f0101c2e:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU3_2[BUFLEN] = "tst priorityRR 2";	//
f0101c30:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101c36:	bb 1a 43 13 f0       	mov    $0xf013431a,%ebx
f0101c3b:	ba 11 00 00 00       	mov    $0x11,%edx
f0101c40:	89 c7                	mov    %eax,%edi
f0101c42:	89 de                	mov    %ebx,%esi
f0101c44:	89 d1                	mov    %edx,%ecx
f0101c46:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c48:	8d 95 f9 f7 ff ff    	lea    -0x807(%ebp),%edx
f0101c4e:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c53:	b0 00                	mov    $0x0,%al
f0101c55:	89 d7                	mov    %edx,%edi
f0101c57:	f3 aa                	rep stos %al,%es:(%edi)
//		execute_command(cmdU3_2);
		__autograde__ = 0;
f0101c59:	c7 05 20 70 19 f0 00 	movl   $0x0,0xf0197020
f0101c60:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101c63:	c7 05 0c 54 96 f1 00 	movl   $0x0,0xf196540c
f0101c6a:	00 00 00 
f0101c6d:	c7 05 10 54 96 f1 00 	movl   $0x0,0xf1965410
f0101c74:	00 00 00 
f0101c77:	c7 05 18 54 96 f1 00 	movl   $0x0,0xf1965418
f0101c7e:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101c81:	83 ec 04             	sub    $0x4,%esp
f0101c84:	68 00 04 00 00       	push   $0x400
f0101c89:	6a 00                	push   $0x0
f0101c8b:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101c91:	50                   	push   %eax
f0101c92:	e8 86 13 02 00       	call   f012301d <memset>
f0101c97:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101c9a:	83 ec 08             	sub    $0x8,%esp
f0101c9d:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101ca3:	50                   	push   %eax
f0101ca4:	68 14 3b 13 f0       	push   $0xf0133b14
f0101ca9:	e8 42 06 00 00       	call   f01022f0 <command_prompt_readline>
f0101cae:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101cb1:	83 ec 0c             	sub    $0xc,%esp
f0101cb4:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101cba:	50                   	push   %eax
f0101cbb:	e8 4c 01 00 00       	call   f0101e0c <execute_command>
f0101cc0:	83 c4 10             	add    $0x10,%esp
f0101cc3:	85 c0                	test   %eax,%eax
f0101cc5:	78 02                	js     f0101cc9 <run_command_prompt+0x104>
				break;
	}
f0101cc7:	eb b8                	jmp    f0101c81 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101cc9:	90                   	nop
	}
}
f0101cca:	90                   	nop
f0101ccb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101cce:	5b                   	pop    %ebx
f0101ccf:	5e                   	pop    %esi
f0101cd0:	5f                   	pop    %edi
f0101cd1:	5d                   	pop    %ebp
f0101cd2:	c3                   	ret    

f0101cd3 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101cd3:	55                   	push   %ebp
f0101cd4:	89 e5                	mov    %esp,%ebp
f0101cd6:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101cd9:	9c                   	pushf  
f0101cda:	58                   	pop    %eax
f0101cdb:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101cde:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101ce1:	25 00 02 00 00       	and    $0x200,%eax
f0101ce6:	85 c0                	test   %eax,%eax
f0101ce8:	74 01                	je     f0101ceb <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101cea:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101ceb:	e8 de bb 00 00       	call   f010d8ce <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101cf0:	e8 0a 68 00 00       	call   f01084ff <mycpu>
f0101cf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101cf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101cfb:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101d02:	00 00 00 
		c->intena = 0;
f0101d05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d08:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101d0f:	00 00 00 
		c->scheduler = NULL;
f0101d12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d15:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101d1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d1f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101d26:	00 00 00 
		c->proc = NULL;
f0101d29:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d2c:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101d33:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101d36:	89 e0                	mov    %esp,%eax
f0101d38:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101d3b:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101d3e:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101d41:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d44:	8b 40 08             	mov    0x8(%eax),%eax
f0101d47:	05 00 80 00 00       	add    $0x8000,%eax
f0101d4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101d4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d52:	8b 40 08             	mov    0x8(%eax),%eax
f0101d55:	05 00 10 00 00       	add    $0x1000,%eax
f0101d5a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101d5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101d60:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101d63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101d66:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101d68:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d6b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101d6e:	73 44                	jae    f0101db4 <get_into_prompt+0xe1>
f0101d70:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d73:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101d76:	72 3c                	jb     f0101db4 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101d78:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d7b:	a3 14 55 96 f1       	mov    %eax,0xf1965514
			m = cpuStackTop - cur_esp;
f0101d80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101d83:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101d86:	a3 18 55 96 f1       	mov    %eax,0xf1965518
			while (--m >= 0)
f0101d8b:	eb 11                	jmp    f0101d9e <get_into_prompt+0xcb>
				*p++ = 0;
f0101d8d:	a1 14 55 96 f1       	mov    0xf1965514,%eax
f0101d92:	8d 50 01             	lea    0x1(%eax),%edx
f0101d95:	89 15 14 55 96 f1    	mov    %edx,0xf1965514
f0101d9b:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101d9e:	a1 18 55 96 f1       	mov    0xf1965518,%eax
f0101da3:	48                   	dec    %eax
f0101da4:	a3 18 55 96 f1       	mov    %eax,0xf1965518
f0101da9:	a1 18 55 96 f1       	mov    0xf1965518,%eax
f0101dae:	85 c0                	test   %eax,%eax
f0101db0:	79 db                	jns    f0101d8d <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101db2:	eb 3a                	jmp    f0101dee <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101db4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101db7:	a3 14 55 96 f1       	mov    %eax,0xf1965514
			m = cpuStackTop - cpuStackBottom;
f0101dbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101dbf:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101dc2:	a3 18 55 96 f1       	mov    %eax,0xf1965518
			while (--m >= 0)
f0101dc7:	eb 11                	jmp    f0101dda <get_into_prompt+0x107>
				*p++ = 0;
f0101dc9:	a1 14 55 96 f1       	mov    0xf1965514,%eax
f0101dce:	8d 50 01             	lea    0x1(%eax),%edx
f0101dd1:	89 15 14 55 96 f1    	mov    %edx,0xf1965514
f0101dd7:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101dda:	a1 18 55 96 f1       	mov    0xf1965518,%eax
f0101ddf:	48                   	dec    %eax
f0101de0:	a3 18 55 96 f1       	mov    %eax,0xf1965518
f0101de5:	a1 18 55 96 f1       	mov    0xf1965518,%eax
f0101dea:	85 c0                	test   %eax,%eax
f0101dec:	79 db                	jns    f0101dc9 <get_into_prompt+0xf6>
f0101dee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101df5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101df8:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101dfa:	83 ec 0c             	sub    $0xc,%esp
f0101dfd:	6a 00                	push   $0x0
f0101dff:	e8 c1 fd ff ff       	call   f0101bc5 <run_command_prompt>
f0101e04:	83 c4 10             	add    $0x10,%esp
	}
f0101e07:	e9 cd fe ff ff       	jmp    f0101cd9 <get_into_prompt+0x6>

f0101e0c <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101e0c:	55                   	push   %ebp
f0101e0d:	89 e5                	mov    %esp,%ebp
f0101e0f:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101e12:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101e15:	50                   	push   %eax
f0101e16:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101e19:	50                   	push   %eax
f0101e1a:	68 1a 47 13 f0       	push   $0xf013471a
f0101e1f:	ff 75 08             	pushl  0x8(%ebp)
f0101e22:	e8 cc 16 02 00       	call   f01234f3 <strsplit>
f0101e27:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101e2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101e2d:	85 c0                	test   %eax,%eax
f0101e2f:	75 0a                	jne    f0101e3b <execute_command+0x2f>
		return 0;
f0101e31:	b8 00 00 00 00       	mov    $0x0,%eax
f0101e36:	e9 a4 02 00 00       	jmp    f01020df <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101e3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101e3e:	83 ec 08             	sub    $0x8,%esp
f0101e41:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101e44:	52                   	push   %edx
f0101e45:	50                   	push   %eax
f0101e46:	e8 96 02 00 00       	call   f01020e1 <process_command>
f0101e4b:	83 c4 10             	add    $0x10,%esp
f0101e4e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (ret == CMD_INVALID)
f0101e51:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101e55:	75 19                	jne    f0101e70 <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101e57:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101e5a:	83 ec 08             	sub    $0x8,%esp
f0101e5d:	50                   	push   %eax
f0101e5e:	68 1f 47 13 f0       	push   $0xf013471f
f0101e63:	e8 e5 fc ff ff       	call   f0101b4d <cprintf>
f0101e68:	83 c4 10             	add    $0x10,%esp
f0101e6b:	e9 6a 02 00 00       	jmp    f01020da <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101e70:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101e74:	75 4f                	jne    f0101ec5 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101e76:	a1 18 54 96 f1       	mov    0xf1965418,%eax
f0101e7b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101e7e:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101e82:	74 17                	je     f0101e9b <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101e84:	83 ec 04             	sub    $0x4,%esp
f0101e87:	68 38 47 13 f0       	push   $0xf0134738
f0101e8c:	68 90 00 00 00       	push   $0x90
f0101e91:	68 89 47 13 f0       	push   $0xf0134789
f0101e96:	e8 14 f0 ff ff       	call   f0100eaf <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101e9b:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f0101ea0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101ea3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101ea6:	8b 50 04             	mov    0x4(%eax),%edx
f0101ea9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101eac:	8b 00                	mov    (%eax),%eax
f0101eae:	83 ec 04             	sub    $0x4,%esp
f0101eb1:	52                   	push   %edx
f0101eb2:	50                   	push   %eax
f0101eb3:	68 a4 47 13 f0       	push   $0xf01347a4
f0101eb8:	e8 90 fc ff ff       	call   f0101b4d <cprintf>
f0101ebd:	83 c4 10             	add    $0x10,%esp
f0101ec0:	e9 15 02 00 00       	jmp    f01020da <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101ec5:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101ec9:	0f 85 e6 01 00 00    	jne    f01020b5 <execute_command+0x2a9>
	{
		int i = 1;
f0101ecf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101ed6:	a1 18 54 96 f1       	mov    0xf1965418,%eax
f0101edb:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101ede:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101ee2:	75 17                	jne    f0101efb <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101ee4:	83 ec 04             	sub    $0x4,%esp
f0101ee7:	68 d4 47 13 f0       	push   $0xf01347d4
f0101eec:	68 9b 00 00 00       	push   $0x9b
f0101ef1:	68 89 47 13 f0       	push   $0xf0134789
f0101ef6:	e8 b4 ef ff ff       	call   f0100eaf <_panic>
		}
		struct Command * cmd = NULL;
f0101efb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101f02:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f0101f07:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101f0a:	eb 28                	jmp    f0101f34 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101f0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101f0f:	8b 10                	mov    (%eax),%edx
f0101f11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101f14:	8d 48 01             	lea    0x1(%eax),%ecx
f0101f17:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101f1a:	83 ec 04             	sub    $0x4,%esp
f0101f1d:	52                   	push   %edx
f0101f1e:	50                   	push   %eax
f0101f1f:	68 fe 47 13 f0       	push   $0xf01347fe
f0101f24:	e8 24 fc ff ff       	call   f0101b4d <cprintf>
f0101f29:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101f2c:	a1 14 54 96 f1       	mov    0xf1965414,%eax
f0101f31:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101f34:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101f38:	74 08                	je     f0101f42 <execute_command+0x136>
f0101f3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101f3d:	8b 40 10             	mov    0x10(%eax),%eax
f0101f40:	eb 05                	jmp    f0101f47 <execute_command+0x13b>
f0101f42:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f47:	a3 14 54 96 f1       	mov    %eax,0xf1965414
f0101f4c:	a1 14 54 96 f1       	mov    0xf1965414,%eax
f0101f51:	85 c0                	test   %eax,%eax
f0101f53:	75 b7                	jne    f0101f0c <execute_command+0x100>
f0101f55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101f59:	75 b1                	jne    f0101f0c <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f0101f5b:	83 ec 08             	sub    $0x8,%esp
f0101f5e:	ff 75 dc             	pushl  -0x24(%ebp)
f0101f61:	68 08 48 13 f0       	push   $0xf0134808
f0101f66:	e8 e2 fb ff ff       	call   f0101b4d <cprintf>
f0101f6b:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f0101f6e:	e8 c8 fa ff ff       	call   f0101a3b <getchar>
f0101f73:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0101f76:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101f7a:	83 ec 0c             	sub    $0xc,%esp
f0101f7d:	50                   	push   %eax
f0101f7e:	e8 a1 fa ff ff       	call   f0101a24 <cputchar>
f0101f83:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0101f86:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f0101f8d:	eb 40                	jmp    f0101fcf <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f0101f8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0101f92:	89 d0                	mov    %edx,%eax
f0101f94:	c1 e0 02             	shl    $0x2,%eax
f0101f97:	01 d0                	add    %edx,%eax
f0101f99:	01 c0                	add    %eax,%eax
f0101f9b:	89 c2                	mov    %eax,%edx
f0101f9d:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101fa1:	83 e8 30             	sub    $0x30,%eax
f0101fa4:	01 d0                	add    %edx,%eax
f0101fa6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0101fa9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0101fad:	7e 2c                	jle    f0101fdb <execute_command+0x1cf>
f0101faf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101fb2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0101fb5:	7f 24                	jg     f0101fdb <execute_command+0x1cf>
				break;

			Chose = getchar();
f0101fb7:	e8 7f fa ff ff       	call   f0101a3b <getchar>
f0101fbc:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f0101fbf:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101fc3:	83 ec 0c             	sub    $0xc,%esp
f0101fc6:	50                   	push   %eax
f0101fc7:	e8 58 fa ff ff       	call   f0101a24 <cputchar>
f0101fcc:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f0101fcf:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f0101fd3:	7e 06                	jle    f0101fdb <execute_command+0x1cf>
f0101fd5:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f0101fd9:	7e b4                	jle    f0101f8f <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f0101fdb:	83 ec 0c             	sub    $0xc,%esp
f0101fde:	6a 0a                	push   $0xa
f0101fe0:	e8 3f fa ff ff       	call   f0101a24 <cputchar>
f0101fe5:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f0101fe8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0101fec:	0f 8e e8 00 00 00    	jle    f01020da <execute_command+0x2ce>
f0101ff2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101ff5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0101ff8:	0f 8f dc 00 00 00    	jg     f01020da <execute_command+0x2ce>
		{
			int c = 1;
f0101ffe:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f0102005:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f010200a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010200d:	eb 75                	jmp    f0102084 <execute_command+0x278>
			{
				if (c++ == selection)
f010200f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102012:	8d 50 01             	lea    0x1(%eax),%edx
f0102015:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102018:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010201b:	75 5f                	jne    f010207c <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010201d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102020:	8b 40 0c             	mov    0xc(%eax),%eax
f0102023:	85 c0                	test   %eax,%eax
f0102025:	75 31                	jne    f0102058 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102027:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202a:	8b 00                	mov    (%eax),%eax
f010202c:	83 ec 08             	sub    $0x8,%esp
f010202f:	50                   	push   %eax
f0102030:	68 6b 48 13 f0       	push   $0xf013486b
f0102035:	e8 13 fb ff ff       	call   f0101b4d <cprintf>
f010203a:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010203d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102040:	8b 40 08             	mov    0x8(%eax),%eax
f0102043:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102046:	83 ec 08             	sub    $0x8,%esp
f0102049:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010204c:	51                   	push   %ecx
f010204d:	52                   	push   %edx
f010204e:	ff d0                	call   *%eax
f0102050:	83 c4 10             	add    $0x10,%esp
f0102053:	e9 87 00 00 00       	jmp    f01020df <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102058:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010205b:	8b 50 04             	mov    0x4(%eax),%edx
f010205e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102061:	8b 00                	mov    (%eax),%eax
f0102063:	83 ec 04             	sub    $0x4,%esp
f0102066:	52                   	push   %edx
f0102067:	50                   	push   %eax
f0102068:	68 74 48 13 f0       	push   $0xf0134874
f010206d:	e8 db fa ff ff       	call   f0101b4d <cprintf>
f0102072:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102075:	b8 00 00 00 00       	mov    $0x0,%eax
f010207a:	eb 63                	jmp    f01020df <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010207c:	a1 14 54 96 f1       	mov    0xf1965414,%eax
f0102081:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102084:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102088:	74 08                	je     f0102092 <execute_command+0x286>
f010208a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010208d:	8b 40 10             	mov    0x10(%eax),%eax
f0102090:	eb 05                	jmp    f0102097 <execute_command+0x28b>
f0102092:	b8 00 00 00 00       	mov    $0x0,%eax
f0102097:	a3 14 54 96 f1       	mov    %eax,0xf1965414
f010209c:	a1 14 54 96 f1       	mov    0xf1965414,%eax
f01020a1:	85 c0                	test   %eax,%eax
f01020a3:	0f 85 66 ff ff ff    	jne    f010200f <execute_command+0x203>
f01020a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01020ad:	0f 85 5c ff ff ff    	jne    f010200f <execute_command+0x203>
f01020b3:	eb 25                	jmp    f01020da <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01020b5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01020b8:	89 d0                	mov    %edx,%eax
f01020ba:	01 c0                	add    %eax,%eax
f01020bc:	01 d0                	add    %edx,%eax
f01020be:	c1 e0 03             	shl    $0x3,%eax
f01020c1:	05 68 75 19 f0       	add    $0xf0197568,%eax
f01020c6:	8b 00                	mov    (%eax),%eax
f01020c8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01020cb:	83 ec 08             	sub    $0x8,%esp
f01020ce:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01020d1:	51                   	push   %ecx
f01020d2:	52                   	push   %edx
f01020d3:	ff d0                	call   *%eax
f01020d5:	83 c4 10             	add    $0x10,%esp
f01020d8:	eb 05                	jmp    f01020df <execute_command+0x2d3>
	}
	return 0;
f01020da:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01020df:	c9                   	leave  
f01020e0:	c3                   	ret    

f01020e1 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01020e1:	55                   	push   %ebp
f01020e2:	89 e5                	mov    %esp,%ebp
f01020e4:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01020e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01020ee:	eb 31                	jmp    f0102121 <process_command+0x40>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01020f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01020f3:	89 d0                	mov    %edx,%eax
f01020f5:	01 c0                	add    %eax,%eax
f01020f7:	01 d0                	add    %edx,%eax
f01020f9:	c1 e0 03             	shl    $0x3,%eax
f01020fc:	05 60 75 19 f0       	add    $0xf0197560,%eax
f0102101:	8b 10                	mov    (%eax),%edx
f0102103:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102106:	8b 00                	mov    (%eax),%eax
f0102108:	83 ec 08             	sub    $0x8,%esp
f010210b:	52                   	push   %edx
f010210c:	50                   	push   %eax
f010210d:	e8 29 0e 02 00       	call   f0122f3b <strcmp>
f0102112:	83 c4 10             	add    $0x10,%esp
f0102115:	85 c0                	test   %eax,%eax
f0102117:	75 05                	jne    f010211e <process_command+0x3d>
		{
			return i;
f0102119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010211c:	eb 14                	jmp    f0102132 <process_command+0x51>
}


int process_command(int number_of_arguments, char** arguments)
{
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f010211e:	ff 45 f4             	incl   -0xc(%ebp)
f0102121:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102124:	a1 a8 7b 19 f0       	mov    0xf0197ba8,%eax
f0102129:	39 c2                	cmp    %eax,%edx
f010212b:	72 c3                	jb     f01020f0 <process_command+0xf>
		if (strcmp(arguments[0], commands[i].name) == 0)
		{
			return i;
		}
	}
	return CMD_INVALID;
f010212d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102132:	c9                   	leave  
f0102133:	c3                   	ret    

f0102134 <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0102134:	55                   	push   %ebp
f0102135:	89 e5                	mov    %esp,%ebp
f0102137:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f010213a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102141:	eb 10                	jmp    f0102153 <clearandwritecommand+0x1f>
		cputchar('\b');
f0102143:	83 ec 0c             	sub    $0xc,%esp
f0102146:	6a 08                	push   $0x8
f0102148:	e8 d7 f8 ff ff       	call   f0101a24 <cputchar>
f010214d:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0102150:	ff 45 f4             	incl   -0xc(%ebp)
f0102153:	8b 45 08             	mov    0x8(%ebp),%eax
f0102156:	8b 00                	mov    (%eax),%eax
f0102158:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010215b:	7f e6                	jg     f0102143 <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f010215d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102160:	c1 e0 0a             	shl    $0xa,%eax
f0102163:	05 20 e5 97 f1       	add    $0xf197e520,%eax
f0102168:	83 ec 0c             	sub    $0xc,%esp
f010216b:	50                   	push   %eax
f010216c:	e8 be 0c 02 00       	call   f0122e2f <strlen>
f0102171:	83 c4 10             	add    $0x10,%esp
f0102174:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102177:	83 ec 04             	sub    $0x4,%esp
f010217a:	68 00 04 00 00       	push   $0x400
f010217f:	68 20 35 98 f1       	push   $0xf1983520
f0102184:	ff 75 10             	pushl  0x10(%ebp)
f0102187:	e8 34 0f 02 00       	call   f01230c0 <memcpy>
f010218c:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f010218f:	8b 45 08             	mov    0x8(%ebp),%eax
f0102192:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102198:	eb 52                	jmp    f01021ec <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f010219a:	8b 45 08             	mov    0x8(%ebp),%eax
f010219d:	8b 00                	mov    (%eax),%eax
f010219f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01021a2:	c1 e2 0a             	shl    $0xa,%edx
f01021a5:	01 d0                	add    %edx,%eax
f01021a7:	05 20 e5 97 f1       	add    $0xf197e520,%eax
f01021ac:	8a 00                	mov    (%eax),%al
f01021ae:	0f be c0             	movsbl %al,%eax
f01021b1:	83 ec 0c             	sub    $0xc,%esp
f01021b4:	50                   	push   %eax
f01021b5:	e8 6a f8 ff ff       	call   f0101a24 <cputchar>
f01021ba:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f01021bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01021c0:	8b 00                	mov    (%eax),%eax
f01021c2:	89 c2                	mov    %eax,%edx
f01021c4:	8b 45 10             	mov    0x10(%ebp),%eax
f01021c7:	01 c2                	add    %eax,%edx
f01021c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01021cc:	8b 00                	mov    (%eax),%eax
f01021ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01021d1:	c1 e1 0a             	shl    $0xa,%ecx
f01021d4:	01 c8                	add    %ecx,%eax
f01021d6:	05 20 e5 97 f1       	add    $0xf197e520,%eax
f01021db:	8a 00                	mov    (%eax),%al
f01021dd:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01021df:	8b 45 08             	mov    0x8(%ebp),%eax
f01021e2:	8b 00                	mov    (%eax),%eax
f01021e4:	8d 50 01             	lea    0x1(%eax),%edx
f01021e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01021ea:	89 10                	mov    %edx,(%eax)
f01021ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01021ef:	8b 00                	mov    (%eax),%eax
f01021f1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01021f4:	7c a4                	jl     f010219a <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f01021f6:	8b 45 14             	mov    0x14(%ebp),%eax
f01021f9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01021fc:	89 10                	mov    %edx,(%eax)
}
f01021fe:	90                   	nop
f01021ff:	c9                   	leave  
f0102200:	c3                   	ret    

f0102201 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0102201:	55                   	push   %ebp
f0102202:	89 e5                	mov    %esp,%ebp
f0102204:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f0102207:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010220e:	eb 10                	jmp    f0102220 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0102210:	83 ec 0c             	sub    $0xc,%esp
f0102213:	6a 08                	push   $0x8
f0102215:	e8 0a f8 ff ff       	call   f0101a24 <cputchar>
f010221a:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f010221d:	ff 45 f4             	incl   -0xc(%ebp)
f0102220:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102223:	3b 45 08             	cmp    0x8(%ebp),%eax
f0102226:	7c e8                	jl     f0102210 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0102228:	83 ec 0c             	sub    $0xc,%esp
f010222b:	ff 75 0c             	pushl  0xc(%ebp)
f010222e:	e8 fc 0b 02 00       	call   f0122e2f <strlen>
f0102233:	83 c4 10             	add    $0x10,%esp
f0102236:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102239:	83 ec 04             	sub    $0x4,%esp
f010223c:	68 00 04 00 00       	push   $0x400
f0102241:	68 20 35 98 f1       	push   $0xf1983520
f0102246:	ff 75 10             	pushl  0x10(%ebp)
f0102249:	e8 72 0e 02 00       	call   f01230c0 <memcpy>
f010224e:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0102251:	8b 45 14             	mov    0x14(%ebp),%eax
f0102254:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010225a:	eb 46                	jmp    f01022a2 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f010225c:	8b 45 14             	mov    0x14(%ebp),%eax
f010225f:	8b 00                	mov    (%eax),%eax
f0102261:	89 c2                	mov    %eax,%edx
f0102263:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102266:	01 d0                	add    %edx,%eax
f0102268:	8a 00                	mov    (%eax),%al
f010226a:	0f be c0             	movsbl %al,%eax
f010226d:	83 ec 0c             	sub    $0xc,%esp
f0102270:	50                   	push   %eax
f0102271:	e8 ae f7 ff ff       	call   f0101a24 <cputchar>
f0102276:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0102279:	8b 45 14             	mov    0x14(%ebp),%eax
f010227c:	8b 00                	mov    (%eax),%eax
f010227e:	89 c2                	mov    %eax,%edx
f0102280:	8b 45 10             	mov    0x10(%ebp),%eax
f0102283:	01 c2                	add    %eax,%edx
f0102285:	8b 45 14             	mov    0x14(%ebp),%eax
f0102288:	8b 00                	mov    (%eax),%eax
f010228a:	89 c1                	mov    %eax,%ecx
f010228c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010228f:	01 c8                	add    %ecx,%eax
f0102291:	8a 00                	mov    (%eax),%al
f0102293:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0102295:	8b 45 14             	mov    0x14(%ebp),%eax
f0102298:	8b 00                	mov    (%eax),%eax
f010229a:	8d 50 01             	lea    0x1(%eax),%edx
f010229d:	8b 45 14             	mov    0x14(%ebp),%eax
f01022a0:	89 10                	mov    %edx,(%eax)
f01022a2:	8b 45 14             	mov    0x14(%ebp),%eax
f01022a5:	8b 00                	mov    (%eax),%eax
f01022a7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01022aa:	7c b0                	jl     f010225c <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f01022ac:	8b 45 18             	mov    0x18(%ebp),%eax
f01022af:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01022b2:	89 10                	mov    %edx,(%eax)
}
f01022b4:	90                   	nop
f01022b5:	c9                   	leave  
f01022b6:	c3                   	ret    

f01022b7 <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f01022b7:	55                   	push   %ebp
f01022b8:	89 e5                	mov    %esp,%ebp
f01022ba:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f01022bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01022c4:	eb 21                	jmp    f01022e7 <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f01022c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01022c9:	c1 e0 0a             	shl    $0xa,%eax
f01022cc:	05 20 55 96 f1       	add    $0xf1965520,%eax
f01022d1:	83 ec 04             	sub    $0x4,%esp
f01022d4:	68 00 04 00 00       	push   $0x400
f01022d9:	6a 00                	push   $0x0
f01022db:	50                   	push   %eax
f01022dc:	e8 3c 0d 02 00       	call   f012301d <memset>
f01022e1:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f01022e4:	ff 45 f4             	incl   -0xc(%ebp)
f01022e7:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f01022eb:	7e d9                	jle    f01022c6 <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f01022ed:	90                   	nop
f01022ee:	c9                   	leave  
f01022ef:	c3                   	ret    

f01022f0 <command_prompt_readline>:

//Array of tests
extern struct Test tests[] ;
extern uint32 NUM_OF_TESTS;

void command_prompt_readline(const char *prompt, char* buf) {
f01022f0:	55                   	push   %ebp
f01022f1:	89 e5                	mov    %esp,%ebp
f01022f3:	57                   	push   %edi
f01022f4:	53                   	push   %ebx
f01022f5:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f01022fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01022ff:	74 13                	je     f0102314 <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0102301:	83 ec 08             	sub    $0x8,%esp
f0102304:	ff 75 08             	pushl  0x8(%ebp)
f0102307:	68 7c 48 13 f0       	push   $0xf013487c
f010230c:	e8 3c f8 ff ff       	call   f0101b4d <cprintf>
f0102311:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f0102314:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f0102319:	40                   	inc    %eax
f010231a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f010231d:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0102324:	00 00 00 
f0102327:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010232d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102333:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102339:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f010233c:	83 ec 0c             	sub    $0xc,%esp
f010233f:	6a 00                	push   $0x0
f0102341:	e8 0e f7 ff ff       	call   f0101a54 <iscons>
f0102346:	83 c4 10             	add    $0x10,%esp
f0102349:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f010234c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f0102353:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f010235a:	e8 dc f6 ff ff       	call   f0101a3b <getchar>
f010235f:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f0102362:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102368:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010236e:	39 c2                	cmp    %eax,%edx
f0102370:	7e 0c                	jle    f010237e <command_prompt_readline+0x8e>
			lastIndex = i;
f0102372:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102378:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f010237e:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0102382:	79 22                	jns    f01023a6 <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f0102384:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f0102388:	0f 84 94 0a 00 00    	je     f0102e22 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f010238e:	83 ec 08             	sub    $0x8,%esp
f0102391:	ff 75 94             	pushl  -0x6c(%ebp)
f0102394:	68 7f 48 13 f0       	push   $0xf013487f
f0102399:	e8 af f7 ff ff       	call   f0101b4d <cprintf>
f010239e:	83 c4 10             	add    $0x10,%esp
			return;
f01023a1:	e9 7c 0a 00 00       	jmp    f0102e22 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f01023a6:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f01023ad:	75 2a                	jne    f01023d9 <command_prompt_readline+0xe9>
			if (commandidx)
f01023af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01023b3:	74 03                	je     f01023b8 <command_prompt_readline+0xc8>
				commandidx--;
f01023b5:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f01023b8:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01023be:	50                   	push   %eax
f01023bf:	ff 75 0c             	pushl  0xc(%ebp)
f01023c2:	ff 75 f4             	pushl  -0xc(%ebp)
f01023c5:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01023cb:	50                   	push   %eax
f01023cc:	e8 63 fd ff ff       	call   f0102134 <clearandwritecommand>
f01023d1:	83 c4 10             	add    $0x10,%esp
f01023d4:	e9 32 0a 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f01023d9:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f01023e0:	75 3b                	jne    f010241d <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f01023e2:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f01023e7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f01023ea:	7d 03                	jge    f01023ef <command_prompt_readline+0xff>
				commandidx++;
f01023ec:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f01023ef:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f01023f4:	85 c0                	test   %eax,%eax
f01023f6:	0f 88 0f 0a 00 00    	js     f0102e0b <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f01023fc:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0102402:	50                   	push   %eax
f0102403:	ff 75 0c             	pushl  0xc(%ebp)
f0102406:	ff 75 f4             	pushl  -0xc(%ebp)
f0102409:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010240f:	50                   	push   %eax
f0102410:	e8 1f fd ff ff       	call   f0102134 <clearandwritecommand>
f0102415:	83 c4 10             	add    $0x10,%esp
f0102418:	e9 ee 09 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f010241d:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0102421:	0f 85 6d 07 00 00    	jne    f0102b94 <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f0102427:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f010242b:	0f 84 fc 06 00 00    	je     f0102b2d <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0102431:	83 ec 08             	sub    $0x8,%esp
f0102434:	6a 64                	push   $0x64
f0102436:	68 20 55 96 f1       	push   $0xf1965520
f010243b:	e8 77 fe ff ff       	call   f01022b7 <clear_prefix_list>
f0102440:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f0102443:	83 ec 0c             	sub    $0xc,%esp
f0102446:	ff 75 0c             	pushl  0xc(%ebp)
f0102449:	e8 e1 09 02 00       	call   f0122e2f <strlen>
f010244e:	83 c4 10             	add    $0x10,%esp
f0102451:	85 c0                	test   %eax,%eax
f0102453:	0f 84 bd 09 00 00    	je     f0102e16 <command_prompt_readline+0xb26>
f0102459:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f0102460:	0f 84 b0 09 00 00    	je     f0102e16 <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f0102466:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010246d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102470:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f0102476:	83 ec 08             	sub    $0x8,%esp
f0102479:	ff 75 0c             	pushl  0xc(%ebp)
f010247c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102482:	50                   	push   %eax
f0102483:	e8 f6 09 02 00       	call   f0122e7e <strcpy>
f0102488:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f010248b:	83 ec 0c             	sub    $0xc,%esp
f010248e:	ff 75 0c             	pushl  0xc(%ebp)
f0102491:	e8 99 09 02 00       	call   f0122e2f <strlen>
f0102496:	83 c4 10             	add    $0x10,%esp
f0102499:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f010249c:	8b 45 90             	mov    -0x70(%ebp),%eax
f010249f:	8d 50 ff             	lea    -0x1(%eax),%edx
f01024a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01024a5:	01 d0                	add    %edx,%eax
f01024a7:	8a 00                	mov    (%eax),%al
f01024a9:	3c 20                	cmp    $0x20,%al
f01024ab:	0f 84 6b 09 00 00    	je     f0102e1c <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f01024b1:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01024b7:	50                   	push   %eax
f01024b8:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f01024be:	50                   	push   %eax
f01024bf:	68 8f 48 13 f0       	push   $0xf013488f
f01024c4:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01024ca:	50                   	push   %eax
f01024cb:	e8 23 10 02 00       	call   f01234f3 <strsplit>
f01024d0:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f01024d3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f01024da:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01024e0:	83 f8 01             	cmp    $0x1,%eax
f01024e3:	0f 8e 28 01 00 00    	jle    f0102611 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f01024e9:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01024ef:	83 ec 08             	sub    $0x8,%esp
f01024f2:	68 94 48 13 f0       	push   $0xf0134894
f01024f7:	50                   	push   %eax
f01024f8:	e8 3e 0a 02 00       	call   f0122f3b <strcmp>
f01024fd:	83 c4 10             	add    $0x10,%esp
f0102500:	85 c0                	test   %eax,%eax
f0102502:	74 3c                	je     f0102540 <command_prompt_readline+0x250>
f0102504:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f010250a:	83 ec 08             	sub    $0x8,%esp
f010250d:	68 98 48 13 f0       	push   $0xf0134898
f0102512:	50                   	push   %eax
f0102513:	e8 23 0a 02 00       	call   f0122f3b <strcmp>
f0102518:	83 c4 10             	add    $0x10,%esp
f010251b:	85 c0                	test   %eax,%eax
f010251d:	74 21                	je     f0102540 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f010251f:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102525:	83 ec 08             	sub    $0x8,%esp
f0102528:	68 9d 48 13 f0       	push   $0xf013489d
f010252d:	50                   	push   %eax
f010252e:	e8 08 0a 02 00       	call   f0122f3b <strcmp>
f0102533:	83 c4 10             	add    $0x10,%esp
f0102536:	85 c0                	test   %eax,%eax
f0102538:	74 06                	je     f0102540 <command_prompt_readline+0x250>
						continue;
f010253a:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f010253b:	e9 d6 08 00 00       	jmp    f0102e16 <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f0102540:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102546:	83 ec 08             	sub    $0x8,%esp
f0102549:	68 9d 48 13 f0       	push   $0xf013489d
f010254e:	50                   	push   %eax
f010254f:	e8 e7 09 02 00       	call   f0122f3b <strcmp>
f0102554:	83 c4 10             	add    $0x10,%esp
f0102557:	85 c0                	test   %eax,%eax
f0102559:	75 09                	jne    f0102564 <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f010255b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f0102562:	eb 07                	jmp    f010256b <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f0102564:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f010256b:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102572:	00 00 00 
f0102575:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f010257b:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0102580:	b8 00 00 00 00       	mov    $0x0,%eax
f0102585:	89 d7                	mov    %edx,%edi
f0102587:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0102589:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010258f:	48                   	dec    %eax
f0102590:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0102597:	83 ec 0c             	sub    $0xc,%esp
f010259a:	50                   	push   %eax
f010259b:	e8 8f 08 02 00       	call   f0122e2f <strlen>
f01025a0:	83 c4 10             	add    $0x10,%esp
f01025a3:	8b 55 90             	mov    -0x70(%ebp),%edx
f01025a6:	29 c2                	sub    %eax,%edx
f01025a8:	89 d0                	mov    %edx,%eax
f01025aa:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f01025ad:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01025b4:	eb 1d                	jmp    f01025d3 <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f01025b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01025b9:	8d 50 01             	lea    0x1(%eax),%edx
f01025bc:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01025bf:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01025c2:	8b 55 0c             	mov    0xc(%ebp),%edx
f01025c5:	01 ca                	add    %ecx,%edx
f01025c7:	8a 12                	mov    (%edx),%dl
f01025c9:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f01025d0:	ff 45 d8             	incl   -0x28(%ebp)
f01025d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01025d6:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01025d9:	7c db                	jl     f01025b6 <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f01025db:	83 ec 08             	sub    $0x8,%esp
f01025de:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01025e4:	50                   	push   %eax
f01025e5:	ff 75 0c             	pushl  0xc(%ebp)
f01025e8:	e8 91 08 02 00       	call   f0122e7e <strcpy>
f01025ed:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f01025f0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01025f6:	48                   	dec    %eax
f01025f7:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01025fe:	83 ec 08             	sub    $0x8,%esp
f0102601:	50                   	push   %eax
f0102602:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102608:	50                   	push   %eax
f0102609:	e8 70 08 02 00       	call   f0122e7e <strcpy>
f010260e:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0102611:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0102618:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010261e:	83 f8 01             	cmp    $0x1,%eax
f0102621:	0f 85 30 01 00 00    	jne    f0102757 <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f0102627:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010262e:	e9 0f 01 00 00       	jmp    f0102742 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f0102633:	83 ec 0c             	sub    $0xc,%esp
f0102636:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010263c:	50                   	push   %eax
f010263d:	e8 ed 07 02 00       	call   f0122e2f <strlen>
f0102642:	83 c4 10             	add    $0x10,%esp
f0102645:	89 c1                	mov    %eax,%ecx
f0102647:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010264a:	89 d0                	mov    %edx,%eax
f010264c:	01 c0                	add    %eax,%eax
f010264e:	01 d0                	add    %edx,%eax
f0102650:	c1 e0 03             	shl    $0x3,%eax
f0102653:	05 60 75 19 f0       	add    $0xf0197560,%eax
f0102658:	8b 00                	mov    (%eax),%eax
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	51                   	push   %ecx
f010265e:	50                   	push   %eax
f010265f:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102665:	50                   	push   %eax
f0102666:	e8 08 09 02 00       	call   f0122f73 <strncmp>
f010266b:	83 c4 10             	add    $0x10,%esp
f010266e:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f0102671:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f0102675:	0f 85 c4 00 00 00    	jne    f010273f <command_prompt_readline+0x44f>
							it_str = -1;
f010267b:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0102682:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102689:	00 00 00 
f010268c:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0102692:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0102697:	b8 00 00 00 00       	mov    $0x0,%eax
f010269c:	89 d7                	mov    %edx,%edi
f010269e:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01026a0:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01026a7:	eb 2d                	jmp    f01026d6 <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f01026a9:	ff 45 dc             	incl   -0x24(%ebp)
f01026ac:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01026af:	89 d0                	mov    %edx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 d0                	add    %edx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 60 75 19 f0       	add    $0xf0197560,%eax
f01026bd:	8b 10                	mov    (%eax),%edx
f01026bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01026c2:	01 d0                	add    %edx,%eax
f01026c4:	8a 00                	mov    (%eax),%al
f01026c6:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01026cc:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01026cf:	01 ca                	add    %ecx,%edx
f01026d1:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01026d3:	ff 45 cc             	incl   -0x34(%ebp)
f01026d6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01026d9:	89 d0                	mov    %edx,%eax
f01026db:	01 c0                	add    %eax,%eax
f01026dd:	01 d0                	add    %edx,%eax
f01026df:	c1 e0 03             	shl    $0x3,%eax
f01026e2:	05 60 75 19 f0       	add    $0xf0197560,%eax
f01026e7:	8b 00                	mov    (%eax),%eax
f01026e9:	83 ec 0c             	sub    $0xc,%esp
f01026ec:	50                   	push   %eax
f01026ed:	e8 3d 07 02 00       	call   f0122e2f <strlen>
f01026f2:	83 c4 10             	add    $0x10,%esp
f01026f5:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f01026f8:	7f af                	jg     f01026a9 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f01026fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01026fd:	c1 e0 0a             	shl    $0xa,%eax
f0102700:	05 20 55 96 f1       	add    $0xf1965520,%eax
f0102705:	83 ec 04             	sub    $0x4,%esp
f0102708:	68 00 04 00 00       	push   $0x400
f010270d:	6a 00                	push   $0x0
f010270f:	50                   	push   %eax
f0102710:	e8 08 09 02 00       	call   f012301d <memset>
f0102715:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102718:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010271b:	40                   	inc    %eax
f010271c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010271f:	c1 e2 0a             	shl    $0xa,%edx
f0102722:	81 c2 20 55 96 f1    	add    $0xf1965520,%edx
f0102728:	83 ec 04             	sub    $0x4,%esp
f010272b:	50                   	push   %eax
f010272c:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102732:	50                   	push   %eax
f0102733:	52                   	push   %edx
f0102734:	e8 73 07 02 00       	call   f0122eac <strncpy>
f0102739:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f010273c:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010273f:	ff 45 d0             	incl   -0x30(%ebp)
f0102742:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102745:	a1 a8 7b 19 f0       	mov    0xf0197ba8,%eax
f010274a:	39 c2                	cmp    %eax,%edx
f010274c:	0f 82 e1 fe ff ff    	jb     f0102633 <command_prompt_readline+0x343>
f0102752:	e9 fe 02 00 00       	jmp    f0102a55 <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f0102757:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010275b:	0f 84 7b 01 00 00    	je     f01028dc <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f0102761:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0102768:	e9 5c 01 00 00       	jmp    f01028c9 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f010276d:	83 ec 0c             	sub    $0xc,%esp
f0102770:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102776:	50                   	push   %eax
f0102777:	e8 b3 06 02 00       	call   f0122e2f <strlen>
f010277c:	83 c4 10             	add    $0x10,%esp
f010277f:	89 c1                	mov    %eax,%ecx
f0102781:	8b 1d 9c 80 19 f0    	mov    0xf019809c,%ebx
f0102787:	8b 55 c8             	mov    -0x38(%ebp),%edx
f010278a:	89 d0                	mov    %edx,%eax
f010278c:	01 c0                	add    %eax,%eax
f010278e:	01 d0                	add    %edx,%eax
f0102790:	c1 e0 02             	shl    $0x2,%eax
f0102793:	01 d8                	add    %ebx,%eax
f0102795:	8b 00                	mov    (%eax),%eax
f0102797:	83 ec 04             	sub    $0x4,%esp
f010279a:	51                   	push   %ecx
f010279b:	50                   	push   %eax
f010279c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01027a2:	50                   	push   %eax
f01027a3:	e8 cb 07 02 00       	call   f0122f73 <strncmp>
f01027a8:	83 c4 10             	add    $0x10,%esp
f01027ab:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f01027ae:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f01027b2:	0f 85 0e 01 00 00    	jne    f01028c6 <command_prompt_readline+0x5d6>
								it_str = -1;
f01027b8:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01027bf:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01027c6:	00 00 00 
f01027c9:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01027cf:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01027d4:	b8 00 00 00 00       	mov    $0x0,%eax
f01027d9:	89 d7                	mov    %edx,%edi
f01027db:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01027dd:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01027e3:	83 f8 01             	cmp    $0x1,%eax
f01027e6:	7e 39                	jle    f0102821 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01027e8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f01027ef:	eb 1d                	jmp    f010280e <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f01027f1:	ff 45 dc             	incl   -0x24(%ebp)
f01027f4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01027f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01027fa:	01 d0                	add    %edx,%eax
f01027fc:	8a 00                	mov    (%eax),%al
f01027fe:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102804:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102807:	01 ca                	add    %ecx,%edx
f0102809:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010280b:	ff 45 c4             	incl   -0x3c(%ebp)
f010280e:	83 ec 0c             	sub    $0xc,%esp
f0102811:	ff 75 0c             	pushl  0xc(%ebp)
f0102814:	e8 16 06 02 00       	call   f0122e2f <strlen>
f0102819:	83 c4 10             	add    $0x10,%esp
f010281c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f010281f:	7f d0                	jg     f01027f1 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102821:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0102828:	eb 30                	jmp    f010285a <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f010282a:	ff 45 dc             	incl   -0x24(%ebp)
f010282d:	8b 0d 9c 80 19 f0    	mov    0xf019809c,%ecx
f0102833:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102836:	89 d0                	mov    %edx,%eax
f0102838:	01 c0                	add    %eax,%eax
f010283a:	01 d0                	add    %edx,%eax
f010283c:	c1 e0 02             	shl    $0x2,%eax
f010283f:	01 c8                	add    %ecx,%eax
f0102841:	8b 10                	mov    (%eax),%edx
f0102843:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0102846:	01 d0                	add    %edx,%eax
f0102848:	8a 00                	mov    (%eax),%al
f010284a:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102850:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102853:	01 ca                	add    %ecx,%edx
f0102855:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102857:	ff 45 c0             	incl   -0x40(%ebp)
f010285a:	8b 0d 9c 80 19 f0    	mov    0xf019809c,%ecx
f0102860:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102863:	89 d0                	mov    %edx,%eax
f0102865:	01 c0                	add    %eax,%eax
f0102867:	01 d0                	add    %edx,%eax
f0102869:	c1 e0 02             	shl    $0x2,%eax
f010286c:	01 c8                	add    %ecx,%eax
f010286e:	8b 00                	mov    (%eax),%eax
f0102870:	83 ec 0c             	sub    $0xc,%esp
f0102873:	50                   	push   %eax
f0102874:	e8 b6 05 02 00       	call   f0122e2f <strlen>
f0102879:	83 c4 10             	add    $0x10,%esp
f010287c:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010287f:	7f a9                	jg     f010282a <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102881:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102884:	c1 e0 0a             	shl    $0xa,%eax
f0102887:	05 20 55 96 f1       	add    $0xf1965520,%eax
f010288c:	83 ec 04             	sub    $0x4,%esp
f010288f:	68 00 04 00 00       	push   $0x400
f0102894:	6a 00                	push   $0x0
f0102896:	50                   	push   %eax
f0102897:	e8 81 07 02 00       	call   f012301d <memset>
f010289c:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010289f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01028a2:	40                   	inc    %eax
f01028a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01028a6:	c1 e2 0a             	shl    $0xa,%edx
f01028a9:	81 c2 20 55 96 f1    	add    $0xf1965520,%edx
f01028af:	83 ec 04             	sub    $0x4,%esp
f01028b2:	50                   	push   %eax
f01028b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01028b9:	50                   	push   %eax
f01028ba:	52                   	push   %edx
f01028bb:	e8 ec 05 02 00       	call   f0122eac <strncpy>
f01028c0:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01028c3:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01028c6:	ff 45 c8             	incl   -0x38(%ebp)
f01028c9:	a1 a0 80 19 f0       	mov    0xf01980a0,%eax
f01028ce:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f01028d1:	0f 8c 96 fe ff ff    	jl     f010276d <command_prompt_readline+0x47d>
f01028d7:	e9 79 01 00 00       	jmp    f0102a55 <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f01028dc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01028e0:	0f 84 6f 01 00 00    	je     f0102a55 <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01028e6:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01028ed:	e9 53 01 00 00       	jmp    f0102a45 <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f01028f2:	83 ec 0c             	sub    $0xc,%esp
f01028f5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01028fb:	50                   	push   %eax
f01028fc:	e8 2e 05 02 00       	call   f0122e2f <strlen>
f0102901:	83 c4 10             	add    $0x10,%esp
f0102904:	89 c1                	mov    %eax,%ecx
f0102906:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102909:	89 d0                	mov    %edx,%eax
f010290b:	01 c0                	add    %eax,%eax
f010290d:	01 d0                	add    %edx,%eax
f010290f:	c1 e0 02             	shl    $0x2,%eax
f0102912:	05 c0 80 19 f0       	add    $0xf01980c0,%eax
f0102917:	8b 00                	mov    (%eax),%eax
f0102919:	83 ec 04             	sub    $0x4,%esp
f010291c:	51                   	push   %ecx
f010291d:	50                   	push   %eax
f010291e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102924:	50                   	push   %eax
f0102925:	e8 49 06 02 00       	call   f0122f73 <strncmp>
f010292a:	83 c4 10             	add    $0x10,%esp
f010292d:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f0102930:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0102934:	0f 85 08 01 00 00    	jne    f0102a42 <command_prompt_readline+0x752>
								it_str = -1;
f010293a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0102941:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102948:	00 00 00 
f010294b:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0102951:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0102956:	b8 00 00 00 00       	mov    $0x0,%eax
f010295b:	89 d7                	mov    %edx,%edi
f010295d:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f010295f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102965:	83 f8 01             	cmp    $0x1,%eax
f0102968:	7e 39                	jle    f01029a3 <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010296a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f0102971:	eb 1d                	jmp    f0102990 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f0102973:	ff 45 dc             	incl   -0x24(%ebp)
f0102976:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0102979:	8b 45 0c             	mov    0xc(%ebp),%eax
f010297c:	01 d0                	add    %edx,%eax
f010297e:	8a 00                	mov    (%eax),%al
f0102980:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102986:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102989:	01 ca                	add    %ecx,%edx
f010298b:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010298d:	ff 45 b8             	incl   -0x48(%ebp)
f0102990:	83 ec 0c             	sub    $0xc,%esp
f0102993:	ff 75 0c             	pushl  0xc(%ebp)
f0102996:	e8 94 04 02 00       	call   f0122e2f <strlen>
f010299b:	83 c4 10             	add    $0x10,%esp
f010299e:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01029a1:	7f d0                	jg     f0102973 <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f01029a3:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f01029aa:	eb 2d                	jmp    f01029d9 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f01029ac:	ff 45 dc             	incl   -0x24(%ebp)
f01029af:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01029b2:	89 d0                	mov    %edx,%eax
f01029b4:	01 c0                	add    %eax,%eax
f01029b6:	01 d0                	add    %edx,%eax
f01029b8:	c1 e0 02             	shl    $0x2,%eax
f01029bb:	05 c0 80 19 f0       	add    $0xf01980c0,%eax
f01029c0:	8b 10                	mov    (%eax),%edx
f01029c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01029c5:	01 d0                	add    %edx,%eax
f01029c7:	8a 00                	mov    (%eax),%al
f01029c9:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01029cf:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01029d2:	01 ca                	add    %ecx,%edx
f01029d4:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f01029d6:	ff 45 b4             	incl   -0x4c(%ebp)
f01029d9:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01029dc:	89 d0                	mov    %edx,%eax
f01029de:	01 c0                	add    %eax,%eax
f01029e0:	01 d0                	add    %edx,%eax
f01029e2:	c1 e0 02             	shl    $0x2,%eax
f01029e5:	05 c0 80 19 f0       	add    $0xf01980c0,%eax
f01029ea:	8b 00                	mov    (%eax),%eax
f01029ec:	83 ec 0c             	sub    $0xc,%esp
f01029ef:	50                   	push   %eax
f01029f0:	e8 3a 04 02 00       	call   f0122e2f <strlen>
f01029f5:	83 c4 10             	add    $0x10,%esp
f01029f8:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01029fb:	7f af                	jg     f01029ac <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f01029fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a00:	c1 e0 0a             	shl    $0xa,%eax
f0102a03:	05 20 55 96 f1       	add    $0xf1965520,%eax
f0102a08:	83 ec 04             	sub    $0x4,%esp
f0102a0b:	68 00 04 00 00       	push   $0x400
f0102a10:	6a 00                	push   $0x0
f0102a12:	50                   	push   %eax
f0102a13:	e8 05 06 02 00       	call   f012301d <memset>
f0102a18:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102a1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a1e:	40                   	inc    %eax
f0102a1f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0102a22:	c1 e2 0a             	shl    $0xa,%edx
f0102a25:	81 c2 20 55 96 f1    	add    $0xf1965520,%edx
f0102a2b:	83 ec 04             	sub    $0x4,%esp
f0102a2e:	50                   	push   %eax
f0102a2f:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102a35:	50                   	push   %eax
f0102a36:	52                   	push   %edx
f0102a37:	e8 70 04 02 00       	call   f0122eac <strncpy>
f0102a3c:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f0102a3f:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f0102a42:	ff 45 bc             	incl   -0x44(%ebp)
f0102a45:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102a48:	a1 80 81 19 f0       	mov    0xf0198180,%eax
f0102a4d:	39 c2                	cmp    %eax,%edx
f0102a4f:	0f 82 9d fe ff ff    	jb     f01028f2 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f0102a55:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a58:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f0102a5b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0102a5f:	0f 84 a6 03 00 00    	je     f0102e0b <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f0102a65:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0102a6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102a72:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0102a79:	eb 1f                	jmp    f0102a9a <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0102a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a7e:	8d 50 01             	lea    0x1(%eax),%edx
f0102a81:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102a84:	89 c2                	mov    %eax,%edx
f0102a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a89:	01 c2                	add    %eax,%edx
f0102a8b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0102a8e:	05 20 55 96 f1       	add    $0xf1965520,%eax
f0102a93:	8a 00                	mov    (%eax),%al
f0102a95:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102a97:	ff 45 b0             	incl   -0x50(%ebp)
f0102a9a:	83 ec 0c             	sub    $0xc,%esp
f0102a9d:	68 20 55 96 f1       	push   $0xf1965520
f0102aa2:	e8 88 03 02 00       	call   f0122e2f <strlen>
f0102aa7:	83 c4 10             	add    $0x10,%esp
f0102aaa:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0102aad:	7f cc                	jg     f0102a7b <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102aaf:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f0102ab6:	eb 10                	jmp    f0102ac8 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0102ab8:	83 ec 0c             	sub    $0xc,%esp
f0102abb:	6a 08                	push   $0x8
f0102abd:	e8 62 ef ff ff       	call   f0101a24 <cputchar>
f0102ac2:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102ac5:	ff 45 ac             	incl   -0x54(%ebp)
f0102ac8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0102acb:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0102ace:	7c e8                	jl     f0102ab8 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102ad0:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f0102ad7:	eb 1c                	jmp    f0102af5 <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0102ad9:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0102adc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102adf:	01 d0                	add    %edx,%eax
f0102ae1:	8a 00                	mov    (%eax),%al
f0102ae3:	0f be c0             	movsbl %al,%eax
f0102ae6:	83 ec 0c             	sub    $0xc,%esp
f0102ae9:	50                   	push   %eax
f0102aea:	e8 35 ef ff ff       	call   f0101a24 <cputchar>
f0102aef:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102af2:	ff 45 a8             	incl   -0x58(%ebp)
f0102af5:	83 ec 0c             	sub    $0xc,%esp
f0102af8:	ff 75 0c             	pushl  0xc(%ebp)
f0102afb:	e8 2f 03 02 00       	call   f0122e2f <strlen>
f0102b00:	83 c4 10             	add    $0x10,%esp
f0102b03:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f0102b06:	7f d1                	jg     f0102ad9 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0102b08:	83 ec 0c             	sub    $0xc,%esp
f0102b0b:	ff 75 0c             	pushl  0xc(%ebp)
f0102b0e:	e8 1c 03 02 00       	call   f0122e2f <strlen>
f0102b13:	83 c4 10             	add    $0x10,%esp
f0102b16:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102b1c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102b22:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102b28:	e9 de 02 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0102b2d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0102b31:	0f 8e d4 02 00 00    	jle    f0102e0b <command_prompt_readline+0xb1b>
f0102b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b3a:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f0102b40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b43:	40                   	inc    %eax
f0102b44:	99                   	cltd   
f0102b45:	f7 7d ec             	idivl  -0x14(%ebp)
f0102b48:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f0102b4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b4e:	c1 e0 0a             	shl    $0xa,%eax
f0102b51:	8d 98 20 55 96 f1    	lea    -0xe69aae0(%eax),%ebx
f0102b57:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0102b5d:	c1 e0 0a             	shl    $0xa,%eax
f0102b60:	05 20 55 96 f1       	add    $0xf1965520,%eax
f0102b65:	83 ec 0c             	sub    $0xc,%esp
f0102b68:	50                   	push   %eax
f0102b69:	e8 c1 02 02 00       	call   f0122e2f <strlen>
f0102b6e:	83 c4 10             	add    $0x10,%esp
f0102b71:	83 ec 0c             	sub    $0xc,%esp
f0102b74:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0102b7a:	52                   	push   %edx
f0102b7b:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0102b81:	52                   	push   %edx
f0102b82:	ff 75 0c             	pushl  0xc(%ebp)
f0102b85:	53                   	push   %ebx
f0102b86:	50                   	push   %eax
f0102b87:	e8 75 f6 ff ff       	call   f0102201 <RoundAutoCompleteCommandWithTheSamePrefix>
f0102b8c:	83 c4 20             	add    $0x20,%esp
f0102b8f:	e9 77 02 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0102b94:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102b9b:	75 2e                	jne    f0102bcb <command_prompt_readline+0x8db>
			if (i > 0) {
f0102b9d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102ba3:	85 c0                	test   %eax,%eax
f0102ba5:	0f 8e 60 02 00 00    	jle    f0102e0b <command_prompt_readline+0xb1b>
				i--;
f0102bab:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bb1:	48                   	dec    %eax
f0102bb2:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102bb8:	83 ec 0c             	sub    $0xc,%esp
f0102bbb:	ff 75 94             	pushl  -0x6c(%ebp)
f0102bbe:	e8 61 ee ff ff       	call   f0101a24 <cputchar>
f0102bc3:	83 c4 10             	add    $0x10,%esp
f0102bc6:	e9 40 02 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0102bcb:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102bd2:	75 34                	jne    f0102c08 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0102bd4:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102bda:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102be0:	39 c2                	cmp    %eax,%edx
f0102be2:	0f 8d 23 02 00 00    	jge    f0102e0b <command_prompt_readline+0xb1b>
				i++;
f0102be8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bee:	40                   	inc    %eax
f0102bef:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102bf5:	83 ec 0c             	sub    $0xc,%esp
f0102bf8:	ff 75 94             	pushl  -0x6c(%ebp)
f0102bfb:	e8 24 ee ff ff       	call   f0101a24 <cputchar>
f0102c00:	83 c4 10             	add    $0x10,%esp
f0102c03:	e9 03 02 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0102c08:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0102c0f:	75 4c                	jne    f0102c5d <command_prompt_readline+0x96d>
f0102c11:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c17:	85 c0                	test   %eax,%eax
f0102c19:	7e 42                	jle    f0102c5d <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0102c1b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c21:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0102c24:	eb 1a                	jmp    f0102c40 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0102c26:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0102c29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c2c:	01 c2                	add    %eax,%edx
f0102c2e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0102c31:	8d 48 01             	lea    0x1(%eax),%ecx
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	01 c8                	add    %ecx,%eax
f0102c39:	8a 00                	mov    (%eax),%al
f0102c3b:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0102c3d:	ff 45 a4             	incl   -0x5c(%ebp)
f0102c40:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c46:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0102c49:	7e db                	jle    f0102c26 <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0102c4b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c51:	48                   	dec    %eax
f0102c52:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102c58:	e9 ae 01 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0102c5d:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0102c61:	7e 60                	jle    f0102cc3 <command_prompt_readline+0x9d3>
f0102c63:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c69:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0102c6e:	7f 53                	jg     f0102cc3 <command_prompt_readline+0x9d3>
f0102c70:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102c77:	74 4a                	je     f0102cc3 <command_prompt_readline+0x9d3>
f0102c79:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102c80:	74 41                	je     f0102cc3 <command_prompt_readline+0x9d3>
			if (echoing)
f0102c82:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102c86:	74 0e                	je     f0102c96 <command_prompt_readline+0x9a6>
				cputchar(c);
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	ff 75 94             	pushl  -0x6c(%ebp)
f0102c8e:	e8 91 ed ff ff       	call   f0101a24 <cputchar>
f0102c93:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0102c96:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c9c:	8d 50 01             	lea    0x1(%eax),%edx
f0102c9f:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0102ca5:	89 c2                	mov    %eax,%edx
f0102ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102caa:	01 d0                	add    %edx,%eax
f0102cac:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0102caf:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0102cb1:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102cb7:	40                   	inc    %eax
f0102cb8:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102cbe:	e9 48 01 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0102cc3:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0102cc7:	75 60                	jne    f0102d29 <command_prompt_readline+0xa39>
f0102cc9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102ccf:	85 c0                	test   %eax,%eax
f0102cd1:	7e 56                	jle    f0102d29 <command_prompt_readline+0xa39>

			if (echoing)
f0102cd3:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102cd7:	74 0e                	je     f0102ce7 <command_prompt_readline+0x9f7>
				cputchar(c);
f0102cd9:	83 ec 0c             	sub    $0xc,%esp
f0102cdc:	ff 75 94             	pushl  -0x6c(%ebp)
f0102cdf:	e8 40 ed ff ff       	call   f0101a24 <cputchar>
f0102ce4:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0102ce7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102ced:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0102cf0:	eb 1a                	jmp    f0102d0c <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0102cf2:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0102cf5:	8d 50 ff             	lea    -0x1(%eax),%edx
f0102cf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102cfb:	01 c2                	add    %eax,%edx
f0102cfd:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0102d00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d03:	01 c8                	add    %ecx,%eax
f0102d05:	8a 00                	mov    (%eax),%al
f0102d07:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0102d09:	ff 45 a0             	incl   -0x60(%ebp)
f0102d0c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d12:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0102d15:	7e db                	jle    f0102cf2 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0102d17:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d1d:	48                   	dec    %eax
f0102d1e:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102d24:	e9 e2 00 00 00       	jmp    f0102e0b <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0102d29:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0102d2d:	74 0a                	je     f0102d39 <command_prompt_readline+0xa49>
f0102d2f:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0102d33:	0f 85 d2 00 00 00    	jne    f0102e0b <command_prompt_readline+0xb1b>

			if (echoing)
f0102d39:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102d3d:	74 0e                	je     f0102d4d <command_prompt_readline+0xa5d>
				cputchar(c);
f0102d3f:	83 ec 0c             	sub    $0xc,%esp
f0102d42:	ff 75 94             	pushl  -0x6c(%ebp)
f0102d45:	e8 da ec ff ff       	call   f0101a24 <cputchar>
f0102d4a:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0102d4d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102d53:	89 c2                	mov    %eax,%edx
f0102d55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d58:	01 d0                	add    %edx,%eax
f0102d5a:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0102d5d:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f0102d62:	83 f8 13             	cmp    $0x13,%eax
f0102d65:	75 56                	jne    f0102dbd <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102d67:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0102d6e:	eb 2d                	jmp    f0102d9d <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0102d70:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102d73:	40                   	inc    %eax
f0102d74:	c1 e0 0a             	shl    $0xa,%eax
f0102d77:	8d 90 20 e5 97 f1    	lea    -0xe681ae0(%eax),%edx
f0102d7d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102d80:	c1 e0 0a             	shl    $0xa,%eax
f0102d83:	05 20 e5 97 f1       	add    $0xf197e520,%eax
f0102d88:	83 ec 04             	sub    $0x4,%esp
f0102d8b:	68 00 04 00 00       	push   $0x400
f0102d90:	52                   	push   %edx
f0102d91:	50                   	push   %eax
f0102d92:	e8 29 03 02 00       	call   f01230c0 <memcpy>
f0102d97:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102d9a:	ff 45 9c             	incl   -0x64(%ebp)
f0102d9d:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0102da1:	7e cd                	jle    f0102d70 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0102da3:	83 ec 04             	sub    $0x4,%esp
f0102da6:	68 00 04 00 00       	push   $0x400
f0102dab:	ff 75 0c             	pushl  0xc(%ebp)
f0102dae:	68 20 31 98 f1       	push   $0xf1983120
f0102db3:	e8 08 03 02 00       	call   f01230c0 <memcpy>
f0102db8:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102dbb:	eb 68                	jmp    f0102e25 <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0102dbd:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f0102dc2:	c1 e0 0a             	shl    $0xa,%eax
f0102dc5:	05 20 e5 97 f1       	add    $0xf197e520,%eax
f0102dca:	83 ec 08             	sub    $0x8,%esp
f0102dcd:	ff 75 0c             	pushl  0xc(%ebp)
f0102dd0:	50                   	push   %eax
f0102dd1:	e8 65 01 02 00       	call   f0122f3b <strcmp>
f0102dd6:	83 c4 10             	add    $0x10,%esp
f0102dd9:	85 c0                	test   %eax,%eax
f0102ddb:	74 48                	je     f0102e25 <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0102ddd:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f0102de2:	40                   	inc    %eax
f0102de3:	a3 50 75 19 f0       	mov    %eax,0xf0197550
f0102de8:	a1 50 75 19 f0       	mov    0xf0197550,%eax
f0102ded:	c1 e0 0a             	shl    $0xa,%eax
f0102df0:	05 20 e5 97 f1       	add    $0xf197e520,%eax
f0102df5:	83 ec 04             	sub    $0x4,%esp
f0102df8:	68 00 04 00 00       	push   $0x400
f0102dfd:	ff 75 0c             	pushl  0xc(%ebp)
f0102e00:	50                   	push   %eax
f0102e01:	e8 ba 02 02 00       	call   f01230c0 <memcpy>
f0102e06:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0102e09:	eb 1a                	jmp    f0102e25 <command_prompt_readline+0xb35>

		}
		last_c = c;
f0102e0b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0102e0e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0102e11:	e9 44 f5 ff ff       	jmp    f010235a <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0102e16:	90                   	nop
f0102e17:	e9 3e f5 ff ff       	jmp    f010235a <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0102e1c:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0102e1d:	e9 38 f5 ff ff       	jmp    f010235a <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0102e22:	90                   	nop
f0102e23:	eb 01                	jmp    f0102e26 <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102e25:	90                   	nop

		}
		last_c = c;
	}
}
f0102e26:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102e29:	5b                   	pop    %ebx
f0102e2a:	5f                   	pop    %edi
f0102e2b:	5d                   	pop    %ebp
f0102e2c:	c3                   	ret    

f0102e2d <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0102e2d:	55                   	push   %ebp
f0102e2e:	89 e5                	mov    %esp,%ebp
f0102e30:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e33:	a3 64 50 96 f1       	mov    %eax,0xf1965064
f0102e38:	90                   	nop
f0102e39:	5d                   	pop    %ebp
f0102e3a:	c3                   	ret    

f0102e3b <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f0102e3b:	55                   	push   %ebp
f0102e3c:	89 e5                	mov    %esp,%ebp
f0102e3e:	a1 64 50 96 f1       	mov    0xf1965064,%eax
f0102e43:	5d                   	pop    %ebp
f0102e44:	c3                   	ret    

f0102e45 <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f0102e45:	55                   	push   %ebp
f0102e46:	89 e5                	mov    %esp,%ebp
f0102e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e4b:	a3 88 51 96 f1       	mov    %eax,0xf1965188
f0102e50:	90                   	nop
f0102e51:	5d                   	pop    %ebp
f0102e52:	c3                   	ret    

f0102e53 <get_uheap_strategy>:
static inline uint32 get_uheap_strategy(){return _UHeapPlacementStrategy ;}
f0102e53:	55                   	push   %ebp
f0102e54:	89 e5                	mov    %esp,%ebp
f0102e56:	a1 88 51 96 f1       	mov    0xf1965188,%eax
f0102e5b:	5d                   	pop    %ebp
f0102e5c:	c3                   	ret    

f0102e5d <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102e5d:	55                   	push   %ebp
f0102e5e:	89 e5                	mov    %esp,%ebp
f0102e60:	53                   	push   %ebx
f0102e61:	83 ec 04             	sub    $0x4,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102e64:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e67:	c1 e8 0c             	shr    $0xc,%eax
f0102e6a:	89 c2                	mov    %eax,%edx
f0102e6c:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0102e71:	39 c2                	cmp    %eax,%edx
f0102e73:	72 14                	jb     f0102e89 <to_frame_info+0x2c>
		panic("to_frame_info called with invalid pa");
f0102e75:	83 ec 04             	sub    $0x4,%esp
f0102e78:	68 a4 48 13 f0       	push   $0xf01348a4
f0102e7d:	6a 4e                	push   $0x4e
f0102e7f:	68 cc 48 13 f0       	push   $0xf01348cc
f0102e84:	e8 26 e0 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0102e89:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f0102e8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e92:	c1 e8 0c             	shr    $0xc,%eax
f0102e95:	89 c2                	mov    %eax,%edx
f0102e97:	89 d0                	mov    %edx,%eax
f0102e99:	01 c0                	add    %eax,%eax
f0102e9b:	01 d0                	add    %edx,%eax
f0102e9d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0102ea4:	01 d8                	add    %ebx,%eax
f0102ea6:	01 d0                	add    %edx,%eax
f0102ea8:	01 c8                	add    %ecx,%eax
}
f0102eaa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ead:	c9                   	leave  
f0102eae:	c3                   	ret    

f0102eaf <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102eaf:	55                   	push   %ebp
f0102eb0:	89 e5                	mov    %esp,%ebp
f0102eb2:	53                   	push   %ebx
f0102eb3:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102eb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102ebd:	eb 3b                	jmp    f0102efa <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102ebf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102ec2:	89 d0                	mov    %edx,%eax
f0102ec4:	01 c0                	add    %eax,%eax
f0102ec6:	01 d0                	add    %edx,%eax
f0102ec8:	c1 e0 03             	shl    $0x3,%eax
f0102ecb:	05 64 75 19 f0       	add    $0xf0197564,%eax
f0102ed0:	8b 10                	mov    (%eax),%edx
f0102ed2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102ed5:	89 c8                	mov    %ecx,%eax
f0102ed7:	01 c0                	add    %eax,%eax
f0102ed9:	01 c8                	add    %ecx,%eax
f0102edb:	c1 e0 03             	shl    $0x3,%eax
f0102ede:	05 60 75 19 f0       	add    $0xf0197560,%eax
f0102ee3:	8b 00                	mov    (%eax),%eax
f0102ee5:	83 ec 04             	sub    $0x4,%esp
f0102ee8:	52                   	push   %edx
f0102ee9:	50                   	push   %eax
f0102eea:	68 07 58 13 f0       	push   $0xf0135807
f0102eef:	e8 59 ec ff ff       	call   f0101b4d <cprintf>
f0102ef4:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102ef7:	ff 45 f4             	incl   -0xc(%ebp)
f0102efa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102efd:	a1 a8 7b 19 f0       	mov    0xf0197ba8,%eax
f0102f02:	39 c2                	cmp    %eax,%edx
f0102f04:	72 b9                	jb     f0102ebf <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f0102f06:	83 ec 0c             	sub    $0xc,%esp
f0102f09:	68 10 58 13 f0       	push   $0xf0135810
f0102f0e:	e8 3a ec ff ff       	call   f0101b4d <cprintf>
f0102f13:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102f16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102f1d:	eb 42                	jmp    f0102f61 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102f1f:	8b 0d 9c 80 19 f0    	mov    0xf019809c,%ecx
f0102f25:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102f28:	89 d0                	mov    %edx,%eax
f0102f2a:	01 c0                	add    %eax,%eax
f0102f2c:	01 d0                	add    %edx,%eax
f0102f2e:	c1 e0 02             	shl    $0x2,%eax
f0102f31:	01 c8                	add    %ecx,%eax
f0102f33:	8b 50 04             	mov    0x4(%eax),%edx
f0102f36:	8b 1d 9c 80 19 f0    	mov    0xf019809c,%ebx
f0102f3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102f3f:	89 c8                	mov    %ecx,%eax
f0102f41:	01 c0                	add    %eax,%eax
f0102f43:	01 c8                	add    %ecx,%eax
f0102f45:	c1 e0 02             	shl    $0x2,%eax
f0102f48:	01 d8                	add    %ebx,%eax
f0102f4a:	8b 00                	mov    (%eax),%eax
f0102f4c:	83 ec 04             	sub    $0x4,%esp
f0102f4f:	52                   	push   %edx
f0102f50:	50                   	push   %eax
f0102f51:	68 25 58 13 f0       	push   $0xf0135825
f0102f56:	e8 f2 eb ff ff       	call   f0101b4d <cprintf>
f0102f5b:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102f5e:	ff 45 f4             	incl   -0xc(%ebp)
f0102f61:	a1 a0 80 19 f0       	mov    0xf01980a0,%eax
f0102f66:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102f69:	7c b4                	jl     f0102f1f <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102f6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102f73:	c9                   	leave  
f0102f74:	c3                   	ret    

f0102f75 <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f0102f75:	55                   	push   %ebp
f0102f76:	89 e5                	mov    %esp,%ebp
f0102f78:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102f7b:	83 ec 0c             	sub    $0xc,%esp
f0102f7e:	68 41 58 13 f0       	push   $0xf0135841
f0102f83:	e8 c5 eb ff ff       	call   f0101b4d <cprintf>
f0102f88:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102f8b:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0102f90:	83 ec 04             	sub    $0x4,%esp
f0102f93:	50                   	push   %eax
f0102f94:	68 0c 00 10 f0       	push   $0xf010000c
f0102f99:	68 5c 58 13 f0       	push   $0xf013585c
f0102f9e:	e8 aa eb ff ff       	call   f0101b4d <cprintf>
f0102fa3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102fa6:	b8 95 4a 12 00       	mov    $0x124a95,%eax
f0102fab:	83 ec 04             	sub    $0x4,%esp
f0102fae:	50                   	push   %eax
f0102faf:	68 95 4a 12 f0       	push   $0xf0124a95
f0102fb4:	68 98 58 13 f0       	push   $0xf0135898
f0102fb9:	e8 8f eb ff ff       	call   f0101b4d <cprintf>
f0102fbe:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f0102fc1:	b8 c8 3d 92 00       	mov    $0x923dc8,%eax
f0102fc6:	83 ec 04             	sub    $0x4,%esp
f0102fc9:	50                   	push   %eax
f0102fca:	68 c8 3d 92 f0       	push   $0xf0923dc8
f0102fcf:	68 d4 58 13 f0       	push   $0xf01358d4
f0102fd4:	e8 74 eb ff ff       	call   f0101b4d <cprintf>
f0102fd9:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f0102fdc:	b8 d0 85 9a 01       	mov    $0x19a85d0,%eax
f0102fe1:	83 ec 04             	sub    $0x4,%esp
f0102fe4:	50                   	push   %eax
f0102fe5:	68 d0 85 9a f1       	push   $0xf19a85d0
f0102fea:	68 1c 59 13 f0       	push   $0xf013591c
f0102fef:	e8 59 eb ff ff       	call   f0101b4d <cprintf>
f0102ff4:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f0102ff7:	b8 d0 85 9a f1       	mov    $0xf19a85d0,%eax
f0102ffc:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0103002:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f0103007:	29 c2                	sub    %eax,%edx
f0103009:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f010300b:	85 c0                	test   %eax,%eax
f010300d:	79 05                	jns    f0103014 <command_kernel_info+0x9f>
f010300f:	05 ff 03 00 00       	add    $0x3ff,%eax
f0103014:	c1 f8 0a             	sar    $0xa,%eax
f0103017:	83 ec 08             	sub    $0x8,%esp
f010301a:	50                   	push   %eax
f010301b:	68 58 59 13 f0       	push   $0xf0135958
f0103020:	e8 28 eb ff ff       	call   f0101b4d <cprintf>
f0103025:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0103028:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010302d:	c9                   	leave  
f010302e:	c3                   	ret    

f010302f <command_writemem_k>:
//*****************************************************************************************//
//===========================================================================
//Lab2.Examples
//=============
int command_writemem_k(int number_of_arguments, char **arguments)
{
f010302f:	55                   	push   %ebp
f0103030:	89 e5                	mov    %esp,%ebp
f0103032:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0103035:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103038:	83 c0 04             	add    $0x4,%eax
f010303b:	8b 00                	mov    (%eax),%eax
f010303d:	83 ec 04             	sub    $0x4,%esp
f0103040:	6a 10                	push   $0x10
f0103042:	6a 00                	push   $0x0
f0103044:	50                   	push   %eax
f0103045:	e8 f4 01 02 00       	call   f012323e <strtol>
f010304a:	83 c4 10             	add    $0x10,%esp
f010304d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103052:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int stringLen = strlen(arguments[2]);
f0103055:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103058:	83 c0 08             	add    $0x8,%eax
f010305b:	8b 00                	mov    (%eax),%eax
f010305d:	83 ec 0c             	sub    $0xc,%esp
f0103060:	50                   	push   %eax
f0103061:	e8 c9 fd 01 00       	call   f0122e2f <strlen>
f0103066:	83 c4 10             	add    $0x10,%esp
f0103069:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(int i=0;i < stringLen; i++)
f010306c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103073:	eb 1c                	jmp    f0103091 <command_writemem_k+0x62>
	{
		*address = arguments[2][i];
f0103075:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103078:	83 c0 08             	add    $0x8,%eax
f010307b:	8b 10                	mov    (%eax),%edx
f010307d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103080:	01 d0                	add    %edx,%eax
f0103082:	8a 00                	mov    (%eax),%al
f0103084:	88 c2                	mov    %al,%dl
f0103086:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103089:	88 10                	mov    %dl,(%eax)
		address++;
f010308b:	ff 45 f4             	incl   -0xc(%ebp)
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int stringLen = strlen(arguments[2]);

	for(int i=0;i < stringLen; i++)
f010308e:	ff 45 f0             	incl   -0x10(%ebp)
f0103091:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103094:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0103097:	7c dc                	jl     f0103075 <command_writemem_k+0x46>
	{
		*address = arguments[2][i];
		address++;
	}
	return 0;
f0103099:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010309e:	c9                   	leave  
f010309f:	c3                   	ret    

f01030a0 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01030a0:	55                   	push   %ebp
f01030a1:	89 e5                	mov    %esp,%ebp
f01030a3:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "rm"

	unsigned int address = strtol(arguments[1], NULL, 16);
f01030a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030a9:	83 c0 04             	add    $0x4,%eax
f01030ac:	8b 00                	mov    (%eax),%eax
f01030ae:	83 ec 04             	sub    $0x4,%esp
f01030b1:	6a 10                	push   $0x10
f01030b3:	6a 00                	push   $0x0
f01030b5:	50                   	push   %eax
f01030b6:	e8 83 01 02 00       	call   f012323e <strtol>
f01030bb:	83 c4 10             	add    $0x10,%esp
f01030be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char *ptr = (unsigned char *)(address + KERNEL_BASE) ;
f01030c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030c4:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01030c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//Read value at the given address
	cprintf("value at virtual address %x = %c\n", ptr, *ptr);
f01030cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01030cf:	8a 00                	mov    (%eax),%al
f01030d1:	0f b6 c0             	movzbl %al,%eax
f01030d4:	83 ec 04             	sub    $0x4,%esp
f01030d7:	50                   	push   %eax
f01030d8:	ff 75 f0             	pushl  -0x10(%ebp)
f01030db:	68 84 59 13 f0       	push   $0xf0135984
f01030e0:	e8 68 ea ff ff       	call   f0101b4d <cprintf>
f01030e5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01030e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030ed:	c9                   	leave  
f01030ee:	c3                   	ret    

f01030ef <command_get_page_table>:

//===========================================================================
//Lab3.Examples
//=============
int command_get_page_table(int number_of_arguments, char **arguments)
{
f01030ef:	55                   	push   %ebp
f01030f0:	89 e5                	mov    %esp,%ebp
f01030f2:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#1,2: fill this function. corresponding command name is "gpt"
	//Comment the following line
	panic("Function is not implemented yet!");
f01030f5:	83 ec 04             	sub    $0x4,%esp
f01030f8:	68 a8 59 13 f0       	push   $0xf01359a8
f01030fd:	68 cd 00 00 00       	push   $0xcd
f0103102:	68 c9 59 13 f0       	push   $0xf01359c9
f0103107:	e8 a3 dd ff ff       	call   f0100eaf <_panic>

f010310c <command_kernel_base_info>:

	return 0;
}

int command_kernel_base_info(int number_of_arguments, char **arguments)
{
f010310c:	55                   	push   %ebp
f010310d:	89 e5                	mov    %esp,%ebp
f010310f:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#3: fill this function. corresponding command name is "ikb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103112:	83 ec 04             	sub    $0x4,%esp
f0103115:	68 a8 59 13 f0       	push   $0xf01359a8
f010311a:	68 d6 00 00 00       	push   $0xd6
f010311f:	68 c9 59 13 f0       	push   $0xf01359c9
f0103124:	e8 86 dd ff ff       	call   f0100eaf <_panic>

f0103129 <command_del_kernel_base>:

	return 0;
}

int command_del_kernel_base(int number_of_arguments, char **arguments)
{
f0103129:	55                   	push   %ebp
f010312a:	89 e5                	mov    %esp,%ebp
f010312c:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#4: fill this function. corresponding command name is "dkb"
	//Comment the following line
	panic("Function is not implemented yet!");
f010312f:	83 ec 04             	sub    $0x4,%esp
f0103132:	68 a8 59 13 f0       	push   $0xf01359a8
f0103137:	68 df 00 00 00       	push   $0xdf
f010313c:	68 c9 59 13 f0       	push   $0xf01359c9
f0103141:	e8 69 dd ff ff       	call   f0100eaf <_panic>

f0103146 <command_share_page>:

	return 0;
}

int command_share_page(int number_of_arguments, char **arguments)
{
f0103146:	55                   	push   %ebp
f0103147:	89 e5                	mov    %esp,%ebp
f0103149:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#5: fill this function. corresponding command name is "shr"
	//Comment the following line
	panic("Function is not implemented yet!");
f010314c:	83 ec 04             	sub    $0x4,%esp
f010314f:	68 a8 59 13 f0       	push   $0xf01359a8
f0103154:	68 e8 00 00 00       	push   $0xe8
f0103159:	68 c9 59 13 f0       	push   $0xf01359c9
f010315e:	e8 4c dd ff ff       	call   f0100eaf <_panic>

f0103163 <command_nr>:
//===========================================================================
//Lab4.Examples
//==============
//[1] Number of references on the given physical address
int command_nr(int number_of_arguments, char **arguments)
{
f0103163:	55                   	push   %ebp
f0103164:	89 e5                	mov    %esp,%ebp
f0103166:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: corresponding command name is "nr"

	uint32 pa  = strtol(arguments[1], NULL, 16);
f0103169:	8b 45 0c             	mov    0xc(%ebp),%eax
f010316c:	83 c0 04             	add    $0x4,%eax
f010316f:	8b 00                	mov    (%eax),%eax
f0103171:	83 ec 04             	sub    $0x4,%esp
f0103174:	6a 10                	push   $0x10
f0103176:	6a 00                	push   $0x0
f0103178:	50                   	push   %eax
f0103179:	e8 c0 00 02 00       	call   f012323e <strtol>
f010317e:	83 c4 10             	add    $0x10,%esp
f0103181:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int num_of_ref = num_of_references(pa);
f0103184:	83 ec 0c             	sub    $0xc,%esp
f0103187:	ff 75 f4             	pushl  -0xc(%ebp)
f010318a:	e8 29 85 00 00       	call   f010b6b8 <num_of_references>
f010318f:	83 c4 10             	add    $0x10,%esp
f0103192:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("Num of ref's @ pa %x = %d\n", pa, num_of_ref);
f0103195:	83 ec 04             	sub    $0x4,%esp
f0103198:	ff 75 f0             	pushl  -0x10(%ebp)
f010319b:	ff 75 f4             	pushl  -0xc(%ebp)
f010319e:	68 dd 59 13 f0       	push   $0xf01359dd
f01031a3:	e8 a5 e9 ff ff       	call   f0101b4d <cprintf>
f01031a8:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031b0:	c9                   	leave  
f01031b1:	c3                   	ret    

f01031b2 <command_ap>:

//[2] Allocate Page
int command_ap(int number_of_arguments, char **arguments)
{
f01031b2:	55                   	push   %ebp
f01031b3:	89 e5                	mov    %esp,%ebp
f01031b5:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: corresponding command name is "ap"

	uint32 va = strtol(arguments[1], NULL, 16);
f01031b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031bb:	83 c0 04             	add    $0x4,%eax
f01031be:	8b 00                	mov    (%eax),%eax
f01031c0:	83 ec 04             	sub    $0x4,%esp
f01031c3:	6a 10                	push   $0x10
f01031c5:	6a 00                	push   $0x0
f01031c7:	50                   	push   %eax
f01031c8:	e8 71 00 02 00       	call   f012323e <strtol>
f01031cd:	83 c4 10             	add    $0x10,%esp
f01031d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool set_to_zero = 0;
f01031d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 3)
f01031da:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01031de:	75 15                	jne    f01031f5 <command_ap+0x43>
	{
		if (arguments[2][0] == '0')
f01031e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031e3:	83 c0 08             	add    $0x8,%eax
f01031e6:	8b 00                	mov    (%eax),%eax
f01031e8:	8a 00                	mov    (%eax),%al
f01031ea:	3c 30                	cmp    $0x30,%al
f01031ec:	75 07                	jne    f01031f5 <command_ap+0x43>
			set_to_zero = 1;
f01031ee:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	int ret = alloc_page(ptr_page_directory, va, PERM_USER | PERM_WRITEABLE, set_to_zero);
f01031f5:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01031fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01031fd:	6a 06                	push   $0x6
f01031ff:	ff 75 f0             	pushl  -0x10(%ebp)
f0103202:	50                   	push   %eax
f0103203:	e8 d2 84 00 00       	call   f010b6da <alloc_page>
f0103208:	83 c4 10             	add    $0x10,%esp
f010320b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ret == 1)
f010320e:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
f0103212:	75 15                	jne    f0103229 <command_ap+0x77>
	{
		cprintf("Page @ va %x already exists!\n", va);
f0103214:	83 ec 08             	sub    $0x8,%esp
f0103217:	ff 75 f0             	pushl  -0x10(%ebp)
f010321a:	68 f8 59 13 f0       	push   $0xf01359f8
f010321f:	e8 29 e9 ff ff       	call   f0101b4d <cprintf>
f0103224:	83 c4 10             	add    $0x10,%esp
f0103227:	eb 41                	jmp    f010326a <command_ap+0xb8>
	}
	else if (ret == E_NO_MEM)
f0103229:	83 7d ec fc          	cmpl   $0xfffffffc,-0x14(%ebp)
f010322d:	75 12                	jne    f0103241 <command_ap+0x8f>
	{
		cprintf("No enough memory!\n");
f010322f:	83 ec 0c             	sub    $0xc,%esp
f0103232:	68 16 5a 13 f0       	push   $0xf0135a16
f0103237:	e8 11 e9 ff ff       	call   f0101b4d <cprintf>
f010323c:	83 c4 10             	add    $0x10,%esp
f010323f:	eb 29                	jmp    f010326a <command_ap+0xb8>
	}
	else
	{
		cprintf("New page is allocated @ va %x\n", va);
f0103241:	83 ec 08             	sub    $0x8,%esp
f0103244:	ff 75 f0             	pushl  -0x10(%ebp)
f0103247:	68 2c 5a 13 f0       	push   $0xf0135a2c
f010324c:	e8 fc e8 ff ff       	call   f0101b4d <cprintf>
f0103251:	83 c4 10             	add    $0x10,%esp
		if (set_to_zero)
f0103254:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103258:	74 10                	je     f010326a <command_ap+0xb8>
			cprintf("and initialized by ZERO\n");
f010325a:	83 ec 0c             	sub    $0xc,%esp
f010325d:	68 4b 5a 13 f0       	push   $0xf0135a4b
f0103262:	e8 e6 e8 ff ff       	call   f0101b4d <cprintf>
f0103267:	83 c4 10             	add    $0x10,%esp
	}
	return 0 ;
f010326a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010326f:	c9                   	leave  
f0103270:	c3                   	ret    

f0103271 <command_fp>:

//[3] Free Page: Un-map a single page at the given virtual address in the user space
int command_fp(int number_of_arguments, char **arguments)
{
f0103271:	55                   	push   %ebp
f0103272:	89 e5                	mov    %esp,%ebp
f0103274:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#3: corresponding command name is "fp"

	uint32 va = strtol(arguments[1], NULL, 16);
f0103277:	8b 45 0c             	mov    0xc(%ebp),%eax
f010327a:	83 c0 04             	add    $0x4,%eax
f010327d:	8b 00                	mov    (%eax),%eax
f010327f:	83 ec 04             	sub    $0x4,%esp
f0103282:	6a 10                	push   $0x10
f0103284:	6a 00                	push   $0x0
f0103286:	50                   	push   %eax
f0103287:	e8 b2 ff 01 00       	call   f012323e <strtol>
f010328c:	83 c4 10             	add    $0x10,%esp
f010328f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unmap_frame(ptr_page_directory, va);
f0103292:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0103297:	83 ec 08             	sub    $0x8,%esp
f010329a:	ff 75 f4             	pushl  -0xc(%ebp)
f010329d:	50                   	push   %eax
f010329e:	e8 c9 69 00 00       	call   f0109c6c <unmap_frame>
f01032a3:	83 c4 10             	add    $0x10,%esp

	return 0;
f01032a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032ab:	c9                   	leave  
f01032ac:	c3                   	ret    

f01032ad <command_cfp>:
//===========================================================================
//Lab4.Hands-on
//==============
//Count Free Pages in Range
int command_cfp(int number_of_arguments, char **arguments)
{
f01032ad:	55                   	push   %ebp
f01032ae:	89 e5                	mov    %esp,%ebp
f01032b0:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Hands-on: corresponding command name is "cfp"

	uint32* dir_ptr = clone_kern_dir();
f01032b3:	e8 90 f2 01 00       	call   f0122548 <clone_kern_dir>
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 va1 = strtol(arguments[1], NULL, 16);
f01032bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032be:	83 c0 04             	add    $0x4,%eax
f01032c1:	8b 00                	mov    (%eax),%eax
f01032c3:	83 ec 04             	sub    $0x4,%esp
f01032c6:	6a 10                	push   $0x10
f01032c8:	6a 00                	push   $0x0
f01032ca:	50                   	push   %eax
f01032cb:	e8 6e ff 01 00       	call   f012323e <strtol>
f01032d0:	83 c4 10             	add    $0x10,%esp
f01032d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f01032d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032d9:	83 c0 08             	add    $0x8,%eax
f01032dc:	8b 00                	mov    (%eax),%eax
f01032de:	83 ec 04             	sub    $0x4,%esp
f01032e1:	6a 10                	push   $0x10
f01032e3:	6a 00                	push   $0x0
f01032e5:	50                   	push   %eax
f01032e6:	e8 53 ff 01 00       	call   f012323e <strtol>
f01032eb:	83 c4 10             	add    $0x10,%esp
f01032ee:	89 45 ec             	mov    %eax,-0x14(%ebp)

	uint32 num_of_free = calculate_free_space(dir_ptr, va1, va2);
f01032f1:	83 ec 04             	sub    $0x4,%esp
f01032f4:	ff 75 ec             	pushl  -0x14(%ebp)
f01032f7:	ff 75 f0             	pushl  -0x10(%ebp)
f01032fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01032fd:	e8 21 93 00 00       	call   f010c623 <calculate_free_space>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	89 45 e8             	mov    %eax,-0x18(%ebp)

	cprintf("Num of free pages in va range [%x, %x) = %d\n", va1, va2, num_of_free);
f0103308:	ff 75 e8             	pushl  -0x18(%ebp)
f010330b:	ff 75 ec             	pushl  -0x14(%ebp)
f010330e:	ff 75 f0             	pushl  -0x10(%ebp)
f0103311:	68 64 5a 13 f0       	push   $0xf0135a64
f0103316:	e8 32 e8 ff ff       	call   f0101b4d <cprintf>
f010331b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_asp>:

//===========================================================================
//Lab5.Hands.On
//=============
int command_asp(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "asp"

	uint32* dir_ptr = clone_kern_dir();
f010332b:	e8 18 f2 01 00       	call   f0122548 <clone_kern_dir>
f0103330:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va1 = strtol(arguments[1], NULL, 16);
f0103333:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103336:	83 c0 04             	add    $0x4,%eax
f0103339:	8b 00                	mov    (%eax),%eax
f010333b:	83 ec 04             	sub    $0x4,%esp
f010333e:	6a 10                	push   $0x10
f0103340:	6a 00                	push   $0x0
f0103342:	50                   	push   %eax
f0103343:	e8 f6 fe 01 00       	call   f012323e <strtol>
f0103348:	83 c4 10             	add    $0x10,%esp
f010334b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f010334e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103351:	83 c0 08             	add    $0x8,%eax
f0103354:	8b 00                	mov    (%eax),%eax
f0103356:	83 ec 04             	sub    $0x4,%esp
f0103359:	6a 10                	push   $0x10
f010335b:	6a 00                	push   $0x0
f010335d:	50                   	push   %eax
f010335e:	e8 db fe 01 00       	call   f012323e <strtol>
f0103363:	83 c4 10             	add    $0x10,%esp
f0103366:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int ret = alloc_shared_page(dir_ptr, va1, dir_ptr, va2, PERM_USER | PERM_WRITEABLE);
f0103369:	83 ec 0c             	sub    $0xc,%esp
f010336c:	6a 06                	push   $0x6
f010336e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103371:	ff 75 f4             	pushl  -0xc(%ebp)
f0103374:	ff 75 f0             	pushl  -0x10(%ebp)
f0103377:	ff 75 f4             	pushl  -0xc(%ebp)
f010337a:	e8 fe 83 00 00       	call   f010b77d <alloc_shared_page>
f010337f:	83 c4 20             	add    $0x20,%esp
f0103382:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0103385:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0103389:	75 10                	jne    f010339b <command_asp+0x76>
	{
		cprintf("No enough memory!\n");
f010338b:	83 ec 0c             	sub    $0xc,%esp
f010338e:	68 16 5a 13 f0       	push   $0xf0135a16
f0103393:	e8 b5 e7 ff ff       	call   f0101b4d <cprintf>
f0103398:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010339b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a0:	c9                   	leave  
f01033a1:	c3                   	ret    

f01033a2 <command_shmp>:

int command_shmp(int number_of_arguments, char **arguments)
{
f01033a2:	55                   	push   %ebp
f01033a3:	89 e5                	mov    %esp,%ebp
f01033a5:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sm"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033a8:	83 ec 04             	sub    $0x4,%esp
f01033ab:	68 a8 59 13 f0       	push   $0xf01359a8
f01033b0:	68 4d 01 00 00       	push   $0x14d
f01033b5:	68 c9 59 13 f0       	push   $0xf01359c9
f01033ba:	e8 f0 da ff ff       	call   f0100eaf <_panic>

f01033bf <command_scp>:

	return 0 ;
}

int command_scp(int number_of_arguments, char **arguments)
{
f01033bf:	55                   	push   %ebp
f01033c0:	89 e5                	mov    %esp,%ebp
f01033c2:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sp"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033c5:	83 ec 04             	sub    $0x4,%esp
f01033c8:	68 a8 59 13 f0       	push   $0xf01359a8
f01033cd:	68 56 01 00 00       	push   $0x156
f01033d2:	68 c9 59 13 f0       	push   $0xf01359c9
f01033d7:	e8 d3 da ff ff       	call   f0100eaf <_panic>

f01033dc <command_shrr>:

	return 0 ;
}

int command_shrr(int number_of_arguments, char **arguments)
{
f01033dc:	55                   	push   %ebp
f01033dd:	89 e5                	mov    %esp,%ebp
f01033df:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sr"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033e2:	83 ec 04             	sub    $0x4,%esp
f01033e5:	68 a8 59 13 f0       	push   $0xf01359a8
f01033ea:	68 5f 01 00 00       	push   $0x15f
f01033ef:	68 c9 59 13 f0       	push   $0xf01359c9
f01033f4:	e8 b6 da ff ff       	call   f0100eaf <_panic>

f01033f9 <command_v2p>:

	return 0;
}

int command_v2p(int number_of_arguments, char **arguments)
{
f01033f9:	55                   	push   %ebp
f01033fa:	89 e5                	mov    %esp,%ebp
f01033fc:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "v2p"

	uint32 va = strtol(arguments[1], NULL, 16);
f01033ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103402:	83 c0 04             	add    $0x4,%eax
f0103405:	8b 00                	mov    (%eax),%eax
f0103407:	83 ec 04             	sub    $0x4,%esp
f010340a:	6a 10                	push   $0x10
f010340c:	6a 00                	push   $0x0
f010340e:	50                   	push   %eax
f010340f:	e8 2a fe 01 00       	call   f012323e <strtol>
f0103414:	83 c4 10             	add    $0x10,%esp
f0103417:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 pa = virtual_to_physical(ptr_page_directory, va);
f010341a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010341f:	83 ec 08             	sub    $0x8,%esp
f0103422:	ff 75 f4             	pushl  -0xc(%ebp)
f0103425:	50                   	push   %eax
f0103426:	e8 59 82 00 00       	call   f010b684 <virtual_to_physical>
f010342b:	83 c4 10             	add    $0x10,%esp
f010342e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pa == -1)
f0103431:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0103435:	75 12                	jne    f0103449 <command_v2p+0x50>
		cprintf("NOT FOUND\n");
f0103437:	83 ec 0c             	sub    $0xc,%esp
f010343a:	68 91 5a 13 f0       	push   $0xf0135a91
f010343f:	e8 09 e7 ff ff       	call   f0101b4d <cprintf>
f0103444:	83 c4 10             	add    $0x10,%esp
f0103447:	eb 16                	jmp    f010345f <command_v2p+0x66>
	else
		cprintf("PA of VA %x = %x\n", va, pa);
f0103449:	83 ec 04             	sub    $0x4,%esp
f010344c:	ff 75 f0             	pushl  -0x10(%ebp)
f010344f:	ff 75 f4             	pushl  -0xc(%ebp)
f0103452:	68 9c 5a 13 f0       	push   $0xf0135a9c
f0103457:	e8 f1 e6 ff ff       	call   f0101b4d <cprintf>
f010345c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010345f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103464:	c9                   	leave  
f0103465:	c3                   	ret    

f0103466 <command_p2v>:

int command_p2v(int number_of_arguments, char **arguments)
{
f0103466:	55                   	push   %ebp
f0103467:	89 e5                	mov    %esp,%ebp
f0103469:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "p2v"

	uint32 pa = strtol(arguments[1], NULL, 16);
f010346c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010346f:	83 c0 04             	add    $0x4,%eax
f0103472:	8b 00                	mov    (%eax),%eax
f0103474:	83 ec 04             	sub    $0x4,%esp
f0103477:	6a 10                	push   $0x10
f0103479:	6a 00                	push   $0x0
f010347b:	50                   	push   %eax
f010347c:	e8 bd fd 01 00       	call   f012323e <strtol>
f0103481:	83 c4 10             	add    $0x10,%esp
f0103484:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va = physical_to_virtual(ptr_page_directory, pa);
f0103487:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010348c:	83 ec 08             	sub    $0x8,%esp
f010348f:	ff 75 f4             	pushl  -0xc(%ebp)
f0103492:	50                   	push   %eax
f0103493:	e8 06 82 00 00       	call   f010b69e <physical_to_virtual>
f0103498:	83 c4 10             	add    $0x10,%esp
f010349b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (va == 0xFFFFFFFF)
f010349e:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f01034a2:	75 12                	jne    f01034b6 <command_p2v+0x50>
		cprintf("NOT FOUND\n");
f01034a4:	83 ec 0c             	sub    $0xc,%esp
f01034a7:	68 91 5a 13 f0       	push   $0xf0135a91
f01034ac:	e8 9c e6 ff ff       	call   f0101b4d <cprintf>
f01034b1:	83 c4 10             	add    $0x10,%esp
f01034b4:	eb 16                	jmp    f01034cc <command_p2v+0x66>
	else
		cprintf("VA of PA %x = %x\n", pa, va);
f01034b6:	83 ec 04             	sub    $0x4,%esp
f01034b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01034bc:	ff 75 f4             	pushl  -0xc(%ebp)
f01034bf:	68 ae 5a 13 f0       	push   $0xf0135aae
f01034c4:	e8 84 e6 ff ff       	call   f0101b4d <cprintf>
f01034c9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034d1:	c9                   	leave  
f01034d2:	c3                   	ret    

f01034d3 <command_ft>:

//===========================================================================
//Lab6.Examples
//=============
int command_ft(int number_of_arguments, char **arguments)
{
f01034d3:	55                   	push   %ebp
f01034d4:	89 e5                	mov    %esp,%ebp
f01034d6:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB6 Example: corresponding command name is "ft"

	uint32 va = strtol(arguments[1], NULL, 16);
f01034d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034dc:	83 c0 04             	add    $0x4,%eax
f01034df:	8b 00                	mov    (%eax),%eax
f01034e1:	83 ec 04             	sub    $0x4,%esp
f01034e4:	6a 10                	push   $0x10
f01034e6:	6a 00                	push   $0x0
f01034e8:	50                   	push   %eax
f01034e9:	e8 50 fd 01 00       	call   f012323e <strtol>
f01034ee:	83 c4 10             	add    $0x10,%esp
f01034f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	del_page_table(ptr_page_directory, va);
f01034f4:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01034f9:	83 ec 08             	sub    $0x8,%esp
f01034fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01034ff:	50                   	push   %eax
f0103500:	e8 95 82 00 00       	call   f010b79a <del_page_table>
f0103505:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103508:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010350d:	c9                   	leave  
f010350e:	c3                   	ret    

f010350f <command_writeusermem>:

//*****************************************************************************************//
//***************************** UTILITY/TESING COMMANDS ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f010350f:	55                   	push   %ebp
f0103510:	89 e5                	mov    %esp,%ebp
f0103512:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f0103515:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0103519:	75 37                	jne    f0103552 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010351b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010351e:	83 c0 04             	add    $0x4,%eax
f0103521:	8b 00                	mov    (%eax),%eax
f0103523:	83 ec 04             	sub    $0x4,%esp
f0103526:	6a 10                	push   $0x10
f0103528:	6a 00                	push   $0x0
f010352a:	50                   	push   %eax
f010352b:	e8 0e fd 01 00       	call   f012323e <strtol>
f0103530:	83 c4 10             	add    $0x10,%esp
f0103533:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0103536:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103539:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f010353c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010353f:	83 c0 08             	add    $0x8,%eax
f0103542:	8b 00                	mov    (%eax),%eax
f0103544:	8a 00                	mov    (%eax),%al
f0103546:	88 c2                	mov    %al,%dl
f0103548:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010354b:	88 10                	mov    %dl,(%eax)
f010354d:	e9 b9 00 00 00       	jmp    f010360b <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0103552:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103556:	0f 85 9f 00 00 00    	jne    f01035fb <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f010355c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010355f:	83 c0 04             	add    $0x4,%eax
f0103562:	8b 00                	mov    (%eax),%eax
f0103564:	83 ec 04             	sub    $0x4,%esp
f0103567:	6a 0a                	push   $0xa
f0103569:	6a 00                	push   $0x0
f010356b:	50                   	push   %eax
f010356c:	e8 cd fc 01 00       	call   f012323e <strtol>
f0103571:	83 c4 10             	add    $0x10,%esp
f0103574:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0103577:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f010357e:	83 ec 04             	sub    $0x4,%esp
f0103581:	6a 00                	push   $0x0
f0103583:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0103586:	50                   	push   %eax
f0103587:	ff 75 f4             	pushl  -0xc(%ebp)
f010358a:	e8 09 a1 00 00       	call   f010d698 <envid2env>
f010358f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0103592:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103595:	83 c0 08             	add    $0x8,%eax
f0103598:	8b 00                	mov    (%eax),%eax
f010359a:	83 ec 04             	sub    $0x4,%esp
f010359d:	6a 10                	push   $0x10
f010359f:	6a 00                	push   $0x0
f01035a1:	50                   	push   %eax
f01035a2:	e8 97 fc 01 00       	call   f012323e <strtol>
f01035a7:	83 c4 10             	add    $0x10,%esp
f01035aa:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01035ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01035b0:	85 c0                	test   %eax,%eax
f01035b2:	75 07                	jne    f01035bb <command_writeusermem+0xac>
f01035b4:	b8 00 00 00 00       	mov    $0x0,%eax
f01035b9:	eb 55                	jmp    f0103610 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01035bb:	0f 20 d8             	mov    %cr3,%eax
f01035be:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01035c1:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01035c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01035c7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01035ca:	8b 40 68             	mov    0x68(%eax),%eax
f01035cd:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01035d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01035d3:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01035d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01035d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01035dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035df:	83 c0 0c             	add    $0xc,%eax
f01035e2:	8b 00                	mov    (%eax),%eax
f01035e4:	8a 00                	mov    (%eax),%al
f01035e6:	88 c2                	mov    %al,%dl
f01035e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035eb:	88 10                	mov    %dl,(%eax)
f01035ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01035f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01035f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01035f6:	0f 22 d8             	mov    %eax,%cr3
f01035f9:	eb 10                	jmp    f010360b <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01035fb:	83 ec 0c             	sub    $0xc,%esp
f01035fe:	68 c0 5a 13 f0       	push   $0xf0135ac0
f0103603:	e8 45 e5 ff ff       	call   f0101b4d <cprintf>
f0103608:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010360b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103610:	c9                   	leave  
f0103611:	c3                   	ret    

f0103612 <command_readusermem>:


int command_readusermem(int number_of_arguments, char **arguments)
{
f0103612:	55                   	push   %ebp
f0103613:	89 e5                	mov    %esp,%ebp
f0103615:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f0103618:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010361c:	75 42                	jne    f0103660 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010361e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103621:	83 c0 04             	add    $0x4,%eax
f0103624:	8b 00                	mov    (%eax),%eax
f0103626:	83 ec 04             	sub    $0x4,%esp
f0103629:	6a 10                	push   $0x10
f010362b:	6a 00                	push   $0x0
f010362d:	50                   	push   %eax
f010362e:	e8 0b fc 01 00       	call   f012323e <strtol>
f0103633:	83 c4 10             	add    $0x10,%esp
f0103636:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f0103639:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010363c:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f010363f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103642:	8a 00                	mov    (%eax),%al
f0103644:	0f b6 c0             	movzbl %al,%eax
f0103647:	83 ec 04             	sub    $0x4,%esp
f010364a:	50                   	push   %eax
f010364b:	ff 75 d8             	pushl  -0x28(%ebp)
f010364e:	68 ea 5a 13 f0       	push   $0xf0135aea
f0103653:	e8 f5 e4 ff ff       	call   f0101b4d <cprintf>
f0103658:	83 c4 10             	add    $0x10,%esp
f010365b:	e9 c4 00 00 00       	jmp    f0103724 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f0103660:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0103664:	0f 85 aa 00 00 00    	jne    f0103714 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f010366a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010366d:	83 c0 04             	add    $0x4,%eax
f0103670:	8b 00                	mov    (%eax),%eax
f0103672:	83 ec 04             	sub    $0x4,%esp
f0103675:	6a 0a                	push   $0xa
f0103677:	6a 00                	push   $0x0
f0103679:	50                   	push   %eax
f010367a:	e8 bf fb 01 00       	call   f012323e <strtol>
f010367f:	83 c4 10             	add    $0x10,%esp
f0103682:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0103685:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f010368c:	83 ec 04             	sub    $0x4,%esp
f010368f:	6a 00                	push   $0x0
f0103691:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0103694:	50                   	push   %eax
f0103695:	ff 75 f4             	pushl  -0xc(%ebp)
f0103698:	e8 fb 9f 00 00       	call   f010d698 <envid2env>
f010369d:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f01036a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a3:	83 c0 08             	add    $0x8,%eax
f01036a6:	8b 00                	mov    (%eax),%eax
f01036a8:	83 ec 04             	sub    $0x4,%esp
f01036ab:	6a 10                	push   $0x10
f01036ad:	6a 00                	push   $0x0
f01036af:	50                   	push   %eax
f01036b0:	e8 89 fb 01 00       	call   f012323e <strtol>
f01036b5:	83 c4 10             	add    $0x10,%esp
f01036b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01036bb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036be:	85 c0                	test   %eax,%eax
f01036c0:	75 07                	jne    f01036c9 <command_readusermem+0xb7>
f01036c2:	b8 00 00 00 00       	mov    $0x0,%eax
f01036c7:	eb 60                	jmp    f0103729 <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01036c9:	0f 20 d8             	mov    %cr3,%eax
f01036cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01036cf:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01036d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f01036d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036d8:	8b 40 68             	mov    0x68(%eax),%eax
f01036db:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01036de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01036e1:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01036e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01036e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f01036ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01036ed:	8a 00                	mov    (%eax),%al
f01036ef:	0f b6 c0             	movzbl %al,%eax
f01036f2:	83 ec 04             	sub    $0x4,%esp
f01036f5:	50                   	push   %eax
f01036f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01036f9:	68 ea 5a 13 f0       	push   $0xf0135aea
f01036fe:	e8 4a e4 ff ff       	call   f0101b4d <cprintf>
f0103703:	83 c4 10             	add    $0x10,%esp
f0103706:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103709:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010370c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010370f:	0f 22 d8             	mov    %eax,%cr3
f0103712:	eb 10                	jmp    f0103724 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0103714:	83 ec 0c             	sub    $0xc,%esp
f0103717:	68 04 5b 13 f0       	push   $0xf0135b04
f010371c:	e8 2c e4 ff ff       	call   f0101b4d <cprintf>
f0103721:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103724:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0103729:	c9                   	leave  
f010372a:	c3                   	ret    

f010372b <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f010372b:	55                   	push   %ebp
f010372c:	89 e5                	mov    %esp,%ebp
f010372e:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103731:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103734:	83 c0 04             	add    $0x4,%eax
f0103737:	8b 00                	mov    (%eax),%eax
f0103739:	83 ec 04             	sub    $0x4,%esp
f010373c:	6a 0a                	push   $0xa
f010373e:	6a 00                	push   $0x0
f0103740:	50                   	push   %eax
f0103741:	e8 f8 fa 01 00       	call   f012323e <strtol>
f0103746:	83 c4 10             	add    $0x10,%esp
f0103749:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f010374c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0103753:	83 ec 04             	sub    $0x4,%esp
f0103756:	6a 00                	push   $0x0
f0103758:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010375b:	50                   	push   %eax
f010375c:	ff 75 ec             	pushl  -0x14(%ebp)
f010375f:	e8 34 9f 00 00       	call   f010d698 <envid2env>
f0103764:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0103767:	8b 45 0c             	mov    0xc(%ebp),%eax
f010376a:	83 c0 08             	add    $0x8,%eax
f010376d:	8b 00                	mov    (%eax),%eax
f010376f:	83 ec 04             	sub    $0x4,%esp
f0103772:	6a 10                	push   $0x10
f0103774:	6a 00                	push   $0x0
f0103776:	50                   	push   %eax
f0103777:	e8 c2 fa 01 00       	call   f012323e <strtol>
f010377c:	83 c4 10             	add    $0x10,%esp
f010377f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0103782:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103785:	83 c0 0c             	add    $0xc,%eax
f0103788:	8b 00                	mov    (%eax),%eax
f010378a:	83 ec 04             	sub    $0x4,%esp
f010378d:	6a 0a                	push   $0xa
f010378f:	6a 00                	push   $0x0
f0103791:	50                   	push   %eax
f0103792:	e8 a7 fa 01 00       	call   f012323e <strtol>
f0103797:	83 c4 10             	add    $0x10,%esp
f010379a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f010379d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01037a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f01037a3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037a6:	85 c0                	test   %eax,%eax
f01037a8:	75 07                	jne    f01037b1 <command_readuserblock+0x86>
f01037aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01037af:	eb 65                	jmp    f0103816 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01037b1:	0f 20 d8             	mov    %cr3,%eax
f01037b4:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01037b7:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f01037ba:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f01037bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037c0:	8b 40 68             	mov    0x68(%eax),%eax
f01037c3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01037c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01037c9:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01037cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01037d3:	eb 28                	jmp    f01037fd <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01037d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037d8:	8a 00                	mov    (%eax),%al
f01037da:	0f b6 d0             	movzbl %al,%edx
f01037dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037e0:	8a 00                	mov    (%eax),%al
f01037e2:	0f b6 c0             	movzbl %al,%eax
f01037e5:	52                   	push   %edx
f01037e6:	50                   	push   %eax
f01037e7:	ff 75 f4             	pushl  -0xc(%ebp)
f01037ea:	68 2e 5b 13 f0       	push   $0xf0135b2e
f01037ef:	e8 59 e3 ff ff       	call   f0101b4d <cprintf>
f01037f4:	83 c4 10             	add    $0x10,%esp
		ptr++;
f01037f7:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f01037fa:	ff 45 f0             	incl   -0x10(%ebp)
f01037fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103800:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0103803:	7c d0                	jl     f01037d5 <command_readuserblock+0xaa>
f0103805:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103808:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010380b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010380e:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0103811:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103816:	c9                   	leave  
f0103817:	c3                   	ret    

f0103818 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0103818:	55                   	push   %ebp
f0103819:	89 e5                	mov    %esp,%ebp
f010381b:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010381e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103821:	83 c0 04             	add    $0x4,%eax
f0103824:	8b 00                	mov    (%eax),%eax
f0103826:	83 ec 04             	sub    $0x4,%esp
f0103829:	6a 0a                	push   $0xa
f010382b:	6a 00                	push   $0x0
f010382d:	50                   	push   %eax
f010382e:	e8 0b fa 01 00       	call   f012323e <strtol>
f0103833:	83 c4 10             	add    $0x10,%esp
f0103836:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0103839:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0103840:	83 ec 04             	sub    $0x4,%esp
f0103843:	6a 00                	push   $0x0
f0103845:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0103848:	50                   	push   %eax
f0103849:	ff 75 f4             	pushl  -0xc(%ebp)
f010384c:	e8 47 9e 00 00       	call   f010d698 <envid2env>
f0103851:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103854:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103857:	85 c0                	test   %eax,%eax
f0103859:	75 0a                	jne    f0103865 <command_remove_table+0x4d>
f010385b:	b8 00 00 00 00       	mov    $0x0,%eax
f0103860:	e9 c7 00 00 00       	jmp    f010392c <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0103865:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103868:	83 c0 08             	add    $0x8,%eax
f010386b:	8b 00                	mov    (%eax),%eax
f010386d:	83 ec 04             	sub    $0x4,%esp
f0103870:	6a 10                	push   $0x10
f0103872:	6a 00                	push   $0x0
f0103874:	50                   	push   %eax
f0103875:	e8 c4 f9 01 00       	call   f012323e <strtol>
f010387a:	83 c4 10             	add    $0x10,%esp
f010387d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0103880:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103883:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0103886:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103889:	8b 40 64             	mov    0x64(%eax),%eax
f010388c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010388f:	c1 ea 16             	shr    $0x16,%edx
f0103892:	c1 e2 02             	shl    $0x2,%edx
f0103895:	01 d0                	add    %edx,%eax
f0103897:	8b 00                	mov    (%eax),%eax
f0103899:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010389e:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f01038a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01038a4:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f01038a9:	77 1c                	ja     f01038c7 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f01038ab:	83 ec 0c             	sub    $0xc,%esp
f01038ae:	ff 75 e8             	pushl  -0x18(%ebp)
f01038b1:	e8 6a 7b 00 00       	call   f010b420 <kheap_virtual_address>
f01038b6:	83 c4 10             	add    $0x10,%esp
f01038b9:	83 ec 0c             	sub    $0xc,%esp
f01038bc:	50                   	push   %eax
f01038bd:	e8 91 79 00 00       	call   f010b253 <kfree>
f01038c2:	83 c4 10             	add    $0x10,%esp
f01038c5:	eb 28                	jmp    f01038ef <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f01038c7:	83 ec 0c             	sub    $0xc,%esp
f01038ca:	ff 75 e8             	pushl  -0x18(%ebp)
f01038cd:	e8 8b f5 ff ff       	call   f0102e5d <to_frame_info>
f01038d2:	83 c4 10             	add    $0x10,%esp
f01038d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f01038d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01038db:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f01038e1:	83 ec 0c             	sub    $0xc,%esp
f01038e4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01038e7:	e8 92 5e 00 00       	call   f010977e <free_frame>
f01038ec:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01038ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01038f2:	c1 e8 16             	shr    $0x16,%eax
f01038f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f01038f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01038fb:	8b 40 64             	mov    0x64(%eax),%eax
f01038fe:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103901:	c1 e2 02             	shl    $0x2,%edx
f0103904:	01 c2                	add    %eax,%edx
f0103906:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103909:	8b 40 64             	mov    0x64(%eax),%eax
f010390c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f010390f:	c1 e1 02             	shl    $0x2,%ecx
f0103912:	01 c8                	add    %ecx,%eax
f0103914:	8b 00                	mov    (%eax),%eax
f0103916:	83 e0 fe             	and    $0xfffffffe,%eax
f0103919:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010391b:	0f 20 d8             	mov    %cr3,%eax
f010391e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0103921:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103924:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0103927:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392c:	c9                   	leave  
f010392d:	c3                   	ret    

f010392e <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f010392e:	55                   	push   %ebp
f010392f:	89 e5                	mov    %esp,%ebp
f0103931:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0103934:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0103938:	7e 06                	jle    f0103940 <command_allocuserpage+0x12>
f010393a:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010393e:	7e 1a                	jle    f010395a <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0103940:	83 ec 0c             	sub    $0xc,%esp
f0103943:	68 40 5b 13 f0       	push   $0xf0135b40
f0103948:	e8 00 e2 ff ff       	call   f0101b4d <cprintf>
f010394d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103950:	b8 00 00 00 00       	mov    $0x0,%eax
f0103955:	e9 46 01 00 00       	jmp    f0103aa0 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f010395a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010395d:	83 c0 04             	add    $0x4,%eax
f0103960:	8b 00                	mov    (%eax),%eax
f0103962:	83 ec 04             	sub    $0x4,%esp
f0103965:	6a 0a                	push   $0xa
f0103967:	6a 00                	push   $0x0
f0103969:	50                   	push   %eax
f010396a:	e8 cf f8 01 00       	call   f012323e <strtol>
f010396f:	83 c4 10             	add    $0x10,%esp
f0103972:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0103975:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f010397c:	83 ec 04             	sub    $0x4,%esp
f010397f:	6a 00                	push   $0x0
f0103981:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103984:	50                   	push   %eax
f0103985:	ff 75 f0             	pushl  -0x10(%ebp)
f0103988:	e8 0b 9d 00 00       	call   f010d698 <envid2env>
f010398d:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103990:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103993:	85 c0                	test   %eax,%eax
f0103995:	75 0a                	jne    f01039a1 <command_allocuserpage+0x73>
f0103997:	b8 00 00 00 00       	mov    $0x0,%eax
f010399c:	e9 ff 00 00 00       	jmp    f0103aa0 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f01039a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01039a4:	83 c0 08             	add    $0x8,%eax
f01039a7:	8b 00                	mov    (%eax),%eax
f01039a9:	83 ec 04             	sub    $0x4,%esp
f01039ac:	6a 10                	push   $0x10
f01039ae:	6a 00                	push   $0x0
f01039b0:	50                   	push   %eax
f01039b1:	e8 88 f8 01 00       	call   f012323e <strtol>
f01039b6:	83 c4 10             	add    $0x10,%esp
f01039b9:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f01039bc:	83 ec 0c             	sub    $0xc,%esp
f01039bf:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01039c2:	50                   	push   %eax
f01039c3:	e8 8e 5c 00 00       	call   f0109656 <allocate_frame>
f01039c8:	83 c4 10             	add    $0x10,%esp
f01039cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f01039ce:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01039d2:	75 1a                	jne    f01039ee <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f01039d4:	83 ec 0c             	sub    $0xc,%esp
f01039d7:	68 6a 5b 13 f0       	push   $0xf0135b6a
f01039dc:	e8 6c e1 ff ff       	call   f0101b4d <cprintf>
f01039e1:	83 c4 10             	add    $0x10,%esp
		return 0;
f01039e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01039e9:	e9 b2 00 00 00       	jmp    f0103aa0 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f01039ee:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01039f2:	75 1d                	jne    f0103a11 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f01039f4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01039f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01039fa:	8b 40 64             	mov    0x64(%eax),%eax
f01039fd:	6a 06                	push   $0x6
f01039ff:	ff 75 ec             	pushl  -0x14(%ebp)
f0103a02:	52                   	push   %edx
f0103a03:	50                   	push   %eax
f0103a04:	e8 ee 60 00 00       	call   f0109af7 <map_frame>
f0103a09:	83 c4 10             	add    $0x10,%esp
f0103a0c:	e9 8a 00 00 00       	jmp    f0103a9b <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0103a11:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103a15:	0f 85 80 00 00 00    	jne    f0103a9b <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0103a1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a1e:	83 c0 0c             	add    $0xc,%eax
f0103a21:	8b 00                	mov    (%eax),%eax
f0103a23:	8a 00                	mov    (%eax),%al
f0103a25:	3c 72                	cmp    $0x72,%al
f0103a27:	74 0e                	je     f0103a37 <command_allocuserpage+0x109>
f0103a29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a2c:	83 c0 0c             	add    $0xc,%eax
f0103a2f:	8b 00                	mov    (%eax),%eax
f0103a31:	8a 00                	mov    (%eax),%al
f0103a33:	3c 52                	cmp    $0x52,%al
f0103a35:	75 09                	jne    f0103a40 <command_allocuserpage+0x112>
			rw = 0 ;
f0103a37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103a3e:	eb 3c                	jmp    f0103a7c <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0103a40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a43:	83 c0 0c             	add    $0xc,%eax
f0103a46:	8b 00                	mov    (%eax),%eax
f0103a48:	8a 00                	mov    (%eax),%al
f0103a4a:	3c 77                	cmp    $0x77,%al
f0103a4c:	74 0e                	je     f0103a5c <command_allocuserpage+0x12e>
f0103a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a51:	83 c0 0c             	add    $0xc,%eax
f0103a54:	8b 00                	mov    (%eax),%eax
f0103a56:	8a 00                	mov    (%eax),%al
f0103a58:	3c 57                	cmp    $0x57,%al
f0103a5a:	75 09                	jne    f0103a65 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0103a5c:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103a63:	eb 17                	jmp    f0103a7c <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0103a65:	83 ec 0c             	sub    $0xc,%esp
f0103a68:	68 84 5b 13 f0       	push   $0xf0135b84
f0103a6d:	e8 db e0 ff ff       	call   f0101b4d <cprintf>
f0103a72:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0103a75:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0103a7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103a7f:	83 c8 04             	or     $0x4,%eax
f0103a82:	89 c1                	mov    %eax,%ecx
f0103a84:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103a87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103a8a:	8b 40 64             	mov    0x64(%eax),%eax
f0103a8d:	51                   	push   %ecx
f0103a8e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103a91:	52                   	push   %edx
f0103a92:	50                   	push   %eax
f0103a93:	e8 5f 60 00 00       	call   f0109af7 <map_frame>
f0103a98:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103aa0:	c9                   	leave  
f0103aa1:	c3                   	ret    

f0103aa2 <command_meminfo>:
//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
f0103aa2:	55                   	push   %ebp
f0103aa3:	89 e5                	mov    %esp,%ebp
f0103aa5:	56                   	push   %esi
f0103aa6:	53                   	push   %ebx
f0103aa7:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0103aaa:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0103aad:	83 ec 0c             	sub    $0xc,%esp
f0103ab0:	50                   	push   %eax
f0103ab1:	e8 38 63 00 00       	call   f0109dee <calculate_available_frames>
f0103ab6:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103ab9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103abc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103abf:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0103ac2:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0103ac5:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0103ac8:	01 de                	add    %ebx,%esi
f0103aca:	8b 5d f4             	mov    -0xc(%ebp),%ebx
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103acd:	01 f3                	add    %esi,%ebx
f0103acf:	83 ec 0c             	sub    $0xc,%esp
f0103ad2:	51                   	push   %ecx
f0103ad3:	52                   	push   %edx
f0103ad4:	50                   	push   %eax
f0103ad5:	53                   	push   %ebx
f0103ad6:	68 c8 5b 13 f0       	push   $0xf0135bc8
f0103adb:	e8 6d e0 ff ff       	call   f0101b4d <cprintf>
f0103ae0:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0103ae3:	a1 d0 52 96 f1       	mov    0xf19652d0,%eax
f0103ae8:	83 ec 08             	sub    $0x8,%esp
f0103aeb:	50                   	push   %eax
f0103aec:	68 20 5c 13 f0       	push   $0xf0135c20
f0103af1:	e8 57 e0 ff ff       	call   f0101b4d <cprintf>
f0103af6:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103af9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103afe:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103b01:	5b                   	pop    %ebx
f0103b02:	5e                   	pop    %esi
f0103b03:	5d                   	pop    %ebp
f0103b04:	c3                   	ret    

f0103b05 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0103b05:	55                   	push   %ebp
f0103b06:	89 e5                	mov    %esp,%ebp
f0103b08:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0103b0b:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0103b12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0103b19:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0103b20:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0103b27:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0103b2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b31:	83 f8 04             	cmp    $0x4,%eax
f0103b34:	0f 84 c3 00 00 00    	je     f0103bfd <CreateEnv+0xf8>
f0103b3a:	83 f8 05             	cmp    $0x5,%eax
f0103b3d:	74 0e                	je     f0103b4d <CreateEnv+0x48>
f0103b3f:	83 f8 03             	cmp    $0x3,%eax
f0103b42:	0f 84 4a 01 00 00    	je     f0103c92 <CreateEnv+0x18d>
f0103b48:	e9 8d 01 00 00       	jmp    f0103cda <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103b4d:	83 ec 0c             	sub    $0xc,%esp
f0103b50:	6a 02                	push   $0x2
f0103b52:	e8 27 db 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0103b57:	83 c4 10             	add    $0x10,%esp
f0103b5a:	85 c0                	test   %eax,%eax
f0103b5c:	75 1a                	jne    f0103b78 <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0103b5e:	83 ec 0c             	sub    $0xc,%esp
f0103b61:	68 5c 5c 13 f0       	push   $0xf0135c5c
f0103b66:	e8 e2 df ff ff       	call   f0101b4d <cprintf>
f0103b6b:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103b6e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103b73:	e9 7b 02 00 00       	jmp    f0103df3 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0103b78:	e8 fc 3c 00 00       	call   f0107879 <isSchedMethodBSD>
f0103b7d:	85 c0                	test   %eax,%eax
f0103b7f:	74 1d                	je     f0103b9e <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0103b81:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b84:	83 c0 10             	add    $0x10,%eax
f0103b87:	8b 00                	mov    (%eax),%eax
f0103b89:	83 ec 04             	sub    $0x4,%esp
f0103b8c:	6a 0a                	push   $0xa
f0103b8e:	6a 00                	push   $0x0
f0103b90:	50                   	push   %eax
f0103b91:	e8 a8 f6 01 00       	call   f012323e <strtol>
f0103b96:	83 c4 10             	add    $0x10,%esp
f0103b99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103b9c:	eb 24                	jmp    f0103bc2 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0103b9e:	e8 e9 3c 00 00       	call   f010788c <isSchedMethodPRIRR>
f0103ba3:	85 c0                	test   %eax,%eax
f0103ba5:	74 1b                	je     f0103bc2 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0103ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103baa:	83 c0 10             	add    $0x10,%eax
f0103bad:	8b 00                	mov    (%eax),%eax
f0103baf:	83 ec 04             	sub    $0x4,%esp
f0103bb2:	6a 0a                	push   $0xa
f0103bb4:	6a 00                	push   $0x0
f0103bb6:	50                   	push   %eax
f0103bb7:	e8 82 f6 01 00       	call   f012323e <strtol>
f0103bbc:	83 c4 10             	add    $0x10,%esp
f0103bbf:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bc5:	83 c0 0c             	add    $0xc,%eax
f0103bc8:	8b 00                	mov    (%eax),%eax
f0103bca:	83 ec 04             	sub    $0x4,%esp
f0103bcd:	6a 0a                	push   $0xa
f0103bcf:	6a 00                	push   $0x0
f0103bd1:	50                   	push   %eax
f0103bd2:	e8 67 f6 01 00       	call   f012323e <strtol>
f0103bd7:	83 c4 10             	add    $0x10,%esp
f0103bda:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103bdd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103be0:	83 c0 08             	add    $0x8,%eax
f0103be3:	8b 00                	mov    (%eax),%eax
f0103be5:	83 ec 04             	sub    $0x4,%esp
f0103be8:	6a 0a                	push   $0xa
f0103bea:	6a 00                	push   $0x0
f0103bec:	50                   	push   %eax
f0103bed:	e8 4c f6 01 00       	call   f012323e <strtol>
f0103bf2:	83 c4 10             	add    $0x10,%esp
f0103bf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103bf8:	e9 f7 00 00 00       	jmp    f0103cf4 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103bfd:	83 ec 0c             	sub    $0xc,%esp
f0103c00:	6a 02                	push   $0x2
f0103c02:	e8 77 da 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0103c07:	83 c4 10             	add    $0x10,%esp
f0103c0a:	85 c0                	test   %eax,%eax
f0103c0c:	75 4c                	jne    f0103c5a <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0103c0e:	e8 66 3c 00 00       	call   f0107879 <isSchedMethodBSD>
f0103c13:	85 c0                	test   %eax,%eax
f0103c15:	74 1d                	je     f0103c34 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0103c17:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c1a:	83 c0 0c             	add    $0xc,%eax
f0103c1d:	8b 00                	mov    (%eax),%eax
f0103c1f:	83 ec 04             	sub    $0x4,%esp
f0103c22:	6a 0a                	push   $0xa
f0103c24:	6a 00                	push   $0x0
f0103c26:	50                   	push   %eax
f0103c27:	e8 12 f6 01 00       	call   f012323e <strtol>
f0103c2c:	83 c4 10             	add    $0x10,%esp
f0103c2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103c32:	eb 41                	jmp    f0103c75 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103c34:	e8 53 3c 00 00       	call   f010788c <isSchedMethodPRIRR>
f0103c39:	85 c0                	test   %eax,%eax
f0103c3b:	74 38                	je     f0103c75 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f0103c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c40:	83 c0 0c             	add    $0xc,%eax
f0103c43:	8b 00                	mov    (%eax),%eax
f0103c45:	83 ec 04             	sub    $0x4,%esp
f0103c48:	6a 0a                	push   $0xa
f0103c4a:	6a 00                	push   $0x0
f0103c4c:	50                   	push   %eax
f0103c4d:	e8 ec f5 01 00       	call   f012323e <strtol>
f0103c52:	83 c4 10             	add    $0x10,%esp
f0103c55:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103c58:	eb 1b                	jmp    f0103c75 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103c5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c5d:	83 c0 0c             	add    $0xc,%eax
f0103c60:	8b 00                	mov    (%eax),%eax
f0103c62:	83 ec 04             	sub    $0x4,%esp
f0103c65:	6a 0a                	push   $0xa
f0103c67:	6a 00                	push   $0x0
f0103c69:	50                   	push   %eax
f0103c6a:	e8 cf f5 01 00       	call   f012323e <strtol>
f0103c6f:	83 c4 10             	add    $0x10,%esp
f0103c72:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103c75:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c78:	83 c0 08             	add    $0x8,%eax
f0103c7b:	8b 00                	mov    (%eax),%eax
f0103c7d:	83 ec 04             	sub    $0x4,%esp
f0103c80:	6a 0a                	push   $0xa
f0103c82:	6a 00                	push   $0x0
f0103c84:	50                   	push   %eax
f0103c85:	e8 b4 f5 01 00       	call   f012323e <strtol>
f0103c8a:	83 c4 10             	add    $0x10,%esp
f0103c8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103c90:	eb 62                	jmp    f0103cf4 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103c92:	83 ec 0c             	sub    $0xc,%esp
f0103c95:	6a 02                	push   $0x2
f0103c97:	e8 e2 d9 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0103c9c:	83 c4 10             	add    $0x10,%esp
f0103c9f:	85 c0                	test   %eax,%eax
f0103ca1:	74 1a                	je     f0103cbd <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103ca3:	83 ec 0c             	sub    $0xc,%esp
f0103ca6:	68 08 5d 13 f0       	push   $0xf0135d08
f0103cab:	e8 9d de ff ff       	call   f0101b4d <cprintf>
f0103cb0:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103cb3:	b8 00 00 00 00       	mov    $0x0,%eax
f0103cb8:	e9 36 01 00 00       	jmp    f0103df3 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103cbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cc0:	83 c0 08             	add    $0x8,%eax
f0103cc3:	8b 00                	mov    (%eax),%eax
f0103cc5:	83 ec 04             	sub    $0x4,%esp
f0103cc8:	6a 0a                	push   $0xa
f0103cca:	6a 00                	push   $0x0
f0103ccc:	50                   	push   %eax
f0103ccd:	e8 6c f5 01 00       	call   f012323e <strtol>
f0103cd2:	83 c4 10             	add    $0x10,%esp
f0103cd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103cd8:	eb 1a                	jmp    f0103cf4 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103cda:	83 ec 0c             	sub    $0xc,%esp
f0103cdd:	68 98 5d 13 f0       	push   $0xf0135d98
f0103ce2:	e8 66 de ff ff       	call   f0101b4d <cprintf>
f0103ce7:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103cea:	b8 00 00 00 00       	mov    $0x0,%eax
f0103cef:	e9 ff 00 00 00       	jmp    f0103df3 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103cf4:	83 ec 0c             	sub    $0xc,%esp
f0103cf7:	6a 02                	push   $0x2
f0103cf9:	e8 80 d9 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0103cfe:	83 c4 10             	add    $0x10,%esp
f0103d01:	85 c0                	test   %eax,%eax
f0103d03:	74 23                	je     f0103d28 <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f0103d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103d08:	48                   	dec    %eax
f0103d09:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103d0c:	73 1a                	jae    f0103d28 <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103d0e:	83 ec 0c             	sub    $0xc,%esp
f0103d11:	68 30 5e 13 f0       	push   $0xf0135e30
f0103d16:	e8 32 de ff ff       	call   f0101b4d <cprintf>
f0103d1b:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103d1e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d23:	e9 cb 00 00 00       	jmp    f0103df3 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103d28:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103d2c:	76 19                	jbe    f0103d47 <CreateEnv+0x242>
f0103d2e:	68 88 5e 13 f0       	push   $0xf0135e88
f0103d33:	68 cd 5e 13 f0       	push   $0xf0135ecd
f0103d38:	68 a5 02 00 00       	push   $0x2a5
f0103d3d:	68 c9 59 13 f0       	push   $0xf01359c9
f0103d42:	e8 68 d1 ff ff       	call   f0100eaf <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103d47:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103d4b:	76 19                	jbe    f0103d66 <CreateEnv+0x261>
f0103d4d:	68 88 5e 13 f0       	push   $0xf0135e88
f0103d52:	68 cd 5e 13 f0       	push   $0xf0135ecd
f0103d57:	68 c3 02 00 00       	push   $0x2c3
f0103d5c:	68 c9 59 13 f0       	push   $0xf01359c9
f0103d61:	e8 49 d1 ff ff       	call   f0100eaf <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103d66:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d69:	83 c0 04             	add    $0x4,%eax
f0103d6c:	8b 00                	mov    (%eax),%eax
f0103d6e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103d71:	ff 75 f0             	pushl  -0x10(%ebp)
f0103d74:	ff 75 f4             	pushl  -0xc(%ebp)
f0103d77:	50                   	push   %eax
f0103d78:	e8 14 8d 00 00       	call   f010ca91 <env_create>
f0103d7d:	83 c4 10             	add    $0x10,%esp
f0103d80:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103d83:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103d87:	74 49                	je     f0103dd2 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103d89:	83 ec 08             	sub    $0x8,%esp
f0103d8c:	ff 75 ec             	pushl  -0x14(%ebp)
f0103d8f:	68 e2 5e 13 f0       	push   $0xf0135ee2
f0103d94:	e8 b4 dd ff ff       	call   f0101b4d <cprintf>
f0103d99:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103d9c:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f0103da0:	7c 06                	jl     f0103da8 <CreateEnv+0x2a3>
f0103da2:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103da6:	7e 19                	jle    f0103dc1 <CreateEnv+0x2bc>
f0103da8:	68 f4 5e 13 f0       	push   $0xf0135ef4
f0103dad:	68 cd 5e 13 f0       	push   $0xf0135ecd
f0103db2:	68 c8 02 00 00       	push   $0x2c8
f0103db7:	68 c9 59 13 f0       	push   $0xf01359c9
f0103dbc:	e8 ee d0 ff ff       	call   f0100eaf <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103dc1:	83 ec 08             	sub    $0x8,%esp
f0103dc4:	ff 75 ec             	pushl  -0x14(%ebp)
f0103dc7:	ff 75 e0             	pushl  -0x20(%ebp)
f0103dca:	e8 42 39 00 00       	call   f0107711 <env_set_nice>
f0103dcf:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f0103dd2:	e8 b5 3a 00 00       	call   f010788c <isSchedMethodPRIRR>
f0103dd7:	85 c0                	test   %eax,%eax
f0103dd9:	74 15                	je     f0103df0 <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f0103ddb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103dde:	8b 40 10             	mov    0x10(%eax),%eax
f0103de1:	83 ec 08             	sub    $0x8,%esp
f0103de4:	ff 75 e8             	pushl  -0x18(%ebp)
f0103de7:	50                   	push   %eax
f0103de8:	e8 7b 39 00 00       	call   f0107768 <env_set_priority>
f0103ded:	83 c4 10             	add    $0x10,%esp

	return env;
f0103df0:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0103df3:	c9                   	leave  
f0103df4:	c3                   	ret    

f0103df5 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103dfb:	83 ec 08             	sub    $0x8,%esp
f0103dfe:	ff 75 0c             	pushl  0xc(%ebp)
f0103e01:	ff 75 08             	pushl  0x8(%ebp)
f0103e04:	e8 fc fc ff ff       	call   f0103b05 <CreateEnv>
f0103e09:	83 c4 10             	add    $0x10,%esp
f0103e0c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0103e0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103e13:	75 07                	jne    f0103e1c <command_run_program+0x27>
f0103e15:	b8 00 00 00 00       	mov    $0x0,%eax
f0103e1a:	eb 46                	jmp    f0103e62 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103e1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e1f:	8b 40 10             	mov    0x10(%eax),%eax
f0103e22:	83 ec 08             	sub    $0x8,%esp
f0103e25:	50                   	push   %eax
f0103e26:	68 24 5f 13 f0       	push   $0xf0135f24
f0103e2b:	e8 1d dd ff ff       	call   f0101b4d <cprintf>
f0103e30:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103e33:	83 ec 0c             	sub    $0xc,%esp
f0103e36:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e39:	e8 55 29 00 00       	call   f0106793 <sched_new_env>
f0103e3e:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103e41:	c7 05 d0 52 96 f1 00 	movl   $0x0,0xf19652d0
f0103e48:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e4e:	8b 40 10             	mov    0x10(%eax),%eax
f0103e51:	83 ec 0c             	sub    $0xc,%esp
f0103e54:	50                   	push   %eax
f0103e55:	e8 8f 29 00 00       	call   f01067e9 <sched_run_env>
f0103e5a:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103e5d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103e62:	c9                   	leave  
f0103e63:	c3                   	ret    

f0103e64 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103e64:	55                   	push   %ebp
f0103e65:	89 e5                	mov    %esp,%ebp
f0103e67:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e6d:	83 c0 04             	add    $0x4,%eax
f0103e70:	8b 00                	mov    (%eax),%eax
f0103e72:	83 ec 04             	sub    $0x4,%esp
f0103e75:	6a 0a                	push   $0xa
f0103e77:	6a 00                	push   $0x0
f0103e79:	50                   	push   %eax
f0103e7a:	e8 bf f3 01 00       	call   f012323e <strtol>
f0103e7f:	83 c4 10             	add    $0x10,%esp
f0103e82:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103e85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e88:	83 ec 0c             	sub    $0xc,%esp
f0103e8b:	50                   	push   %eax
f0103e8c:	e8 9e 2c 00 00       	call   f0106b2f <sched_kill_env>
f0103e91:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103e94:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103e99:	c9                   	leave  
f0103e9a:	c3                   	ret    

f0103e9b <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0103e9b:	55                   	push   %ebp
f0103e9c:	89 e5                	mov    %esp,%ebp
f0103e9e:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103ea1:	83 ec 08             	sub    $0x8,%esp
f0103ea4:	ff 75 0c             	pushl  0xc(%ebp)
f0103ea7:	ff 75 08             	pushl  0x8(%ebp)
f0103eaa:	e8 56 fc ff ff       	call   f0103b05 <CreateEnv>
f0103eaf:	83 c4 10             	add    $0x10,%esp
f0103eb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103eb5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103eb9:	75 07                	jne    f0103ec2 <commnad_load_env+0x27>
		return 0 ;
f0103ebb:	b8 00 00 00 00       	mov    $0x0,%eax
f0103ec0:	eb 2a                	jmp    f0103eec <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103ec2:	83 ec 0c             	sub    $0xc,%esp
f0103ec5:	ff 75 f4             	pushl  -0xc(%ebp)
f0103ec8:	e8 c6 28 00 00       	call   f0106793 <sched_new_env>
f0103ecd:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103ed0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103ed3:	8b 40 10             	mov    0x10(%eax),%eax
f0103ed6:	83 ec 08             	sub    $0x8,%esp
f0103ed9:	50                   	push   %eax
f0103eda:	68 24 5f 13 f0       	push   $0xf0135f24
f0103edf:	e8 69 dc ff ff       	call   f0101b4d <cprintf>
f0103ee4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ee7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103eec:	c9                   	leave  
f0103eed:	c3                   	ret    

f0103eee <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0103eee:	55                   	push   %ebp
f0103eef:	89 e5                	mov    %esp,%ebp
f0103ef1:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103ef4:	c7 05 d0 52 96 f1 00 	movl   $0x0,0xf19652d0
f0103efb:	00 00 00 
	sched_run_all();
f0103efe:	e8 fd 31 00 00       	call   f0107100 <sched_run_all>

	return 0 ;
f0103f03:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f08:	c9                   	leave  
f0103f09:	c3                   	ret    

f0103f0a <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103f0a:	55                   	push   %ebp
f0103f0b:	89 e5                	mov    %esp,%ebp
f0103f0d:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0103f10:	e8 ca 2f 00 00       	call   f0106edf <sched_print_all>

	return 0 ;
f0103f15:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f1a:	c9                   	leave  
f0103f1b:	c3                   	ret    

f0103f1c <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103f1c:	55                   	push   %ebp
f0103f1d:	89 e5                	mov    %esp,%ebp
f0103f1f:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f0103f22:	e8 6e 32 00 00       	call   f0107195 <sched_kill_all>

	return 0 ;
f0103f27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f2c:	c9                   	leave  
f0103f2d:	c3                   	ret    

f0103f2e <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0103f2e:	55                   	push   %ebp
f0103f2f:	89 e5                	mov    %esp,%ebp
f0103f31:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103f34:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103f38:	7f 1a                	jg     f0103f54 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103f3a:	83 ec 0c             	sub    $0xc,%esp
f0103f3d:	68 3c 5f 13 f0       	push   $0xf0135f3c
f0103f42:	e8 06 dc ff ff       	call   f0101b4d <cprintf>
f0103f47:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103f4a:	b8 00 00 00 00       	mov    $0x0,%eax
f0103f4f:	e9 83 00 00 00       	jmp    f0103fd7 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103f54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f57:	83 c0 04             	add    $0x4,%eax
f0103f5a:	8b 00                	mov    (%eax),%eax
f0103f5c:	83 ec 04             	sub    $0x4,%esp
f0103f5f:	6a 0a                	push   $0xa
f0103f61:	6a 00                	push   $0x0
f0103f63:	50                   	push   %eax
f0103f64:	e8 d5 f2 01 00       	call   f012323e <strtol>
f0103f69:	83 c4 10             	add    $0x10,%esp
f0103f6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0103f6f:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103f73:	75 20                	jne    f0103f95 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103f75:	83 ec 0c             	sub    $0xc,%esp
f0103f78:	ff 75 f4             	pushl  -0xc(%ebp)
f0103f7b:	e8 55 d6 00 00       	call   f01115d5 <setPageReplacmentAlgorithmLRU>
f0103f80:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103f83:	83 ec 0c             	sub    $0xc,%esp
f0103f86:	68 9c 5f 13 f0       	push   $0xf0135f9c
f0103f8b:	e8 bd db ff ff       	call   f0101b4d <cprintf>
f0103f90:	83 c4 10             	add    $0x10,%esp
f0103f93:	eb 3d                	jmp    f0103fd2 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103f95:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103f99:	75 20                	jne    f0103fbb <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103f9b:	83 ec 0c             	sub    $0xc,%esp
f0103f9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0103fa1:	e8 2f d6 00 00       	call   f01115d5 <setPageReplacmentAlgorithmLRU>
f0103fa6:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103fa9:	83 ec 0c             	sub    $0xc,%esp
f0103fac:	68 e0 5f 13 f0       	push   $0xf0135fe0
f0103fb1:	e8 97 db ff ff       	call   f0101b4d <cprintf>
f0103fb6:	83 c4 10             	add    $0x10,%esp
f0103fb9:	eb 17                	jmp    f0103fd2 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103fbb:	83 ec 0c             	sub    $0xc,%esp
f0103fbe:	68 20 60 13 f0       	push   $0xf0136020
f0103fc3:	e8 85 db ff ff       	call   f0101b4d <cprintf>
f0103fc8:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103fcb:	b8 00 00 00 00       	mov    $0x0,%eax
f0103fd0:	eb 05                	jmp    f0103fd7 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f0103fd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103fd7:	c9                   	leave  
f0103fd8:	c3                   	ret    

f0103fd9 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103fd9:	55                   	push   %ebp
f0103fda:	89 e5                	mov    %esp,%ebp
f0103fdc:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0103fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fe2:	83 c0 04             	add    $0x4,%eax
f0103fe5:	8b 00                	mov    (%eax),%eax
f0103fe7:	83 ec 04             	sub    $0x4,%esp
f0103fea:	6a 0a                	push   $0xa
f0103fec:	6a 00                	push   $0x0
f0103fee:	50                   	push   %eax
f0103fef:	e8 4a f2 01 00       	call   f012323e <strtol>
f0103ff4:	83 c4 10             	add    $0x10,%esp
f0103ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f0103ffa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ffd:	83 c0 08             	add    $0x8,%eax
f0104000:	8b 00                	mov    (%eax),%eax
f0104002:	83 ec 04             	sub    $0x4,%esp
f0104005:	6a 0a                	push   $0xa
f0104007:	6a 00                	push   $0x0
f0104009:	50                   	push   %eax
f010400a:	e8 2f f2 01 00       	call   f012323e <strtol>
f010400f:	83 c4 10             	add    $0x10,%esp
f0104012:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f0104015:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104019:	75 17                	jne    f0104032 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f010401b:	83 ec 0c             	sub    $0xc,%esp
f010401e:	68 74 60 13 f0       	push   $0xf0136074
f0104023:	e8 25 db ff ff       	call   f0101b4d <cprintf>
f0104028:	83 c4 10             	add    $0x10,%esp
		return 0;
f010402b:	b8 00 00 00 00       	mov    $0x0,%eax
f0104030:	eb 4b                	jmp    f010407d <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0104032:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f0104036:	74 22                	je     f010405a <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f0104038:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f010403c:	75 05                	jne    f0104043 <command_set_page_rep_nthCLOCK+0x6a>
f010403e:	f7 5d f4             	negl   -0xc(%ebp)
f0104041:	eb 17                	jmp    f010405a <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0104043:	83 ec 0c             	sub    $0xc,%esp
f0104046:	68 a4 60 13 f0       	push   $0xf01360a4
f010404b:	e8 fd da ff ff       	call   f0101b4d <cprintf>
f0104050:	83 c4 10             	add    $0x10,%esp
		return 0;
f0104053:	b8 00 00 00 00       	mov    $0x0,%eax
f0104058:	eb 23                	jmp    f010407d <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f010405a:	83 ec 0c             	sub    $0xc,%esp
f010405d:	ff 75 f4             	pushl  -0xc(%ebp)
f0104060:	e8 e3 d5 00 00       	call   f0111648 <setPageReplacmentAlgorithmNchanceCLOCK>
f0104065:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0104068:	83 ec 0c             	sub    $0xc,%esp
f010406b:	68 e0 60 13 f0       	push   $0xf01360e0
f0104070:	e8 d8 da ff ff       	call   f0101b4d <cprintf>
f0104075:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104078:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010407d:	c9                   	leave  
f010407e:	c3                   	ret    

f010407f <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010407f:	55                   	push   %ebp
f0104080:	89 e5                	mov    %esp,%ebp
f0104082:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0104085:	e8 7e d5 00 00       	call   f0111608 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f010408a:	83 ec 0c             	sub    $0xc,%esp
f010408d:	68 14 61 13 f0       	push   $0xf0136114
f0104092:	e8 b6 da ff ff       	call   f0101b4d <cprintf>
f0104097:	83 c4 10             	add    $0x10,%esp
	return 0;
f010409a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010409f:	c9                   	leave  
f01040a0:	c3                   	ret    

f01040a1 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f01040a1:	55                   	push   %ebp
f01040a2:	89 e5                	mov    %esp,%ebp
f01040a4:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f01040a7:	e8 6c d5 00 00       	call   f0111618 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f01040ac:	83 ec 0c             	sub    $0xc,%esp
f01040af:	68 40 61 13 f0       	push   $0xf0136140
f01040b4:	e8 94 da ff ff       	call   f0101b4d <cprintf>
f01040b9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01040bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040c1:	c9                   	leave  
f01040c2:	c3                   	ret    

f01040c3 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01040c3:	55                   	push   %ebp
f01040c4:	89 e5                	mov    %esp,%ebp
f01040c6:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01040c9:	e8 5a d5 00 00       	call   f0111628 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01040ce:	83 ec 0c             	sub    $0xc,%esp
f01040d1:	68 68 61 13 f0       	push   $0xf0136168
f01040d6:	e8 72 da ff ff       	call   f0101b4d <cprintf>
f01040db:	83 c4 10             	add    $0x10,%esp
	return 0;
f01040de:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040e3:	c9                   	leave  
f01040e4:	c3                   	ret    

f01040e5 <command_set_page_rep_OPTIMAL>:

int command_set_page_rep_OPTIMAL(int number_of_arguments, char **arguments)
{
f01040e5:	55                   	push   %ebp
f01040e6:	89 e5                	mov    %esp,%ebp
f01040e8:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmOPTIMAL();
f01040eb:	e8 7e d5 00 00       	call   f011166e <setPageReplacmentAlgorithmOPTIMAL>
	cprintf("Page replacement algorithm is now OPTIMAL\n");
f01040f0:	83 ec 0c             	sub    $0xc,%esp
f01040f3:	68 9c 61 13 f0       	push   $0xf013619c
f01040f8:	e8 50 da ff ff       	call   f0101b4d <cprintf>
f01040fd:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104100:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104105:	c9                   	leave  
f0104106:	c3                   	ret    

f0104107 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f0104107:	55                   	push   %ebp
f0104108:	89 e5                	mov    %esp,%ebp
f010410a:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f010410d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104110:	83 c0 04             	add    $0x4,%eax
f0104113:	8b 00                	mov    (%eax),%eax
f0104115:	83 ec 04             	sub    $0x4,%esp
f0104118:	6a 0a                	push   $0xa
f010411a:	6a 00                	push   $0x0
f010411c:	50                   	push   %eax
f010411d:	e8 1c f1 01 00       	call   f012323e <strtol>
f0104122:	83 c4 10             	add    $0x10,%esp
f0104125:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f0104128:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010412c:	83 ec 0c             	sub    $0xc,%esp
f010412f:	50                   	push   %eax
f0104130:	e8 c9 39 00 00       	call   f0107afe <sched_init_RR>
f0104135:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0104138:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f010413d:	8a 00                	mov    (%eax),%al
f010413f:	0f b6 c0             	movzbl %al,%eax
f0104142:	83 ec 08             	sub    $0x8,%esp
f0104145:	50                   	push   %eax
f0104146:	68 c8 61 13 f0       	push   $0xf01361c8
f010414b:	e8 fd d9 ff ff       	call   f0101b4d <cprintf>
f0104150:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104153:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104158:	c9                   	leave  
f0104159:	c3                   	ret    

f010415a <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f010415a:	55                   	push   %ebp
f010415b:	89 e5                	mov    %esp,%ebp
f010415d:	53                   	push   %ebx
f010415e:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0104161:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104164:	83 c0 04             	add    $0x4,%eax
f0104167:	8b 00                	mov    (%eax),%eax
f0104169:	83 ec 04             	sub    $0x4,%esp
f010416c:	6a 0a                	push   $0xa
f010416e:	6a 00                	push   $0x0
f0104170:	50                   	push   %eax
f0104171:	e8 c8 f0 01 00       	call   f012323e <strtol>
f0104176:	83 c4 10             	add    $0x10,%esp
f0104179:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010417c:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0104183:	eb 2e                	jmp    f01041b3 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0104185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104188:	8d 58 fe             	lea    -0x2(%eax),%ebx
f010418b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010418e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104195:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104198:	01 d0                	add    %edx,%eax
f010419a:	8b 00                	mov    (%eax),%eax
f010419c:	83 ec 04             	sub    $0x4,%esp
f010419f:	6a 0a                	push   $0xa
f01041a1:	6a 00                	push   $0x0
f01041a3:	50                   	push   %eax
f01041a4:	e8 95 f0 01 00       	call   f012323e <strtol>
f01041a9:	83 c4 10             	add    $0x10,%esp
f01041ac:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01041b0:	ff 45 f4             	incl   -0xc(%ebp)
f01041b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01041b6:	3b 45 08             	cmp    0x8(%ebp),%eax
f01041b9:	7c ca                	jl     f0104185 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f01041bb:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01041bf:	83 ec 08             	sub    $0x8,%esp
f01041c2:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f01041c5:	52                   	push   %edx
f01041c6:	50                   	push   %eax
f01041c7:	e8 e0 39 00 00       	call   f0107bac <sched_init_MLFQ>
f01041cc:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f01041cf:	83 ec 0c             	sub    $0xc,%esp
f01041d2:	68 00 62 13 f0       	push   $0xf0136200
f01041d7:	e8 71 d9 ff ff       	call   f0101b4d <cprintf>
f01041dc:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01041df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01041e6:	eb 24                	jmp    f010420c <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01041e8:	8b 15 84 51 96 f1    	mov    0xf1965184,%edx
f01041ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041f1:	01 d0                	add    %edx,%eax
f01041f3:	8a 00                	mov    (%eax),%al
f01041f5:	0f b6 c0             	movzbl %al,%eax
f01041f8:	83 ec 08             	sub    $0x8,%esp
f01041fb:	50                   	push   %eax
f01041fc:	68 2d 62 13 f0       	push   $0xf013622d
f0104201:	e8 47 d9 ff ff       	call   f0101b4d <cprintf>
f0104206:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f0104209:	ff 45 f0             	incl   -0x10(%ebp)
f010420c:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0104211:	0f b6 c0             	movzbl %al,%eax
f0104214:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0104217:	7f cf                	jg     f01041e8 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f0104219:	83 ec 0c             	sub    $0xc,%esp
f010421c:	68 33 62 13 f0       	push   $0xf0136233
f0104221:	e8 27 d9 ff ff       	call   f0101b4d <cprintf>
f0104226:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104229:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010422e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104231:	c9                   	leave  
f0104232:	c3                   	ret    

f0104233 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0104233:	55                   	push   %ebp
f0104234:	89 e5                	mov    %esp,%ebp
f0104236:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0104239:	8b 45 0c             	mov    0xc(%ebp),%eax
f010423c:	83 c0 04             	add    $0x4,%eax
f010423f:	8b 00                	mov    (%eax),%eax
f0104241:	83 ec 04             	sub    $0x4,%esp
f0104244:	6a 0a                	push   $0xa
f0104246:	6a 00                	push   $0x0
f0104248:	50                   	push   %eax
f0104249:	e8 f0 ef 01 00       	call   f012323e <strtol>
f010424e:	83 c4 10             	add    $0x10,%esp
f0104251:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0104254:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104257:	83 c0 08             	add    $0x8,%eax
f010425a:	8b 00                	mov    (%eax),%eax
f010425c:	83 ec 04             	sub    $0x4,%esp
f010425f:	6a 0a                	push   $0xa
f0104261:	6a 00                	push   $0x0
f0104263:	50                   	push   %eax
f0104264:	e8 d5 ef 01 00       	call   f012323e <strtol>
f0104269:	83 c4 10             	add    $0x10,%esp
f010426c:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f010426f:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104273:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104277:	83 ec 08             	sub    $0x8,%esp
f010427a:	52                   	push   %edx
f010427b:	50                   	push   %eax
f010427c:	e8 4e 39 00 00       	call   f0107bcf <sched_init_BSD>
f0104281:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0104284:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104288:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010428c:	83 ec 04             	sub    $0x4,%esp
f010428f:	52                   	push   %edx
f0104290:	50                   	push   %eax
f0104291:	68 38 62 13 f0       	push   $0xf0136238
f0104296:	e8 b2 d8 ff ff       	call   f0101b4d <cprintf>
f010429b:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010429e:	83 ec 0c             	sub    $0xc,%esp
f01042a1:	68 33 62 13 f0       	push   $0xf0136233
f01042a6:	e8 a2 d8 ff ff       	call   f0101b4d <cprintf>
f01042ab:	83 c4 10             	add    $0x10,%esp
	return 0;
f01042ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01042b3:	c9                   	leave  
f01042b4:	c3                   	ret    

f01042b5 <command_sch_PRIRR>:

int command_sch_PRIRR(int number_of_arguments, char **arguments)
{
f01042b5:	55                   	push   %ebp
f01042b6:	89 e5                	mov    %esp,%ebp
f01042b8:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01042bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042be:	83 c0 04             	add    $0x4,%eax
f01042c1:	8b 00                	mov    (%eax),%eax
f01042c3:	83 ec 04             	sub    $0x4,%esp
f01042c6:	6a 0a                	push   $0xa
f01042c8:	6a 00                	push   $0x0
f01042ca:	50                   	push   %eax
f01042cb:	e8 6e ef 01 00       	call   f012323e <strtol>
f01042d0:	83 c4 10             	add    $0x10,%esp
f01042d3:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01042d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042d9:	83 c0 08             	add    $0x8,%eax
f01042dc:	8b 00                	mov    (%eax),%eax
f01042de:	83 ec 04             	sub    $0x4,%esp
f01042e1:	6a 0a                	push   $0xa
f01042e3:	6a 00                	push   $0x0
f01042e5:	50                   	push   %eax
f01042e6:	e8 53 ef 01 00       	call   f012323e <strtol>
f01042eb:	83 c4 10             	add    $0x10,%esp
f01042ee:	88 45 f6             	mov    %al,-0xa(%ebp)
	uint32 starvThresh = strtol(arguments[3], NULL, 10);
f01042f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042f4:	83 c0 0c             	add    $0xc,%eax
f01042f7:	8b 00                	mov    (%eax),%eax
f01042f9:	83 ec 04             	sub    $0x4,%esp
f01042fc:	6a 0a                	push   $0xa
f01042fe:	6a 00                	push   $0x0
f0104300:	50                   	push   %eax
f0104301:	e8 38 ef 01 00       	call   f012323e <strtol>
f0104306:	83 c4 10             	add    $0x10,%esp
f0104309:	89 45 f0             	mov    %eax,-0x10(%ebp)

	sched_init_PRIRR(numOfLevels, quantum, starvThresh);
f010430c:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104310:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104314:	83 ec 04             	sub    $0x4,%esp
f0104317:	ff 75 f0             	pushl  -0x10(%ebp)
f010431a:	52                   	push   %edx
f010431b:	50                   	push   %eax
f010431c:	e8 d7 38 00 00       	call   f0107bf8 <sched_init_PRIRR>
f0104321:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to PRIORITY RR with %d priorities, quantum = %d and starvation thresh %d\n", numOfLevels, quantum, starvThresh);
f0104324:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104328:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010432c:	ff 75 f0             	pushl  -0x10(%ebp)
f010432f:	52                   	push   %edx
f0104330:	50                   	push   %eax
f0104331:	68 74 62 13 f0       	push   $0xf0136274
f0104336:	e8 12 d8 ff ff       	call   f0101b4d <cprintf>
f010433b:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010433e:	83 ec 0c             	sub    $0xc,%esp
f0104341:	68 33 62 13 f0       	push   $0xf0136233
f0104346:	e8 02 d8 ff ff       	call   f0101b4d <cprintf>
f010434b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010434e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104353:	c9                   	leave  
f0104354:	c3                   	ret    

f0104355 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0104355:	55                   	push   %ebp
f0104356:	89 e5                	mov    %esp,%ebp
f0104358:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f010435b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010435e:	83 c0 04             	add    $0x4,%eax
f0104361:	8b 00                	mov    (%eax),%eax
f0104363:	83 ec 04             	sub    $0x4,%esp
f0104366:	6a 0a                	push   $0xa
f0104368:	6a 00                	push   $0x0
f010436a:	50                   	push   %eax
f010436b:	e8 ce ee 01 00       	call   f012323e <strtol>
f0104370:	83 c4 10             	add    $0x10,%esp
f0104373:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f0104376:	83 ec 0c             	sub    $0xc,%esp
f0104379:	ff 75 f4             	pushl  -0xc(%ebp)
f010437c:	e8 bd 34 00 00       	call   f010783e <sched_set_starv_thresh>
f0104381:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104384:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104389:	c9                   	leave  
f010438a:	c3                   	ret    

f010438b <command_set_priority>:
//*********************************************************************************//

int command_set_priority(int number_of_arguments, char **arguments)
{
f010438b:	55                   	push   %ebp
f010438c:	89 e5                	mov    %esp,%ebp
f010438e:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0104391:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104394:	83 c0 04             	add    $0x4,%eax
f0104397:	8b 00                	mov    (%eax),%eax
f0104399:	83 ec 04             	sub    $0x4,%esp
f010439c:	6a 0a                	push   $0xa
f010439e:	6a 00                	push   $0x0
f01043a0:	50                   	push   %eax
f01043a1:	e8 98 ee 01 00       	call   f012323e <strtol>
f01043a6:	83 c4 10             	add    $0x10,%esp
f01043a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01043ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043af:	83 c0 08             	add    $0x8,%eax
f01043b2:	8b 00                	mov    (%eax),%eax
f01043b4:	83 ec 04             	sub    $0x4,%esp
f01043b7:	6a 0a                	push   $0xa
f01043b9:	6a 00                	push   $0x0
f01043bb:	50                   	push   %eax
f01043bc:	e8 7d ee 01 00       	call   f012323e <strtol>
f01043c1:	83 c4 10             	add    $0x10,%esp
f01043c4:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01043c7:	83 ec 08             	sub    $0x8,%esp
f01043ca:	ff 75 f0             	pushl  -0x10(%ebp)
f01043cd:	ff 75 f4             	pushl  -0xc(%ebp)
f01043d0:	e8 93 33 00 00       	call   f0107768 <env_set_priority>
f01043d5:	83 c4 10             	add    $0x10,%esp

	return 0;
f01043d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01043dd:	c9                   	leave  
f01043de:	c3                   	ret    

f01043df <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01043df:	55                   	push   %ebp
f01043e0:	89 e5                	mov    %esp,%ebp
f01043e2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01043e5:	e8 7c 34 00 00       	call   f0107866 <isSchedMethodMLFQ>
f01043ea:	85 c0                	test   %eax,%eax
f01043ec:	74 5f                	je     f010444d <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01043ee:	83 ec 0c             	sub    $0xc,%esp
f01043f1:	68 d4 62 13 f0       	push   $0xf01362d4
f01043f6:	e8 52 d7 ff ff       	call   f0101b4d <cprintf>
f01043fb:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01043fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104405:	eb 24                	jmp    f010442b <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f0104407:	8b 15 84 51 96 f1    	mov    0xf1965184,%edx
f010440d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104410:	01 d0                	add    %edx,%eax
f0104412:	8a 00                	mov    (%eax),%al
f0104414:	0f b6 c0             	movzbl %al,%eax
f0104417:	83 ec 08             	sub    $0x8,%esp
f010441a:	50                   	push   %eax
f010441b:	68 2d 62 13 f0       	push   $0xf013622d
f0104420:	e8 28 d7 ff ff       	call   f0101b4d <cprintf>
f0104425:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0104428:	ff 45 f4             	incl   -0xc(%ebp)
f010442b:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0104430:	0f b6 c0             	movzbl %al,%eax
f0104433:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0104436:	7f cf                	jg     f0104407 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0104438:	83 ec 0c             	sub    $0xc,%esp
f010443b:	68 33 62 13 f0       	push   $0xf0136233
f0104440:	e8 08 d7 ff ff       	call   f0101b4d <cprintf>
f0104445:	83 c4 10             	add    $0x10,%esp
f0104448:	e9 94 00 00 00       	jmp    f01044e1 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f010444d:	e8 02 34 00 00       	call   f0107854 <isSchedMethodRR>
f0104452:	85 c0                	test   %eax,%eax
f0104454:	74 1d                	je     f0104473 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0104456:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f010445b:	8a 00                	mov    (%eax),%al
f010445d:	0f b6 c0             	movzbl %al,%eax
f0104460:	83 ec 08             	sub    $0x8,%esp
f0104463:	50                   	push   %eax
f0104464:	68 08 63 13 f0       	push   $0xf0136308
f0104469:	e8 df d6 ff ff       	call   f0101b4d <cprintf>
f010446e:	83 c4 10             	add    $0x10,%esp
f0104471:	eb 6e                	jmp    f01044e1 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0104473:	e8 01 34 00 00       	call   f0107879 <isSchedMethodBSD>
f0104478:	85 c0                	test   %eax,%eax
f010447a:	74 26                	je     f01044a2 <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f010447c:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0104481:	8a 00                	mov    (%eax),%al
f0104483:	0f b6 d0             	movzbl %al,%edx
f0104486:	a0 00 54 96 f1       	mov    0xf1965400,%al
f010448b:	0f b6 c0             	movzbl %al,%eax
f010448e:	83 ec 04             	sub    $0x4,%esp
f0104491:	52                   	push   %edx
f0104492:	50                   	push   %eax
f0104493:	68 38 62 13 f0       	push   $0xf0136238
f0104498:	e8 b0 d6 ff ff       	call   f0101b4d <cprintf>
f010449d:	83 c4 10             	add    $0x10,%esp
f01044a0:	eb 3f                	jmp    f01044e1 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01044a2:	e8 e5 33 00 00       	call   f010788c <isSchedMethodPRIRR>
f01044a7:	85 c0                	test   %eax,%eax
f01044a9:	74 26                	je     f01044d1 <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01044ab:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f01044b0:	8a 00                	mov    (%eax),%al
f01044b2:	0f b6 d0             	movzbl %al,%edx
f01044b5:	a0 00 54 96 f1       	mov    0xf1965400,%al
f01044ba:	0f b6 c0             	movzbl %al,%eax
f01044bd:	83 ec 04             	sub    $0x4,%esp
f01044c0:	52                   	push   %edx
f01044c1:	50                   	push   %eax
f01044c2:	68 44 63 13 f0       	push   $0xf0136344
f01044c7:	e8 81 d6 ff ff       	call   f0101b4d <cprintf>
f01044cc:	83 c4 10             	add    $0x10,%esp
f01044cf:	eb 10                	jmp    f01044e1 <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01044d1:	83 ec 0c             	sub    $0xc,%esp
f01044d4:	68 8c 63 13 f0       	push   $0xf013638c
f01044d9:	e8 6f d6 ff ff       	call   f0101b4d <cprintf>
f01044de:	83 c4 10             	add    $0x10,%esp

	return 0;
f01044e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01044e6:	c9                   	leave  
f01044e7:	c3                   	ret    

f01044e8 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01044e8:	55                   	push   %ebp
f01044e9:	89 e5                	mov    %esp,%ebp
f01044eb:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01044ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044f1:	83 c0 04             	add    $0x4,%eax
f01044f4:	8b 00                	mov    (%eax),%eax
f01044f6:	83 ec 04             	sub    $0x4,%esp
f01044f9:	6a 0a                	push   $0xa
f01044fb:	6a 00                	push   $0x0
f01044fd:	50                   	push   %eax
f01044fe:	e8 3b ed 01 00       	call   f012323e <strtol>
f0104503:	83 c4 10             	add    $0x10,%esp
f0104506:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0104509:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010450c:	0f b6 c0             	movzbl %al,%eax
f010450f:	83 ec 0c             	sub    $0xc,%esp
f0104512:	50                   	push   %eax
f0104513:	e8 c3 d9 01 00       	call   f0121edb <chksch>
f0104518:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f010451b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010451f:	75 12                	jne    f0104533 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f0104521:	83 ec 0c             	sub    $0xc,%esp
f0104524:	68 b4 63 13 f0       	push   $0xf01363b4
f0104529:	e8 1f d6 ff ff       	call   f0101b4d <cprintf>
f010452e:	83 c4 10             	add    $0x10,%esp
f0104531:	eb 16                	jmp    f0104549 <command_sch_test+0x61>
	else if (status == 1)
f0104533:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0104537:	75 10                	jne    f0104549 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0104539:	83 ec 0c             	sub    $0xc,%esp
f010453c:	68 dc 63 13 f0       	push   $0xf01363dc
f0104541:	e8 07 d6 ff ff       	call   f0101b4d <cprintf>
f0104546:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104549:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010454e:	c9                   	leave  
f010454f:	c3                   	ret    

f0104550 <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f0104550:	55                   	push   %ebp
f0104551:	89 e5                	mov    %esp,%ebp
f0104553:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0104556:	e8 39 d1 00 00       	call   f0111694 <isPageReplacmentAlgorithmCLOCK>
f010455b:	85 c0                	test   %eax,%eax
f010455d:	74 15                	je     f0104574 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010455f:	83 ec 0c             	sub    $0xc,%esp
f0104562:	68 00 64 13 f0       	push   $0xf0136400
f0104567:	e8 e1 d5 ff ff       	call   f0101b4d <cprintf>
f010456c:	83 c4 10             	add    $0x10,%esp
f010456f:	e9 ff 00 00 00       	jmp    f0104673 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0104574:	83 ec 0c             	sub    $0xc,%esp
f0104577:	6a 01                	push   $0x1
f0104579:	e8 00 d1 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010457e:	83 c4 10             	add    $0x10,%esp
f0104581:	85 c0                	test   %eax,%eax
f0104583:	74 15                	je     f010459a <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0104585:	83 ec 0c             	sub    $0xc,%esp
f0104588:	68 28 64 13 f0       	push   $0xf0136428
f010458d:	e8 bb d5 ff ff       	call   f0101b4d <cprintf>
f0104592:	83 c4 10             	add    $0x10,%esp
f0104595:	e9 d9 00 00 00       	jmp    f0104673 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010459a:	83 ec 0c             	sub    $0xc,%esp
f010459d:	6a 02                	push   $0x2
f010459f:	e8 da d0 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f01045a4:	83 c4 10             	add    $0x10,%esp
f01045a7:	85 c0                	test   %eax,%eax
f01045a9:	74 15                	je     f01045c0 <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01045ab:	83 ec 0c             	sub    $0xc,%esp
f01045ae:	68 68 64 13 f0       	push   $0xf0136468
f01045b3:	e8 95 d5 ff ff       	call   f0101b4d <cprintf>
f01045b8:	83 c4 10             	add    $0x10,%esp
f01045bb:	e9 b3 00 00 00       	jmp    f0104673 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmFIFO())
f01045c0:	e8 ea d0 00 00       	call   f01116af <isPageReplacmentAlgorithmFIFO>
f01045c5:	85 c0                	test   %eax,%eax
f01045c7:	74 15                	je     f01045de <command_print_page_rep+0x8e>
		cprintf("Page replacement algorithm is FIFO\n");
f01045c9:	83 ec 0c             	sub    $0xc,%esp
f01045cc:	68 a4 64 13 f0       	push   $0xf01364a4
f01045d1:	e8 77 d5 ff ff       	call   f0101b4d <cprintf>
f01045d6:	83 c4 10             	add    $0x10,%esp
f01045d9:	e9 95 00 00 00       	jmp    f0104673 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01045de:	e8 e7 d0 00 00       	call   f01116ca <isPageReplacmentAlgorithmModifiedCLOCK>
f01045e3:	85 c0                	test   %eax,%eax
f01045e5:	74 12                	je     f01045f9 <command_print_page_rep+0xa9>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01045e7:	83 ec 0c             	sub    $0xc,%esp
f01045ea:	68 c8 64 13 f0       	push   $0xf01364c8
f01045ef:	e8 59 d5 ff ff       	call   f0101b4d <cprintf>
f01045f4:	83 c4 10             	add    $0x10,%esp
f01045f7:	eb 7a                	jmp    f0104673 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmOPTIMAL())
f01045f9:	e8 1d d1 00 00       	call   f011171b <isPageReplacmentAlgorithmOPTIMAL>
f01045fe:	85 c0                	test   %eax,%eax
f0104600:	74 12                	je     f0104614 <command_print_page_rep+0xc4>
		cprintf("Page replacement algorithm is OPTIMAL\n");
f0104602:	83 ec 0c             	sub    $0xc,%esp
f0104605:	68 f8 64 13 f0       	push   $0xf01364f8
f010460a:	e8 3e d5 ff ff       	call   f0101b4d <cprintf>
f010460f:	83 c4 10             	add    $0x10,%esp
f0104612:	eb 5f                	jmp    f0104673 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0104614:	e8 e7 d0 00 00       	call   f0111700 <isPageReplacmentAlgorithmNchanceCLOCK>
f0104619:	85 c0                	test   %eax,%eax
f010461b:	74 46                	je     f0104663 <command_print_page_rep+0x113>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f010461d:	83 ec 0c             	sub    $0xc,%esp
f0104620:	68 20 65 13 f0       	push   $0xf0136520
f0104625:	e8 23 d5 ff ff       	call   f0101b4d <cprintf>
f010462a:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f010462d:	a1 54 ce 94 f1       	mov    0xf194ce54,%eax
f0104632:	85 c0                	test   %eax,%eax
f0104634:	7e 12                	jle    f0104648 <command_print_page_rep+0xf8>
f0104636:	83 ec 0c             	sub    $0xc,%esp
f0104639:	68 50 65 13 f0       	push   $0xf0136550
f010463e:	e8 0a d5 ff ff       	call   f0101b4d <cprintf>
f0104643:	83 c4 10             	add    $0x10,%esp
f0104646:	eb 2b                	jmp    f0104673 <command_print_page_rep+0x123>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f0104648:	a1 54 ce 94 f1       	mov    0xf194ce54,%eax
f010464d:	85 c0                	test   %eax,%eax
f010464f:	79 22                	jns    f0104673 <command_print_page_rep+0x123>
f0104651:	83 ec 0c             	sub    $0xc,%esp
f0104654:	68 5e 65 13 f0       	push   $0xf013655e
f0104659:	e8 ef d4 ff ff       	call   f0101b4d <cprintf>
f010465e:	83 c4 10             	add    $0x10,%esp
f0104661:	eb 10                	jmp    f0104673 <command_print_page_rep+0x123>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0104663:	83 ec 0c             	sub    $0xc,%esp
f0104666:	68 70 65 13 f0       	push   $0xf0136570
f010466b:	e8 dd d4 ff ff       	call   f0101b4d <cprintf>
f0104670:	83 c4 10             	add    $0x10,%esp

	return 0;
f0104673:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104678:	c9                   	leave  
f0104679:	c3                   	ret    

f010467a <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f010467a:	55                   	push   %ebp
f010467b:	89 e5                	mov    %esp,%ebp
f010467d:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_FIRSTFIT);
f0104680:	6a 01                	push   $0x1
f0104682:	e8 be e7 ff ff       	call   f0102e45 <set_uheap_strategy>
f0104687:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f010468a:	83 ec 0c             	sub    $0xc,%esp
f010468d:	68 9c 65 13 f0       	push   $0xf013659c
f0104692:	e8 b6 d4 ff ff       	call   f0101b4d <cprintf>
f0104697:	83 c4 10             	add    $0x10,%esp
	return 0;
f010469a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010469f:	c9                   	leave  
f01046a0:	c3                   	ret    

f01046a1 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01046a1:	55                   	push   %ebp
f01046a2:	89 e5                	mov    %esp,%ebp
f01046a4:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_BESTFIT);
f01046a7:	6a 02                	push   $0x2
f01046a9:	e8 97 e7 ff ff       	call   f0102e45 <set_uheap_strategy>
f01046ae:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01046b1:	83 ec 0c             	sub    $0xc,%esp
f01046b4:	68 cc 65 13 f0       	push   $0xf01365cc
f01046b9:	e8 8f d4 ff ff       	call   f0101b4d <cprintf>
f01046be:	83 c4 10             	add    $0x10,%esp
	return 0;
f01046c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046c6:	c9                   	leave  
f01046c7:	c3                   	ret    

f01046c8 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01046c8:	55                   	push   %ebp
f01046c9:	89 e5                	mov    %esp,%ebp
f01046cb:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_NEXTFIT);
f01046ce:	6a 03                	push   $0x3
f01046d0:	e8 70 e7 ff ff       	call   f0102e45 <set_uheap_strategy>
f01046d5:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01046d8:	83 ec 0c             	sub    $0xc,%esp
f01046db:	68 fc 65 13 f0       	push   $0xf01365fc
f01046e0:	e8 68 d4 ff ff       	call   f0101b4d <cprintf>
f01046e5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01046e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046ed:	c9                   	leave  
f01046ee:	c3                   	ret    

f01046ef <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01046ef:	55                   	push   %ebp
f01046f0:	89 e5                	mov    %esp,%ebp
f01046f2:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_WORSTFIT);
f01046f5:	6a 04                	push   $0x4
f01046f7:	e8 49 e7 ff ff       	call   f0102e45 <set_uheap_strategy>
f01046fc:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01046ff:	83 ec 0c             	sub    $0xc,%esp
f0104702:	68 2c 66 13 f0       	push   $0xf013662c
f0104707:	e8 41 d4 ff ff       	call   f0101b4d <cprintf>
f010470c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010470f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104714:	c9                   	leave  
f0104715:	c3                   	ret    

f0104716 <command_set_uheap_plac_CUSTOMFIT>:
int command_set_uheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f0104716:	55                   	push   %ebp
f0104717:	89 e5                	mov    %esp,%ebp
f0104719:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f010471c:	6a 05                	push   $0x5
f010471e:	e8 22 e7 ff ff       	call   f0102e45 <set_uheap_strategy>
f0104723:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now CUSTOM FIT\n");
f0104726:	83 ec 0c             	sub    $0xc,%esp
f0104729:	68 5c 66 13 f0       	push   $0xf013665c
f010472e:	e8 1a d4 ff ff       	call   f0101b4d <cprintf>
f0104733:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104736:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010473b:	c9                   	leave  
f010473c:	c3                   	ret    

f010473d <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f010473d:	55                   	push   %ebp
f010473e:	89 e5                	mov    %esp,%ebp
f0104740:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_uheap_strategy();
f0104743:	e8 0b e7 ff ff       	call   f0102e53 <get_uheap_strategy>
f0104748:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f010474b:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f010474f:	77 69                	ja     f01047ba <command_print_uheap_plac+0x7d>
f0104751:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104754:	c1 e0 02             	shl    $0x2,%eax
f0104757:	05 94 67 13 f0       	add    $0xf0136794,%eax
f010475c:	8b 00                	mov    (%eax),%eax
f010475e:	ff e0                	jmp    *%eax
	{
	case UHP_PLACE_FIRSTFIT:
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0104760:	83 ec 0c             	sub    $0xc,%esp
f0104763:	68 8c 66 13 f0       	push   $0xf013668c
f0104768:	e8 e0 d3 ff ff       	call   f0101b4d <cprintf>
f010476d:	83 c4 10             	add    $0x10,%esp
		break;
f0104770:	eb 58                	jmp    f01047ca <command_print_uheap_plac+0x8d>
	case UHP_PLACE_NEXTFIT:
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0104772:	83 ec 0c             	sub    $0xc,%esp
f0104775:	68 b8 66 13 f0       	push   $0xf01366b8
f010477a:	e8 ce d3 ff ff       	call   f0101b4d <cprintf>
f010477f:	83 c4 10             	add    $0x10,%esp
		break;
f0104782:	eb 46                	jmp    f01047ca <command_print_uheap_plac+0x8d>
	case UHP_PLACE_BESTFIT:
		cprintf("User Heap placement strategy is BEST FIT\n");
f0104784:	83 ec 0c             	sub    $0xc,%esp
f0104787:	68 e4 66 13 f0       	push   $0xf01366e4
f010478c:	e8 bc d3 ff ff       	call   f0101b4d <cprintf>
f0104791:	83 c4 10             	add    $0x10,%esp
		break;
f0104794:	eb 34                	jmp    f01047ca <command_print_uheap_plac+0x8d>
	case UHP_PLACE_WORSTFIT:
		cprintf("User Heap placement strategy is WORST FIT\n");
f0104796:	83 ec 0c             	sub    $0xc,%esp
f0104799:	68 10 67 13 f0       	push   $0xf0136710
f010479e:	e8 aa d3 ff ff       	call   f0101b4d <cprintf>
f01047a3:	83 c4 10             	add    $0x10,%esp
		break;
f01047a6:	eb 22                	jmp    f01047ca <command_print_uheap_plac+0x8d>
	case UHP_PLACE_CUSTOMFIT:
		cprintf("User Heap placement strategy is CUSTOM FIT\n");
f01047a8:	83 ec 0c             	sub    $0xc,%esp
f01047ab:	68 3c 67 13 f0       	push   $0xf013673c
f01047b0:	e8 98 d3 ff ff       	call   f0101b4d <cprintf>
f01047b5:	83 c4 10             	add    $0x10,%esp
		break;
f01047b8:	eb 10                	jmp    f01047ca <command_print_uheap_plac+0x8d>
	default:
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01047ba:	83 ec 0c             	sub    $0xc,%esp
f01047bd:	68 68 67 13 f0       	push   $0xf0136768
f01047c2:	e8 86 d3 ff ff       	call   f0101b4d <cprintf>
f01047c7:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01047ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047cf:	c9                   	leave  
f01047d0:	c3                   	ret    

f01047d1 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f01047d1:	55                   	push   %ebp
f01047d2:	89 e5                	mov    %esp,%ebp
f01047d4:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CONTALLOC);
f01047d7:	6a 00                	push   $0x0
f01047d9:	e8 4f e6 ff ff       	call   f0102e2d <set_kheap_strategy>
f01047de:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01047e1:	83 ec 0c             	sub    $0xc,%esp
f01047e4:	68 ac 67 13 f0       	push   $0xf01367ac
f01047e9:	e8 5f d3 ff ff       	call   f0101b4d <cprintf>
f01047ee:	83 c4 10             	add    $0x10,%esp
	return 0;
f01047f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047f6:	c9                   	leave  
f01047f7:	c3                   	ret    

f01047f8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01047f8:	55                   	push   %ebp
f01047f9:	89 e5                	mov    %esp,%ebp
f01047fb:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f01047fe:	6a 01                	push   $0x1
f0104800:	e8 28 e6 ff ff       	call   f0102e2d <set_kheap_strategy>
f0104805:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0104808:	83 ec 0c             	sub    $0xc,%esp
f010480b:	68 ac 67 13 f0       	push   $0xf01367ac
f0104810:	e8 38 d3 ff ff       	call   f0101b4d <cprintf>
f0104815:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104818:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010481d:	c9                   	leave  
f010481e:	c3                   	ret    

f010481f <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f010481f:	55                   	push   %ebp
f0104820:	89 e5                	mov    %esp,%ebp
f0104822:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_BESTFIT);
f0104825:	6a 02                	push   $0x2
f0104827:	e8 01 e6 ff ff       	call   f0102e2d <set_kheap_strategy>
f010482c:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f010482f:	83 ec 0c             	sub    $0xc,%esp
f0104832:	68 e0 67 13 f0       	push   $0xf01367e0
f0104837:	e8 11 d3 ff ff       	call   f0101b4d <cprintf>
f010483c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010483f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104844:	c9                   	leave  
f0104845:	c3                   	ret    

f0104846 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0104846:	55                   	push   %ebp
f0104847:	89 e5                	mov    %esp,%ebp
f0104849:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_NEXTFIT);
f010484c:	6a 03                	push   $0x3
f010484e:	e8 da e5 ff ff       	call   f0102e2d <set_kheap_strategy>
f0104853:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0104856:	83 ec 0c             	sub    $0xc,%esp
f0104859:	68 10 68 13 f0       	push   $0xf0136810
f010485e:	e8 ea d2 ff ff       	call   f0101b4d <cprintf>
f0104863:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104866:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010486b:	c9                   	leave  
f010486c:	c3                   	ret    

f010486d <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010486d:	55                   	push   %ebp
f010486e:	89 e5                	mov    %esp,%ebp
f0104870:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0104873:	6a 04                	push   $0x4
f0104875:	e8 b3 e5 ff ff       	call   f0102e2d <set_kheap_strategy>
f010487a:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f010487d:	83 ec 0c             	sub    $0xc,%esp
f0104880:	68 40 68 13 f0       	push   $0xf0136840
f0104885:	e8 c3 d2 ff ff       	call   f0101b4d <cprintf>
f010488a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010488d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104892:	c9                   	leave  
f0104893:	c3                   	ret    

f0104894 <command_set_kheap_plac_CUSTOMFIT>:
int command_set_kheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f0104894:	55                   	push   %ebp
f0104895:	89 e5                	mov    %esp,%ebp
f0104897:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f010489a:	6a 05                	push   $0x5
f010489c:	e8 8c e5 ff ff       	call   f0102e2d <set_kheap_strategy>
f01048a1:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now CUSTOM FIT\n");
f01048a4:	83 ec 0c             	sub    $0xc,%esp
f01048a7:	68 74 68 13 f0       	push   $0xf0136874
f01048ac:	e8 9c d2 ff ff       	call   f0101b4d <cprintf>
f01048b1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01048b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01048b9:	c9                   	leave  
f01048ba:	c3                   	ret    

f01048bb <command_print_kheap_plac>:
int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01048bb:	55                   	push   %ebp
f01048bc:	89 e5                	mov    %esp,%ebp
f01048be:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_kheap_strategy();
f01048c1:	e8 75 e5 ff ff       	call   f0102e3b <get_kheap_strategy>
f01048c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f01048c9:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f01048cd:	77 7b                	ja     f010494a <command_print_kheap_plac+0x8f>
f01048cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01048d2:	c1 e0 02             	shl    $0x2,%eax
f01048d5:	05 fc 69 13 f0       	add    $0xf01369fc,%eax
f01048da:	8b 00                	mov    (%eax),%eax
f01048dc:	ff e0                	jmp    *%eax
	{
	case KHP_PLACE_CONTALLOC:
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01048de:	83 ec 0c             	sub    $0xc,%esp
f01048e1:	68 a8 68 13 f0       	push   $0xf01368a8
f01048e6:	e8 62 d2 ff ff       	call   f0101b4d <cprintf>
f01048eb:	83 c4 10             	add    $0x10,%esp
		break;
f01048ee:	eb 6a                	jmp    f010495a <command_print_kheap_plac+0x9f>
	case KHP_PLACE_FIRSTFIT:
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01048f0:	83 ec 0c             	sub    $0xc,%esp
f01048f3:	68 e4 68 13 f0       	push   $0xf01368e4
f01048f8:	e8 50 d2 ff ff       	call   f0101b4d <cprintf>
f01048fd:	83 c4 10             	add    $0x10,%esp
		break;
f0104900:	eb 58                	jmp    f010495a <command_print_kheap_plac+0x9f>
	case KHP_PLACE_NEXTFIT:
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0104902:	83 ec 0c             	sub    $0xc,%esp
f0104905:	68 14 69 13 f0       	push   $0xf0136914
f010490a:	e8 3e d2 ff ff       	call   f0101b4d <cprintf>
f010490f:	83 c4 10             	add    $0x10,%esp
		break;
f0104912:	eb 46                	jmp    f010495a <command_print_kheap_plac+0x9f>
	case KHP_PLACE_BESTFIT:
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0104914:	83 ec 0c             	sub    $0xc,%esp
f0104917:	68 40 69 13 f0       	push   $0xf0136940
f010491c:	e8 2c d2 ff ff       	call   f0101b4d <cprintf>
f0104921:	83 c4 10             	add    $0x10,%esp
		break;
f0104924:	eb 34                	jmp    f010495a <command_print_kheap_plac+0x9f>
	case KHP_PLACE_WORSTFIT:
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0104926:	83 ec 0c             	sub    $0xc,%esp
f0104929:	68 6c 69 13 f0       	push   $0xf013696c
f010492e:	e8 1a d2 ff ff       	call   f0101b4d <cprintf>
f0104933:	83 c4 10             	add    $0x10,%esp
		break;
f0104936:	eb 22                	jmp    f010495a <command_print_kheap_plac+0x9f>
	case KHP_PLACE_CUSTOMFIT:
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f0104938:	83 ec 0c             	sub    $0xc,%esp
f010493b:	68 9c 69 13 f0       	push   $0xf013699c
f0104940:	e8 08 d2 ff ff       	call   f0101b4d <cprintf>
f0104945:	83 c4 10             	add    $0x10,%esp
		break;
f0104948:	eb 10                	jmp    f010495a <command_print_kheap_plac+0x9f>
	default:
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f010494a:	83 ec 0c             	sub    $0xc,%esp
f010494d:	68 cc 69 13 f0       	push   $0xf01369cc
f0104952:	e8 f6 d1 ff ff       	call   f0101b4d <cprintf>
f0104957:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010495a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010495f:	c9                   	leave  
f0104960:	c3                   	ret    

f0104961 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0104961:	55                   	push   %ebp
f0104962:	89 e5                	mov    %esp,%ebp
f0104964:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104967:	e8 f0 cd 00 00       	call   f011175c <isBufferingEnabled>
f010496c:	84 c0                	test   %al,%al
f010496e:	75 12                	jne    f0104982 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0104970:	83 ec 0c             	sub    $0xc,%esp
f0104973:	68 14 6a 13 f0       	push   $0xf0136a14
f0104978:	e8 d0 d1 ff ff       	call   f0101b4d <cprintf>
f010497d:	83 c4 10             	add    $0x10,%esp
f0104980:	eb 1d                	jmp    f010499f <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0104982:	83 ec 0c             	sub    $0xc,%esp
f0104985:	6a 00                	push   $0x0
f0104987:	e8 aa cd 00 00       	call   f0111736 <enableModifiedBuffer>
f010498c:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f010498f:	83 ec 0c             	sub    $0xc,%esp
f0104992:	68 50 6a 13 f0       	push   $0xf0136a50
f0104997:	e8 b1 d1 ff ff       	call   f0101b4d <cprintf>
f010499c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010499f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049a4:	c9                   	leave  
f01049a5:	c3                   	ret    

f01049a6 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f01049a6:	55                   	push   %ebp
f01049a7:	89 e5                	mov    %esp,%ebp
f01049a9:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01049ac:	e8 ab cd 00 00       	call   f011175c <isBufferingEnabled>
f01049b1:	84 c0                	test   %al,%al
f01049b3:	75 12                	jne    f01049c7 <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01049b5:	83 ec 0c             	sub    $0xc,%esp
f01049b8:	68 14 6a 13 f0       	push   $0xf0136a14
f01049bd:	e8 8b d1 ff ff       	call   f0101b4d <cprintf>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	eb 1d                	jmp    f01049e4 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f01049c7:	83 ec 0c             	sub    $0xc,%esp
f01049ca:	6a 01                	push   $0x1
f01049cc:	e8 65 cd 00 00       	call   f0111736 <enableModifiedBuffer>
f01049d1:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f01049d4:	83 ec 0c             	sub    $0xc,%esp
f01049d7:	68 74 6a 13 f0       	push   $0xf0136a74
f01049dc:	e8 6c d1 ff ff       	call   f0101b4d <cprintf>
f01049e1:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01049e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049e9:	c9                   	leave  
f01049ea:	c3                   	ret    

f01049eb <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01049eb:	55                   	push   %ebp
f01049ec:	89 e5                	mov    %esp,%ebp
f01049ee:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01049f1:	83 ec 0c             	sub    $0xc,%esp
f01049f4:	6a 00                	push   $0x0
f01049f6:	e8 53 cd 00 00       	call   f011174e <enableBuffering>
f01049fb:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f01049fe:	83 ec 0c             	sub    $0xc,%esp
f0104a01:	6a 00                	push   $0x0
f0104a03:	e8 2e cd 00 00       	call   f0111736 <enableModifiedBuffer>
f0104a08:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0104a0b:	83 ec 0c             	sub    $0xc,%esp
f0104a0e:	68 94 6a 13 f0       	push   $0xf0136a94
f0104a13:	e8 35 d1 ff ff       	call   f0101b4d <cprintf>
f0104a18:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104a1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104a20:	c9                   	leave  
f0104a21:	c3                   	ret    

f0104a22 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0104a22:	55                   	push   %ebp
f0104a23:	89 e5                	mov    %esp,%ebp
f0104a25:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0104a28:	83 ec 0c             	sub    $0xc,%esp
f0104a2b:	6a 01                	push   $0x1
f0104a2d:	e8 1c cd 00 00       	call   f011174e <enableBuffering>
f0104a32:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0104a35:	83 ec 0c             	sub    $0xc,%esp
f0104a38:	6a 01                	push   $0x1
f0104a3a:	e8 f7 cc 00 00       	call   f0111736 <enableModifiedBuffer>
f0104a3f:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0104a42:	e8 2d cd 00 00       	call   f0111774 <getModifiedBufferLength>
f0104a47:	85 c0                	test   %eax,%eax
f0104a49:	75 59                	jne    f0104aa4 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0104a4b:	83 ec 0c             	sub    $0xc,%esp
f0104a4e:	68 b0 6a 13 f0       	push   $0xf0136ab0
f0104a53:	e8 f5 d0 ff ff       	call   f0101b4d <cprintf>
f0104a58:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0104a5b:	83 ec 08             	sub    $0x8,%esp
f0104a5e:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104a61:	50                   	push   %eax
f0104a62:	68 e0 6a 13 f0       	push   $0xf0136ae0
f0104a67:	e8 bb e1 01 00       	call   f0122c27 <readline>
f0104a6c:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0104a6f:	83 ec 04             	sub    $0x4,%esp
f0104a72:	6a 0a                	push   $0xa
f0104a74:	6a 00                	push   $0x0
f0104a76:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104a79:	50                   	push   %eax
f0104a7a:	e8 bf e7 01 00       	call   f012323e <strtol>
f0104a7f:	83 c4 10             	add    $0x10,%esp
f0104a82:	83 ec 0c             	sub    $0xc,%esp
f0104a85:	50                   	push   %eax
f0104a86:	e8 db cc 00 00       	call   f0111766 <setModifiedBufferLength>
f0104a8b:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104a8e:	e8 e1 cc 00 00       	call   f0111774 <getModifiedBufferLength>
f0104a93:	83 ec 08             	sub    $0x8,%esp
f0104a96:	50                   	push   %eax
f0104a97:	68 0c 6b 13 f0       	push   $0xf0136b0c
f0104a9c:	e8 ac d0 ff ff       	call   f0101b4d <cprintf>
f0104aa1:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0104aa4:	83 ec 0c             	sub    $0xc,%esp
f0104aa7:	68 31 6b 13 f0       	push   $0xf0136b31
f0104aac:	e8 9c d0 ff ff       	call   f0101b4d <cprintf>
f0104ab1:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104ab4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104ab9:	c9                   	leave  
f0104aba:	c3                   	ret    

f0104abb <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104abb:	55                   	push   %ebp
f0104abc:	89 e5                	mov    %esp,%ebp
f0104abe:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104ac1:	e8 96 cc 00 00       	call   f011175c <isBufferingEnabled>
f0104ac6:	84 c0                	test   %al,%al
f0104ac8:	75 12                	jne    f0104adc <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104aca:	83 ec 0c             	sub    $0xc,%esp
f0104acd:	68 4c 6b 13 f0       	push   $0xf0136b4c
f0104ad2:	e8 76 d0 ff ff       	call   f0101b4d <cprintf>
f0104ad7:	83 c4 10             	add    $0x10,%esp
f0104ada:	eb 19                	jmp    f0104af5 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104adc:	e8 63 cc 00 00       	call   f0111744 <isModifiedBufferEnabled>
f0104ae1:	84 c0                	test   %al,%al
f0104ae3:	75 10                	jne    f0104af5 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104ae5:	83 ec 0c             	sub    $0xc,%esp
f0104ae8:	68 9c 6b 13 f0       	push   $0xf0136b9c
f0104aed:	e8 5b d0 ff ff       	call   f0101b4d <cprintf>
f0104af2:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0104af5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104af8:	83 c0 04             	add    $0x4,%eax
f0104afb:	8b 00                	mov    (%eax),%eax
f0104afd:	83 ec 04             	sub    $0x4,%esp
f0104b00:	6a 0a                	push   $0xa
f0104b02:	6a 00                	push   $0x0
f0104b04:	50                   	push   %eax
f0104b05:	e8 34 e7 01 00       	call   f012323e <strtol>
f0104b0a:	83 c4 10             	add    $0x10,%esp
f0104b0d:	83 ec 0c             	sub    $0xc,%esp
f0104b10:	50                   	push   %eax
f0104b11:	e8 50 cc 00 00       	call   f0111766 <setModifiedBufferLength>
f0104b16:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104b19:	e8 56 cc 00 00       	call   f0111774 <getModifiedBufferLength>
f0104b1e:	83 ec 08             	sub    $0x8,%esp
f0104b21:	50                   	push   %eax
f0104b22:	68 0c 6b 13 f0       	push   $0xf0136b0c
f0104b27:	e8 21 d0 ff ff       	call   f0101b4d <cprintf>
f0104b2c:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b34:	c9                   	leave  
f0104b35:	c3                   	ret    

f0104b36 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104b36:	55                   	push   %ebp
f0104b37:	89 e5                	mov    %esp,%ebp
f0104b39:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104b3c:	e8 1b cc 00 00       	call   f011175c <isBufferingEnabled>
f0104b41:	84 c0                	test   %al,%al
f0104b43:	75 12                	jne    f0104b57 <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104b45:	83 ec 0c             	sub    $0xc,%esp
f0104b48:	68 4c 6b 13 f0       	push   $0xf0136b4c
f0104b4d:	e8 fb cf ff ff       	call   f0101b4d <cprintf>
f0104b52:	83 c4 10             	add    $0x10,%esp
f0104b55:	eb 19                	jmp    f0104b70 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104b57:	e8 e8 cb 00 00       	call   f0111744 <isModifiedBufferEnabled>
f0104b5c:	84 c0                	test   %al,%al
f0104b5e:	75 10                	jne    f0104b70 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104b60:	83 ec 0c             	sub    $0xc,%esp
f0104b63:	68 9c 6b 13 f0       	push   $0xf0136b9c
f0104b68:	e8 e0 cf ff ff       	call   f0101b4d <cprintf>
f0104b6d:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0104b70:	e8 ff cb 00 00       	call   f0111774 <getModifiedBufferLength>
f0104b75:	83 ec 08             	sub    $0x8,%esp
f0104b78:	50                   	push   %eax
f0104b79:	68 e2 6b 13 f0       	push   $0xf0136be2
f0104b7e:	e8 ca cf ff ff       	call   f0101b4d <cprintf>
f0104b83:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b86:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b8b:	c9                   	leave  
f0104b8c:	c3                   	ret    

f0104b8d <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0104b8d:	55                   	push   %ebp
f0104b8e:	89 e5                	mov    %esp,%ebp
f0104b90:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0104b93:	83 ec 08             	sub    $0x8,%esp
f0104b96:	ff 75 0c             	pushl  0xc(%ebp)
f0104b99:	ff 75 08             	pushl  0x8(%ebp)
f0104b9c:	e8 96 f0 00 00       	call   f0113c37 <tst_handler>
f0104ba1:	83 c4 10             	add    $0x10,%esp
}
f0104ba4:	c9                   	leave  
f0104ba5:	c3                   	ret    

f0104ba6 <command_cls>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int command_cls(int number_of_arguments, char **arguments)
{
f0104ba6:	55                   	push   %ebp
f0104ba7:	89 e5                	mov    %esp,%ebp
f0104ba9:	83 ec 08             	sub    $0x8,%esp
	clear_screen_buffer();
f0104bac:	e8 ad ce ff ff       	call   f0101a5e <clear_screen_buffer>
	return 0;
f0104bb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104bb6:	c9                   	leave  
f0104bb7:	c3                   	ret    

f0104bb8 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0104bb8:	55                   	push   %ebp
f0104bb9:	89 e5                	mov    %esp,%ebp
f0104bbb:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104bbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bc1:	05 00 14 00 00       	add    $0x1400,%eax
f0104bc6:	c1 e0 03             	shl    $0x3,%eax
f0104bc9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104bcc:	83 ec 04             	sub    $0x4,%esp
f0104bcf:	6a 08                	push   $0x8
f0104bd1:	ff 75 0c             	pushl  0xc(%ebp)
f0104bd4:	ff 75 f4             	pushl  -0xc(%ebp)
f0104bd7:	e8 e5 ea 01 00       	call   f01236c1 <ide_read>
f0104bdc:	83 c4 10             	add    $0x10,%esp
f0104bdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0104be2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104be5:	c9                   	leave  
f0104be6:	c3                   	ret    

f0104be7 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0104be7:	55                   	push   %ebp
f0104be8:	89 e5                	mov    %esp,%ebp
f0104bea:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104bed:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bf0:	05 00 14 00 00       	add    $0x1400,%eax
f0104bf5:	c1 e0 03             	shl    $0x3,%eax
f0104bf8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104bfb:	83 ec 04             	sub    $0x4,%esp
f0104bfe:	6a 08                	push   $0x8
f0104c00:	ff 75 0c             	pushl  0xc(%ebp)
f0104c03:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c06:	e8 10 ec 01 00       	call   f012381b <ide_write>
f0104c0b:	83 c4 10             	add    $0x10,%esp
f0104c0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0104c11:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104c15:	74 14                	je     f0104c2b <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0104c17:	83 ec 04             	sub    $0x4,%esp
f0104c1a:	68 00 6c 13 f0       	push   $0xf0136c00
f0104c1f:	6a 2f                	push   $0x2f
f0104c21:	68 17 6c 13 f0       	push   $0xf0136c17
f0104c26:	e8 84 c2 ff ff       	call   f0100eaf <_panic>
	return success;
f0104c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c2e:	c9                   	leave  
f0104c2f:	c3                   	ret    

f0104c30 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0104c30:	55                   	push   %ebp
f0104c31:	89 e5                	mov    %esp,%ebp
f0104c33:	56                   	push   %esi
f0104c34:	53                   	push   %ebx
f0104c35:	83 ec 10             	sub    $0x10,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0104c38:	c7 05 80 53 96 f1 00 	movl   $0x0,0xf1965380
f0104c3f:	00 00 00 
f0104c42:	c7 05 84 53 96 f1 00 	movl   $0x0,0xf1965384
f0104c49:	00 00 00 
f0104c4c:	c7 05 8c 53 96 f1 00 	movl   $0x0,0xf196538c
f0104c53:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104c56:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0104c5d:	e9 20 01 00 00       	jmp    f0104d82 <initialize_disk_page_file+0x152>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0104c62:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104c68:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c6b:	89 d0                	mov    %edx,%eax
f0104c6d:	01 c0                	add    %eax,%eax
f0104c6f:	01 d0                	add    %edx,%eax
f0104c71:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104c78:	01 d8                	add    %ebx,%eax
f0104c7a:	01 d0                	add    %edx,%eax
f0104c7c:	01 c8                	add    %ecx,%eax
f0104c7e:	83 ec 0c             	sub    $0xc,%esp
f0104c81:	50                   	push   %eax
f0104c82:	e8 b4 49 00 00       	call   f010963b <initialize_frame_info>
f0104c87:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0104c8a:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104c90:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c93:	89 d0                	mov    %edx,%eax
f0104c95:	01 c0                	add    %eax,%eax
f0104c97:	01 d0                	add    %edx,%eax
f0104c99:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104ca0:	01 d8                	add    %ebx,%eax
f0104ca2:	01 d0                	add    %edx,%eax
f0104ca4:	01 c8                	add    %ecx,%eax
f0104ca6:	85 c0                	test   %eax,%eax
f0104ca8:	75 14                	jne    f0104cbe <initialize_disk_page_file+0x8e>
f0104caa:	83 ec 04             	sub    $0x4,%esp
f0104cad:	68 34 6c 13 f0       	push   $0xf0136c34
f0104cb2:	6a 56                	push   $0x56
f0104cb4:	68 17 6c 13 f0       	push   $0xf0136c17
f0104cb9:	e8 f1 c1 ff ff       	call   f0100eaf <_panic>
f0104cbe:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104cc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cc7:	89 d0                	mov    %edx,%eax
f0104cc9:	01 c0                	add    %eax,%eax
f0104ccb:	01 d0                	add    %edx,%eax
f0104ccd:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104cd4:	01 d8                	add    %ebx,%eax
f0104cd6:	01 d0                	add    %edx,%eax
f0104cd8:	01 c8                	add    %ecx,%eax
f0104cda:	8b 15 80 53 96 f1    	mov    0xf1965380,%edx
f0104ce0:	89 10                	mov    %edx,(%eax)
f0104ce2:	8b 00                	mov    (%eax),%eax
f0104ce4:	85 c0                	test   %eax,%eax
f0104ce6:	74 27                	je     f0104d0f <initialize_disk_page_file+0xdf>
f0104ce8:	8b 0d 80 53 96 f1    	mov    0xf1965380,%ecx
f0104cee:	8b 1d e4 cb 94 f1    	mov    0xf194cbe4,%ebx
f0104cf4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cf7:	89 d0                	mov    %edx,%eax
f0104cf9:	01 c0                	add    %eax,%eax
f0104cfb:	01 d0                	add    %edx,%eax
f0104cfd:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f0104d04:	01 f0                	add    %esi,%eax
f0104d06:	01 d0                	add    %edx,%eax
f0104d08:	01 d8                	add    %ebx,%eax
f0104d0a:	89 41 04             	mov    %eax,0x4(%ecx)
f0104d0d:	eb 21                	jmp    f0104d30 <initialize_disk_page_file+0x100>
f0104d0f:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104d15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d18:	89 d0                	mov    %edx,%eax
f0104d1a:	01 c0                	add    %eax,%eax
f0104d1c:	01 d0                	add    %edx,%eax
f0104d1e:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104d25:	01 d8                	add    %ebx,%eax
f0104d27:	01 d0                	add    %edx,%eax
f0104d29:	01 c8                	add    %ecx,%eax
f0104d2b:	a3 84 53 96 f1       	mov    %eax,0xf1965384
f0104d30:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104d36:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d39:	89 d0                	mov    %edx,%eax
f0104d3b:	01 c0                	add    %eax,%eax
f0104d3d:	01 d0                	add    %edx,%eax
f0104d3f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104d46:	01 d8                	add    %ebx,%eax
f0104d48:	01 d0                	add    %edx,%eax
f0104d4a:	01 c8                	add    %ecx,%eax
f0104d4c:	a3 80 53 96 f1       	mov    %eax,0xf1965380
f0104d51:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104d57:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d5a:	89 d0                	mov    %edx,%eax
f0104d5c:	01 c0                	add    %eax,%eax
f0104d5e:	01 d0                	add    %edx,%eax
f0104d60:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104d67:	01 d8                	add    %ebx,%eax
f0104d69:	01 d0                	add    %edx,%eax
f0104d6b:	01 c8                	add    %ecx,%eax
f0104d6d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104d74:	a1 8c 53 96 f1       	mov    0xf196538c,%eax
f0104d79:	40                   	inc    %eax
f0104d7a:	a3 8c 53 96 f1       	mov    %eax,0xf196538c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104d7f:	ff 45 f4             	incl   -0xc(%ebp)
f0104d82:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0104d89:	0f 8e d3 fe ff ff    	jle    f0104c62 <initialize_disk_page_file+0x32>

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}

	init_kspinlock(&DiskFrameLists.dfllock, "Disk FrameList Lock");
f0104d8f:	83 ec 08             	sub    $0x8,%esp
f0104d92:	68 57 6c 13 f0       	push   $0xf0136c57
f0104d97:	68 90 53 96 f1       	push   $0xf1965390
f0104d9c:	e8 73 e7 00 00       	call   f0113514 <init_kspinlock>
f0104da1:	83 c4 10             	add    $0x10,%esp
}
f0104da4:	90                   	nop
f0104da5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104da8:	5b                   	pop    %ebx
f0104da9:	5e                   	pop    %esi
f0104daa:	5d                   	pop    %ebp
f0104dab:	c3                   	ret    

f0104dac <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0104dac:	55                   	push   %ebp
f0104dad:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0104daf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104db2:	8b 15 e4 cb 94 f1    	mov    0xf194cbe4,%edx
f0104db8:	29 d0                	sub    %edx,%eax
f0104dba:	c1 f8 02             	sar    $0x2,%eax
f0104dbd:	89 c2                	mov    %eax,%edx
f0104dbf:	89 d0                	mov    %edx,%eax
f0104dc1:	c1 e0 03             	shl    $0x3,%eax
f0104dc4:	01 d0                	add    %edx,%eax
f0104dc6:	c1 e0 03             	shl    $0x3,%eax
f0104dc9:	01 d0                	add    %edx,%eax
f0104dcb:	c1 e0 03             	shl    $0x3,%eax
f0104dce:	01 d0                	add    %edx,%eax
f0104dd0:	c1 e0 03             	shl    $0x3,%eax
f0104dd3:	01 d0                	add    %edx,%eax
f0104dd5:	89 c1                	mov    %eax,%ecx
f0104dd7:	c1 e1 0f             	shl    $0xf,%ecx
f0104dda:	01 c8                	add    %ecx,%eax
f0104ddc:	c1 e0 03             	shl    $0x3,%eax
f0104ddf:	01 d0                	add    %edx,%eax
f0104de1:	f7 d8                	neg    %eax
}
f0104de3:	5d                   	pop    %ebp
f0104de4:	c3                   	ret    

f0104de5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0104de5:	55                   	push   %ebp
f0104de6:	89 e5                	mov    %esp,%ebp
f0104de8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0104deb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104df2:	83 ec 0c             	sub    $0xc,%esp
f0104df5:	68 90 53 96 f1       	push   $0xf1965390
f0104dfa:	e8 46 e7 00 00       	call   f0113545 <acquire_kspinlock>
f0104dff:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104e02:	a1 80 53 96 f1       	mov    0xf1965380,%eax
f0104e07:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0104e0a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104e0e:	75 0c                	jne    f0104e1c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104e10:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0104e17:	e9 a2 00 00 00       	jmp    f0104ebe <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104e1c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104e20:	75 14                	jne    f0104e36 <allocate_disk_frame+0x51>
f0104e22:	83 ec 04             	sub    $0x4,%esp
f0104e25:	68 6b 6c 13 f0       	push   $0xf0136c6b
f0104e2a:	6a 7d                	push   $0x7d
f0104e2c:	68 17 6c 13 f0       	push   $0xf0136c17
f0104e31:	e8 79 c0 ff ff       	call   f0100eaf <_panic>
f0104e36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e39:	8b 00                	mov    (%eax),%eax
f0104e3b:	85 c0                	test   %eax,%eax
f0104e3d:	74 10                	je     f0104e4f <allocate_disk_frame+0x6a>
f0104e3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e42:	8b 00                	mov    (%eax),%eax
f0104e44:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e47:	8b 52 04             	mov    0x4(%edx),%edx
f0104e4a:	89 50 04             	mov    %edx,0x4(%eax)
f0104e4d:	eb 0b                	jmp    f0104e5a <allocate_disk_frame+0x75>
f0104e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e52:	8b 40 04             	mov    0x4(%eax),%eax
f0104e55:	a3 84 53 96 f1       	mov    %eax,0xf1965384
f0104e5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e5d:	8b 40 04             	mov    0x4(%eax),%eax
f0104e60:	85 c0                	test   %eax,%eax
f0104e62:	74 0f                	je     f0104e73 <allocate_disk_frame+0x8e>
f0104e64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e67:	8b 40 04             	mov    0x4(%eax),%eax
f0104e6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e6d:	8b 12                	mov    (%edx),%edx
f0104e6f:	89 10                	mov    %edx,(%eax)
f0104e71:	eb 0a                	jmp    f0104e7d <allocate_disk_frame+0x98>
f0104e73:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e76:	8b 00                	mov    (%eax),%eax
f0104e78:	a3 80 53 96 f1       	mov    %eax,0xf1965380
f0104e7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e80:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104e86:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104e90:	a1 8c 53 96 f1       	mov    0xf196538c,%eax
f0104e95:	48                   	dec    %eax
f0104e96:	a3 8c 53 96 f1       	mov    %eax,0xf196538c
			initialize_frame_info(ptr_frame_info);
f0104e9b:	83 ec 0c             	sub    $0xc,%esp
f0104e9e:	ff 75 f0             	pushl  -0x10(%ebp)
f0104ea1:	e8 95 47 00 00       	call   f010963b <initialize_frame_info>
f0104ea6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0104ea9:	83 ec 0c             	sub    $0xc,%esp
f0104eac:	ff 75 f0             	pushl  -0x10(%ebp)
f0104eaf:	e8 f8 fe ff ff       	call   f0104dac <to_disk_frame_number>
f0104eb4:	83 c4 10             	add    $0x10,%esp
f0104eb7:	89 c2                	mov    %eax,%edx
f0104eb9:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ebc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104ebe:	83 ec 0c             	sub    $0xc,%esp
f0104ec1:	68 90 53 96 f1       	push   $0xf1965390
f0104ec6:	e8 1f e7 00 00       	call   f01135ea <release_kspinlock>
f0104ecb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0104ece:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104ed1:	c9                   	leave  
f0104ed2:	c3                   	ret    

f0104ed3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0104ed3:	55                   	push   %ebp
f0104ed4:	89 e5                	mov    %esp,%ebp
f0104ed6:	56                   	push   %esi
f0104ed7:	53                   	push   %ebx
	// Fill this function in
	if(dfn == 0) return;
f0104ed8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104edc:	0f 84 1a 01 00 00    	je     f0104ffc <free_disk_frame+0x129>
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104ee2:	83 ec 0c             	sub    $0xc,%esp
f0104ee5:	68 90 53 96 f1       	push   $0xf1965390
f0104eea:	e8 56 e6 00 00       	call   f0113545 <acquire_kspinlock>
f0104eef:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0104ef2:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104ef8:	8b 55 08             	mov    0x8(%ebp),%edx
f0104efb:	89 d0                	mov    %edx,%eax
f0104efd:	01 c0                	add    %eax,%eax
f0104eff:	01 d0                	add    %edx,%eax
f0104f01:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104f08:	01 d8                	add    %ebx,%eax
f0104f0a:	01 d0                	add    %edx,%eax
f0104f0c:	01 c8                	add    %ecx,%eax
f0104f0e:	85 c0                	test   %eax,%eax
f0104f10:	75 17                	jne    f0104f29 <free_disk_frame+0x56>
f0104f12:	83 ec 04             	sub    $0x4,%esp
f0104f15:	68 34 6c 13 f0       	push   $0xf0136c34
f0104f1a:	68 90 00 00 00       	push   $0x90
f0104f1f:	68 17 6c 13 f0       	push   $0xf0136c17
f0104f24:	e8 86 bf ff ff       	call   f0100eaf <_panic>
f0104f29:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104f2f:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f32:	89 d0                	mov    %edx,%eax
f0104f34:	01 c0                	add    %eax,%eax
f0104f36:	01 d0                	add    %edx,%eax
f0104f38:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104f3f:	01 d8                	add    %ebx,%eax
f0104f41:	01 d0                	add    %edx,%eax
f0104f43:	01 c8                	add    %ecx,%eax
f0104f45:	8b 15 80 53 96 f1    	mov    0xf1965380,%edx
f0104f4b:	89 10                	mov    %edx,(%eax)
f0104f4d:	8b 00                	mov    (%eax),%eax
f0104f4f:	85 c0                	test   %eax,%eax
f0104f51:	74 27                	je     f0104f7a <free_disk_frame+0xa7>
f0104f53:	8b 0d 80 53 96 f1    	mov    0xf1965380,%ecx
f0104f59:	8b 1d e4 cb 94 f1    	mov    0xf194cbe4,%ebx
f0104f5f:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f62:	89 d0                	mov    %edx,%eax
f0104f64:	01 c0                	add    %eax,%eax
f0104f66:	01 d0                	add    %edx,%eax
f0104f68:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f0104f6f:	01 f0                	add    %esi,%eax
f0104f71:	01 d0                	add    %edx,%eax
f0104f73:	01 d8                	add    %ebx,%eax
f0104f75:	89 41 04             	mov    %eax,0x4(%ecx)
f0104f78:	eb 21                	jmp    f0104f9b <free_disk_frame+0xc8>
f0104f7a:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104f80:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f83:	89 d0                	mov    %edx,%eax
f0104f85:	01 c0                	add    %eax,%eax
f0104f87:	01 d0                	add    %edx,%eax
f0104f89:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104f90:	01 d8                	add    %ebx,%eax
f0104f92:	01 d0                	add    %edx,%eax
f0104f94:	01 c8                	add    %ecx,%eax
f0104f96:	a3 84 53 96 f1       	mov    %eax,0xf1965384
f0104f9b:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104fa1:	8b 55 08             	mov    0x8(%ebp),%edx
f0104fa4:	89 d0                	mov    %edx,%eax
f0104fa6:	01 c0                	add    %eax,%eax
f0104fa8:	01 d0                	add    %edx,%eax
f0104faa:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104fb1:	01 d8                	add    %ebx,%eax
f0104fb3:	01 d0                	add    %edx,%eax
f0104fb5:	01 c8                	add    %ecx,%eax
f0104fb7:	a3 80 53 96 f1       	mov    %eax,0xf1965380
f0104fbc:	8b 0d e4 cb 94 f1    	mov    0xf194cbe4,%ecx
f0104fc2:	8b 55 08             	mov    0x8(%ebp),%edx
f0104fc5:	89 d0                	mov    %edx,%eax
f0104fc7:	01 c0                	add    %eax,%eax
f0104fc9:	01 d0                	add    %edx,%eax
f0104fcb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104fd2:	01 d8                	add    %ebx,%eax
f0104fd4:	01 d0                	add    %edx,%eax
f0104fd6:	01 c8                	add    %ecx,%eax
f0104fd8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104fdf:	a1 8c 53 96 f1       	mov    0xf196538c,%eax
f0104fe4:	40                   	inc    %eax
f0104fe5:	a3 8c 53 96 f1       	mov    %eax,0xf196538c
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104fea:	83 ec 0c             	sub    $0xc,%esp
f0104fed:	68 90 53 96 f1       	push   $0xf1965390
f0104ff2:	e8 f3 e5 00 00       	call   f01135ea <release_kspinlock>
f0104ff7:	83 c4 10             	add    $0x10,%esp
f0104ffa:	eb 01                	jmp    f0104ffd <free_disk_frame+0x12a>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0104ffc:	90                   	nop
	acquire_kspinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_kspinlock(&DiskFrameLists.dfllock);
}
f0104ffd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0105000:	5b                   	pop    %ebx
f0105001:	5e                   	pop    %esi
f0105002:	5d                   	pop    %ebp
f0105003:	c3                   	ret    

f0105004 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0105004:	55                   	push   %ebp
f0105005:	89 e5                	mov    %esp,%ebp
f0105007:	53                   	push   %ebx
f0105008:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f010500b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010500e:	c1 e8 16             	shr    $0x16,%eax
f0105011:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105018:	8b 45 08             	mov    0x8(%ebp),%eax
f010501b:	01 d0                	add    %edx,%eax
f010501d:	8b 00                	mov    (%eax),%eax
f010501f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0105022:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0105029:	77 1d                	ja     f0105048 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010502b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010502e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0105033:	83 ec 0c             	sub    $0xc,%esp
f0105036:	50                   	push   %eax
f0105037:	e8 e4 63 00 00       	call   f010b420 <kheap_virtual_address>
f010503c:	83 c4 10             	add    $0x10,%esp
f010503f:	89 c2                	mov    %eax,%edx
f0105041:	8b 45 14             	mov    0x14(%ebp),%eax
f0105044:	89 10                	mov    %edx,(%eax)
f0105046:	eb 44                	jmp    f010508c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0105048:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010504b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0105050:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0105053:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105056:	c1 e8 0c             	shr    $0xc,%eax
f0105059:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010505c:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0105061:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0105064:	72 17                	jb     f010507d <get_disk_page_table+0x79>
f0105066:	ff 75 f0             	pushl  -0x10(%ebp)
f0105069:	68 8c 6c 13 f0       	push   $0xf0136c8c
f010506e:	68 9f 00 00 00       	push   $0x9f
f0105073:	68 17 6c 13 f0       	push   $0xf0136c17
f0105078:	e8 32 be ff ff       	call   f0100eaf <_panic>
f010507d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105080:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0105085:	89 c2                	mov    %eax,%edx
f0105087:	8b 45 14             	mov    0x14(%ebp),%eax
f010508a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010508c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105090:	0f 85 80 00 00 00    	jne    f0105116 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0105096:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010509a:	74 6a                	je     f0105106 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010509c:	83 ec 0c             	sub    $0xc,%esp
f010509f:	68 00 10 00 00       	push   $0x1000
f01050a4:	e8 29 5e 00 00       	call   f010aed2 <kmalloc>
f01050a9:	83 c4 10             	add    $0x10,%esp
f01050ac:	89 c2                	mov    %eax,%edx
f01050ae:	8b 45 14             	mov    0x14(%ebp),%eax
f01050b1:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f01050b3:	8b 45 14             	mov    0x14(%ebp),%eax
f01050b6:	8b 00                	mov    (%eax),%eax
f01050b8:	85 c0                	test   %eax,%eax
f01050ba:	75 07                	jne    f01050c3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f01050bc:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01050c1:	eb 58                	jmp    f010511b <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01050c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050c6:	c1 e8 16             	shr    $0x16,%eax
f01050c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01050d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01050d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01050d6:	8b 45 14             	mov    0x14(%ebp),%eax
f01050d9:	8b 00                	mov    (%eax),%eax
f01050db:	83 ec 0c             	sub    $0xc,%esp
f01050de:	50                   	push   %eax
f01050df:	e8 a8 63 00 00       	call   f010b48c <kheap_physical_address>
f01050e4:	83 c4 10             	add    $0x10,%esp
f01050e7:	83 c8 01             	or     $0x1,%eax
f01050ea:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01050ec:	8b 45 14             	mov    0x14(%ebp),%eax
f01050ef:	8b 00                	mov    (%eax),%eax
f01050f1:	83 ec 04             	sub    $0x4,%esp
f01050f4:	68 00 10 00 00       	push   $0x1000
f01050f9:	6a 00                	push   $0x0
f01050fb:	50                   	push   %eax
f01050fc:	e8 1c df 01 00       	call   f012301d <memset>
f0105101:	83 c4 10             	add    $0x10,%esp
f0105104:	eb 10                	jmp    f0105116 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f0105106:	8b 45 14             	mov    0x14(%ebp),%eax
f0105109:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f010510f:	b8 00 00 00 00       	mov    $0x0,%eax
f0105114:	eb 05                	jmp    f010511b <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f0105116:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010511b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010511e:	c9                   	leave  
f010511f:	c3                   	ret    

f0105120 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0105120:	55                   	push   %ebp
f0105121:	89 e5                	mov    %esp,%ebp
f0105123:	83 ec 28             	sub    $0x28,%esp
f0105126:	8b 45 10             	mov    0x10(%ebp),%eax
f0105129:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010512c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0105130:	74 72                	je     f01051a4 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0105132:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0105139:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010513c:	2d 01 30 fe 5f       	sub    $0x5ffe3001,%eax
f0105141:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0105144:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105147:	ba 00 00 00 00       	mov    $0x0,%edx
f010514c:	f7 75 f4             	divl   -0xc(%ebp)
f010514f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105152:	29 d0                	sub    %edx,%eax
f0105154:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105157:	73 2f                	jae    f0105188 <pf_add_empty_env_page+0x68>
f0105159:	8b 45 08             	mov    0x8(%ebp),%eax
f010515c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010515f:	b8 00 00 00 00       	mov    $0x0,%eax
f0105164:	29 d0                	sub    %edx,%eax
f0105166:	c1 e0 0c             	shl    $0xc,%eax
f0105169:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010516e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105171:	76 15                	jbe    f0105188 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0105173:	8b 45 08             	mov    0x8(%ebp),%eax
f0105176:	8b 80 9c 06 00 00    	mov    0x69c(%eax),%eax
f010517c:	8d 50 01             	lea    0x1(%eax),%edx
f010517f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105182:	89 90 9c 06 00 00    	mov    %edx,0x69c(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0105188:	a1 b8 51 96 f1       	mov    0xf19651b8,%eax
f010518d:	83 ec 04             	sub    $0x4,%esp
f0105190:	50                   	push   %eax
f0105191:	ff 75 0c             	pushl  0xc(%ebp)
f0105194:	ff 75 08             	pushl  0x8(%ebp)
f0105197:	e8 b2 00 00 00       	call   f010524e <pf_add_env_page>
f010519c:	83 c4 10             	add    $0x10,%esp
f010519f:	e9 a8 00 00 00       	jmp    f010524c <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f01051a4:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01051ab:	76 19                	jbe    f01051c6 <pf_add_empty_env_page+0xa6>
f01051ad:	68 bc 6c 13 f0       	push   $0xf0136cbc
f01051b2:	68 e2 6c 13 f0       	push   $0xf0136ce2
f01051b7:	68 de 00 00 00       	push   $0xde
f01051bc:	68 17 6c 13 f0       	push   $0xf0136c17
f01051c1:	e8 e9 bc ff ff       	call   f0100eaf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	83 c0 74             	add    $0x74,%eax
f01051cc:	83 ec 08             	sub    $0x8,%esp
f01051cf:	50                   	push   %eax
f01051d0:	ff 75 08             	pushl  0x8(%ebp)
f01051d3:	e8 42 06 00 00       	call   f010581a <get_disk_page_directory>
f01051d8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01051db:	8b 45 08             	mov    0x8(%ebp),%eax
f01051de:	8b 40 74             	mov    0x74(%eax),%eax
f01051e1:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01051e4:	52                   	push   %edx
f01051e5:	6a 01                	push   $0x1
f01051e7:	ff 75 0c             	pushl  0xc(%ebp)
f01051ea:	50                   	push   %eax
f01051eb:	e8 14 fe ff ff       	call   f0105004 <get_disk_page_table>
f01051f0:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01051f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01051f6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051f9:	c1 ea 0c             	shr    $0xc,%edx
f01051fc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105202:	c1 e2 02             	shl    $0x2,%edx
f0105205:	01 d0                	add    %edx,%eax
f0105207:	8b 00                	mov    (%eax),%eax
f0105209:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f010520c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010520f:	85 c0                	test   %eax,%eax
f0105211:	75 34                	jne    f0105247 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0105213:	83 ec 0c             	sub    $0xc,%esp
f0105216:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0105219:	50                   	push   %eax
f010521a:	e8 c6 fb ff ff       	call   f0104de5 <allocate_disk_frame>
f010521f:	83 c4 10             	add    $0x10,%esp
f0105222:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0105225:	75 07                	jne    f010522e <pf_add_empty_env_page+0x10e>
f0105227:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010522c:	eb 1e                	jmp    f010524c <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f010522e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105231:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105234:	c1 ea 0c             	shr    $0xc,%edx
f0105237:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010523d:	c1 e2 02             	shl    $0x2,%edx
f0105240:	01 c2                	add    %eax,%edx
f0105242:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105245:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0105247:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010524c:	c9                   	leave  
f010524d:	c3                   	ret    

f010524e <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f010524e:	55                   	push   %ebp
f010524f:	89 e5                	mov    %esp,%ebp
f0105251:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0105254:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010525b:	76 19                	jbe    f0105276 <pf_add_env_page+0x28>
f010525d:	68 bc 6c 13 f0       	push   $0xf0136cbc
f0105262:	68 e2 6c 13 f0       	push   $0xf0136ce2
f0105267:	68 f3 00 00 00       	push   $0xf3
f010526c:	68 17 6c 13 f0       	push   $0xf0136c17
f0105271:	e8 39 bc ff ff       	call   f0100eaf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0105276:	8b 45 08             	mov    0x8(%ebp),%eax
f0105279:	83 c0 74             	add    $0x74,%eax
f010527c:	83 ec 08             	sub    $0x8,%esp
f010527f:	50                   	push   %eax
f0105280:	ff 75 08             	pushl  0x8(%ebp)
f0105283:	e8 92 05 00 00       	call   f010581a <get_disk_page_directory>
f0105288:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010528b:	8b 45 08             	mov    0x8(%ebp),%eax
f010528e:	8b 40 74             	mov    0x74(%eax),%eax
f0105291:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0105294:	52                   	push   %edx
f0105295:	6a 01                	push   $0x1
f0105297:	ff 75 0c             	pushl  0xc(%ebp)
f010529a:	50                   	push   %eax
f010529b:	e8 64 fd ff ff       	call   f0105004 <get_disk_page_table>
f01052a0:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01052a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01052a6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01052a9:	c1 ea 0c             	shr    $0xc,%edx
f01052ac:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01052b2:	c1 e2 02             	shl    $0x2,%edx
f01052b5:	01 d0                	add    %edx,%eax
f01052b7:	8b 00                	mov    (%eax),%eax
f01052b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01052bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01052bf:	85 c0                	test   %eax,%eax
f01052c1:	75 34                	jne    f01052f7 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01052c3:	83 ec 0c             	sub    $0xc,%esp
f01052c6:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01052c9:	50                   	push   %eax
f01052ca:	e8 16 fb ff ff       	call   f0104de5 <allocate_disk_frame>
f01052cf:	83 c4 10             	add    $0x10,%esp
f01052d2:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01052d5:	75 07                	jne    f01052de <pf_add_env_page+0x90>
f01052d7:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01052dc:	eb 31                	jmp    f010530f <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01052de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01052e1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01052e4:	c1 ea 0c             	shr    $0xc,%edx
f01052e7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01052ed:	c1 e2 02             	shl    $0x2,%edx
f01052f0:	01 c2                	add    %eax,%edx
f01052f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01052f5:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01052f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01052fa:	83 ec 08             	sub    $0x8,%esp
f01052fd:	ff 75 10             	pushl  0x10(%ebp)
f0105300:	50                   	push   %eax
f0105301:	e8 e1 f8 ff ff       	call   f0104be7 <write_disk_page>
f0105306:	83 c4 10             	add    $0x10,%esp
f0105309:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f010530c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010530f:	c9                   	leave  
f0105310:	c3                   	ret    

f0105311 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f0105311:	55                   	push   %ebp
f0105312:	89 e5                	mov    %esp,%ebp
f0105314:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f0105317:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010531e:	76 19                	jbe    f0105339 <pf_update_env_page+0x28>
f0105320:	68 bc 6c 13 f0       	push   $0xf0136cbc
f0105325:	68 e2 6c 13 f0       	push   $0xf0136ce2
f010532a:	68 15 01 00 00       	push   $0x115
f010532f:	68 17 6c 13 f0       	push   $0xf0136c17
f0105334:	e8 76 bb ff ff       	call   f0100eaf <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0105339:	8b 45 08             	mov    0x8(%ebp),%eax
f010533c:	83 c0 74             	add    $0x74,%eax
f010533f:	83 ec 08             	sub    $0x8,%esp
f0105342:	50                   	push   %eax
f0105343:	ff 75 08             	pushl  0x8(%ebp)
f0105346:	e8 cf 04 00 00       	call   f010581a <get_disk_page_directory>
f010534b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 74             	mov    0x74(%eax),%eax
f0105354:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0105357:	52                   	push   %edx
f0105358:	6a 00                	push   $0x0
f010535a:	ff 75 0c             	pushl  0xc(%ebp)
f010535d:	50                   	push   %eax
f010535e:	e8 a1 fc ff ff       	call   f0105004 <get_disk_page_table>
f0105363:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0105366:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105369:	85 c0                	test   %eax,%eax
f010536b:	74 29                	je     f0105396 <pf_update_env_page+0x85>
f010536d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105370:	85 c0                	test   %eax,%eax
f0105372:	0f 84 bf 00 00 00    	je     f0105437 <pf_update_env_page+0x126>
f0105378:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010537b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010537e:	c1 ea 0c             	shr    $0xc,%edx
f0105381:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105387:	c1 e2 02             	shl    $0x2,%edx
f010538a:	01 d0                	add    %edx,%eax
f010538c:	8b 00                	mov    (%eax),%eax
f010538e:	85 c0                	test   %eax,%eax
f0105390:	0f 85 a1 00 00 00    	jne    f0105437 <pf_update_env_page+0x126>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0105396:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105399:	85 c0                	test   %eax,%eax
f010539b:	79 09                	jns    f01053a6 <pf_update_env_page+0x95>
f010539d:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f01053a4:	76 30                	jbe    f01053d6 <pf_update_env_page+0xc5>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01053a6:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f01053ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01053b0:	2d 01 30 fe 5f       	sub    $0x5ffe3001,%eax
f01053b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01053b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01053bb:	ba 00 00 00 00       	mov    $0x0,%edx
f01053c0:	f7 75 f4             	divl   -0xc(%ebp)
f01053c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01053c6:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f01053c8:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01053cb:	77 53                	ja     f0105420 <pf_update_env_page+0x10f>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01053cd:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f01053d4:	77 4a                	ja     f0105420 <pf_update_env_page+0x10f>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f01053d6:	83 ec 04             	sub    $0x4,%esp
f01053d9:	6a 00                	push   $0x0
f01053db:	ff 75 0c             	pushl  0xc(%ebp)
f01053de:	ff 75 08             	pushl  0x8(%ebp)
f01053e1:	e8 3a fd ff ff       	call   f0105120 <pf_add_empty_env_page>
f01053e6:	83 c4 10             	add    $0x10,%esp
f01053e9:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01053ec:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f01053f0:	75 17                	jne    f0105409 <pf_update_env_page+0xf8>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01053f2:	83 ec 04             	sub    $0x4,%esp
f01053f5:	68 f8 6c 13 f0       	push   $0xf0136cf8
f01053fa:	68 45 01 00 00       	push   $0x145
f01053ff:	68 17 6c 13 f0       	push   $0xf0136c17
f0105404:	e8 a6 ba ff ff       	call   f0100eaf <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f0105409:	8b 45 08             	mov    0x8(%ebp),%eax
f010540c:	8b 80 9c 06 00 00    	mov    0x69c(%eax),%eax
f0105412:	8d 50 01             	lea    0x1(%eax),%edx
f0105415:	8b 45 08             	mov    0x8(%ebp),%eax
f0105418:	89 90 9c 06 00 00    	mov    %edx,0x69c(%eax)
f010541e:	eb 17                	jmp    f0105437 <pf_update_env_page+0x126>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f0105420:	83 ec 04             	sub    $0x4,%esp
f0105423:	68 44 6d 13 f0       	push   $0xf0136d44
f0105428:	68 4e 01 00 00       	push   $0x14e
f010542d:	68 17 6c 13 f0       	push   $0xf0136c17
f0105432:	e8 78 ba ff ff       	call   f0100eaf <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0105437:	8b 45 08             	mov    0x8(%ebp),%eax
f010543a:	8b 40 74             	mov    0x74(%eax),%eax
f010543d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0105440:	52                   	push   %edx
f0105441:	6a 00                	push   $0x0
f0105443:	ff 75 0c             	pushl  0xc(%ebp)
f0105446:	50                   	push   %eax
f0105447:	e8 b8 fb ff ff       	call   f0105004 <get_disk_page_table>
f010544c:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010544f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105452:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105455:	c1 ea 0c             	shr    $0xc,%edx
f0105458:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010545e:	c1 e2 02             	shl    $0x2,%edx
f0105461:	01 d0                	add    %edx,%eax
f0105463:	8b 00                	mov    (%eax),%eax
f0105465:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'25 (el7): instead of using a TEMP location to update, use the given virtual_address
		// even if it's not present (e.g. in LRU 2nd list), temporarily set its PRESENT to 1
		//1. Get current permissions
		uint32 *ptrTable ;
		get_page_table(ptr_env->env_page_directory, virtual_address, &ptrTable);
f0105468:	8b 45 08             	mov    0x8(%ebp),%eax
f010546b:	8b 40 64             	mov    0x64(%eax),%eax
f010546e:	83 ec 04             	sub    $0x4,%esp
f0105471:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0105474:	52                   	push   %edx
f0105475:	ff 75 0c             	pushl  0xc(%ebp)
f0105478:	50                   	push   %eax
f0105479:	e8 e9 43 00 00       	call   f0109867 <get_page_table>
f010547e:	83 c4 10             	add    $0x10,%esp
		uint32 origPerms = ptrTable[PTX(virtual_address)] & 0xFFF;
f0105481:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0105484:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105487:	c1 ea 0c             	shr    $0xc,%edx
f010548a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105490:	c1 e2 02             	shl    $0x2,%edx
f0105493:	01 d0                	add    %edx,%eax
f0105495:	8b 00                	mov    (%eax),%eax
f0105497:	25 ff 0f 00 00       	and    $0xfff,%eax
f010549c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//2. If NOT PRESENT, temporarily set its PRESENT
		if ((origPerms & PERM_PRESENT) == 0)
f010549f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01054a2:	83 e0 01             	and    $0x1,%eax
f01054a5:	85 c0                	test   %eax,%eax
f01054a7:	75 2f                	jne    f01054d8 <pf_update_env_page+0x1c7>
		{
			ptrTable[PTX(virtual_address)] |= PERM_PRESENT ;
f01054a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01054ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054af:	c1 ea 0c             	shr    $0xc,%edx
f01054b2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01054b8:	c1 e2 02             	shl    $0x2,%edx
f01054bb:	01 d0                	add    %edx,%eax
f01054bd:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01054c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01054c3:	c1 e9 0c             	shr    $0xc,%ecx
f01054c6:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f01054cc:	c1 e1 02             	shl    $0x2,%ecx
f01054cf:	01 ca                	add    %ecx,%edx
f01054d1:	8b 12                	mov    (%edx),%edx
f01054d3:	83 ca 01             	or     $0x1,%edx
f01054d6:	89 10                	mov    %edx,(%eax)
		}
		//3. Write the disk page
		ret = write_disk_page(dfn, (void*)ROUNDDOWN(virtual_address, PAGE_SIZE));
f01054d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01054db:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01054de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01054e1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01054e6:	83 ec 08             	sub    $0x8,%esp
f01054e9:	50                   	push   %eax
f01054ea:	ff 75 e8             	pushl  -0x18(%ebp)
f01054ed:	e8 f5 f6 ff ff       	call   f0104be7 <write_disk_page>
f01054f2:	83 c4 10             	add    $0x10,%esp
f01054f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//4. Restore the original permissions
		ptrTable[PTX(virtual_address)] &= 0xFFFFF000 ;
f01054f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01054fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054fe:	c1 ea 0c             	shr    $0xc,%edx
f0105501:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105507:	c1 e2 02             	shl    $0x2,%edx
f010550a:	01 d0                	add    %edx,%eax
f010550c:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010550f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0105512:	c1 e9 0c             	shr    $0xc,%ecx
f0105515:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010551b:	c1 e1 02             	shl    $0x2,%ecx
f010551e:	01 ca                	add    %ecx,%edx
f0105520:	8b 12                	mov    (%edx),%edx
f0105522:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0105528:	89 10                	mov    %edx,(%eax)
		ptrTable[PTX(virtual_address)] |= origPerms ;
f010552a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010552d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105530:	c1 ea 0c             	shr    $0xc,%edx
f0105533:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105539:	c1 e2 02             	shl    $0x2,%edx
f010553c:	01 c2                	add    %eax,%edx
f010553e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0105541:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0105544:	c1 e9 0c             	shr    $0xc,%ecx
f0105547:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010554d:	c1 e1 02             	shl    $0x2,%ecx
f0105550:	01 c8                	add    %ecx,%eax
f0105552:	8b 00                	mov    (%eax),%eax
f0105554:	0b 45 e4             	or     -0x1c(%ebp),%eax
f0105557:	89 02                	mov    %eax,(%edx)
		//5. Clear modified bit
		ptrTable[PTX(virtual_address)] &= ~PERM_MODIFIED;
f0105559:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010555c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010555f:	c1 ea 0c             	shr    $0xc,%edx
f0105562:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105568:	c1 e2 02             	shl    $0x2,%edx
f010556b:	01 d0                	add    %edx,%eax
f010556d:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105570:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0105573:	c1 e9 0c             	shr    $0xc,%ecx
f0105576:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010557c:	c1 e1 02             	shl    $0x2,%ecx
f010557f:	01 ca                	add    %ecx,%edx
f0105581:	8b 12                	mov    (%edx),%edx
f0105583:	83 e2 bf             	and    $0xffffffbf,%edx
f0105586:	89 10                	mov    %edx,(%eax)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f0105588:	8b 45 08             	mov    0x8(%ebp),%eax
f010558b:	8b 80 98 06 00 00    	mov    0x698(%eax),%eax
f0105591:	8d 50 01             	lea    0x1(%eax),%edx
f0105594:	8b 45 08             	mov    0x8(%ebp),%eax
f0105597:	89 90 98 06 00 00    	mov    %edx,0x698(%eax)
	//======================

	return ret;
f010559d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01055a0:	c9                   	leave  
f01055a1:	c3                   	ret    

f01055a2 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01055a2:	55                   	push   %ebp
f01055a3:	89 e5                	mov    %esp,%ebp
f01055a5:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01055a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01055ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01055ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01055b6:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01055b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01055bc:	8b 40 74             	mov    0x74(%eax),%eax
f01055bf:	85 c0                	test   %eax,%eax
f01055c1:	75 0a                	jne    f01055cd <pf_read_env_page+0x2b>
f01055c3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01055c8:	e9 90 00 00 00       	jmp    f010565d <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01055cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01055d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01055d3:	8b 40 74             	mov    0x74(%eax),%eax
f01055d6:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f01055d9:	51                   	push   %ecx
f01055da:	6a 00                	push   $0x0
f01055dc:	52                   	push   %edx
f01055dd:	50                   	push   %eax
f01055de:	e8 21 fa ff ff       	call   f0105004 <get_disk_page_table>
f01055e3:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01055e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01055e9:	85 c0                	test   %eax,%eax
f01055eb:	75 07                	jne    f01055f4 <pf_read_env_page+0x52>
f01055ed:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01055f2:	eb 69                	jmp    f010565d <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01055f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01055f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01055fa:	c1 ea 0c             	shr    $0xc,%edx
f01055fd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105603:	c1 e2 02             	shl    $0x2,%edx
f0105606:	01 d0                	add    %edx,%eax
f0105608:	8b 00                	mov    (%eax),%eax
f010560a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010560d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105611:	75 07                	jne    f010561a <pf_read_env_page+0x78>
f0105613:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0105618:	eb 43                	jmp    f010565d <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010561a:	83 ec 08             	sub    $0x8,%esp
f010561d:	ff 75 0c             	pushl  0xc(%ebp)
f0105620:	ff 75 f0             	pushl  -0x10(%ebp)
f0105623:	e8 90 f5 ff ff       	call   f0104bb8 <read_disk_page>
f0105628:	83 c4 10             	add    $0x10,%esp
f010562b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f010562e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105631:	8b 45 08             	mov    0x8(%ebp),%eax
f0105634:	8b 40 64             	mov    0x64(%eax),%eax
f0105637:	6a 40                	push   $0x40
f0105639:	6a 00                	push   $0x0
f010563b:	52                   	push   %edx
f010563c:	50                   	push   %eax
f010563d:	e8 1a 5f 00 00       	call   f010b55c <pt_set_page_permissions>
f0105642:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0105645:	8b 45 08             	mov    0x8(%ebp),%eax
f0105648:	8b 80 94 06 00 00    	mov    0x694(%eax),%eax
f010564e:	8d 50 01             	lea    0x1(%eax),%edx
f0105651:	8b 45 08             	mov    0x8(%ebp),%eax
f0105654:	89 90 94 06 00 00    	mov    %edx,0x694(%eax)
	//======================

	return disk_read_error;
f010565a:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010565d:	c9                   	leave  
f010565e:	c3                   	ret    

f010565f <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f010565f:	55                   	push   %ebp
f0105660:	89 e5                	mov    %esp,%ebp
f0105662:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0105665:	8b 45 08             	mov    0x8(%ebp),%eax
f0105668:	8b 40 74             	mov    0x74(%eax),%eax
f010566b:	85 c0                	test   %eax,%eax
f010566d:	74 62                	je     f01056d1 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010566f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105672:	8b 40 74             	mov    0x74(%eax),%eax
f0105675:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0105678:	52                   	push   %edx
f0105679:	6a 00                	push   $0x0
f010567b:	ff 75 0c             	pushl  0xc(%ebp)
f010567e:	50                   	push   %eax
f010567f:	e8 80 f9 ff ff       	call   f0105004 <get_disk_page_table>
f0105684:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f0105687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010568a:	85 c0                	test   %eax,%eax
f010568c:	74 46                	je     f01056d4 <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010568e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105691:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105694:	c1 ea 0c             	shr    $0xc,%edx
f0105697:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010569d:	c1 e2 02             	shl    $0x2,%edx
f01056a0:	01 d0                	add    %edx,%eax
f01056a2:	8b 00                	mov    (%eax),%eax
f01056a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01056a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01056aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01056ad:	c1 ea 0c             	shr    $0xc,%edx
f01056b0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01056b6:	c1 e2 02             	shl    $0x2,%edx
f01056b9:	01 d0                	add    %edx,%eax
f01056bb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01056c1:	83 ec 0c             	sub    $0xc,%esp
f01056c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01056c7:	e8 07 f8 ff ff       	call   f0104ed3 <free_disk_frame>
f01056cc:	83 c4 10             	add    $0x10,%esp
f01056cf:	eb 04                	jmp    f01056d5 <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01056d1:	90                   	nop
f01056d2:	eb 01                	jmp    f01056d5 <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f01056d4:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f01056d5:	c9                   	leave  
f01056d6:	c3                   	ret    

f01056d7 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f01056d7:	55                   	push   %ebp
f01056d8:	89 e5                	mov    %esp,%ebp
f01056da:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01056dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01056e4:	e9 b8 00 00 00       	jmp    f01057a1 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f01056e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01056ec:	8b 40 74             	mov    0x74(%eax),%eax
f01056ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01056f2:	c1 e2 02             	shl    $0x2,%edx
f01056f5:	01 d0                	add    %edx,%eax
f01056f7:	8b 00                	mov    (%eax),%eax
f01056f9:	83 e0 01             	and    $0x1,%eax
f01056fc:	85 c0                	test   %eax,%eax
f01056fe:	0f 84 99 00 00 00    	je     f010579d <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0105704:	8b 45 08             	mov    0x8(%ebp),%eax
f0105707:	8b 40 74             	mov    0x74(%eax),%eax
f010570a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010570d:	c1 e2 02             	shl    $0x2,%edx
f0105710:	01 d0                	add    %edx,%eax
f0105712:	8b 00                	mov    (%eax),%eax
f0105714:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0105719:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010571c:	83 ec 0c             	sub    $0xc,%esp
f010571f:	ff 75 ec             	pushl  -0x14(%ebp)
f0105722:	e8 f9 5c 00 00       	call   f010b420 <kheap_virtual_address>
f0105727:	83 c4 10             	add    $0x10,%esp
f010572a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010572d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105734:	eb 3a                	jmp    f0105770 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0105736:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105739:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105740:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105743:	01 d0                	add    %edx,%eax
f0105745:	8b 00                	mov    (%eax),%eax
f0105747:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010574a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010574d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105754:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105757:	01 d0                	add    %edx,%eax
f0105759:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105765:	e8 69 f7 ff ff       	call   f0104ed3 <free_disk_frame>
f010576a:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010576d:	ff 45 f0             	incl   -0x10(%ebp)
f0105770:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f0105777:	76 bd                	jbe    f0105736 <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f0105779:	8b 45 08             	mov    0x8(%ebp),%eax
f010577c:	8b 40 74             	mov    0x74(%eax),%eax
f010577f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105782:	c1 e2 02             	shl    $0x2,%edx
f0105785:	01 d0                	add    %edx,%eax
f0105787:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f010578d:	83 ec 0c             	sub    $0xc,%esp
f0105790:	ff 75 e8             	pushl  -0x18(%ebp)
f0105793:	e8 bb 5a 00 00       	call   f010b253 <kfree>
f0105798:	83 c4 10             	add    $0x10,%esp
f010579b:	eb 01                	jmp    f010579e <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f010579d:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010579e:	ff 45 f4             	incl   -0xc(%ebp)
f01057a1:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01057a8:	0f 86 3b ff ff ff    	jbe    f01056e9 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01057ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b1:	8b 40 74             	mov    0x74(%eax),%eax
f01057b4:	83 ec 0c             	sub    $0xc,%esp
f01057b7:	50                   	push   %eax
f01057b8:	e8 96 5a 00 00       	call   f010b253 <kfree>
f01057bd:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f01057c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c3:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01057ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01057cd:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f01057d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01057d7:	8b 40 7c             	mov    0x7c(%eax),%eax
f01057da:	85 c0                	test   %eax,%eax
f01057dc:	74 39                	je     f0105817 <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f01057de:	83 ec 0c             	sub    $0xc,%esp
f01057e1:	ff 75 08             	pushl  0x8(%ebp)
f01057e4:	e8 f1 02 00 00       	call   f0105ada <__pf_remove_env_all_tables>
f01057e9:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f01057ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01057ef:	8b 40 7c             	mov    0x7c(%eax),%eax
f01057f2:	83 ec 0c             	sub    $0xc,%esp
f01057f5:	50                   	push   %eax
f01057f6:	e8 58 5a 00 00       	call   f010b253 <kfree>
f01057fb:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f01057fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0105801:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f0105808:	8b 45 08             	mov    0x8(%ebp),%eax
f010580b:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0105812:	00 00 00 
f0105815:	eb 01                	jmp    f0105818 <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f0105817:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f0105818:	c9                   	leave  
f0105819:	c3                   	ret    

f010581a <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010581a:	55                   	push   %ebp
f010581b:	89 e5                	mov    %esp,%ebp
f010581d:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0105820:	8b 45 08             	mov    0x8(%ebp),%eax
f0105823:	8b 50 74             	mov    0x74(%eax),%edx
f0105826:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105829:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f010582b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010582e:	8b 00                	mov    (%eax),%eax
f0105830:	85 c0                	test   %eax,%eax
f0105832:	75 58                	jne    f010588c <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f0105834:	83 ec 0c             	sub    $0xc,%esp
f0105837:	68 00 10 00 00       	push   $0x1000
f010583c:	e8 91 56 00 00       	call   f010aed2 <kmalloc>
f0105841:	83 c4 10             	add    $0x10,%esp
f0105844:	89 c2                	mov    %eax,%edx
f0105846:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105849:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f010584b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010584e:	8b 00                	mov    (%eax),%eax
f0105850:	85 c0                	test   %eax,%eax
f0105852:	75 07                	jne    f010585b <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f0105854:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0105859:	eb 36                	jmp    f0105891 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f010585b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010585e:	8b 00                	mov    (%eax),%eax
f0105860:	83 ec 0c             	sub    $0xc,%esp
f0105863:	50                   	push   %eax
f0105864:	e8 23 5c 00 00       	call   f010b48c <kheap_physical_address>
f0105869:	83 c4 10             	add    $0x10,%esp
f010586c:	89 c2                	mov    %eax,%edx
f010586e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105871:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f0105874:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105877:	8b 00                	mov    (%eax),%eax
f0105879:	83 ec 04             	sub    $0x4,%esp
f010587c:	68 00 10 00 00       	push   $0x1000
f0105881:	6a 00                	push   $0x0
f0105883:	50                   	push   %eax
f0105884:	e8 94 d7 01 00       	call   f012301d <memset>
f0105889:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010588c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105891:	c9                   	leave  
f0105892:	c3                   	ret    

f0105893 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0105893:	55                   	push   %ebp
f0105894:	89 e5                	mov    %esp,%ebp
f0105896:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0105899:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01058a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01058a7:	eb 78                	jmp    f0105921 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f01058a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01058ac:	8b 40 74             	mov    0x74(%eax),%eax
f01058af:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058b2:	c1 e2 02             	shl    $0x2,%edx
f01058b5:	01 d0                	add    %edx,%eax
f01058b7:	8b 00                	mov    (%eax),%eax
f01058b9:	83 e0 01             	and    $0x1,%eax
f01058bc:	85 c0                	test   %eax,%eax
f01058be:	74 5d                	je     f010591d <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01058c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01058c3:	8b 40 74             	mov    0x74(%eax),%eax
f01058c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058c9:	c1 e2 02             	shl    $0x2,%edx
f01058cc:	01 d0                	add    %edx,%eax
f01058ce:	8b 00                	mov    (%eax),%eax
f01058d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01058d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f01058d8:	83 ec 0c             	sub    $0xc,%esp
f01058db:	ff 75 e8             	pushl  -0x18(%ebp)
f01058de:	e8 3d 5b 00 00       	call   f010b420 <kheap_virtual_address>
f01058e3:	83 c4 10             	add    $0x10,%esp
f01058e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// count existing PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01058e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058f0:	eb 20                	jmp    f0105912 <pf_calculate_allocated_pages+0x7f>
		{
			uint32 dfn=pt[ptIndex];
f01058f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01058f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01058fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01058ff:	01 d0                	add    %edx,%eax
f0105901:	8b 00                	mov    (%eax),%eax
f0105903:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0105906:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010590a:	74 03                	je     f010590f <pf_calculate_allocated_pages+0x7c>
				counter ++;
f010590c:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// count existing PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010590f:	ff 45 ec             	incl   -0x14(%ebp)
f0105912:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0105919:	76 d7                	jbe    f01058f2 <pf_calculate_allocated_pages+0x5f>
f010591b:	eb 01                	jmp    f010591e <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010591d:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010591e:	ff 45 f4             	incl   -0xc(%ebp)
f0105921:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0105928:	0f 86 7b ff ff ff    	jbe    f01058a9 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f010592e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0105931:	c9                   	leave  
f0105932:	c3                   	ret    

f0105933 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0105933:	55                   	push   %ebp
f0105934:	89 e5                	mov    %esp,%ebp
f0105936:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0105939:	83 ec 0c             	sub    $0xc,%esp
f010593c:	68 90 53 96 f1       	push   $0xf1965390
f0105941:	e8 ff db 00 00       	call   f0113545 <acquire_kspinlock>
f0105946:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0105949:	a1 8c 53 96 f1       	mov    0xf196538c,%eax
f010594e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0105951:	83 ec 0c             	sub    $0xc,%esp
f0105954:	68 90 53 96 f1       	push   $0xf1965390
f0105959:	e8 8c dc 00 00       	call   f01135ea <release_kspinlock>
f010595e:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0105961:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0105964:	c9                   	leave  
f0105965:	c3                   	ret    

f0105966 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0105966:	55                   	push   %ebp
f0105967:	89 e5                	mov    %esp,%ebp
f0105969:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f010596c:	8b 45 08             	mov    0x8(%ebp),%eax
f010596f:	8b 50 7c             	mov    0x7c(%eax),%edx
f0105972:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105975:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0105977:	8b 45 0c             	mov    0xc(%ebp),%eax
f010597a:	8b 00                	mov    (%eax),%eax
f010597c:	85 c0                	test   %eax,%eax
f010597e:	75 5b                	jne    f01059db <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0105980:	83 ec 0c             	sub    $0xc,%esp
f0105983:	68 00 10 00 00       	push   $0x1000
f0105988:	e8 45 55 00 00       	call   f010aed2 <kmalloc>
f010598d:	83 c4 10             	add    $0x10,%esp
f0105990:	89 c2                	mov    %eax,%edx
f0105992:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105995:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f0105997:	8b 45 0c             	mov    0xc(%ebp),%eax
f010599a:	8b 00                	mov    (%eax),%eax
f010599c:	85 c0                	test   %eax,%eax
f010599e:	75 07                	jne    f01059a7 <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f01059a0:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01059a5:	eb 39                	jmp    f01059e0 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f01059a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01059aa:	8b 00                	mov    (%eax),%eax
f01059ac:	83 ec 0c             	sub    $0xc,%esp
f01059af:	50                   	push   %eax
f01059b0:	e8 d7 5a 00 00       	call   f010b48c <kheap_physical_address>
f01059b5:	83 c4 10             	add    $0x10,%esp
f01059b8:	89 c2                	mov    %eax,%edx
f01059ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01059bd:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01059c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01059c6:	8b 00                	mov    (%eax),%eax
f01059c8:	83 ec 04             	sub    $0x4,%esp
f01059cb:	68 00 10 00 00       	push   $0x1000
f01059d0:	6a 00                	push   $0x0
f01059d2:	50                   	push   %eax
f01059d3:	e8 45 d6 01 00       	call   f012301d <memset>
f01059d8:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01059db:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01059e0:	c9                   	leave  
f01059e1:	c3                   	ret    

f01059e2 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01059e2:	55                   	push   %ebp
f01059e3:	89 e5                	mov    %esp,%ebp
f01059e5:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f01059e8:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01059ef:	76 19                	jbe    f0105a0a <__pf_write_env_table+0x28>
f01059f1:	68 bc 6c 13 f0       	push   $0xf0136cbc
f01059f6:	68 e2 6c 13 f0       	push   $0xf0136ce2
f01059fb:	68 ac 02 00 00       	push   $0x2ac
f0105a00:	68 17 6c 13 f0       	push   $0xf0136c17
f0105a05:	e8 a5 b4 ff ff       	call   f0100eaf <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0105a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a0d:	83 c0 7c             	add    $0x7c,%eax
f0105a10:	83 ec 08             	sub    $0x8,%esp
f0105a13:	50                   	push   %eax
f0105a14:	ff 75 08             	pushl  0x8(%ebp)
f0105a17:	e8 4a ff ff ff       	call   f0105966 <get_disk_table_directory>
f0105a1c:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105a1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a22:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a25:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a28:	c1 ea 16             	shr    $0x16,%edx
f0105a2b:	c1 e2 02             	shl    $0x2,%edx
f0105a2e:	01 d0                	add    %edx,%eax
f0105a30:	8b 00                	mov    (%eax),%eax
f0105a32:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0105a35:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105a38:	85 c0                	test   %eax,%eax
f0105a3a:	75 31                	jne    f0105a6d <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0105a3c:	83 ec 0c             	sub    $0xc,%esp
f0105a3f:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0105a42:	50                   	push   %eax
f0105a43:	e8 9d f3 ff ff       	call   f0104de5 <allocate_disk_frame>
f0105a48:	83 c4 10             	add    $0x10,%esp
f0105a4b:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0105a4e:	75 07                	jne    f0105a57 <__pf_write_env_table+0x75>
f0105a50:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0105a55:	eb 2e                	jmp    f0105a85 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0105a57:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a5a:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a5d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a60:	c1 ea 16             	shr    $0x16,%edx
f0105a63:	c1 e2 02             	shl    $0x2,%edx
f0105a66:	01 c2                	add    %eax,%edx
f0105a68:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105a6b:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0105a6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105a70:	83 ec 08             	sub    $0x8,%esp
f0105a73:	ff 75 10             	pushl  0x10(%ebp)
f0105a76:	50                   	push   %eax
f0105a77:	e8 6b f1 ff ff       	call   f0104be7 <write_disk_page>
f0105a7c:	83 c4 10             	add    $0x10,%esp
f0105a7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0105a82:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0105a85:	c9                   	leave  
f0105a86:	c3                   	ret    

f0105a87 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0105a87:	55                   	push   %ebp
f0105a88:	89 e5                	mov    %esp,%ebp
f0105a8a:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0105a8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a90:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a93:	85 c0                	test   %eax,%eax
f0105a95:	75 07                	jne    f0105a9e <__pf_read_env_table+0x17>
f0105a97:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0105a9c:	eb 3a                	jmp    f0105ad8 <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105a9e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105aa1:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105aa4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105aa7:	c1 ea 16             	shr    $0x16,%edx
f0105aaa:	c1 e2 02             	shl    $0x2,%edx
f0105aad:	01 d0                	add    %edx,%eax
f0105aaf:	8b 00                	mov    (%eax),%eax
f0105ab1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0105ab4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ab8:	75 07                	jne    f0105ac1 <__pf_read_env_table+0x3a>
f0105aba:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0105abf:	eb 17                	jmp    f0105ad8 <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0105ac1:	83 ec 08             	sub    $0x8,%esp
f0105ac4:	ff 75 10             	pushl  0x10(%ebp)
f0105ac7:	ff 75 f4             	pushl  -0xc(%ebp)
f0105aca:	e8 e9 f0 ff ff       	call   f0104bb8 <read_disk_page>
f0105acf:	83 c4 10             	add    $0x10,%esp
f0105ad2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0105ad5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0105ad8:	c9                   	leave  
f0105ad9:	c3                   	ret    

f0105ada <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0105ada:	55                   	push   %ebp
f0105adb:	89 e5                	mov    %esp,%ebp
f0105add:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0105ae0:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ae3:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105ae6:	85 c0                	test   %eax,%eax
f0105ae8:	74 4c                	je     f0105b36 <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105aea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105af1:	eb 38                	jmp    f0105b2b <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0105af3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105af6:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105af9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105afc:	c1 e2 02             	shl    $0x2,%edx
f0105aff:	01 d0                	add    %edx,%eax
f0105b01:	8b 00                	mov    (%eax),%eax
f0105b03:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0105b06:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b09:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105b0f:	c1 e2 02             	shl    $0x2,%edx
f0105b12:	01 d0                	add    %edx,%eax
f0105b14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0105b1a:	83 ec 0c             	sub    $0xc,%esp
f0105b1d:	ff 75 f0             	pushl  -0x10(%ebp)
f0105b20:	e8 ae f3 ff ff       	call   f0104ed3 <free_disk_frame>
f0105b25:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105b28:	ff 45 f4             	incl   -0xc(%ebp)
f0105b2b:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0105b32:	76 bf                	jbe    f0105af3 <__pf_remove_env_all_tables+0x19>
f0105b34:	eb 01                	jmp    f0105b37 <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0105b36:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0105b37:	c9                   	leave  
f0105b38:	c3                   	ret    

f0105b39 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0105b39:	55                   	push   %ebp
f0105b3a:	89 e5                	mov    %esp,%ebp
f0105b3c:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0105b3f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105b43:	75 10                	jne    f0105b55 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0105b45:	83 ec 0c             	sub    $0xc,%esp
f0105b48:	68 c0 6d 13 f0       	push   $0xf0136dc0
f0105b4d:	e8 fb bf ff ff       	call   f0101b4d <cprintf>
f0105b52:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0105b55:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b58:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b5b:	85 c0                	test   %eax,%eax
f0105b5d:	74 3d                	je     f0105b9c <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105b5f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b62:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b65:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105b68:	c1 ea 16             	shr    $0x16,%edx
f0105b6b:	c1 e2 02             	shl    $0x2,%edx
f0105b6e:	01 d0                	add    %edx,%eax
f0105b70:	8b 00                	mov    (%eax),%eax
f0105b72:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0105b75:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b78:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b7b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105b7e:	c1 ea 16             	shr    $0x16,%edx
f0105b81:	c1 e2 02             	shl    $0x2,%edx
f0105b84:	01 d0                	add    %edx,%eax
f0105b86:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0105b8c:	83 ec 0c             	sub    $0xc,%esp
f0105b8f:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b92:	e8 3c f3 ff ff       	call   f0104ed3 <free_disk_frame>
f0105b97:	83 c4 10             	add    $0x10,%esp
f0105b9a:	eb 01                	jmp    f0105b9d <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0105b9c:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0105b9d:	c9                   	leave  
f0105b9e:	c3                   	ret    

f0105b9f <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0105b9f:	55                   	push   %ebp
f0105ba0:	89 e5                	mov    %esp,%ebp
f0105ba2:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0105ba5:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0105bac:	eb 1f                	jmp    f0105bcd <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0105bae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb1:	83 ec 04             	sub    $0x4,%esp
f0105bb4:	6a 08                	push   $0x8
f0105bb6:	ff 75 08             	pushl  0x8(%ebp)
f0105bb9:	50                   	push   %eax
f0105bba:	e8 5c dc 01 00       	call   f012381b <ide_write>
f0105bbf:	83 c4 10             	add    $0x10,%esp
f0105bc2:	85 c0                	test   %eax,%eax
f0105bc4:	75 12                	jne    f0105bd8 <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0105bc6:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0105bcd:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0105bd4:	7e d8                	jle    f0105bae <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105bd6:	eb 01                	jmp    f0105bd9 <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0105bd8:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105bd9:	90                   	nop
f0105bda:	c9                   	leave  
f0105bdb:	c3                   	ret    

f0105bdc <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0105bdc:	55                   	push   %ebp
  pushl %eax
f0105bdd:	50                   	push   %eax
  pushl %ebx
f0105bde:	53                   	push   %ebx
  pushl %ecx
f0105bdf:	51                   	push   %ecx
  pushl %edx
f0105be0:	52                   	push   %edx
  pushl %esi
f0105be1:	56                   	push   %esi
  pushl %edi
f0105be2:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0105be3:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0105be7:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0105beb:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0105bed:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0105bef:	5f                   	pop    %edi
  popl %esi
f0105bf0:	5e                   	pop    %esi
  popl %edx
f0105bf1:	5a                   	pop    %edx
  popl %ecx
f0105bf2:	59                   	pop    %ecx
  popl %ebx
f0105bf3:	5b                   	pop    %ebx
  popl %eax
f0105bf4:	58                   	pop    %eax
  popl %ebp
f0105bf5:	5d                   	pop    %ebp
  ret
f0105bf6:	c3                   	ret    

f0105bf7 <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0105bf7:	55                   	push   %ebp
f0105bf8:	89 e5                	mov    %esp,%ebp
f0105bfa:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105bfd:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c00:	0f b6 c0             	movzbl %al,%eax
f0105c03:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105c0a:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105c0d:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105c10:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105c13:	ee                   	out    %al,(%dx)
f0105c14:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105c1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105c1e:	89 c2                	mov    %eax,%edx
f0105c20:	ec                   	in     (%dx),%al
f0105c21:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0105c24:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0105c27:	0f b6 c0             	movzbl %al,%eax
}
f0105c2a:	c9                   	leave  
f0105c2b:	c3                   	ret    

f0105c2c <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0105c2c:	55                   	push   %ebp
f0105c2d:	89 e5                	mov    %esp,%ebp
f0105c2f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105c32:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c35:	0f b6 c0             	movzbl %al,%eax
f0105c38:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105c3f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105c42:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105c45:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105c48:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0105c49:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105c4c:	0f b6 c0             	movzbl %al,%eax
f0105c4f:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0105c56:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105c59:	8a 45 f7             	mov    -0x9(%ebp),%al
f0105c5c:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0105c5f:	ee                   	out    %al,(%dx)
}
f0105c60:	90                   	nop
f0105c61:	c9                   	leave  
f0105c62:	c3                   	ret    

f0105c63 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0105c63:	55                   	push   %ebp
f0105c64:	89 e5                	mov    %esp,%ebp
f0105c66:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0105c69:	c7 05 c8 52 96 f1 00 	movl   $0x0,0xf19652c8
f0105c70:	00 00 00 
f0105c73:	c7 05 cc 52 96 f1 00 	movl   $0x0,0xf19652cc
f0105c7a:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0105c7d:	83 ec 08             	sub    $0x8,%esp
f0105c80:	68 e0 7e 10 f0       	push   $0xf0107ee0
f0105c85:	6a 00                	push   $0x0
f0105c87:	e8 01 a3 00 00       	call   f010ff8d <irq_install_handler>
f0105c8c:	83 c4 10             	add    $0x10,%esp
}
f0105c8f:	90                   	nop
f0105c90:	c9                   	leave  
f0105c91:	c3                   	ret    

f0105c92 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0105c92:	55                   	push   %ebp
f0105c93:	89 e5                	mov    %esp,%ebp
f0105c95:	53                   	push   %ebx
f0105c96:	83 ec 24             	sub    $0x24,%esp
f0105c99:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c9c:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105c9f:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105ca6:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105caa:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105cad:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105cb0:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105cb1:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105cb5:	77 48                	ja     f0105cff <kclock_start+0x6d>
f0105cb7:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105cbe:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0105cc2:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105cc5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cc8:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0105cc9:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105ccd:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105cd2:	99                   	cltd   
f0105cd3:	f7 fb                	idiv   %ebx
f0105cd5:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105cdb:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105cdf:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105ce4:	99                   	cltd   
f0105ce5:	f7 fb                	idiv   %ebx
f0105ce7:	89 c3                	mov    %eax,%ebx
f0105ce9:	89 c8                	mov    %ecx,%eax
f0105ceb:	99                   	cltd   
f0105cec:	f7 fb                	idiv   %ebx
f0105cee:	0f b7 c0             	movzwl %ax,%eax
f0105cf1:	83 ec 0c             	sub    $0xc,%esp
f0105cf4:	50                   	push   %eax
f0105cf5:	e8 b3 01 00 00       	call   f0105ead <kclock_write_cnt0_LSB_first>
f0105cfa:	83 c4 10             	add    $0x10,%esp
f0105cfd:	eb 13                	jmp    f0105d12 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105cff:	6a 35                	push   $0x35
f0105d01:	68 e4 6d 13 f0       	push   $0xf0136de4
f0105d06:	6a 41                	push   $0x41
f0105d08:	68 40 6e 13 f0       	push   $0xf0136e40
f0105d0d:	e8 9d b1 ff ff       	call   f0100eaf <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105d12:	83 ec 0c             	sub    $0xc,%esp
f0105d15:	6a 00                	push   $0x0
f0105d17:	e8 cb 26 00 00       	call   f01083e7 <irq_clear_mask>
f0105d1c:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0105d1f:	90                   	nop
f0105d20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105d23:	c9                   	leave  
f0105d24:	c3                   	ret    

f0105d25 <kclock_stop>:

void
kclock_stop(void)
{
f0105d25:	55                   	push   %ebp
f0105d26:	89 e5                	mov    %esp,%ebp
f0105d28:	83 ec 18             	sub    $0x18,%esp
f0105d2b:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105d32:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105d36:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105d3c:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0105d3d:	83 ec 0c             	sub    $0xc,%esp
f0105d40:	6a 00                	push   $0x0
f0105d42:	e8 2b 26 00 00       	call   f0108372 <irq_set_mask>
f0105d47:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0105d4a:	90                   	nop
f0105d4b:	c9                   	leave  
f0105d4c:	c3                   	ret    

f0105d4d <kclock_resume>:

void
kclock_resume(void)
{
f0105d4d:	55                   	push   %ebp
f0105d4e:	89 e5                	mov    %esp,%ebp
f0105d50:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0105d53:	e8 f5 01 00 00       	call   f0105f4d <kclock_read_cnt0_latch>
f0105d58:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0105d5c:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0105d61:	77 06                	ja     f0105d69 <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0105d63:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0105d69:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105d6d:	83 e0 01             	and    $0x1,%eax
f0105d70:	66 85 c0             	test   %ax,%ax
f0105d73:	74 09                	je     f0105d7e <kclock_resume+0x31>
		cnt0++;
f0105d75:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105d79:	40                   	inc    %eax
f0105d7a:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0105d7e:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105d85:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105d89:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105d8c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105d8f:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105d90:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0105d94:	83 ec 0c             	sub    $0xc,%esp
f0105d97:	50                   	push   %eax
f0105d98:	e8 10 01 00 00       	call   f0105ead <kclock_write_cnt0_LSB_first>
f0105d9d:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105da0:	83 ec 0c             	sub    $0xc,%esp
f0105da3:	6a 00                	push   $0x0
f0105da5:	e8 3d 26 00 00       	call   f01083e7 <irq_clear_mask>
f0105daa:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0105dad:	90                   	nop
f0105dae:	c9                   	leave  
f0105daf:	c3                   	ret    

f0105db0 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0105db0:	55                   	push   %ebp
f0105db1:	89 e5                	mov    %esp,%ebp
f0105db3:	83 ec 28             	sub    $0x28,%esp
f0105db6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105db9:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105dbc:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105dc3:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105dc7:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105dca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105dcd:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105dce:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0105dd2:	83 ec 0c             	sub    $0xc,%esp
f0105dd5:	50                   	push   %eax
f0105dd6:	e8 d2 00 00 00       	call   f0105ead <kclock_write_cnt0_LSB_first>
f0105ddb:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105dde:	83 ec 0c             	sub    $0xc,%esp
f0105de1:	6a 00                	push   $0x0
f0105de3:	e8 ff 25 00 00       	call   f01083e7 <irq_clear_mask>
f0105de8:	83 c4 10             	add    $0x10,%esp
}
f0105deb:	90                   	nop
f0105dec:	c9                   	leave  
f0105ded:	c3                   	ret    

f0105dee <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0105dee:	55                   	push   %ebp
f0105def:	89 e5                	mov    %esp,%ebp
f0105df1:	56                   	push   %esi
f0105df2:	53                   	push   %ebx
f0105df3:	83 ec 20             	sub    $0x20,%esp
f0105df6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105df9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105dfc:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105e00:	0f 87 8a 00 00 00    	ja     f0105e90 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0105e06:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105e0a:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105e0f:	99                   	cltd   
f0105e10:	f7 fe                	idiv   %esi
f0105e12:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105e18:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105e1c:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105e21:	99                   	cltd   
f0105e22:	f7 fb                	idiv   %ebx
f0105e24:	89 c6                	mov    %eax,%esi
f0105e26:	89 c8                	mov    %ecx,%eax
f0105e28:	99                   	cltd   
f0105e29:	f7 fe                	idiv   %esi
f0105e2b:	89 c3                	mov    %eax,%ebx
f0105e2d:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0105e31:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105e36:	99                   	cltd   
f0105e37:	f7 f9                	idiv   %ecx
f0105e39:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105e3f:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105e43:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105e48:	99                   	cltd   
f0105e49:	f7 fe                	idiv   %esi
f0105e4b:	89 c6                	mov    %eax,%esi
f0105e4d:	89 c8                	mov    %ecx,%eax
f0105e4f:	99                   	cltd   
f0105e50:	f7 fe                	idiv   %esi
f0105e52:	25 01 00 00 80       	and    $0x80000001,%eax
f0105e57:	85 c0                	test   %eax,%eax
f0105e59:	79 05                	jns    f0105e60 <kclock_set_quantum+0x72>
f0105e5b:	48                   	dec    %eax
f0105e5c:	83 c8 fe             	or     $0xfffffffe,%eax
f0105e5f:	40                   	inc    %eax
f0105e60:	01 d8                	add    %ebx,%eax
f0105e62:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e65:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105e6c:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105e70:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105e73:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105e76:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0105e77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e7a:	0f b7 c0             	movzwl %ax,%eax
f0105e7d:	83 ec 0c             	sub    $0xc,%esp
f0105e80:	50                   	push   %eax
f0105e81:	e8 27 00 00 00       	call   f0105ead <kclock_write_cnt0_LSB_first>
f0105e86:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0105e89:	e8 97 fe ff ff       	call   f0105d25 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105e8e:	eb 16                	jmp    f0105ea6 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105e90:	6a 35                	push   $0x35
f0105e92:	68 e4 6d 13 f0       	push   $0xf0136de4
f0105e97:	68 ea 00 00 00       	push   $0xea
f0105e9c:	68 40 6e 13 f0       	push   $0xf0136e40
f0105ea1:	e8 09 b0 ff ff       	call   f0100eaf <_panic>
	}
}
f0105ea6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0105ea9:	5b                   	pop    %ebx
f0105eaa:	5e                   	pop    %esi
f0105eab:	5d                   	pop    %ebp
f0105eac:	c3                   	ret    

f0105ead <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105ead:	55                   	push   %ebp
f0105eae:	89 e5                	mov    %esp,%ebp
f0105eb0:	83 ec 28             	sub    $0x28,%esp
f0105eb3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105eb6:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0105eba:	e8 03 27 00 00       	call   f01085c2 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105ebf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105ec2:	0f b6 c0             	movzbl %al,%eax
f0105ec5:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0105ecc:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105ecf:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105ed2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ed5:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105ed6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105ed9:	66 c1 e8 08          	shr    $0x8,%ax
f0105edd:	0f b6 c0             	movzbl %al,%eax
f0105ee0:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0105ee7:	88 45 ef             	mov    %al,-0x11(%ebp)
f0105eea:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105eed:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ef0:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105ef1:	e8 1e 27 00 00       	call   f0108614 <popcli>

}
f0105ef6:	90                   	nop
f0105ef7:	c9                   	leave  
f0105ef8:	c3                   	ret    

f0105ef9 <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0105ef9:	55                   	push   %ebp
f0105efa:	89 e5                	mov    %esp,%ebp
f0105efc:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105eff:	e8 be 26 00 00       	call   f01085c2 <pushcli>
f0105f04:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f0e:	89 c2                	mov    %eax,%edx
f0105f10:	ec                   	in     (%dx),%al
f0105f11:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105f14:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105f17:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105f1a:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f21:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105f24:	89 c2                	mov    %eax,%edx
f0105f26:	ec                   	in     (%dx),%al
f0105f27:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0105f2a:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105f2d:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105f30:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0105f34:	c1 e0 08             	shl    $0x8,%eax
f0105f37:	89 c2                	mov    %eax,%edx
f0105f39:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0105f3d:	09 d0                	or     %edx,%eax
f0105f3f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0105f43:	e8 cc 26 00 00       	call   f0108614 <popcli>
	return cnt0 ;
f0105f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105f4b:	c9                   	leave  
f0105f4c:	c3                   	ret    

f0105f4d <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0105f4d:	55                   	push   %ebp
f0105f4e:	89 e5                	mov    %esp,%ebp
f0105f50:	83 ec 30             	sub    $0x30,%esp
f0105f53:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105f5d:	89 c2                	mov    %eax,%edx
f0105f5f:	ec                   	in     (%dx),%al
f0105f60:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0105f63:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0105f66:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105f69:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105f70:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105f74:	8a 45 dc             	mov    -0x24(%ebp),%al
f0105f77:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f7a:	ee                   	out    %al,(%dx)
f0105f7b:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105f85:	89 c2                	mov    %eax,%edx
f0105f87:	ec                   	in     (%dx),%al
f0105f88:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0105f8b:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105f8e:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105f91:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105f9b:	89 c2                	mov    %eax,%edx
f0105f9d:	ec                   	in     (%dx),%al
f0105f9e:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105fa1:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105fa4:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105fa7:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0105fab:	c1 e0 08             	shl    $0x8,%eax
f0105fae:	89 c2                	mov    %eax,%edx
f0105fb0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105fb4:	09 d0                	or     %edx,%eax
f0105fb6:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0105fba:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105fbe:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105fc5:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105fc8:	8a 45 df             	mov    -0x21(%ebp),%al
f0105fcb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105fce:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105fcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105fd2:	c9                   	leave  
f0105fd3:	c3                   	ret    

f0105fd4 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105fd4:	55                   	push   %ebp
f0105fd5:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105fd7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105fdb:	74 1d                	je     f0105ffa <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105fdd:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fe0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105fe6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fe9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105ff0:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ff3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0105ffa:	90                   	nop
f0105ffb:	5d                   	pop    %ebp
f0105ffc:	c3                   	ret    

f0105ffd <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105ffd:	55                   	push   %ebp
f0105ffe:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0106000:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106004:	74 08                	je     f010600e <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0106006:	8b 45 08             	mov    0x8(%ebp),%eax
f0106009:	8b 40 0c             	mov    0xc(%eax),%eax
f010600c:	eb 05                	jmp    f0106013 <queue_size+0x16>
	}
	else
	{
		return 0;
f010600e:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0106013:	5d                   	pop    %ebp
f0106014:	c3                   	ret    

f0106015 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0106015:	55                   	push   %ebp
f0106016:	89 e5                	mov    %esp,%ebp
f0106018:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010601b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010601f:	75 16                	jne    f0106037 <enqueue+0x22>
f0106021:	68 54 6e 13 f0       	push   $0xf0136e54
f0106026:	68 62 6e 13 f0       	push   $0xf0136e62
f010602b:	6a 34                	push   $0x34
f010602d:	68 77 6e 13 f0       	push   $0xf0136e77
f0106032:	e8 78 ae ff ff       	call   f0100eaf <_panic>
	if(env != NULL)
f0106037:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010603b:	74 66                	je     f01060a3 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f010603d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106041:	75 14                	jne    f0106057 <enqueue+0x42>
f0106043:	83 ec 04             	sub    $0x4,%esp
f0106046:	68 90 6e 13 f0       	push   $0xf0136e90
f010604b:	6a 37                	push   $0x37
f010604d:	68 77 6e 13 f0       	push   $0xf0136e77
f0106052:	e8 58 ae ff ff       	call   f0100eaf <_panic>
f0106057:	8b 45 08             	mov    0x8(%ebp),%eax
f010605a:	8b 10                	mov    (%eax),%edx
f010605c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010605f:	89 50 08             	mov    %edx,0x8(%eax)
f0106062:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106065:	8b 40 08             	mov    0x8(%eax),%eax
f0106068:	85 c0                	test   %eax,%eax
f010606a:	74 0d                	je     f0106079 <enqueue+0x64>
f010606c:	8b 45 08             	mov    0x8(%ebp),%eax
f010606f:	8b 00                	mov    (%eax),%eax
f0106071:	8b 55 0c             	mov    0xc(%ebp),%edx
f0106074:	89 50 0c             	mov    %edx,0xc(%eax)
f0106077:	eb 09                	jmp    f0106082 <enqueue+0x6d>
f0106079:	8b 45 08             	mov    0x8(%ebp),%eax
f010607c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010607f:	89 50 04             	mov    %edx,0x4(%eax)
f0106082:	8b 45 08             	mov    0x8(%ebp),%eax
f0106085:	8b 55 0c             	mov    0xc(%ebp),%edx
f0106088:	89 10                	mov    %edx,(%eax)
f010608a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010608d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106094:	8b 45 08             	mov    0x8(%ebp),%eax
f0106097:	8b 40 0c             	mov    0xc(%eax),%eax
f010609a:	8d 50 01             	lea    0x1(%eax),%edx
f010609d:	8b 45 08             	mov    0x8(%ebp),%eax
f01060a0:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01060a3:	90                   	nop
f01060a4:	c9                   	leave  
f01060a5:	c3                   	ret    

f01060a6 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f01060a6:	55                   	push   %ebp
f01060a7:	89 e5                	mov    %esp,%ebp
f01060a9:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f01060ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01060b0:	75 0a                	jne    f01060bc <dequeue+0x16>
f01060b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01060b7:	e9 a0 00 00 00       	jmp    f010615c <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f01060bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01060bf:	8b 40 04             	mov    0x4(%eax),%eax
f01060c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f01060c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01060c9:	0f 84 8a 00 00 00    	je     f0106159 <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f01060cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01060d3:	75 14                	jne    f01060e9 <dequeue+0x43>
f01060d5:	83 ec 04             	sub    $0x4,%esp
f01060d8:	68 b3 6e 13 f0       	push   $0xf0136eb3
f01060dd:	6a 44                	push   $0x44
f01060df:	68 77 6e 13 f0       	push   $0xf0136e77
f01060e4:	e8 c6 ad ff ff       	call   f0100eaf <_panic>
f01060e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ec:	8b 40 08             	mov    0x8(%eax),%eax
f01060ef:	85 c0                	test   %eax,%eax
f01060f1:	74 11                	je     f0106104 <dequeue+0x5e>
f01060f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060f6:	8b 40 08             	mov    0x8(%eax),%eax
f01060f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01060fc:	8b 52 0c             	mov    0xc(%edx),%edx
f01060ff:	89 50 0c             	mov    %edx,0xc(%eax)
f0106102:	eb 0c                	jmp    f0106110 <dequeue+0x6a>
f0106104:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106107:	8b 50 0c             	mov    0xc(%eax),%edx
f010610a:	8b 45 08             	mov    0x8(%ebp),%eax
f010610d:	89 50 04             	mov    %edx,0x4(%eax)
f0106110:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106113:	8b 40 0c             	mov    0xc(%eax),%eax
f0106116:	85 c0                	test   %eax,%eax
f0106118:	74 11                	je     f010612b <dequeue+0x85>
f010611a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010611d:	8b 40 0c             	mov    0xc(%eax),%eax
f0106120:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106123:	8b 52 08             	mov    0x8(%edx),%edx
f0106126:	89 50 08             	mov    %edx,0x8(%eax)
f0106129:	eb 0b                	jmp    f0106136 <dequeue+0x90>
f010612b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010612e:	8b 50 08             	mov    0x8(%eax),%edx
f0106131:	8b 45 08             	mov    0x8(%ebp),%eax
f0106134:	89 10                	mov    %edx,(%eax)
f0106136:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106139:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106140:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106143:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010614a:	8b 45 08             	mov    0x8(%ebp),%eax
f010614d:	8b 40 0c             	mov    0xc(%eax),%eax
f0106150:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106153:	8b 45 08             	mov    0x8(%ebp),%eax
f0106156:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f0106159:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010615c:	c9                   	leave  
f010615d:	c3                   	ret    

f010615e <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f010615e:	55                   	push   %ebp
f010615f:	89 e5                	mov    %esp,%ebp
f0106161:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0106164:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106168:	75 16                	jne    f0106180 <remove_from_queue+0x22>
f010616a:	68 54 6e 13 f0       	push   $0xf0136e54
f010616f:	68 62 6e 13 f0       	push   $0xf0136e62
f0106174:	6a 4e                	push   $0x4e
f0106176:	68 77 6e 13 f0       	push   $0xf0136e77
f010617b:	e8 2f ad ff ff       	call   f0100eaf <_panic>

	if (e != NULL)
f0106180:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106184:	0f 84 8a 00 00 00    	je     f0106214 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010618a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010618e:	75 14                	jne    f01061a4 <remove_from_queue+0x46>
f0106190:	83 ec 04             	sub    $0x4,%esp
f0106193:	68 b3 6e 13 f0       	push   $0xf0136eb3
f0106198:	6a 52                	push   $0x52
f010619a:	68 77 6e 13 f0       	push   $0xf0136e77
f010619f:	e8 0b ad ff ff       	call   f0100eaf <_panic>
f01061a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061a7:	8b 40 08             	mov    0x8(%eax),%eax
f01061aa:	85 c0                	test   %eax,%eax
f01061ac:	74 11                	je     f01061bf <remove_from_queue+0x61>
f01061ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061b1:	8b 40 08             	mov    0x8(%eax),%eax
f01061b4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01061b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01061ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01061bd:	eb 0c                	jmp    f01061cb <remove_from_queue+0x6d>
f01061bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061c2:	8b 50 0c             	mov    0xc(%eax),%edx
f01061c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01061c8:	89 50 04             	mov    %edx,0x4(%eax)
f01061cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01061d1:	85 c0                	test   %eax,%eax
f01061d3:	74 11                	je     f01061e6 <remove_from_queue+0x88>
f01061d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01061db:	8b 55 0c             	mov    0xc(%ebp),%edx
f01061de:	8b 52 08             	mov    0x8(%edx),%edx
f01061e1:	89 50 08             	mov    %edx,0x8(%eax)
f01061e4:	eb 0b                	jmp    f01061f1 <remove_from_queue+0x93>
f01061e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061e9:	8b 50 08             	mov    0x8(%eax),%edx
f01061ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01061ef:	89 10                	mov    %edx,(%eax)
f01061f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061f4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01061fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061fe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106205:	8b 45 08             	mov    0x8(%ebp),%eax
f0106208:	8b 40 0c             	mov    0xc(%eax),%eax
f010620b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010620e:	8b 45 08             	mov    0x8(%ebp),%eax
f0106211:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0106214:	90                   	nop
f0106215:	c9                   	leave  
f0106216:	c3                   	ret    

f0106217 <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f0106217:	55                   	push   %ebp
f0106218:	89 e5                	mov    %esp,%ebp
f010621a:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f010621d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106221:	75 07                	jne    f010622a <find_env_in_queue+0x13>
f0106223:	b8 00 00 00 00       	mov    $0x0,%eax
f0106228:	eb 58                	jmp    f0106282 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f010622a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0106231:	8b 45 08             	mov    0x8(%ebp),%eax
f0106234:	8b 00                	mov    (%eax),%eax
f0106236:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0106239:	eb 19                	jmp    f0106254 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f010623b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010623e:	8b 40 10             	mov    0x10(%eax),%eax
f0106241:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0106244:	75 05                	jne    f010624b <find_env_in_queue+0x34>
		{
			return ptr_env;
f0106246:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106249:	eb 37                	jmp    f0106282 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f010624b:	8b 45 08             	mov    0x8(%ebp),%eax
f010624e:	8b 40 08             	mov    0x8(%eax),%eax
f0106251:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0106254:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0106258:	74 08                	je     f0106262 <find_env_in_queue+0x4b>
f010625a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010625d:	8b 40 08             	mov    0x8(%eax),%eax
f0106260:	eb 05                	jmp    f0106267 <find_env_in_queue+0x50>
f0106262:	b8 00 00 00 00       	mov    $0x0,%eax
f0106267:	8b 55 08             	mov    0x8(%ebp),%edx
f010626a:	89 42 08             	mov    %eax,0x8(%edx)
f010626d:	8b 45 08             	mov    0x8(%ebp),%eax
f0106270:	8b 40 08             	mov    0x8(%eax),%eax
f0106273:	85 c0                	test   %eax,%eax
f0106275:	75 c4                	jne    f010623b <find_env_in_queue+0x24>
f0106277:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010627b:	75 be                	jne    f010623b <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f010627d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0106282:	c9                   	leave  
f0106283:	c3                   	ret    

f0106284 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0106284:	55                   	push   %ebp
f0106285:	89 e5                	mov    %esp,%ebp
f0106287:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f010628a:	83 ec 0c             	sub    $0xc,%esp
f010628d:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106292:	e8 ae d2 00 00       	call   f0113545 <acquire_kspinlock>
f0106297:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010629a:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010629f:	85 c0                	test   %eax,%eax
f01062a1:	74 11                	je     f01062b4 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f01062a3:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01062a8:	83 ec 0c             	sub    $0xc,%esp
f01062ab:	50                   	push   %eax
f01062ac:	e8 a2 4f 00 00       	call   f010b253 <kfree>
f01062b1:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f01062b4:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f01062b9:	85 c0                	test   %eax,%eax
f01062bb:	74 11                	je     f01062ce <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f01062bd:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f01062c2:	83 ec 0c             	sub    $0xc,%esp
f01062c5:	50                   	push   %eax
f01062c6:	e8 88 4f 00 00       	call   f010b253 <kfree>
f01062cb:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&ProcessQueues.qlock);
f01062ce:	83 ec 0c             	sub    $0xc,%esp
f01062d1:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01062d6:	e8 0f d3 00 00       	call   f01135ea <release_kspinlock>
f01062db:	83 c4 10             	add    $0x10,%esp

#endif
}
f01062de:	90                   	nop
f01062df:	c9                   	leave  
f01062e0:	c3                   	ret    

f01062e1 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01062e1:	55                   	push   %ebp
f01062e2:	89 e5                	mov    %esp,%ebp
f01062e4:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01062e7:	83 ec 0c             	sub    $0xc,%esp
f01062ea:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01062ef:	e8 a6 d4 00 00       	call   f011379a <holding_kspinlock>
f01062f4:	83 c4 10             	add    $0x10,%esp
f01062f7:	85 c0                	test   %eax,%eax
f01062f9:	75 17                	jne    f0106312 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01062fb:	83 ec 04             	sub    $0x4,%esp
f01062fe:	68 d4 6e 13 f0       	push   $0xf0136ed4
f0106303:	68 97 00 00 00       	push   $0x97
f0106308:	68 77 6e 13 f0       	push   $0xf0136e77
f010630d:	e8 9d ab ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106312:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106316:	75 19                	jne    f0106331 <sched_insert_ready+0x50>
f0106318:	68 15 6f 13 f0       	push   $0xf0136f15
f010631d:	68 62 6e 13 f0       	push   $0xf0136e62
f0106322:	68 9a 00 00 00       	push   $0x9a
f0106327:	68 77 6e 13 f0       	push   $0xf0136e77
f010632c:	e8 7e ab ff ff       	call   f0100eaf <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0106331:	8b 45 08             	mov    0x8(%ebp),%eax
f0106334:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f010633b:	8b 15 50 ce 94 f1    	mov    0xf194ce50,%edx
f0106341:	8b 45 08             	mov    0x8(%ebp),%eax
f0106344:	8b 40 1c             	mov    0x1c(%eax),%eax
f0106347:	c1 e0 04             	shl    $0x4,%eax
f010634a:	01 d0                	add    %edx,%eax
f010634c:	83 ec 08             	sub    $0x8,%esp
f010634f:	ff 75 08             	pushl  0x8(%ebp)
f0106352:	50                   	push   %eax
f0106353:	e8 bd fc ff ff       	call   f0106015 <enqueue>
f0106358:	83 c4 10             	add    $0x10,%esp
	}
}
f010635b:	90                   	nop
f010635c:	c9                   	leave  
f010635d:	c3                   	ret    

f010635e <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f010635e:	55                   	push   %ebp
f010635f:	89 e5                	mov    %esp,%ebp
f0106361:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106364:	83 ec 0c             	sub    $0xc,%esp
f0106367:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010636c:	e8 29 d4 00 00       	call   f011379a <holding_kspinlock>
f0106371:	83 c4 10             	add    $0x10,%esp
f0106374:	85 c0                	test   %eax,%eax
f0106376:	75 17                	jne    f010638f <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0106378:	83 ec 04             	sub    $0x4,%esp
f010637b:	68 d4 6e 13 f0       	push   $0xf0136ed4
f0106380:	68 a9 00 00 00       	push   $0xa9
f0106385:	68 77 6e 13 f0       	push   $0xf0136e77
f010638a:	e8 20 ab ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f010638f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106393:	74 0b                	je     f01063a0 <sched_remove_ready+0x42>
f0106395:	8b 45 08             	mov    0x8(%ebp),%eax
f0106398:	8b 40 18             	mov    0x18(%eax),%eax
f010639b:	83 f8 01             	cmp    $0x1,%eax
f010639e:	74 19                	je     f01063b9 <sched_remove_ready+0x5b>
f01063a0:	68 24 6f 13 f0       	push   $0xf0136f24
f01063a5:	68 62 6e 13 f0       	push   $0xf0136e62
f01063aa:	68 ac 00 00 00       	push   $0xac
f01063af:	68 77 6e 13 f0       	push   $0xf0136e77
f01063b4:	e8 f6 aa ff ff       	call   f0100eaf <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01063b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01063c0:	e9 e4 00 00 00       	jmp    f01064a9 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01063c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01063c8:	8b 40 10             	mov    0x10(%eax),%eax
f01063cb:	89 c2                	mov    %eax,%edx
f01063cd:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01063d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01063d5:	c1 e1 04             	shl    $0x4,%ecx
f01063d8:	01 c8                	add    %ecx,%eax
f01063da:	83 ec 08             	sub    $0x8,%esp
f01063dd:	52                   	push   %edx
f01063de:	50                   	push   %eax
f01063df:	e8 33 fe ff ff       	call   f0106217 <find_env_in_queue>
f01063e4:	83 c4 10             	add    $0x10,%esp
f01063e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01063ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01063ee:	0f 84 b2 00 00 00    	je     f01064a6 <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01063f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01063f8:	75 17                	jne    f0106411 <sched_remove_ready+0xb3>
f01063fa:	83 ec 04             	sub    $0x4,%esp
f01063fd:	68 b3 6e 13 f0       	push   $0xf0136eb3
f0106402:	68 b3 00 00 00       	push   $0xb3
f0106407:	68 77 6e 13 f0       	push   $0xf0136e77
f010640c:	e8 9e aa ff ff       	call   f0100eaf <_panic>
f0106411:	8b 45 08             	mov    0x8(%ebp),%eax
f0106414:	8b 40 08             	mov    0x8(%eax),%eax
f0106417:	85 c0                	test   %eax,%eax
f0106419:	74 11                	je     f010642c <sched_remove_ready+0xce>
f010641b:	8b 45 08             	mov    0x8(%ebp),%eax
f010641e:	8b 40 08             	mov    0x8(%eax),%eax
f0106421:	8b 55 08             	mov    0x8(%ebp),%edx
f0106424:	8b 52 0c             	mov    0xc(%edx),%edx
f0106427:	89 50 0c             	mov    %edx,0xc(%eax)
f010642a:	eb 16                	jmp    f0106442 <sched_remove_ready+0xe4>
f010642c:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106431:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106434:	c1 e2 04             	shl    $0x4,%edx
f0106437:	01 c2                	add    %eax,%edx
f0106439:	8b 45 08             	mov    0x8(%ebp),%eax
f010643c:	8b 40 0c             	mov    0xc(%eax),%eax
f010643f:	89 42 04             	mov    %eax,0x4(%edx)
f0106442:	8b 45 08             	mov    0x8(%ebp),%eax
f0106445:	8b 40 0c             	mov    0xc(%eax),%eax
f0106448:	85 c0                	test   %eax,%eax
f010644a:	74 11                	je     f010645d <sched_remove_ready+0xff>
f010644c:	8b 45 08             	mov    0x8(%ebp),%eax
f010644f:	8b 40 0c             	mov    0xc(%eax),%eax
f0106452:	8b 55 08             	mov    0x8(%ebp),%edx
f0106455:	8b 52 08             	mov    0x8(%edx),%edx
f0106458:	89 50 08             	mov    %edx,0x8(%eax)
f010645b:	eb 15                	jmp    f0106472 <sched_remove_ready+0x114>
f010645d:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106462:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106465:	c1 e2 04             	shl    $0x4,%edx
f0106468:	01 c2                	add    %eax,%edx
f010646a:	8b 45 08             	mov    0x8(%ebp),%eax
f010646d:	8b 40 08             	mov    0x8(%eax),%eax
f0106470:	89 02                	mov    %eax,(%edx)
f0106472:	8b 45 08             	mov    0x8(%ebp),%eax
f0106475:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010647c:	8b 45 08             	mov    0x8(%ebp),%eax
f010647f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106486:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010648b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010648e:	c1 e2 04             	shl    $0x4,%edx
f0106491:	01 d0                	add    %edx,%eax
f0106493:	8b 50 0c             	mov    0xc(%eax),%edx
f0106496:	4a                   	dec    %edx
f0106497:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f010649a:	8b 45 08             	mov    0x8(%ebp),%eax
f010649d:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
				return ;
f01064a4:	eb 14                	jmp    f01064ba <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064a6:	ff 45 f4             	incl   -0xc(%ebp)
f01064a9:	a0 00 54 96 f1       	mov    0xf1965400,%al
f01064ae:	0f b6 c0             	movzbl %al,%eax
f01064b1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01064b4:	0f 8f 0b ff ff ff    	jg     f01063c5 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01064ba:	c9                   	leave  
f01064bb:	c3                   	ret    

f01064bc <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01064bc:	55                   	push   %ebp
f01064bd:	89 e5                	mov    %esp,%ebp
f01064bf:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01064c2:	83 ec 0c             	sub    $0xc,%esp
f01064c5:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01064ca:	e8 cb d2 00 00       	call   f011379a <holding_kspinlock>
f01064cf:	83 c4 10             	add    $0x10,%esp
f01064d2:	85 c0                	test   %eax,%eax
f01064d4:	75 17                	jne    f01064ed <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01064d6:	83 ec 04             	sub    $0x4,%esp
f01064d9:	68 d4 6e 13 f0       	push   $0xf0136ed4
f01064de:	68 c2 00 00 00       	push   $0xc2
f01064e3:	68 77 6e 13 f0       	push   $0xf0136e77
f01064e8:	e8 c2 a9 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01064ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01064f1:	75 19                	jne    f010650c <sched_insert_new+0x50>
f01064f3:	68 15 6f 13 f0       	push   $0xf0136f15
f01064f8:	68 62 6e 13 f0       	push   $0xf0136e62
f01064fd:	68 c5 00 00 00       	push   $0xc5
f0106502:	68 77 6e 13 f0       	push   $0xf0136e77
f0106507:	e8 a3 a9 ff ff       	call   f0100eaf <_panic>
	{
		env->env_status = ENV_NEW ;
f010650c:	8b 45 08             	mov    0x8(%ebp),%eax
f010650f:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f0106516:	83 ec 08             	sub    $0x8,%esp
f0106519:	ff 75 08             	pushl  0x8(%ebp)
f010651c:	68 30 ce 94 f1       	push   $0xf194ce30
f0106521:	e8 ef fa ff ff       	call   f0106015 <enqueue>
f0106526:	83 c4 10             	add    $0x10,%esp
	}
}
f0106529:	90                   	nop
f010652a:	c9                   	leave  
f010652b:	c3                   	ret    

f010652c <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f010652c:	55                   	push   %ebp
f010652d:	89 e5                	mov    %esp,%ebp
f010652f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106532:	83 ec 0c             	sub    $0xc,%esp
f0106535:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010653a:	e8 5b d2 00 00       	call   f011379a <holding_kspinlock>
f010653f:	83 c4 10             	add    $0x10,%esp
f0106542:	85 c0                	test   %eax,%eax
f0106544:	75 17                	jne    f010655d <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0106546:	83 ec 04             	sub    $0x4,%esp
f0106549:	68 d4 6e 13 f0       	push   $0xf0136ed4
f010654e:	68 d3 00 00 00       	push   $0xd3
f0106553:	68 77 6e 13 f0       	push   $0xf0136e77
f0106558:	e8 52 a9 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f010655d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106561:	74 0b                	je     f010656e <sched_remove_new+0x42>
f0106563:	8b 45 08             	mov    0x8(%ebp),%eax
f0106566:	8b 40 18             	mov    0x18(%eax),%eax
f0106569:	83 f8 04             	cmp    $0x4,%eax
f010656c:	74 19                	je     f0106587 <sched_remove_new+0x5b>
f010656e:	68 50 6f 13 f0       	push   $0xf0136f50
f0106573:	68 62 6e 13 f0       	push   $0xf0136e62
f0106578:	68 d6 00 00 00       	push   $0xd6
f010657d:	68 77 6e 13 f0       	push   $0xf0136e77
f0106582:	e8 28 a9 ff ff       	call   f0100eaf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0106587:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010658b:	75 17                	jne    f01065a4 <sched_remove_new+0x78>
f010658d:	83 ec 04             	sub    $0x4,%esp
f0106590:	68 b3 6e 13 f0       	push   $0xf0136eb3
f0106595:	68 d8 00 00 00       	push   $0xd8
f010659a:	68 77 6e 13 f0       	push   $0xf0136e77
f010659f:	e8 0b a9 ff ff       	call   f0100eaf <_panic>
f01065a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01065a7:	8b 40 08             	mov    0x8(%eax),%eax
f01065aa:	85 c0                	test   %eax,%eax
f01065ac:	74 11                	je     f01065bf <sched_remove_new+0x93>
f01065ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01065b1:	8b 40 08             	mov    0x8(%eax),%eax
f01065b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01065b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01065ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01065bd:	eb 0b                	jmp    f01065ca <sched_remove_new+0x9e>
f01065bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01065c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01065c5:	a3 34 ce 94 f1       	mov    %eax,0xf194ce34
f01065ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01065cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01065d0:	85 c0                	test   %eax,%eax
f01065d2:	74 11                	je     f01065e5 <sched_remove_new+0xb9>
f01065d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01065d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01065da:	8b 55 08             	mov    0x8(%ebp),%edx
f01065dd:	8b 52 08             	mov    0x8(%edx),%edx
f01065e0:	89 50 08             	mov    %edx,0x8(%eax)
f01065e3:	eb 0b                	jmp    f01065f0 <sched_remove_new+0xc4>
f01065e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01065e8:	8b 40 08             	mov    0x8(%eax),%eax
f01065eb:	a3 30 ce 94 f1       	mov    %eax,0xf194ce30
f01065f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01065f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01065fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106604:	a1 3c ce 94 f1       	mov    0xf194ce3c,%eax
f0106609:	48                   	dec    %eax
f010660a:	a3 3c ce 94 f1       	mov    %eax,0xf194ce3c
		env->env_status = ENV_UNKNOWN;
f010660f:	8b 45 08             	mov    0x8(%ebp),%eax
f0106612:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f0106619:	90                   	nop
f010661a:	c9                   	leave  
f010661b:	c3                   	ret    

f010661c <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f010661c:	55                   	push   %ebp
f010661d:	89 e5                	mov    %esp,%ebp
f010661f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106622:	83 ec 0c             	sub    $0xc,%esp
f0106625:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010662a:	e8 6b d1 00 00       	call   f011379a <holding_kspinlock>
f010662f:	83 c4 10             	add    $0x10,%esp
f0106632:	85 c0                	test   %eax,%eax
f0106634:	75 17                	jne    f010664d <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0106636:	83 ec 04             	sub    $0x4,%esp
f0106639:	68 d4 6e 13 f0       	push   $0xf0136ed4
f010663e:	68 e4 00 00 00       	push   $0xe4
f0106643:	68 77 6e 13 f0       	push   $0xf0136e77
f0106648:	e8 62 a8 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f010664d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106651:	75 19                	jne    f010666c <sched_insert_exit+0x50>
f0106653:	68 15 6f 13 f0       	push   $0xf0136f15
f0106658:	68 62 6e 13 f0       	push   $0xf0136e62
f010665d:	68 e7 00 00 00       	push   $0xe7
f0106662:	68 77 6e 13 f0       	push   $0xf0136e77
f0106667:	e8 43 a8 ff ff       	call   f0100eaf <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f010666c:	e8 eb b0 00 00       	call   f011175c <isBufferingEnabled>
f0106671:	84 c0                	test   %al,%al
f0106673:	74 0e                	je     f0106683 <sched_insert_exit+0x67>
f0106675:	83 ec 0c             	sub    $0xc,%esp
f0106678:	ff 75 08             	pushl  0x8(%ebp)
f010667b:	e8 f3 82 00 00       	call   f010e973 <cleanup_buffers>
f0106680:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0106683:	8b 45 08             	mov    0x8(%ebp),%eax
f0106686:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f010668d:	83 ec 08             	sub    $0x8,%esp
f0106690:	ff 75 08             	pushl  0x8(%ebp)
f0106693:	68 40 ce 94 f1       	push   $0xf194ce40
f0106698:	e8 78 f9 ff ff       	call   f0106015 <enqueue>
f010669d:	83 c4 10             	add    $0x10,%esp
	}
}
f01066a0:	90                   	nop
f01066a1:	c9                   	leave  
f01066a2:	c3                   	ret    

f01066a3 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01066a9:	83 ec 0c             	sub    $0xc,%esp
f01066ac:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01066b1:	e8 e4 d0 00 00       	call   f011379a <holding_kspinlock>
f01066b6:	83 c4 10             	add    $0x10,%esp
f01066b9:	85 c0                	test   %eax,%eax
f01066bb:	75 17                	jne    f01066d4 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01066bd:	83 ec 04             	sub    $0x4,%esp
f01066c0:	68 d4 6e 13 f0       	push   $0xf0136ed4
f01066c5:	68 f5 00 00 00       	push   $0xf5
f01066ca:	68 77 6e 13 f0       	push   $0xf0136e77
f01066cf:	e8 db a7 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01066d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01066d8:	74 0b                	je     f01066e5 <sched_remove_exit+0x42>
f01066da:	8b 45 08             	mov    0x8(%ebp),%eax
f01066dd:	8b 40 18             	mov    0x18(%eax),%eax
f01066e0:	83 f8 05             	cmp    $0x5,%eax
f01066e3:	74 19                	je     f01066fe <sched_remove_exit+0x5b>
f01066e5:	68 7c 6f 13 f0       	push   $0xf0136f7c
f01066ea:	68 62 6e 13 f0       	push   $0xf0136e62
f01066ef:	68 f8 00 00 00       	push   $0xf8
f01066f4:	68 77 6e 13 f0       	push   $0xf0136e77
f01066f9:	e8 b1 a7 ff ff       	call   f0100eaf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01066fe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106702:	75 17                	jne    f010671b <sched_remove_exit+0x78>
f0106704:	83 ec 04             	sub    $0x4,%esp
f0106707:	68 b3 6e 13 f0       	push   $0xf0136eb3
f010670c:	68 fa 00 00 00       	push   $0xfa
f0106711:	68 77 6e 13 f0       	push   $0xf0136e77
f0106716:	e8 94 a7 ff ff       	call   f0100eaf <_panic>
f010671b:	8b 45 08             	mov    0x8(%ebp),%eax
f010671e:	8b 40 08             	mov    0x8(%eax),%eax
f0106721:	85 c0                	test   %eax,%eax
f0106723:	74 11                	je     f0106736 <sched_remove_exit+0x93>
f0106725:	8b 45 08             	mov    0x8(%ebp),%eax
f0106728:	8b 40 08             	mov    0x8(%eax),%eax
f010672b:	8b 55 08             	mov    0x8(%ebp),%edx
f010672e:	8b 52 0c             	mov    0xc(%edx),%edx
f0106731:	89 50 0c             	mov    %edx,0xc(%eax)
f0106734:	eb 0b                	jmp    f0106741 <sched_remove_exit+0x9e>
f0106736:	8b 45 08             	mov    0x8(%ebp),%eax
f0106739:	8b 40 0c             	mov    0xc(%eax),%eax
f010673c:	a3 44 ce 94 f1       	mov    %eax,0xf194ce44
f0106741:	8b 45 08             	mov    0x8(%ebp),%eax
f0106744:	8b 40 0c             	mov    0xc(%eax),%eax
f0106747:	85 c0                	test   %eax,%eax
f0106749:	74 11                	je     f010675c <sched_remove_exit+0xb9>
f010674b:	8b 45 08             	mov    0x8(%ebp),%eax
f010674e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106751:	8b 55 08             	mov    0x8(%ebp),%edx
f0106754:	8b 52 08             	mov    0x8(%edx),%edx
f0106757:	89 50 08             	mov    %edx,0x8(%eax)
f010675a:	eb 0b                	jmp    f0106767 <sched_remove_exit+0xc4>
f010675c:	8b 45 08             	mov    0x8(%ebp),%eax
f010675f:	8b 40 08             	mov    0x8(%eax),%eax
f0106762:	a3 40 ce 94 f1       	mov    %eax,0xf194ce40
f0106767:	8b 45 08             	mov    0x8(%ebp),%eax
f010676a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106771:	8b 45 08             	mov    0x8(%ebp),%eax
f0106774:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010677b:	a1 4c ce 94 f1       	mov    0xf194ce4c,%eax
f0106780:	48                   	dec    %eax
f0106781:	a3 4c ce 94 f1       	mov    %eax,0xf194ce4c
		env->env_status = ENV_UNKNOWN;
f0106786:	8b 45 08             	mov    0x8(%ebp),%eax
f0106789:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f0106790:	90                   	nop
f0106791:	c9                   	leave  
f0106792:	c3                   	ret    

f0106793 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0106793:	55                   	push   %ebp
f0106794:	89 e5                	mov    %esp,%ebp
f0106796:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106799:	83 ec 0c             	sub    $0xc,%esp
f010679c:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01067a1:	e8 9f cd 00 00       	call   f0113545 <acquire_kspinlock>
f01067a6:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01067a9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01067ad:	75 19                	jne    f01067c8 <sched_new_env+0x35>
f01067af:	68 a7 6f 13 f0       	push   $0xf0136fa7
f01067b4:	68 62 6e 13 f0       	push   $0xf0136e62
f01067b9:	68 08 01 00 00       	push   $0x108
f01067be:	68 77 6e 13 f0       	push   $0xf0136e77
f01067c3:	e8 e7 a6 ff ff       	call   f0100eaf <_panic>
	{
		sched_insert_new(e);
f01067c8:	83 ec 0c             	sub    $0xc,%esp
f01067cb:	ff 75 08             	pushl  0x8(%ebp)
f01067ce:	e8 e9 fc ff ff       	call   f01064bc <sched_insert_new>
f01067d3:	83 c4 10             	add    $0x10,%esp
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01067d6:	83 ec 0c             	sub    $0xc,%esp
f01067d9:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01067de:	e8 07 ce 00 00       	call   f01135ea <release_kspinlock>
f01067e3:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01067e6:	90                   	nop
f01067e7:	c9                   	leave  
f01067e8:	c3                   	ret    

f01067e9 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01067e9:	55                   	push   %ebp
f01067ea:	89 e5                	mov    %esp,%ebp
f01067ec:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01067ef:	83 ec 0c             	sub    $0xc,%esp
f01067f2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01067f7:	e8 49 cd 00 00       	call   f0113545 <acquire_kspinlock>
f01067fc:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01067ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106806:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f010680b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010680e:	eb 53                	jmp    f0106863 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0106810:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106813:	8b 40 10             	mov    0x10(%eax),%eax
f0106816:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106819:	75 40                	jne    f010685b <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f010681b:	83 ec 0c             	sub    $0xc,%esp
f010681e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106821:	e8 06 fd ff ff       	call   f010652c <sched_remove_new>
f0106826:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f0106829:	83 ec 0c             	sub    $0xc,%esp
f010682c:	ff 75 f4             	pushl  -0xc(%ebp)
f010682f:	e8 ad fa ff ff       	call   f01062e1 <sched_insert_ready>
f0106834:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0106837:	e8 c3 1c 00 00       	call   f01084ff <mycpu>
f010683c:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106842:	85 c0                	test   %eax,%eax
f0106844:	75 46                	jne    f010688c <sched_run_env+0xa3>
			{
				release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106846:	83 ec 0c             	sub    $0xc,%esp
f0106849:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010684e:	e8 97 cd 00 00       	call   f01135ea <release_kspinlock>
f0106853:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0106856:	e8 a8 10 00 00       	call   f0107903 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010685b:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106860:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106863:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106867:	74 08                	je     f0106871 <sched_run_env+0x88>
f0106869:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010686c:	8b 40 08             	mov    0x8(%eax),%eax
f010686f:	eb 05                	jmp    f0106876 <sched_run_env+0x8d>
f0106871:	b8 00 00 00 00       	mov    $0x0,%eax
f0106876:	a3 38 ce 94 f1       	mov    %eax,0xf194ce38
f010687b:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106880:	85 c0                	test   %eax,%eax
f0106882:	75 8c                	jne    f0106810 <sched_run_env+0x27>
f0106884:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106888:	75 86                	jne    f0106810 <sched_run_env+0x27>
f010688a:	eb 01                	jmp    f010688d <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f010688c:	90                   	nop
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010688d:	83 ec 0c             	sub    $0xc,%esp
f0106890:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106895:	e8 50 cd 00 00       	call   f01135ea <release_kspinlock>
f010689a:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f010689d:	90                   	nop
f010689e:	c9                   	leave  
f010689f:	c3                   	ret    

f01068a0 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f01068a0:	55                   	push   %ebp
f01068a1:	89 e5                	mov    %esp,%ebp
f01068a3:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_kspinlock(&ProcessQueues.qlock);
f01068a6:	83 ec 0c             	sub    $0xc,%esp
f01068a9:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01068ae:	e8 e7 ce 00 00       	call   f011379a <holding_kspinlock>
f01068b3:	83 c4 10             	add    $0x10,%esp
f01068b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01068b9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01068bd:	75 10                	jne    f01068cf <sched_exit_env+0x2f>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01068bf:	83 ec 0c             	sub    $0xc,%esp
f01068c2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01068c7:	e8 79 cc 00 00       	call   f0113545 <acquire_kspinlock>
f01068cc:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01068cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01068d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01068dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01068e1:	75 59                	jne    f010693c <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01068e3:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f01068e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01068eb:	eb 28                	jmp    f0106915 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01068ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068f0:	8b 40 10             	mov    0x10(%eax),%eax
f01068f3:	3b 45 08             	cmp    0x8(%ebp),%eax
f01068f6:	75 15                	jne    f010690d <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f01068f8:	83 ec 0c             	sub    $0xc,%esp
f01068fb:	ff 75 f4             	pushl  -0xc(%ebp)
f01068fe:	e8 29 fc ff ff       	call   f010652c <sched_remove_new>
f0106903:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106906:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010690d:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106912:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106915:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106919:	74 08                	je     f0106923 <sched_exit_env+0x83>
f010691b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010691e:	8b 40 08             	mov    0x8(%eax),%eax
f0106921:	eb 05                	jmp    f0106928 <sched_exit_env+0x88>
f0106923:	b8 00 00 00 00       	mov    $0x0,%eax
f0106928:	a3 38 ce 94 f1       	mov    %eax,0xf194ce38
f010692d:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106932:	85 c0                	test   %eax,%eax
f0106934:	75 b7                	jne    f01068ed <sched_exit_env+0x4d>
f0106936:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010693a:	75 b1                	jne    f01068ed <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f010693c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106940:	0f 85 67 01 00 00    	jne    f0106aad <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106946:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010694d:	e9 47 01 00 00       	jmp    f0106a99 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106952:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106957:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010695a:	c1 e2 04             	shl    $0x4,%edx
f010695d:	01 d0                	add    %edx,%eax
f010695f:	8b 00                	mov    (%eax),%eax
f0106961:	85 c0                	test   %eax,%eax
f0106963:	0f 84 27 01 00 00    	je     f0106a90 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0106969:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106970:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106975:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106978:	c1 e2 04             	shl    $0x4,%edx
f010697b:	01 d0                	add    %edx,%eax
f010697d:	8b 00                	mov    (%eax),%eax
f010697f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106982:	e9 d1 00 00 00       	jmp    f0106a58 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0106987:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010698a:	8b 40 10             	mov    0x10(%eax),%eax
f010698d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106990:	0f 85 af 00 00 00    	jne    f0106a45 <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106996:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699a:	75 17                	jne    f01069b3 <sched_exit_env+0x113>
f010699c:	83 ec 04             	sub    $0x4,%esp
f010699f:	68 b3 6e 13 f0       	push   $0xf0136eb3
f01069a4:	68 56 01 00 00       	push   $0x156
f01069a9:	68 77 6e 13 f0       	push   $0xf0136e77
f01069ae:	e8 fc a4 ff ff       	call   f0100eaf <_panic>
f01069b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069b6:	8b 40 08             	mov    0x8(%eax),%eax
f01069b9:	85 c0                	test   %eax,%eax
f01069bb:	74 11                	je     f01069ce <sched_exit_env+0x12e>
f01069bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069c0:	8b 40 08             	mov    0x8(%eax),%eax
f01069c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01069c6:	8b 52 0c             	mov    0xc(%edx),%edx
f01069c9:	89 50 0c             	mov    %edx,0xc(%eax)
f01069cc:	eb 16                	jmp    f01069e4 <sched_exit_env+0x144>
f01069ce:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01069d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01069d6:	c1 e2 04             	shl    $0x4,%edx
f01069d9:	01 c2                	add    %eax,%edx
f01069db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069de:	8b 40 0c             	mov    0xc(%eax),%eax
f01069e1:	89 42 04             	mov    %eax,0x4(%edx)
f01069e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069e7:	8b 40 0c             	mov    0xc(%eax),%eax
f01069ea:	85 c0                	test   %eax,%eax
f01069ec:	74 11                	je     f01069ff <sched_exit_env+0x15f>
f01069ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069f1:	8b 40 0c             	mov    0xc(%eax),%eax
f01069f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01069f7:	8b 52 08             	mov    0x8(%edx),%edx
f01069fa:	89 50 08             	mov    %edx,0x8(%eax)
f01069fd:	eb 15                	jmp    f0106a14 <sched_exit_env+0x174>
f01069ff:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106a04:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a07:	c1 e2 04             	shl    $0x4,%edx
f0106a0a:	01 c2                	add    %eax,%edx
f0106a0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a0f:	8b 40 08             	mov    0x8(%eax),%eax
f0106a12:	89 02                	mov    %eax,(%edx)
f0106a14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a17:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106a1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a21:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106a28:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106a2d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a30:	c1 e2 04             	shl    $0x4,%edx
f0106a33:	01 d0                	add    %edx,%eax
f0106a35:	8b 50 0c             	mov    0xc(%eax),%edx
f0106a38:	4a                   	dec    %edx
f0106a39:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106a3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106a43:	eb 4b                	jmp    f0106a90 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106a45:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106a4a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a4d:	c1 e2 04             	shl    $0x4,%edx
f0106a50:	01 d0                	add    %edx,%eax
f0106a52:	8b 40 08             	mov    0x8(%eax),%eax
f0106a55:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106a58:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106a5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a60:	c1 e2 04             	shl    $0x4,%edx
f0106a63:	01 d0                	add    %edx,%eax
f0106a65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106a69:	74 08                	je     f0106a73 <sched_exit_env+0x1d3>
f0106a6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106a6e:	8b 52 08             	mov    0x8(%edx),%edx
f0106a71:	eb 05                	jmp    f0106a78 <sched_exit_env+0x1d8>
f0106a73:	ba 00 00 00 00       	mov    $0x0,%edx
f0106a78:	89 50 08             	mov    %edx,0x8(%eax)
f0106a7b:	8b 40 08             	mov    0x8(%eax),%eax
f0106a7e:	85 c0                	test   %eax,%eax
f0106a80:	0f 85 01 ff ff ff    	jne    f0106987 <sched_exit_env+0xe7>
f0106a86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106a8a:	0f 85 f7 fe ff ff    	jne    f0106987 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0106a90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106a94:	75 16                	jne    f0106aac <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106a96:	ff 45 ec             	incl   -0x14(%ebp)
f0106a99:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0106a9e:	0f b6 c0             	movzbl %al,%eax
f0106aa1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106aa4:	0f 8f a8 fe ff ff    	jg     f0106952 <sched_exit_env+0xb2>
f0106aaa:	eb 01                	jmp    f0106aad <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0106aac:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0106aad:	e8 96 6b 00 00       	call   f010d648 <get_cpu_proc>
f0106ab2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0106ab5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0106ab9:	75 19                	jne    f0106ad4 <sched_exit_env+0x234>
f0106abb:	68 af 6f 13 f0       	push   $0xf0136faf
f0106ac0:	68 62 6e 13 f0       	push   $0xf0136e62
f0106ac5:	68 60 01 00 00       	push   $0x160
f0106aca:	68 77 6e 13 f0       	push   $0xf0136e77
f0106acf:	e8 db a3 ff ff       	call   f0100eaf <_panic>
	if (!found)
f0106ad4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106ad8:	75 18                	jne    f0106af2 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0106ada:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106add:	8b 40 10             	mov    0x10(%eax),%eax
f0106ae0:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106ae3:	75 0d                	jne    f0106af2 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0106ae5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106ae8:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0106aeb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0106af2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106af6:	74 1e                	je     f0106b16 <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0106af8:	83 ec 0c             	sub    $0xc,%esp
f0106afb:	ff 75 f4             	pushl  -0xc(%ebp)
f0106afe:	e8 19 fb ff ff       	call   f010661c <sched_insert_exit>
f0106b03:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0106b06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106b09:	8b 40 10             	mov    0x10(%eax),%eax
f0106b0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106b0f:	75 05                	jne    f0106b16 <sched_exit_env+0x276>
		{
//			cprintf("\n[%d:%s] LAST WS BEFORE EXIT\n", cur_env->env_id,  cur_env->prog_name);
//			env_page_ws_print(cur_env);
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0106b11:	e8 ac 6c 00 00       	call   f010d7c2 <sched>
		}
	}
	if (!lock_already_held)
f0106b16:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106b1a:	75 10                	jne    f0106b2c <sched_exit_env+0x28c>
	{
		release_kspinlock(&ProcessQueues.qlock);
f0106b1c:	83 ec 0c             	sub    $0xc,%esp
f0106b1f:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106b24:	e8 c1 ca 00 00       	call   f01135ea <release_kspinlock>
f0106b29:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0106b2c:	90                   	nop
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106b3d:	e8 03 ca 00 00       	call   f0113545 <acquire_kspinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106b45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0106b4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0106b53:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106b57:	75 79                	jne    f0106bd2 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106b59:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f0106b5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106b61:	eb 48                	jmp    f0106bab <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0106b63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b66:	8b 40 10             	mov    0x10(%eax),%eax
f0106b69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106b6c:	75 35                	jne    f0106ba3 <sched_kill_env+0x74>
			{
				cprintf("[BEGIN] killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0106b6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b71:	8d 50 20             	lea    0x20(%eax),%edx
f0106b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b77:	8b 40 10             	mov    0x10(%eax),%eax
f0106b7a:	83 ec 04             	sub    $0x4,%esp
f0106b7d:	52                   	push   %edx
f0106b7e:	50                   	push   %eax
f0106b7f:	68 c0 6f 13 f0       	push   $0xf0136fc0
f0106b84:	e8 c4 af ff ff       	call   f0101b4d <cprintf>
f0106b89:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0106b8c:	83 ec 0c             	sub    $0xc,%esp
f0106b8f:	ff 75 f4             	pushl  -0xc(%ebp)
f0106b92:	e8 95 f9 ff ff       	call   f010652c <sched_remove_new>
f0106b97:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106b9a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106ba1:	eb 2f                	jmp    f0106bd2 <sched_kill_env+0xa3>
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106ba3:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106ba8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106bab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106baf:	74 08                	je     f0106bb9 <sched_kill_env+0x8a>
f0106bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bb4:	8b 40 08             	mov    0x8(%eax),%eax
f0106bb7:	eb 05                	jmp    f0106bbe <sched_kill_env+0x8f>
f0106bb9:	b8 00 00 00 00       	mov    $0x0,%eax
f0106bbe:	a3 38 ce 94 f1       	mov    %eax,0xf194ce38
f0106bc3:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106bc8:	85 c0                	test   %eax,%eax
f0106bca:	75 97                	jne    f0106b63 <sched_kill_env+0x34>
f0106bcc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106bd0:	75 91                	jne    f0106b63 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0106bd2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106bd6:	0f 85 85 01 00 00    	jne    f0106d61 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106bdc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106be3:	e9 65 01 00 00       	jmp    f0106d4d <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106be8:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106bed:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bf0:	c1 e2 04             	shl    $0x4,%edx
f0106bf3:	01 d0                	add    %edx,%eax
f0106bf5:	8b 00                	mov    (%eax),%eax
f0106bf7:	85 c0                	test   %eax,%eax
f0106bf9:	0f 84 45 01 00 00    	je     f0106d44 <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0106bff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106c06:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106c0b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c0e:	c1 e2 04             	shl    $0x4,%edx
f0106c11:	01 d0                	add    %edx,%eax
f0106c13:	8b 00                	mov    (%eax),%eax
f0106c15:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c18:	e9 ef 00 00 00       	jmp    f0106d0c <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0106c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c20:	8b 40 10             	mov    0x10(%eax),%eax
f0106c23:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106c26:	0f 85 cd 00 00 00    	jne    f0106cf9 <sched_kill_env+0x1ca>
					{
						cprintf("[BEGIN] killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0106c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c2f:	8d 50 20             	lea    0x20(%eax),%edx
f0106c32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c35:	8b 40 10             	mov    0x10(%eax),%eax
f0106c38:	ff 75 ec             	pushl  -0x14(%ebp)
f0106c3b:	52                   	push   %edx
f0106c3c:	50                   	push   %eax
f0106c3d:	68 f0 6f 13 f0       	push   $0xf0136ff0
f0106c42:	e8 06 af ff ff       	call   f0101b4d <cprintf>
f0106c47:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106c4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c4e:	75 17                	jne    f0106c67 <sched_kill_env+0x138>
f0106c50:	83 ec 04             	sub    $0x4,%esp
f0106c53:	68 b3 6e 13 f0       	push   $0xf0136eb3
f0106c58:	68 a5 01 00 00       	push   $0x1a5
f0106c5d:	68 77 6e 13 f0       	push   $0xf0136e77
f0106c62:	e8 48 a2 ff ff       	call   f0100eaf <_panic>
f0106c67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6a:	8b 40 08             	mov    0x8(%eax),%eax
f0106c6d:	85 c0                	test   %eax,%eax
f0106c6f:	74 11                	je     f0106c82 <sched_kill_env+0x153>
f0106c71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c74:	8b 40 08             	mov    0x8(%eax),%eax
f0106c77:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106c7a:	8b 52 0c             	mov    0xc(%edx),%edx
f0106c7d:	89 50 0c             	mov    %edx,0xc(%eax)
f0106c80:	eb 16                	jmp    f0106c98 <sched_kill_env+0x169>
f0106c82:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c8a:	c1 e2 04             	shl    $0x4,%edx
f0106c8d:	01 c2                	add    %eax,%edx
f0106c8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c92:	8b 40 0c             	mov    0xc(%eax),%eax
f0106c95:	89 42 04             	mov    %eax,0x4(%edx)
f0106c98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c9b:	8b 40 0c             	mov    0xc(%eax),%eax
f0106c9e:	85 c0                	test   %eax,%eax
f0106ca0:	74 11                	je     f0106cb3 <sched_kill_env+0x184>
f0106ca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ca5:	8b 40 0c             	mov    0xc(%eax),%eax
f0106ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106cab:	8b 52 08             	mov    0x8(%edx),%edx
f0106cae:	89 50 08             	mov    %edx,0x8(%eax)
f0106cb1:	eb 15                	jmp    f0106cc8 <sched_kill_env+0x199>
f0106cb3:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106cb8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cbb:	c1 e2 04             	shl    $0x4,%edx
f0106cbe:	01 c2                	add    %eax,%edx
f0106cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cc3:	8b 40 08             	mov    0x8(%eax),%eax
f0106cc6:	89 02                	mov    %eax,(%edx)
f0106cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ccb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106cdc:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106ce1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106ce4:	c1 e2 04             	shl    $0x4,%edx
f0106ce7:	01 d0                	add    %edx,%eax
f0106ce9:	8b 50 0c             	mov    0xc(%eax),%edx
f0106cec:	4a                   	dec    %edx
f0106ced:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106cf0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106cf7:	eb 4b                	jmp    f0106d44 <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106cf9:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106cfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106d01:	c1 e2 04             	shl    $0x4,%edx
f0106d04:	01 d0                	add    %edx,%eax
f0106d06:	8b 40 08             	mov    0x8(%eax),%eax
f0106d09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106d0c:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106d11:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106d14:	c1 e2 04             	shl    $0x4,%edx
f0106d17:	01 d0                	add    %edx,%eax
f0106d19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d1d:	74 08                	je     f0106d27 <sched_kill_env+0x1f8>
f0106d1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106d22:	8b 52 08             	mov    0x8(%edx),%edx
f0106d25:	eb 05                	jmp    f0106d2c <sched_kill_env+0x1fd>
f0106d27:	ba 00 00 00 00       	mov    $0x0,%edx
f0106d2c:	89 50 08             	mov    %edx,0x8(%eax)
f0106d2f:	8b 40 08             	mov    0x8(%eax),%eax
f0106d32:	85 c0                	test   %eax,%eax
f0106d34:	0f 85 e3 fe ff ff    	jne    f0106c1d <sched_kill_env+0xee>
f0106d3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d3e:	0f 85 d9 fe ff ff    	jne    f0106c1d <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0106d44:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106d48:	75 16                	jne    f0106d60 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106d4a:	ff 45 ec             	incl   -0x14(%ebp)
f0106d4d:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0106d52:	0f b6 c0             	movzbl %al,%eax
f0106d55:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106d58:	0f 8f 8a fe ff ff    	jg     f0106be8 <sched_kill_env+0xb9>
f0106d5e:	eb 01                	jmp    f0106d61 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0106d60:	90                   	nop
		}
	}
	if (!found)
f0106d61:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106d65:	0f 85 80 00 00 00    	jne    f0106deb <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0106d6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106d72:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0106d77:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106d7a:	eb 48                	jmp    f0106dc4 <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0106d7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d7f:	8b 40 10             	mov    0x10(%eax),%eax
f0106d82:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106d85:	75 35                	jne    f0106dbc <sched_kill_env+0x28d>
			{
				cprintf("[BEGIN] killing[%d] %s from the EXIT queue...\n", ptr_env->env_id, ptr_env->prog_name);
f0106d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d8a:	8d 50 20             	lea    0x20(%eax),%edx
f0106d8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d90:	8b 40 10             	mov    0x10(%eax),%eax
f0106d93:	83 ec 04             	sub    $0x4,%esp
f0106d96:	52                   	push   %edx
f0106d97:	50                   	push   %eax
f0106d98:	68 24 70 13 f0       	push   $0xf0137024
f0106d9d:	e8 ab ad ff ff       	call   f0101b4d <cprintf>
f0106da2:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0106da5:	83 ec 0c             	sub    $0xc,%esp
f0106da8:	ff 75 f4             	pushl  -0xc(%ebp)
f0106dab:	e8 f3 f8 ff ff       	call   f01066a3 <sched_remove_exit>
f0106db0:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106db3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106dba:	eb 2f                	jmp    f0106deb <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106dbc:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0106dc1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106dc4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106dc8:	74 08                	je     f0106dd2 <sched_kill_env+0x2a3>
f0106dca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106dcd:	8b 40 08             	mov    0x8(%eax),%eax
f0106dd0:	eb 05                	jmp    f0106dd7 <sched_kill_env+0x2a8>
f0106dd2:	b8 00 00 00 00       	mov    $0x0,%eax
f0106dd7:	a3 48 ce 94 f1       	mov    %eax,0xf194ce48
f0106ddc:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0106de1:	85 c0                	test   %eax,%eax
f0106de3:	75 97                	jne    f0106d7c <sched_kill_env+0x24d>
f0106de5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106de9:	75 91                	jne    f0106d7c <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106deb:	83 ec 0c             	sub    $0xc,%esp
f0106dee:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106df3:	e8 f2 c7 00 00       	call   f01135ea <release_kspinlock>
f0106df8:	83 c4 10             	add    $0x10,%esp

	if (found)
f0106dfb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106dff:	74 23                	je     f0106e24 <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0106e01:	83 ec 0c             	sub    $0xc,%esp
f0106e04:	ff 75 f4             	pushl  -0xc(%ebp)
f0106e07:	e8 dd 67 00 00       	call   f010d5e9 <env_free>
f0106e0c:	83 c4 10             	add    $0x10,%esp
		cprintf("[END] DONE\n");
f0106e0f:	83 ec 0c             	sub    $0xc,%esp
f0106e12:	68 53 70 13 f0       	push   $0xf0137053
f0106e17:	e8 31 ad ff ff       	call   f0101b4d <cprintf>
f0106e1c:	83 c4 10             	add    $0x10,%esp
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
			sched();
		}
	}

}
f0106e1f:	e9 b8 00 00 00       	jmp    f0106edc <sched_kill_env+0x3ad>
		env_free(ptr_env);
		cprintf("[END] DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106e24:	e8 1f 68 00 00       	call   f010d648 <get_cpu_proc>
f0106e29:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106e2c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106e30:	75 19                	jne    f0106e4b <sched_kill_env+0x31c>
f0106e32:	68 af 6f 13 f0       	push   $0xf0136faf
f0106e37:	68 62 6e 13 f0       	push   $0xf0136e62
f0106e3c:	68 c7 01 00 00       	push   $0x1c7
f0106e41:	68 77 6e 13 f0       	push   $0xf0136e77
f0106e46:	e8 64 a0 ff ff       	call   f0100eaf <_panic>

		if (cur_env->env_id == envId)
f0106e4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106e4e:	8b 40 10             	mov    0x10(%eax),%eax
f0106e51:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106e54:	0f 85 82 00 00 00    	jne    f0106edc <sched_kill_env+0x3ad>
		{
			ptr_env = cur_env;
f0106e5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106e5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106e60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e63:	8b 40 18             	mov    0x18(%eax),%eax
f0106e66:	83 f8 02             	cmp    $0x2,%eax
f0106e69:	74 19                	je     f0106e84 <sched_kill_env+0x355>
f0106e6b:	68 60 70 13 f0       	push   $0xf0137060
f0106e70:	68 62 6e 13 f0       	push   $0xf0136e62
f0106e75:	68 cc 01 00 00       	push   $0x1cc
f0106e7a:	68 77 6e 13 f0       	push   $0xf0136e77
f0106e7f:	e8 2b a0 ff ff       	call   f0100eaf <_panic>
			cprintf("[BEGIN] killing a RUNNABLE environment [%d] %s...\n", ptr_env->env_id, ptr_env->prog_name);
f0106e84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e87:	8d 50 20             	lea    0x20(%eax),%edx
f0106e8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e8d:	8b 40 10             	mov    0x10(%eax),%eax
f0106e90:	83 ec 04             	sub    $0x4,%esp
f0106e93:	52                   	push   %edx
f0106e94:	50                   	push   %eax
f0106e95:	68 84 70 13 f0       	push   $0xf0137084
f0106e9a:	e8 ae ac ff ff       	call   f0101b4d <cprintf>
f0106e9f:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106ea2:	83 ec 0c             	sub    $0xc,%esp
f0106ea5:	ff 75 f4             	pushl  -0xc(%ebp)
f0106ea8:	e8 3c 67 00 00       	call   f010d5e9 <env_free>
f0106ead:	83 c4 10             	add    $0x10,%esp
			cprintf("[END] DONE\n");
f0106eb0:	83 ec 0c             	sub    $0xc,%esp
f0106eb3:	68 53 70 13 f0       	push   $0xf0137053
f0106eb8:	e8 90 ac ff ff       	call   f0101b4d <cprintf>
f0106ebd:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0106ec0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ec7:	83 ec 0c             	sub    $0xc,%esp
f0106eca:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106ecf:	e8 71 c6 00 00       	call   f0113545 <acquire_kspinlock>
f0106ed4:	83 c4 10             	add    $0x10,%esp
			sched();
f0106ed7:	e8 e6 68 00 00       	call   f010d7c2 <sched>
		}
	}

}
f0106edc:	90                   	nop
f0106edd:	c9                   	leave  
f0106ede:	c3                   	ret    

f0106edf <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0106edf:	55                   	push   %ebp
f0106ee0:	89 e5                	mov    %esp,%ebp
f0106ee2:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ee5:	83 ec 0c             	sub    $0xc,%esp
f0106ee8:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0106eed:	e8 53 c6 00 00       	call   f0113545 <acquire_kspinlock>
f0106ef2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106ef5:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f0106efa:	85 c0                	test   %eax,%eax
f0106efc:	74 69                	je     f0106f67 <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0106efe:	83 ec 0c             	sub    $0xc,%esp
f0106f01:	68 b8 70 13 f0       	push   $0xf01370b8
f0106f06:	e8 42 ac ff ff       	call   f0101b4d <cprintf>
f0106f0b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106f0e:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f0106f13:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f16:	eb 26                	jmp    f0106f3e <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106f18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f1b:	8d 50 20             	lea    0x20(%eax),%edx
f0106f1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f21:	8b 40 10             	mov    0x10(%eax),%eax
f0106f24:	83 ec 04             	sub    $0x4,%esp
f0106f27:	52                   	push   %edx
f0106f28:	50                   	push   %eax
f0106f29:	68 da 70 13 f0       	push   $0xf01370da
f0106f2e:	e8 1a ac ff ff       	call   f0101b4d <cprintf>
f0106f33:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106f36:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106f3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f42:	74 08                	je     f0106f4c <sched_print_all+0x6d>
f0106f44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f47:	8b 40 08             	mov    0x8(%eax),%eax
f0106f4a:	eb 05                	jmp    f0106f51 <sched_print_all+0x72>
f0106f4c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106f51:	a3 38 ce 94 f1       	mov    %eax,0xf194ce38
f0106f56:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0106f5b:	85 c0                	test   %eax,%eax
f0106f5d:	75 b9                	jne    f0106f18 <sched_print_all+0x39>
f0106f5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f63:	75 b3                	jne    f0106f18 <sched_print_all+0x39>
f0106f65:	eb 10                	jmp    f0106f77 <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106f67:	83 ec 0c             	sub    $0xc,%esp
f0106f6a:	68 e4 70 13 f0       	push   $0xf01370e4
f0106f6f:	e8 d9 ab ff ff       	call   f0101b4d <cprintf>
f0106f74:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106f77:	83 ec 0c             	sub    $0xc,%esp
f0106f7a:	68 00 71 13 f0       	push   $0xf0137100
f0106f7f:	e8 c9 ab ff ff       	call   f0101b4d <cprintf>
f0106f84:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106f87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106f8e:	e9 c7 00 00 00       	jmp    f010705a <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106f93:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106f98:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106f9b:	c1 e2 04             	shl    $0x4,%edx
f0106f9e:	01 d0                	add    %edx,%eax
f0106fa0:	8b 00                	mov    (%eax),%eax
f0106fa2:	85 c0                	test   %eax,%eax
f0106fa4:	0f 84 8a 00 00 00    	je     f0107034 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0106faa:	83 ec 08             	sub    $0x8,%esp
f0106fad:	ff 75 f0             	pushl  -0x10(%ebp)
f0106fb0:	68 34 71 13 f0       	push   $0xf0137134
f0106fb5:	e8 93 ab ff ff       	call   f0101b4d <cprintf>
f0106fba:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106fbd:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106fc2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fc5:	c1 e2 04             	shl    $0x4,%edx
f0106fc8:	01 d0                	add    %edx,%eax
f0106fca:	8b 00                	mov    (%eax),%eax
f0106fcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106fcf:	eb 31                	jmp    f0107002 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106fd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fd4:	8d 50 20             	lea    0x20(%eax),%edx
f0106fd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fda:	8b 40 10             	mov    0x10(%eax),%eax
f0106fdd:	83 ec 04             	sub    $0x4,%esp
f0106fe0:	52                   	push   %edx
f0106fe1:	50                   	push   %eax
f0106fe2:	68 da 70 13 f0       	push   $0xf01370da
f0106fe7:	e8 61 ab ff ff       	call   f0101b4d <cprintf>
f0106fec:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106fef:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0106ff4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ff7:	c1 e2 04             	shl    $0x4,%edx
f0106ffa:	01 d0                	add    %edx,%eax
f0106ffc:	8b 40 08             	mov    0x8(%eax),%eax
f0106fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107002:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107007:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010700a:	c1 e2 04             	shl    $0x4,%edx
f010700d:	01 d0                	add    %edx,%eax
f010700f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107013:	74 08                	je     f010701d <sched_print_all+0x13e>
f0107015:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107018:	8b 52 08             	mov    0x8(%edx),%edx
f010701b:	eb 05                	jmp    f0107022 <sched_print_all+0x143>
f010701d:	ba 00 00 00 00       	mov    $0x0,%edx
f0107022:	89 50 08             	mov    %edx,0x8(%eax)
f0107025:	8b 40 08             	mov    0x8(%eax),%eax
f0107028:	85 c0                	test   %eax,%eax
f010702a:	75 a5                	jne    f0106fd1 <sched_print_all+0xf2>
f010702c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107030:	75 9f                	jne    f0106fd1 <sched_print_all+0xf2>
f0107032:	eb 13                	jmp    f0107047 <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0107034:	83 ec 08             	sub    $0x8,%esp
f0107037:	ff 75 f0             	pushl  -0x10(%ebp)
f010703a:	68 5c 71 13 f0       	push   $0xf013715c
f010703f:	e8 09 ab ff ff       	call   f0101b4d <cprintf>
f0107044:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0107047:	83 ec 0c             	sub    $0xc,%esp
f010704a:	68 00 71 13 f0       	push   $0xf0137100
f010704f:	e8 f9 aa ff ff       	call   f0101b4d <cprintf>
f0107054:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107057:	ff 45 f0             	incl   -0x10(%ebp)
f010705a:	a0 00 54 96 f1       	mov    0xf1965400,%al
f010705f:	0f b6 c0             	movzbl %al,%eax
f0107062:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0107065:	0f 8f 28 ff ff ff    	jg     f0106f93 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f010706b:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0107070:	85 c0                	test   %eax,%eax
f0107072:	74 69                	je     f01070dd <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0107074:	83 ec 0c             	sub    $0xc,%esp
f0107077:	68 80 71 13 f0       	push   $0xf0137180
f010707c:	e8 cc aa ff ff       	call   f0101b4d <cprintf>
f0107081:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107084:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0107089:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010708c:	eb 26                	jmp    f01070b4 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f010708e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107091:	8d 50 20             	lea    0x20(%eax),%edx
f0107094:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107097:	8b 40 10             	mov    0x10(%eax),%eax
f010709a:	83 ec 04             	sub    $0x4,%esp
f010709d:	52                   	push   %edx
f010709e:	50                   	push   %eax
f010709f:	68 da 70 13 f0       	push   $0xf01370da
f01070a4:	e8 a4 aa ff ff       	call   f0101b4d <cprintf>
f01070a9:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01070ac:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f01070b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01070b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01070b8:	74 08                	je     f01070c2 <sched_print_all+0x1e3>
f01070ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070bd:	8b 40 08             	mov    0x8(%eax),%eax
f01070c0:	eb 05                	jmp    f01070c7 <sched_print_all+0x1e8>
f01070c2:	b8 00 00 00 00       	mov    $0x0,%eax
f01070c7:	a3 48 ce 94 f1       	mov    %eax,0xf194ce48
f01070cc:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f01070d1:	85 c0                	test   %eax,%eax
f01070d3:	75 b9                	jne    f010708e <sched_print_all+0x1af>
f01070d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01070d9:	75 b3                	jne    f010708e <sched_print_all+0x1af>
f01070db:	eb 10                	jmp    f01070ed <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01070dd:	83 ec 0c             	sub    $0xc,%esp
f01070e0:	68 a2 71 13 f0       	push   $0xf01371a2
f01070e5:	e8 63 aa ff ff       	call   f0101b4d <cprintf>
f01070ea:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01070ed:	83 ec 0c             	sub    $0xc,%esp
f01070f0:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01070f5:	e8 f0 c4 00 00       	call   f01135ea <release_kspinlock>
f01070fa:	83 c4 10             	add    $0x10,%esp
}
f01070fd:	90                   	nop
f01070fe:	c9                   	leave  
f01070ff:	c3                   	ret    

f0107100 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0107100:	55                   	push   %ebp
f0107101:	89 e5                	mov    %esp,%ebp
f0107103:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107106:	83 ec 0c             	sub    $0xc,%esp
f0107109:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010710e:	e8 32 c4 00 00       	call   f0113545 <acquire_kspinlock>
f0107113:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0107116:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f010711d:	a1 3c ce 94 f1       	mov    0xf194ce3c,%eax
f0107122:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0107125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010712c:	eb 24                	jmp    f0107152 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f010712e:	83 ec 0c             	sub    $0xc,%esp
f0107131:	68 30 ce 94 f1       	push   $0xf194ce30
f0107136:	e8 6b ef ff ff       	call   f01060a6 <dequeue>
f010713b:	83 c4 10             	add    $0x10,%esp
f010713e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0107141:	83 ec 0c             	sub    $0xc,%esp
f0107144:	ff 75 f0             	pushl  -0x10(%ebp)
f0107147:	e8 95 f1 ff ff       	call   f01062e1 <sched_insert_ready>
f010714c:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f010714f:	ff 45 f4             	incl   -0xc(%ebp)
f0107152:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107155:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0107158:	7c d4                	jl     f010712e <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010715a:	83 ec 0c             	sub    $0xc,%esp
f010715d:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107162:	e8 83 c4 00 00       	call   f01135ea <release_kspinlock>
f0107167:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010716a:	e8 90 13 00 00       	call   f01084ff <mycpu>
f010716f:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0107175:	85 c0                	test   %eax,%eax
f0107177:	75 05                	jne    f010717e <sched_run_all+0x7e>
		fos_scheduler();
f0107179:	e8 85 07 00 00       	call   f0107903 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f010717e:	83 ec 04             	sub    $0x4,%esp
f0107181:	68 c0 71 13 f0       	push   $0xf01371c0
f0107186:	68 2a 02 00 00       	push   $0x22a
f010718b:	68 77 6e 13 f0       	push   $0xf0136e77
f0107190:	e8 1a 9d ff ff       	call   f0100eaf <_panic>

f0107195 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f0107195:	55                   	push   %ebp
f0107196:	89 e5                	mov    %esp,%ebp
f0107198:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010719b:	83 ec 0c             	sub    $0xc,%esp
f010719e:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01071a3:	e8 9d c3 00 00       	call   f0113545 <acquire_kspinlock>
f01071a8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01071ab:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f01071b0:	85 c0                	test   %eax,%eax
f01071b2:	0f 84 95 00 00 00    	je     f010724d <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01071b8:	83 ec 0c             	sub    $0xc,%esp
f01071bb:	68 fc 71 13 f0       	push   $0xf01371fc
f01071c0:	e8 88 a9 ff ff       	call   f0101b4d <cprintf>
f01071c5:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01071c8:	a1 30 ce 94 f1       	mov    0xf194ce30,%eax
f01071cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01071d0:	eb 52                	jmp    f0107224 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01071d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071d5:	8d 50 20             	lea    0x20(%eax),%edx
f01071d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071db:	8b 40 10             	mov    0x10(%eax),%eax
f01071de:	83 ec 04             	sub    $0x4,%esp
f01071e1:	52                   	push   %edx
f01071e2:	50                   	push   %eax
f01071e3:	68 28 72 13 f0       	push   $0xf0137228
f01071e8:	e8 60 a9 ff ff       	call   f0101b4d <cprintf>
f01071ed:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01071f0:	83 ec 0c             	sub    $0xc,%esp
f01071f3:	ff 75 f4             	pushl  -0xc(%ebp)
f01071f6:	e8 31 f3 ff ff       	call   f010652c <sched_remove_new>
f01071fb:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01071fe:	83 ec 0c             	sub    $0xc,%esp
f0107201:	ff 75 f4             	pushl  -0xc(%ebp)
f0107204:	e8 e0 63 00 00       	call   f010d5e9 <env_free>
f0107209:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f010720c:	83 ec 0c             	sub    $0xc,%esp
f010720f:	68 3b 72 13 f0       	push   $0xf013723b
f0107214:	e8 34 a9 ff ff       	call   f0101b4d <cprintf>
f0107219:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010721c:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0107221:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107224:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107228:	74 08                	je     f0107232 <sched_kill_all+0x9d>
f010722a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010722d:	8b 40 08             	mov    0x8(%eax),%eax
f0107230:	eb 05                	jmp    f0107237 <sched_kill_all+0xa2>
f0107232:	b8 00 00 00 00       	mov    $0x0,%eax
f0107237:	a3 38 ce 94 f1       	mov    %eax,0xf194ce38
f010723c:	a1 38 ce 94 f1       	mov    0xf194ce38,%eax
f0107241:	85 c0                	test   %eax,%eax
f0107243:	75 8d                	jne    f01071d2 <sched_kill_all+0x3d>
f0107245:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107249:	75 87                	jne    f01071d2 <sched_kill_all+0x3d>
f010724b:	eb 10                	jmp    f010725d <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f010724d:	83 ec 0c             	sub    $0xc,%esp
f0107250:	68 41 72 13 f0       	push   $0xf0137241
f0107255:	e8 f3 a8 ff ff       	call   f0101b4d <cprintf>
f010725a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f010725d:	83 ec 0c             	sub    $0xc,%esp
f0107260:	68 00 71 13 f0       	push   $0xf0137100
f0107265:	e8 e3 a8 ff ff       	call   f0101b4d <cprintf>
f010726a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010726d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0107274:	e9 96 01 00 00       	jmp    f010740f <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0107279:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010727e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107281:	c1 e2 04             	shl    $0x4,%edx
f0107284:	01 d0                	add    %edx,%eax
f0107286:	8b 00                	mov    (%eax),%eax
f0107288:	85 c0                	test   %eax,%eax
f010728a:	0f 84 59 01 00 00    	je     f01073e9 <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0107290:	83 ec 08             	sub    $0x8,%esp
f0107293:	ff 75 f0             	pushl  -0x10(%ebp)
f0107296:	68 5c 72 13 f0       	push   $0xf013725c
f010729b:	e8 ad a8 ff ff       	call   f0101b4d <cprintf>
f01072a0:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01072a3:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01072a8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01072ab:	c1 e2 04             	shl    $0x4,%edx
f01072ae:	01 d0                	add    %edx,%eax
f01072b0:	8b 00                	mov    (%eax),%eax
f01072b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01072b5:	e9 f5 00 00 00       	jmp    f01073af <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01072ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072bd:	8d 50 20             	lea    0x20(%eax),%edx
f01072c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072c3:	8b 40 10             	mov    0x10(%eax),%eax
f01072c6:	83 ec 04             	sub    $0x4,%esp
f01072c9:	52                   	push   %edx
f01072ca:	50                   	push   %eax
f01072cb:	68 28 72 13 f0       	push   $0xf0137228
f01072d0:	e8 78 a8 ff ff       	call   f0101b4d <cprintf>
f01072d5:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01072d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01072dc:	75 17                	jne    f01072f5 <sched_kill_all+0x160>
f01072de:	83 ec 04             	sub    $0x4,%esp
f01072e1:	68 b3 6e 13 f0       	push   $0xf0136eb3
f01072e6:	68 4c 02 00 00       	push   $0x24c
f01072eb:	68 77 6e 13 f0       	push   $0xf0136e77
f01072f0:	e8 ba 9b ff ff       	call   f0100eaf <_panic>
f01072f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072f8:	8b 40 08             	mov    0x8(%eax),%eax
f01072fb:	85 c0                	test   %eax,%eax
f01072fd:	74 11                	je     f0107310 <sched_kill_all+0x17b>
f01072ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107302:	8b 40 08             	mov    0x8(%eax),%eax
f0107305:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107308:	8b 52 0c             	mov    0xc(%edx),%edx
f010730b:	89 50 0c             	mov    %edx,0xc(%eax)
f010730e:	eb 16                	jmp    f0107326 <sched_kill_all+0x191>
f0107310:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107315:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107318:	c1 e2 04             	shl    $0x4,%edx
f010731b:	01 c2                	add    %eax,%edx
f010731d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107320:	8b 40 0c             	mov    0xc(%eax),%eax
f0107323:	89 42 04             	mov    %eax,0x4(%edx)
f0107326:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107329:	8b 40 0c             	mov    0xc(%eax),%eax
f010732c:	85 c0                	test   %eax,%eax
f010732e:	74 11                	je     f0107341 <sched_kill_all+0x1ac>
f0107330:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107333:	8b 40 0c             	mov    0xc(%eax),%eax
f0107336:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107339:	8b 52 08             	mov    0x8(%edx),%edx
f010733c:	89 50 08             	mov    %edx,0x8(%eax)
f010733f:	eb 15                	jmp    f0107356 <sched_kill_all+0x1c1>
f0107341:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107346:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107349:	c1 e2 04             	shl    $0x4,%edx
f010734c:	01 c2                	add    %eax,%edx
f010734e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107351:	8b 40 08             	mov    0x8(%eax),%eax
f0107354:	89 02                	mov    %eax,(%edx)
f0107356:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107359:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0107360:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107363:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010736a:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010736f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107372:	c1 e2 04             	shl    $0x4,%edx
f0107375:	01 d0                	add    %edx,%eax
f0107377:	8b 50 0c             	mov    0xc(%eax),%edx
f010737a:	4a                   	dec    %edx
f010737b:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f010737e:	83 ec 0c             	sub    $0xc,%esp
f0107381:	ff 75 f4             	pushl  -0xc(%ebp)
f0107384:	e8 60 62 00 00       	call   f010d5e9 <env_free>
f0107389:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f010738c:	83 ec 0c             	sub    $0xc,%esp
f010738f:	68 3b 72 13 f0       	push   $0xf013723b
f0107394:	e8 b4 a7 ff ff       	call   f0101b4d <cprintf>
f0107399:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010739c:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01073a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01073a4:	c1 e2 04             	shl    $0x4,%edx
f01073a7:	01 d0                	add    %edx,%eax
f01073a9:	8b 40 08             	mov    0x8(%eax),%eax
f01073ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01073af:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01073b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01073b7:	c1 e2 04             	shl    $0x4,%edx
f01073ba:	01 d0                	add    %edx,%eax
f01073bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073c0:	74 08                	je     f01073ca <sched_kill_all+0x235>
f01073c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01073c5:	8b 52 08             	mov    0x8(%edx),%edx
f01073c8:	eb 05                	jmp    f01073cf <sched_kill_all+0x23a>
f01073ca:	ba 00 00 00 00       	mov    $0x0,%edx
f01073cf:	89 50 08             	mov    %edx,0x8(%eax)
f01073d2:	8b 40 08             	mov    0x8(%eax),%eax
f01073d5:	85 c0                	test   %eax,%eax
f01073d7:	0f 85 dd fe ff ff    	jne    f01072ba <sched_kill_all+0x125>
f01073dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073e1:	0f 85 d3 fe ff ff    	jne    f01072ba <sched_kill_all+0x125>
f01073e7:	eb 13                	jmp    f01073fc <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01073e9:	83 ec 08             	sub    $0x8,%esp
f01073ec:	ff 75 f0             	pushl  -0x10(%ebp)
f01073ef:	68 5c 71 13 f0       	push   $0xf013715c
f01073f4:	e8 54 a7 ff ff       	call   f0101b4d <cprintf>
f01073f9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01073fc:	83 ec 0c             	sub    $0xc,%esp
f01073ff:	68 00 71 13 f0       	push   $0xf0137100
f0107404:	e8 44 a7 ff ff       	call   f0101b4d <cprintf>
f0107409:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010740c:	ff 45 f0             	incl   -0x10(%ebp)
f010740f:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0107414:	0f b6 c0             	movzbl %al,%eax
f0107417:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010741a:	0f 8f 59 fe ff ff    	jg     f0107279 <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0107420:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0107425:	85 c0                	test   %eax,%eax
f0107427:	0f 84 95 00 00 00    	je     f01074c2 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f010742d:	83 ec 0c             	sub    $0xc,%esp
f0107430:	68 90 72 13 f0       	push   $0xf0137290
f0107435:	e8 13 a7 ff ff       	call   f0101b4d <cprintf>
f010743a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010743d:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0107442:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107445:	eb 52                	jmp    f0107499 <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0107447:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744a:	8d 50 20             	lea    0x20(%eax),%edx
f010744d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107450:	8b 40 10             	mov    0x10(%eax),%eax
f0107453:	83 ec 04             	sub    $0x4,%esp
f0107456:	52                   	push   %edx
f0107457:	50                   	push   %eax
f0107458:	68 28 72 13 f0       	push   $0xf0137228
f010745d:	e8 eb a6 ff ff       	call   f0101b4d <cprintf>
f0107462:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0107465:	83 ec 0c             	sub    $0xc,%esp
f0107468:	ff 75 f4             	pushl  -0xc(%ebp)
f010746b:	e8 33 f2 ff ff       	call   f01066a3 <sched_remove_exit>
f0107470:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0107473:	83 ec 0c             	sub    $0xc,%esp
f0107476:	ff 75 f4             	pushl  -0xc(%ebp)
f0107479:	e8 6b 61 00 00       	call   f010d5e9 <env_free>
f010747e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107481:	83 ec 0c             	sub    $0xc,%esp
f0107484:	68 3b 72 13 f0       	push   $0xf013723b
f0107489:	e8 bf a6 ff ff       	call   f0101b4d <cprintf>
f010748e:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107491:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0107496:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107499:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010749d:	74 08                	je     f01074a7 <sched_kill_all+0x312>
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8b 40 08             	mov    0x8(%eax),%eax
f01074a5:	eb 05                	jmp    f01074ac <sched_kill_all+0x317>
f01074a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01074ac:	a3 48 ce 94 f1       	mov    %eax,0xf194ce48
f01074b1:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f01074b6:	85 c0                	test   %eax,%eax
f01074b8:	75 8d                	jne    f0107447 <sched_kill_all+0x2b2>
f01074ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01074be:	75 87                	jne    f0107447 <sched_kill_all+0x2b2>
f01074c0:	eb 10                	jmp    f01074d2 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01074c2:	83 ec 0c             	sub    $0xc,%esp
f01074c5:	68 a2 71 13 f0       	push   $0xf01371a2
f01074ca:	e8 7e a6 ff ff       	call   f0101b4d <cprintf>
f01074cf:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01074d2:	e8 71 61 00 00       	call   f010d648 <get_cpu_proc>
f01074d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01074da:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01074de:	74 6b                	je     f010754b <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01074e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01074e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01074e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074e9:	8b 40 18             	mov    0x18(%eax),%eax
f01074ec:	83 f8 02             	cmp    $0x2,%eax
f01074ef:	74 19                	je     f010750a <sched_kill_all+0x375>
f01074f1:	68 60 70 13 f0       	push   $0xf0137060
f01074f6:	68 62 6e 13 f0       	push   $0xf0136e62
f01074fb:	68 6c 02 00 00       	push   $0x26c
f0107500:	68 77 6e 13 f0       	push   $0xf0136e77
f0107505:	e8 a5 99 ff ff       	call   f0100eaf <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010750a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750d:	8d 50 20             	lea    0x20(%eax),%edx
f0107510:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107513:	8b 40 10             	mov    0x10(%eax),%eax
f0107516:	83 ec 04             	sub    $0x4,%esp
f0107519:	52                   	push   %edx
f010751a:	50                   	push   %eax
f010751b:	68 bc 72 13 f0       	push   $0xf01372bc
f0107520:	e8 28 a6 ff ff       	call   f0101b4d <cprintf>
f0107525:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f0107528:	83 ec 0c             	sub    $0xc,%esp
f010752b:	ff 75 f4             	pushl  -0xc(%ebp)
f010752e:	e8 b6 60 00 00       	call   f010d5e9 <env_free>
f0107533:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0107536:	83 ec 0c             	sub    $0xc,%esp
f0107539:	68 3b 72 13 f0       	push   $0xf013723b
f010753e:	e8 0a a6 ff ff       	call   f0101b4d <cprintf>
f0107543:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f0107546:	e8 77 62 00 00       	call   f010d7c2 <sched>
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010754b:	83 ec 0c             	sub    $0xc,%esp
f010754e:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107553:	e8 92 c0 00 00       	call   f01135ea <release_kspinlock>
f0107558:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f010755b:	e8 73 a7 ff ff       	call   f0101cd3 <get_into_prompt>

f0107560 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0107560:	55                   	push   %ebp
f0107561:	89 e5                	mov    %esp,%ebp
f0107563:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107566:	83 ec 0c             	sub    $0xc,%esp
f0107569:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010756e:	e8 d2 bf 00 00       	call   f0113545 <acquire_kspinlock>
f0107573:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0107576:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010757d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0107584:	e9 37 01 00 00       	jmp    f01076c0 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0107589:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010758e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107591:	c1 e2 04             	shl    $0x4,%edx
f0107594:	01 d0                	add    %edx,%eax
f0107596:	8b 00                	mov    (%eax),%eax
f0107598:	85 c0                	test   %eax,%eax
f010759a:	0f 84 1d 01 00 00    	je     f01076bd <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f01075a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01075a7:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01075ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01075af:	c1 e2 04             	shl    $0x4,%edx
f01075b2:	01 d0                	add    %edx,%eax
f01075b4:	8b 00                	mov    (%eax),%eax
f01075b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01075b9:	e9 c7 00 00 00       	jmp    f0107685 <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01075be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01075c2:	75 17                	jne    f01075db <sched_exit_all_ready_envs+0x7b>
f01075c4:	83 ec 04             	sub    $0x4,%esp
f01075c7:	68 b3 6e 13 f0       	push   $0xf0136eb3
f01075cc:	68 8e 02 00 00       	push   $0x28e
f01075d1:	68 77 6e 13 f0       	push   $0xf0136e77
f01075d6:	e8 d4 98 ff ff       	call   f0100eaf <_panic>
f01075db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075de:	8b 40 08             	mov    0x8(%eax),%eax
f01075e1:	85 c0                	test   %eax,%eax
f01075e3:	74 11                	je     f01075f6 <sched_exit_all_ready_envs+0x96>
f01075e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075e8:	8b 40 08             	mov    0x8(%eax),%eax
f01075eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01075ee:	8b 52 0c             	mov    0xc(%edx),%edx
f01075f1:	89 50 0c             	mov    %edx,0xc(%eax)
f01075f4:	eb 16                	jmp    f010760c <sched_exit_all_ready_envs+0xac>
f01075f6:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f01075fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01075fe:	c1 e2 04             	shl    $0x4,%edx
f0107601:	01 c2                	add    %eax,%edx
f0107603:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107606:	8b 40 0c             	mov    0xc(%eax),%eax
f0107609:	89 42 04             	mov    %eax,0x4(%edx)
f010760c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107612:	85 c0                	test   %eax,%eax
f0107614:	74 11                	je     f0107627 <sched_exit_all_ready_envs+0xc7>
f0107616:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107619:	8b 40 0c             	mov    0xc(%eax),%eax
f010761c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010761f:	8b 52 08             	mov    0x8(%edx),%edx
f0107622:	89 50 08             	mov    %edx,0x8(%eax)
f0107625:	eb 15                	jmp    f010763c <sched_exit_all_ready_envs+0xdc>
f0107627:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010762c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010762f:	c1 e2 04             	shl    $0x4,%edx
f0107632:	01 c2                	add    %eax,%edx
f0107634:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107637:	8b 40 08             	mov    0x8(%eax),%eax
f010763a:	89 02                	mov    %eax,(%edx)
f010763c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010763f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0107646:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107649:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107650:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107655:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107658:	c1 e2 04             	shl    $0x4,%edx
f010765b:	01 d0                	add    %edx,%eax
f010765d:	8b 50 0c             	mov    0xc(%eax),%edx
f0107660:	4a                   	dec    %edx
f0107661:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0107664:	83 ec 0c             	sub    $0xc,%esp
f0107667:	ff 75 f4             	pushl  -0xc(%ebp)
f010766a:	e8 ad ef ff ff       	call   f010661c <sched_insert_exit>
f010766f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107672:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107677:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010767a:	c1 e2 04             	shl    $0x4,%edx
f010767d:	01 d0                	add    %edx,%eax
f010767f:	8b 40 08             	mov    0x8(%eax),%eax
f0107682:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107685:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f010768a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010768d:	c1 e2 04             	shl    $0x4,%edx
f0107690:	01 d0                	add    %edx,%eax
f0107692:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107696:	74 08                	je     f01076a0 <sched_exit_all_ready_envs+0x140>
f0107698:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010769b:	8b 52 08             	mov    0x8(%edx),%edx
f010769e:	eb 05                	jmp    f01076a5 <sched_exit_all_ready_envs+0x145>
f01076a0:	ba 00 00 00 00       	mov    $0x0,%edx
f01076a5:	89 50 08             	mov    %edx,0x8(%eax)
f01076a8:	8b 40 08             	mov    0x8(%eax),%eax
f01076ab:	85 c0                	test   %eax,%eax
f01076ad:	0f 85 0b ff ff ff    	jne    f01075be <sched_exit_all_ready_envs+0x5e>
f01076b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076b7:	0f 85 01 ff ff ff    	jne    f01075be <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01076bd:	ff 45 f0             	incl   -0x10(%ebp)
f01076c0:	a0 00 54 96 f1       	mov    0xf1965400,%al
f01076c5:	0f b6 c0             	movzbl %al,%eax
f01076c8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01076cb:	0f 8f b8 fe ff ff    	jg     f0107589 <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01076d1:	83 ec 0c             	sub    $0xc,%esp
f01076d4:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01076d9:	e8 0c bf 00 00       	call   f01135ea <release_kspinlock>
f01076de:	83 c4 10             	add    $0x10,%esp
}
f01076e1:	90                   	nop
f01076e2:	c9                   	leave  
f01076e3:	c3                   	ret    

f01076e4 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01076e4:	55                   	push   %ebp
f01076e5:	89 e5                	mov    %esp,%ebp
	return ticks;
f01076e7:	a1 c8 52 96 f1       	mov    0xf19652c8,%eax
f01076ec:	8b 15 cc 52 96 f1    	mov    0xf19652cc,%edx
}
f01076f2:	5d                   	pop    %ebp
f01076f3:	c3                   	ret    

f01076f4 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01076f4:	55                   	push   %ebp
f01076f5:	89 e5                	mov    %esp,%ebp
f01076f7:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f01076fa:	83 ec 04             	sub    $0x4,%esp
f01076fd:	68 e6 72 13 f0       	push   $0xf01372e6
f0107702:	68 9e 02 00 00       	push   $0x29e
f0107707:	68 77 6e 13 f0       	push   $0xf0136e77
f010770c:	e8 9e 97 ff ff       	call   f0100eaf <_panic>

f0107711 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0107711:	55                   	push   %ebp
f0107712:	89 e5                	mov    %esp,%ebp
f0107714:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f0107717:	83 ec 04             	sub    $0x4,%esp
f010771a:	68 e6 72 13 f0       	push   $0xf01372e6
f010771f:	68 a3 02 00 00       	push   $0x2a3
f0107724:	68 77 6e 13 f0       	push   $0xf0136e77
f0107729:	e8 81 97 ff ff       	call   f0100eaf <_panic>

f010772e <env_get_recent_cpu>:
}
int env_get_recent_cpu(struct Env* e)
{
f010772e:	55                   	push   %ebp
f010772f:	89 e5                	mov    %esp,%ebp
f0107731:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f0107734:	83 ec 04             	sub    $0x4,%esp
f0107737:	68 e6 72 13 f0       	push   $0xf01372e6
f010773c:	68 a7 02 00 00       	push   $0x2a7
f0107741:	68 77 6e 13 f0       	push   $0xf0136e77
f0107746:	e8 64 97 ff ff       	call   f0100eaf <_panic>

f010774b <get_load_average>:
}
int get_load_average()
{
f010774b:	55                   	push   %ebp
f010774c:	89 e5                	mov    %esp,%ebp
f010774e:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f0107751:	83 ec 04             	sub    $0x4,%esp
f0107754:	68 e6 72 13 f0       	push   $0xf01372e6
f0107759:	68 ab 02 00 00       	push   $0x2ab
f010775e:	68 77 6e 13 f0       	push   $0xf0136e77
f0107763:	e8 47 97 ff ff       	call   f0100eaf <_panic>

f0107768 <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f0107768:	55                   	push   %ebp
f0107769:	89 e5                	mov    %esp,%ebp
f010776b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 env_set_priority
#if USE_KHEAP
	struct Env* ptr_env;
	int foundOrNot = envid2env(envID, &ptr_env, 0);
f010776e:	83 ec 04             	sub    $0x4,%esp
f0107771:	6a 00                	push   $0x0
f0107773:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0107776:	50                   	push   %eax
f0107777:	ff 75 08             	pushl  0x8(%ebp)
f010777a:	e8 19 5f 00 00       	call   f010d698 <envid2env>
f010777f:	83 c4 10             	add    $0x10,%esp
f0107782:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (foundOrNot!=0){
f0107785:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107789:	0f 85 a3 00 00 00    	jne    f0107832 <env_set_priority+0xca>
    	//cprintf("the passed process is not found\n");
        return;
    }
    if(priority<0){
f010778f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0107793:	0f 88 9c 00 00 00    	js     f0107835 <env_set_priority+0xcd>
    	//cprintf("invalid priority\n");
    	return;
    }
    if(priority>=num_of_ready_queues){
f0107799:	a0 00 54 96 f1       	mov    0xf1965400,%al
f010779e:	0f b6 c0             	movzbl %al,%eax
f01077a1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01077a4:	0f 8e 8e 00 00 00    	jle    f0107838 <env_set_priority+0xd0>
    	//cprint("the passed priority exceeds the number of ready queues\n");
    	return;
    }
    if(ptr_env->priority==priority){
f01077aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077ad:	8b 40 1c             	mov    0x1c(%eax),%eax
f01077b0:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01077b3:	0f 84 82 00 00 00    	je     f010783b <env_set_priority+0xd3>
    	return;
    }
    acquire_kspinlock(&(ProcessQueues.qlock));
f01077b9:	83 ec 0c             	sub    $0xc,%esp
f01077bc:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01077c1:	e8 7f bd 00 00       	call   f0113545 <acquire_kspinlock>
f01077c6:	83 c4 10             	add    $0x10,%esp
    if(ptr_env->env_status == ENV_READY){
f01077c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077cc:	8b 40 18             	mov    0x18(%eax),%eax
f01077cf:	83 f8 01             	cmp    $0x1,%eax
f01077d2:	75 36                	jne    f010780a <env_set_priority+0xa2>

    	sched_remove_ready(ptr_env);
f01077d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077d7:	83 ec 0c             	sub    $0xc,%esp
f01077da:	50                   	push   %eax
f01077db:	e8 7e eb ff ff       	call   f010635e <sched_remove_ready>
f01077e0:	83 c4 10             	add    $0x10,%esp
    	ptr_env->priority=priority;
f01077e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077e6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01077e9:	89 50 1c             	mov    %edx,0x1c(%eax)
   		ptr_env->ticks_of_starv=0;
f01077ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077ef:	c7 80 74 06 00 00 00 	movl   $0x0,0x674(%eax)
f01077f6:	00 00 00 
   		sched_insert_ready(ptr_env);
f01077f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077fc:	83 ec 0c             	sub    $0xc,%esp
f01077ff:	50                   	push   %eax
f0107800:	e8 dc ea ff ff       	call   f01062e1 <sched_insert_ready>
f0107805:	83 c4 10             	add    $0x10,%esp
f0107808:	eb 16                	jmp    f0107820 <env_set_priority+0xb8>
   	}else{
    	ptr_env->priority=priority;
f010780a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010780d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0107810:	89 50 1c             	mov    %edx,0x1c(%eax)
    	ptr_env->ticks_of_starv=0;
f0107813:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107816:	c7 80 74 06 00 00 00 	movl   $0x0,0x674(%eax)
f010781d:	00 00 00 
    }
    release_kspinlock(&(ProcessQueues.qlock));
f0107820:	83 ec 0c             	sub    $0xc,%esp
f0107823:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107828:	e8 bd bd 00 00       	call   f01135ea <release_kspinlock>
f010782d:	83 c4 10             	add    $0x10,%esp
f0107830:	eb 0a                	jmp    f010783c <env_set_priority+0xd4>
#if USE_KHEAP
	struct Env* ptr_env;
	int foundOrNot = envid2env(envID, &ptr_env, 0);
    if (foundOrNot!=0){
    	//cprintf("the passed process is not found\n");
        return;
f0107832:	90                   	nop
f0107833:	eb 07                	jmp    f010783c <env_set_priority+0xd4>
    }
    if(priority<0){
    	//cprintf("invalid priority\n");
    	return;
f0107835:	90                   	nop
f0107836:	eb 04                	jmp    f010783c <env_set_priority+0xd4>
    }
    if(priority>=num_of_ready_queues){
    	//cprint("the passed priority exceeds the number of ready queues\n");
    	return;
f0107838:	90                   	nop
f0107839:	eb 01                	jmp    f010783c <env_set_priority+0xd4>
    }
    if(ptr_env->priority==priority){
    	return;
f010783b:	90                   	nop
#endif

	//Comment the following line
    //panic("env_set_priority() is not implemented yet...!!");

}
f010783c:	c9                   	leave  
f010783d:	c3                   	ret    

f010783e <sched_set_starv_thresh>:

void sched_set_starv_thresh(uint32 starvThresh)
{
f010783e:	55                   	push   %ebp
f010783f:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 sched_set_starv_thresh
#if USE_KHEAP
	if(starvThresh<=0){
f0107841:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0107845:	74 0a                	je     f0107851 <sched_set_starv_thresh+0x13>
		//cprintf("invalid number of Threshold\n");
		return;
	}
	StarvThresh = starvThresh;
f0107847:	8b 45 08             	mov    0x8(%ebp),%eax
f010784a:	a3 dc 52 96 f1       	mov    %eax,0xf19652dc
f010784f:	eb 01                	jmp    f0107852 <sched_set_starv_thresh+0x14>
{
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 sched_set_starv_thresh
#if USE_KHEAP
	if(starvThresh<=0){
		//cprintf("invalid number of Threshold\n");
		return;
f0107851:	90                   	nop
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

	//Comment the following line
	//panic("sched_set_starv_thresh() is not implemented yet...!!");
}
f0107852:	5d                   	pop    %ebp
f0107853:	c3                   	ret    

f0107854 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0107854:	55                   	push   %ebp
f0107855:	89 e5                	mov    %esp,%ebp
f0107857:	a1 9c 51 96 f1       	mov    0xf196519c,%eax
f010785c:	85 c0                	test   %eax,%eax
f010785e:	0f 94 c0             	sete   %al
f0107861:	0f b6 c0             	movzbl %al,%eax
f0107864:	5d                   	pop    %ebp
f0107865:	c3                   	ret    

f0107866 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f0107866:	55                   	push   %ebp
f0107867:	89 e5                	mov    %esp,%ebp
f0107869:	a1 9c 51 96 f1       	mov    0xf196519c,%eax
f010786e:	83 f8 01             	cmp    $0x1,%eax
f0107871:	0f 94 c0             	sete   %al
f0107874:	0f b6 c0             	movzbl %al,%eax
f0107877:	5d                   	pop    %ebp
f0107878:	c3                   	ret    

f0107879 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f0107879:	55                   	push   %ebp
f010787a:	89 e5                	mov    %esp,%ebp
f010787c:	a1 9c 51 96 f1       	mov    0xf196519c,%eax
f0107881:	83 f8 02             	cmp    $0x2,%eax
f0107884:	0f 94 c0             	sete   %al
f0107887:	0f b6 c0             	movzbl %al,%eax
f010788a:	5d                   	pop    %ebp
f010788b:	c3                   	ret    

f010788c <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f010788c:	55                   	push   %ebp
f010788d:	89 e5                	mov    %esp,%ebp
f010788f:	a1 9c 51 96 f1       	mov    0xf196519c,%eax
f0107894:	83 f8 03             	cmp    $0x3,%eax
f0107897:	0f 94 c0             	sete   %al
f010789a:	0f b6 c0             	movzbl %al,%eax
f010789d:	5d                   	pop    %ebp
f010789e:	c3                   	ret    

f010789f <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010789f:	55                   	push   %ebp
f01078a0:	89 e5                	mov    %esp,%ebp
f01078a2:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01078a5:	c7 05 98 cf 94 f1 00 	movl   $0x0,0xf194cf98
f01078ac:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01078af:	83 ec 0c             	sub    $0xc,%esp
f01078b2:	6a 0a                	push   $0xa
f01078b4:	e8 45 02 00 00       	call   f0107afe <sched_init_RR>
f01078b9:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f01078bc:	83 ec 0c             	sub    $0xc,%esp
f01078bf:	68 30 ce 94 f1       	push   $0xf194ce30
f01078c4:	e8 0b e7 ff ff       	call   f0105fd4 <init_queue>
f01078c9:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f01078cc:	83 ec 0c             	sub    $0xc,%esp
f01078cf:	68 40 ce 94 f1       	push   $0xf194ce40
f01078d4:	e8 fb e6 ff ff       	call   f0105fd4 <init_queue>
f01078d9:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f01078dc:	e8 1e 0c 00 00       	call   f01084ff <mycpu>
f01078e1:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01078e8:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_kspinlock(&ProcessQueues.qlock, "process queues lock");
f01078eb:	83 ec 08             	sub    $0x8,%esp
f01078ee:	68 00 73 13 f0       	push   $0xf0137300
f01078f3:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01078f8:	e8 17 bc 00 00       	call   f0113514 <init_kspinlock>
f01078fd:	83 c4 10             	add    $0x10,%esp
}
f0107900:	90                   	nop
f0107901:	c9                   	leave  
f0107902:	c3                   	ret    

f0107903 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0107903:	55                   	push   %ebp
f0107904:	89 e5                	mov    %esp,%ebp
f0107906:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107909:	9c                   	pushf  
f010790a:	58                   	pop    %eax
f010790b:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return eflags;
f010790e:	8b 45 dc             	mov    -0x24(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0107911:	25 00 02 00 00       	and    $0x200,%eax
f0107916:	85 c0                	test   %eax,%eax
f0107918:	74 14                	je     f010792e <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f010791a:	83 ec 04             	sub    $0x4,%esp
f010791d:	68 14 73 13 f0       	push   $0xf0137314
f0107922:	6a 3a                	push   $0x3a
f0107924:	68 4a 73 13 f0       	push   $0xf013734a
f0107929:	e8 81 95 ff ff       	call   f0100eaf <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f010792e:	e8 cc 0b 00 00       	call   f01084ff <mycpu>
f0107933:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0107936:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107939:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107940:	00 00 00 

	chk1();
f0107943:	e8 fb a5 01 00       	call   f0121f43 <chk1>
	c->scheduler_status = SCH_STARTED;
f0107948:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010794b:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0107952:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0107955:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f010795c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0107963:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_kspinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0107964:	83 ec 0c             	sub    $0xc,%esp
f0107967:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010796c:	e8 d4 bb 00 00       	call   f0113545 <acquire_kspinlock>
f0107971:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0107974:	a1 9c 51 96 f1       	mov    0xf196519c,%eax
f0107979:	8b 04 85 ac 7b 19 f0 	mov    -0xfe68454(,%eax,4),%eax
f0107980:	ff d0                	call   *%eax
f0107982:	89 45 e8             	mov    %eax,-0x18(%ebp)

			if(next_env != NULL)
f0107985:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0107989:	0f 84 f5 00 00 00    	je     f0107a84 <fos_scheduler+0x181>
			{
				//cprintf("\nScheduler select program '%s' [%d]... clock counter = %d\n", next_env->prog_name, next_env->env_id, kclock_read_cnt0());
				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f010798f:	83 ec 0c             	sub    $0xc,%esp
f0107992:	ff 75 e8             	pushl  -0x18(%ebp)
f0107995:	e8 d7 5c 00 00       	call   f010d671 <set_cpu_proc>
f010799a:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010799d:	83 ec 0c             	sub    $0xc,%esp
f01079a0:	ff 75 e8             	pushl  -0x18(%ebp)
f01079a3:	e8 3d 5f 00 00       	call   f010d8e5 <switchuvm>
f01079a8:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f01079ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079ae:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f01079b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079b8:	8b 40 04             	mov    0x4(%eax),%eax
f01079bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01079be:	83 c2 04             	add    $0x4,%edx
f01079c1:	83 ec 08             	sub    $0x8,%esp
f01079c4:	50                   	push   %eax
f01079c5:	52                   	push   %edx
f01079c6:	e8 11 e2 ff ff       	call   f0105bdc <context_switch>
f01079cb:	83 c4 10             	add    $0x10,%esp

				//ensure that the qlock is still held after returning from the process
				if(!holding_kspinlock(&ProcessQueues.qlock))
f01079ce:	83 ec 0c             	sub    $0xc,%esp
f01079d1:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01079d6:	e8 bf bd 00 00       	call   f011379a <holding_kspinlock>
f01079db:	83 c4 10             	add    $0x10,%esp
f01079de:	85 c0                	test   %eax,%eax
f01079e0:	75 24                	jne    f0107a06 <fos_scheduler+0x103>
				{
					printcallstack(&ProcessQueues.qlock);
f01079e2:	83 ec 0c             	sub    $0xc,%esp
f01079e5:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01079ea:	e8 44 bd 00 00       	call   f0113733 <printcallstack>
f01079ef:	83 c4 10             	add    $0x10,%esp
					panic("fos_scheduler(): qlock is either not held or held by another CPU!");
f01079f2:	83 ec 04             	sub    $0x4,%esp
f01079f5:	68 5c 73 13 f0       	push   $0xf013735c
f01079fa:	6a 6c                	push   $0x6c
f01079fc:	68 4a 73 13 f0       	push   $0xf013734a
f0107a01:	e8 a9 94 ff ff       	call   f0100eaf <_panic>
				}

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0107a06:	e8 1a e3 ff ff       	call   f0105d25 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, c->proc == NULL? 0 : c->proc->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0107a0b:	e8 38 5c 00 00       	call   f010d648 <get_cpu_proc>
f0107a10:	89 c2                	mov    %eax,%edx
f0107a12:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a15:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0107a1b:	39 c2                	cmp    %eax,%edx
f0107a1d:	74 16                	je     f0107a35 <fos_scheduler+0x132>
f0107a1f:	68 9e 73 13 f0       	push   $0xf013739e
f0107a24:	68 b8 73 13 f0       	push   $0xf01373b8
f0107a29:	6a 76                	push   $0x76
f0107a2b:	68 4a 73 13 f0       	push   $0xf013734a
f0107a30:	e8 7a 94 ff ff       	call   f0100eaf <_panic>
				int status = c->proc->env_status ;
f0107a35:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a38:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0107a3e:	8b 40 18             	mov    0x18(%eax),%eax
f0107a41:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				assert(status != ENV_RUNNING);
f0107a44:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
f0107a48:	75 16                	jne    f0107a60 <fos_scheduler+0x15d>
f0107a4a:	68 cd 73 13 f0       	push   $0xf01373cd
f0107a4f:	68 b8 73 13 f0       	push   $0xf01373b8
f0107a54:	6a 78                	push   $0x78
f0107a56:	68 4a 73 13 f0       	push   $0xf013734a
f0107a5b:	e8 4f 94 ff ff       	call   f0100eaf <_panic>
				if (status == ENV_READY)
f0107a60:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f0107a64:	74 1e                	je     f0107a84 <fos_scheduler+0x181>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0107a66:	e8 63 5e 00 00       	call   f010d8ce <switchkvm>
					struct Env* __e__ = c->proc;
f0107a6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a6e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0107a74:	89 45 e0             	mov    %eax,-0x20(%ebp)
					set_cpu_proc(NULL);
f0107a77:	83 ec 0c             	sub    $0xc,%esp
f0107a7a:	6a 00                	push   $0x0
f0107a7c:	e8 f0 5b 00 00       	call   f010d671 <set_cpu_proc>
f0107a81:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0107a84:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0107a88:	0f 85 e6 fe ff ff    	jne    f0107974 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0107a8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0107a95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0107a9c:	eb 37                	jmp    f0107ad5 <fos_scheduler+0x1d2>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0107a9e:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f0107aa4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107aa7:	89 d0                	mov    %edx,%eax
f0107aa9:	01 c0                	add    %eax,%eax
f0107aab:	01 d0                	add    %edx,%eax
f0107aad:	c1 e0 02             	shl    $0x2,%eax
f0107ab0:	01 d0                	add    %edx,%eax
f0107ab2:	c1 e0 02             	shl    $0x2,%eax
f0107ab5:	01 d0                	add    %edx,%eax
f0107ab7:	c1 e0 03             	shl    $0x3,%eax
f0107aba:	01 d0                	add    %edx,%eax
f0107abc:	c1 e0 02             	shl    $0x2,%eax
f0107abf:	01 c8                	add    %ecx,%eax
f0107ac1:	8b 40 18             	mov    0x18(%eax),%eax
f0107ac4:	83 f8 03             	cmp    $0x3,%eax
f0107ac7:	75 09                	jne    f0107ad2 <fos_scheduler+0x1cf>
			{
				is_any_blocked = 1;
f0107ac9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0107ad0:	eb 0d                	jmp    f0107adf <fos_scheduler+0x1dc>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0107ad2:	ff 45 f0             	incl   -0x10(%ebp)
f0107ad5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107ad8:	3d 67 02 00 00       	cmp    $0x267,%eax
f0107add:	76 bf                	jbe    f0107a9e <fos_scheduler+0x19b>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0107adf:	83 ec 0c             	sub    $0xc,%esp
f0107ae2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107ae7:	e8 fe ba 00 00       	call   f01135ea <release_kspinlock>
f0107aec:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);
	} while (is_any_blocked > 0);
f0107aef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107af3:	0f 8f 6a fe ff ff    	jg     f0107963 <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0107af9:	e8 d5 a1 ff ff       	call   f0101cd3 <get_into_prompt>

f0107afe <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0107afe:	55                   	push   %ebp
f0107aff:	89 e5                	mov    %esp,%ebp
f0107b01:	83 ec 28             	sub    $0x28,%esp
f0107b04:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b07:	88 45 e4             	mov    %al,-0x1c(%ebp)
	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0107b0a:	c6 05 00 54 96 f1 01 	movb   $0x1,0xf1965400
#if USE_KHEAP
	sched_delete_ready_queues();
f0107b11:	e8 6e e7 ff ff       	call   f0106284 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0107b16:	83 ec 0c             	sub    $0xc,%esp
f0107b19:	6a 10                	push   $0x10
f0107b1b:	e8 b2 33 00 00       	call   f010aed2 <kmalloc>
f0107b20:	83 c4 10             	add    $0x10,%esp
f0107b23:	a3 50 ce 94 f1       	mov    %eax,0xf194ce50
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0107b28:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0107b2d:	0f b6 c0             	movzbl %al,%eax
f0107b30:	83 ec 0c             	sub    $0xc,%esp
f0107b33:	50                   	push   %eax
f0107b34:	e8 99 33 00 00       	call   f010aed2 <kmalloc>
f0107b39:	83 c4 10             	add    $0x10,%esp
f0107b3c:	a3 84 51 96 f1       	mov    %eax,0xf1965184
#endif
	quantums[0] = quantum;
f0107b41:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0107b46:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0107b49:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0107b4b:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0107b50:	8a 00                	mov    (%eax),%al
f0107b52:	0f b6 c0             	movzbl %al,%eax
f0107b55:	83 ec 0c             	sub    $0xc,%esp
f0107b58:	50                   	push   %eax
f0107b59:	e8 90 e2 ff ff       	call   f0105dee <kclock_set_quantum>
f0107b5e:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0107b61:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107b66:	83 ec 0c             	sub    $0xc,%esp
f0107b69:	50                   	push   %eax
f0107b6a:	e8 65 e4 ff ff       	call   f0105fd4 <init_queue>
f0107b6f:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0107b72:	e8 d6 e3 ff ff       	call   f0105f4d <kclock_read_cnt0_latch>
f0107b77:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0107b7b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0107b7f:	83 ec 08             	sub    $0x8,%esp
f0107b82:	50                   	push   %eax
f0107b83:	68 e4 73 13 f0       	push   $0xf01373e4
f0107b88:	e8 c0 9f ff ff       	call   f0101b4d <cprintf>
f0107b8d:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0107b90:	e8 6a 09 00 00       	call   f01084ff <mycpu>
f0107b95:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0107b9c:	00 00 00 
	scheduler_method = SCH_RR;
f0107b9f:	c7 05 9c 51 96 f1 00 	movl   $0x0,0xf196519c
f0107ba6:	00 00 00 
	//=========================================
	//=========================================
}
f0107ba9:	90                   	nop
f0107baa:	c9                   	leave  
f0107bab:	c3                   	ret    

f0107bac <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0107bac:	55                   	push   %ebp
f0107bad:	89 e5                	mov    %esp,%ebp
f0107baf:	83 ec 18             	sub    $0x18,%esp
f0107bb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0107bb5:	88 45 f4             	mov    %al,-0xc(%ebp)
	panic("Not implemented yet");
f0107bb8:	83 ec 04             	sub    $0x4,%esp
f0107bbb:	68 0c 74 13 f0       	push   $0xf013740c
f0107bc0:	68 bb 00 00 00       	push   $0xbb
f0107bc5:	68 4a 73 13 f0       	push   $0xf013734a
f0107bca:	e8 e0 92 ff ff       	call   f0100eaf <_panic>

f0107bcf <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0107bcf:	55                   	push   %ebp
f0107bd0:	89 e5                	mov    %esp,%ebp
f0107bd2:	83 ec 18             	sub    $0x18,%esp
f0107bd5:	8b 55 08             	mov    0x8(%ebp),%edx
f0107bd8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107bdb:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107bde:	88 45 f0             	mov    %al,-0x10(%ebp)
	panic("Not implemented yet");
f0107be1:	83 ec 04             	sub    $0x4,%esp
f0107be4:	68 0c 74 13 f0       	push   $0xf013740c
f0107be9:	68 ce 00 00 00       	push   $0xce
f0107bee:	68 4a 73 13 f0       	push   $0xf013734a
f0107bf3:	e8 b7 92 ff ff       	call   f0100eaf <_panic>

f0107bf8 <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0107bf8:	55                   	push   %ebp
f0107bf9:	89 e5                	mov    %esp,%ebp
f0107bfb:	83 ec 28             	sub    $0x28,%esp
f0107bfe:	8b 55 08             	mov    0x8(%ebp),%edx
f0107c01:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c04:	88 55 e4             	mov    %dl,-0x1c(%ebp)
f0107c07:	88 45 e0             	mov    %al,-0x20(%ebp)
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #2 sched_init_PRIRR
		//Your code is here
#if USE_KHEAP
		if(numOfPriorities<=0 || quantum<=0 || starvThresh<=0 ){
f0107c0a:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0107c0e:	0f 84 ea 00 00 00    	je     f0107cfe <sched_init_PRIRR+0x106>
f0107c14:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
f0107c18:	0f 84 e0 00 00 00    	je     f0107cfe <sched_init_PRIRR+0x106>
f0107c1e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107c22:	0f 84 d6 00 00 00    	je     f0107cfe <sched_init_PRIRR+0x106>
			return;
		}
		num_of_ready_queues=numOfPriorities;
f0107c28:	8a 45 e4             	mov    -0x1c(%ebp),%al
f0107c2b:	a2 00 54 96 f1       	mov    %al,0xf1965400
		ProcessQueues.env_ready_queues=kmalloc(sizeof(struct Env_Queue) * num_of_ready_queues);
f0107c30:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0107c35:	0f b6 c0             	movzbl %al,%eax
f0107c38:	c1 e0 04             	shl    $0x4,%eax
f0107c3b:	83 ec 0c             	sub    $0xc,%esp
f0107c3e:	50                   	push   %eax
f0107c3f:	e8 8e 32 00 00       	call   f010aed2 <kmalloc>
f0107c44:	83 c4 10             	add    $0x10,%esp
f0107c47:	a3 50 ce 94 f1       	mov    %eax,0xf194ce50
		for(int i=0;i<num_of_ready_queues;i++){
f0107c4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107c53:	eb 1c                	jmp    f0107c71 <sched_init_PRIRR+0x79>
			init_queue(&(ProcessQueues.env_ready_queues[i]));
f0107c55:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c5d:	c1 e2 04             	shl    $0x4,%edx
f0107c60:	01 d0                	add    %edx,%eax
f0107c62:	83 ec 0c             	sub    $0xc,%esp
f0107c65:	50                   	push   %eax
f0107c66:	e8 69 e3 ff ff       	call   f0105fd4 <init_queue>
f0107c6b:	83 c4 10             	add    $0x10,%esp
		if(numOfPriorities<=0 || quantum<=0 || starvThresh<=0 ){
			return;
		}
		num_of_ready_queues=numOfPriorities;
		ProcessQueues.env_ready_queues=kmalloc(sizeof(struct Env_Queue) * num_of_ready_queues);
		for(int i=0;i<num_of_ready_queues;i++){
f0107c6e:	ff 45 f4             	incl   -0xc(%ebp)
f0107c71:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0107c76:	0f b6 c0             	movzbl %al,%eax
f0107c79:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107c7c:	7f d7                	jg     f0107c55 <sched_init_PRIRR+0x5d>
			init_queue(&(ProcessQueues.env_ready_queues[i]));
		}
		quantums = kmalloc(sizeof(uint8) * num_of_ready_queues);
f0107c7e:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0107c83:	0f b6 c0             	movzbl %al,%eax
f0107c86:	83 ec 0c             	sub    $0xc,%esp
f0107c89:	50                   	push   %eax
f0107c8a:	e8 43 32 00 00       	call   f010aed2 <kmalloc>
f0107c8f:	83 c4 10             	add    $0x10,%esp
f0107c92:	a3 84 51 96 f1       	mov    %eax,0xf1965184
		quantums[0]=quantum;
f0107c97:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0107c9c:	8a 55 e0             	mov    -0x20(%ebp),%dl
f0107c9f:	88 10                	mov    %dl,(%eax)
		kclock_set_quantum(quantums[0]);
f0107ca1:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0107ca6:	8a 00                	mov    (%eax),%al
f0107ca8:	0f b6 c0             	movzbl %al,%eax
f0107cab:	83 ec 0c             	sub    $0xc,%esp
f0107cae:	50                   	push   %eax
f0107caf:	e8 3a e1 ff ff       	call   f0105dee <kclock_set_quantum>
f0107cb4:	83 c4 10             	add    $0x10,%esp
		sched_set_starv_thresh(starvThresh);
f0107cb7:	83 ec 0c             	sub    $0xc,%esp
f0107cba:	ff 75 10             	pushl  0x10(%ebp)
f0107cbd:	e8 7c fb ff ff       	call   f010783e <sched_set_starv_thresh>
f0107cc2:	83 c4 10             	add    $0x10,%esp
		//Comment the following line
		//panic("sched_init_PRIRR() is not implemented yet...!!");
	}
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0107cc5:	e8 83 e2 ff ff       	call   f0105f4d <kclock_read_cnt0_latch>
f0107cca:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	cprintf("*	PRIORITY RR scheduler with initial clock = %d\n", cnt0);
f0107cce:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
f0107cd2:	83 ec 08             	sub    $0x8,%esp
f0107cd5:	50                   	push   %eax
f0107cd6:	68 20 74 13 f0       	push   $0xf0137420
f0107cdb:	e8 6d 9e ff ff       	call   f0101b4d <cprintf>
f0107ce0:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0107ce3:	e8 17 08 00 00       	call   f01084ff <mycpu>
f0107ce8:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0107cef:	00 00 00 
	scheduler_method = SCH_PRIRR;
f0107cf2:	c7 05 9c 51 96 f1 03 	movl   $0x3,0xf196519c
f0107cf9:	00 00 00 
f0107cfc:	eb 01                	jmp    f0107cff <sched_init_PRIRR+0x107>
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #2 sched_init_PRIRR
		//Your code is here
#if USE_KHEAP
		if(numOfPriorities<=0 || quantum<=0 || starvThresh<=0 ){
			return;
f0107cfe:	90                   	nop
	cprintf("*	PRIORITY RR scheduler with initial clock = %d\n", cnt0);
	mycpu()->scheduler_status = SCH_STOPPED;
	scheduler_method = SCH_PRIRR;
	//=========================================
	//=========================================
}
f0107cff:	c9                   	leave  
f0107d00:	c3                   	ret    

f0107d01 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0107d01:	55                   	push   %ebp
f0107d02:	89 e5                	mov    %esp,%ebp
f0107d04:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107d07:	83 ec 0c             	sub    $0xc,%esp
f0107d0a:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107d0f:	e8 86 ba 00 00       	call   f011379a <holding_kspinlock>
f0107d14:	83 c4 10             	add    $0x10,%esp
f0107d17:	85 c0                	test   %eax,%eax
f0107d19:	75 17                	jne    f0107d32 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0107d1b:	83 ec 04             	sub    $0x4,%esp
f0107d1e:	68 54 74 13 f0       	push   $0xf0137454
f0107d23:	68 0b 01 00 00       	push   $0x10b
f0107d28:	68 4a 73 13 f0       	push   $0xf013734a
f0107d2d:	e8 7d 91 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0107d32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0107d39:	e8 0a 59 00 00       	call   f010d648 <get_cpu_proc>
f0107d3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0107d41:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107d45:	74 14                	je     f0107d5b <fos_scheduler_RR+0x5a>
	{
		//cprintf("RR: [%d] with status %d will be added to ready Q", cur_env->env_id, cur_env->env_status);
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0107d47:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107d4c:	83 ec 08             	sub    $0x8,%esp
f0107d4f:	ff 75 f0             	pushl  -0x10(%ebp)
f0107d52:	50                   	push   %eax
f0107d53:	e8 bd e2 ff ff       	call   f0106015 <enqueue>
f0107d58:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0107d5b:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107d60:	83 ec 0c             	sub    $0xc,%esp
f0107d63:	50                   	push   %eax
f0107d64:	e8 3d e3 ff ff       	call   f01060a6 <dequeue>
f0107d69:	83 c4 10             	add    $0x10,%esp
f0107d6c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0107d6f:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0107d74:	8a 00                	mov    (%eax),%al
f0107d76:	0f b6 c0             	movzbl %al,%eax
f0107d79:	83 ec 0c             	sub    $0xc,%esp
f0107d7c:	50                   	push   %eax
f0107d7d:	e8 6c e0 ff ff       	call   f0105dee <kclock_set_quantum>
f0107d82:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0107d85:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0107d88:	c9                   	leave  
f0107d89:	c3                   	ret    

f0107d8a <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0107d8a:	55                   	push   %ebp
f0107d8b:	89 e5                	mov    %esp,%ebp
f0107d8d:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107d90:	83 ec 0c             	sub    $0xc,%esp
f0107d93:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107d98:	e8 fd b9 00 00       	call   f011379a <holding_kspinlock>
f0107d9d:	83 c4 10             	add    $0x10,%esp
f0107da0:	85 c0                	test   %eax,%eax
f0107da2:	75 17                	jne    f0107dbb <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0107da4:	83 ec 04             	sub    $0x4,%esp
f0107da7:	68 a0 74 13 f0       	push   $0xf01374a0
f0107dac:	68 2b 01 00 00       	push   $0x12b
f0107db1:	68 4a 73 13 f0       	push   $0xf013734a
f0107db6:	e8 f4 90 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107dbb:	83 ec 04             	sub    $0x4,%esp
f0107dbe:	68 0c 74 13 f0       	push   $0xf013740c
f0107dc3:	68 2d 01 00 00       	push   $0x12d
f0107dc8:	68 4a 73 13 f0       	push   $0xf013734a
f0107dcd:	e8 dd 90 ff ff       	call   f0100eaf <_panic>

f0107dd2 <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0107dd2:	55                   	push   %ebp
f0107dd3:	89 e5                	mov    %esp,%ebp
f0107dd5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107dd8:	83 ec 0c             	sub    $0xc,%esp
f0107ddb:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107de0:	e8 b5 b9 00 00       	call   f011379a <holding_kspinlock>
f0107de5:	83 c4 10             	add    $0x10,%esp
f0107de8:	85 c0                	test   %eax,%eax
f0107dea:	75 17                	jne    f0107e03 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0107dec:	83 ec 04             	sub    $0x4,%esp
f0107def:	68 f0 74 13 f0       	push   $0xf01374f0
f0107df4:	68 37 01 00 00       	push   $0x137
f0107df9:	68 4a 73 13 f0       	push   $0xf013734a
f0107dfe:	e8 ac 90 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107e03:	83 ec 04             	sub    $0x4,%esp
f0107e06:	68 0c 74 13 f0       	push   $0xf013740c
f0107e0b:	68 39 01 00 00       	push   $0x139
f0107e10:	68 4a 73 13 f0       	push   $0xf013734a
f0107e15:	e8 95 90 ff ff       	call   f0100eaf <_panic>

f0107e1a <fos_scheduler_PRIRR>:

//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0107e1a:	55                   	push   %ebp
f0107e1b:	89 e5                	mov    %esp,%ebp
f0107e1d:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107e20:	83 ec 0c             	sub    $0xc,%esp
f0107e23:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107e28:	e8 6d b9 00 00       	call   f011379a <holding_kspinlock>
f0107e2d:	83 c4 10             	add    $0x10,%esp
f0107e30:	85 c0                	test   %eax,%eax
f0107e32:	75 17                	jne    f0107e4b <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0107e34:	83 ec 04             	sub    $0x4,%esp
f0107e37:	68 40 75 13 f0       	push   $0xf0137540
f0107e3c:	68 43 01 00 00       	push   $0x143
f0107e41:	68 4a 73 13 f0       	push   $0xf013734a
f0107e46:	e8 64 90 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #3 fos_scheduler_PRIRR
	//Your code is here
#if USE_KHEAP
	struct Env *next_env = NULL;
f0107e4b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0107e52:	e8 f1 57 00 00       	call   f010d648 <get_cpu_proc>
f0107e57:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env != NULL)
f0107e5a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107e5e:	74 1b                	je     f0107e7b <fos_scheduler_PRIRR+0x61>
	{
		//cprintf("RR: [%d] with status %d will be added to ready Q", cur_env->env_id, cur_env->env_status);
		sched_insert_ready(cur_env);
f0107e60:	83 ec 0c             	sub    $0xc,%esp
f0107e63:	ff 75 ec             	pushl  -0x14(%ebp)
f0107e66:	e8 76 e4 ff ff       	call   f01062e1 <sched_insert_ready>
f0107e6b:	83 c4 10             	add    $0x10,%esp
		cur_env->ticks_of_starv=0;
f0107e6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107e71:	c7 80 74 06 00 00 00 	movl   $0x0,0x674(%eax)
f0107e78:	00 00 00 
	}
	for(int i=0;i<num_of_ready_queues;i++){
f0107e7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0107e82:	eb 34                	jmp    f0107eb8 <fos_scheduler_PRIRR+0x9e>
		if(!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i]))){
f0107e84:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107e89:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107e8c:	c1 e2 04             	shl    $0x4,%edx
f0107e8f:	01 d0                	add    %edx,%eax
f0107e91:	8b 00                	mov    (%eax),%eax
f0107e93:	85 c0                	test   %eax,%eax
f0107e95:	74 1e                	je     f0107eb5 <fos_scheduler_PRIRR+0x9b>
			next_env= dequeue(&(ProcessQueues.env_ready_queues[i]));
f0107e97:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107e9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107e9f:	c1 e2 04             	shl    $0x4,%edx
f0107ea2:	01 d0                	add    %edx,%eax
f0107ea4:	83 ec 0c             	sub    $0xc,%esp
f0107ea7:	50                   	push   %eax
f0107ea8:	e8 f9 e1 ff ff       	call   f01060a6 <dequeue>
f0107ead:	83 c4 10             	add    $0x10,%esp
f0107eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0107eb3:	eb 10                	jmp    f0107ec5 <fos_scheduler_PRIRR+0xab>
	{
		//cprintf("RR: [%d] with status %d will be added to ready Q", cur_env->env_id, cur_env->env_status);
		sched_insert_ready(cur_env);
		cur_env->ticks_of_starv=0;
	}
	for(int i=0;i<num_of_ready_queues;i++){
f0107eb5:	ff 45 f0             	incl   -0x10(%ebp)
f0107eb8:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0107ebd:	0f b6 c0             	movzbl %al,%eax
f0107ec0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0107ec3:	7f bf                	jg     f0107e84 <fos_scheduler_PRIRR+0x6a>
		if(!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i]))){
			next_env= dequeue(&(ProcessQueues.env_ready_queues[i]));
			break;
		}
	}
	kclock_set_quantum(quantums[0]);
f0107ec5:	a1 84 51 96 f1       	mov    0xf1965184,%eax
f0107eca:	8a 00                	mov    (%eax),%al
f0107ecc:	0f b6 c0             	movzbl %al,%eax
f0107ecf:	83 ec 0c             	sub    $0xc,%esp
f0107ed2:	50                   	push   %eax
f0107ed3:	e8 16 df ff ff       	call   f0105dee <kclock_set_quantum>
f0107ed8:	83 c4 10             	add    $0x10,%esp
	return next_env;
f0107edb:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif
	//Comment the following line
	//panic("fos_scheduler_PRIRR() is not implemented yet...!!");
}
f0107ede:	c9                   	leave  
f0107edf:	c3                   	ret    

f0107ee0 <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0107ee0:	55                   	push   %ebp
f0107ee1:	89 e5                	mov    %esp,%ebp
f0107ee3:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0107ee6:	e8 a1 f9 ff ff       	call   f010788c <isSchedMethodPRIRR>
f0107eeb:	85 c0                	test   %eax,%eax
f0107eed:	0f 84 1b 01 00 00    	je     f010800e <clock_interrupt_handler+0x12e>
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #4 clock_interrupt_handler
		//Your code is here
#if USE_KHEAP
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107ef3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107efa:	e9 fe 00 00 00       	jmp    f0107ffd <clock_interrupt_handler+0x11d>
		{
			struct Env* env;
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0107eff:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107f04:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f07:	c1 e2 04             	shl    $0x4,%edx
f0107f0a:	01 d0                	add    %edx,%eax
f0107f0c:	8b 00                	mov    (%eax),%eax
f0107f0e:	85 c0                	test   %eax,%eax
f0107f10:	0f 84 e4 00 00 00    	je     f0107ffa <clock_interrupt_handler+0x11a>
			{
				LIST_FOREACH(env, &(ProcessQueues.env_ready_queues[i]))
f0107f16:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107f1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f1e:	c1 e2 04             	shl    $0x4,%edx
f0107f21:	01 d0                	add    %edx,%eax
f0107f23:	8b 00                	mov    (%eax),%eax
f0107f25:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107f28:	e9 95 00 00 00       	jmp    f0107fc2 <clock_interrupt_handler+0xe2>
				{
					env->ticks_of_starv++;
f0107f2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f30:	8b 80 74 06 00 00    	mov    0x674(%eax),%eax
f0107f36:	8d 50 01             	lea    0x1(%eax),%edx
f0107f39:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f3c:	89 90 74 06 00 00    	mov    %edx,0x674(%eax)
					if(env->ticks_of_starv>=StarvThresh && i>0)
f0107f42:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f45:	8b 90 74 06 00 00    	mov    0x674(%eax),%edx
f0107f4b:	a1 dc 52 96 f1       	mov    0xf19652dc,%eax
f0107f50:	39 c2                	cmp    %eax,%edx
f0107f52:	72 5b                	jb     f0107faf <clock_interrupt_handler+0xcf>
f0107f54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107f58:	7e 55                	jle    f0107faf <clock_interrupt_handler+0xcf>
					{
						acquire_kspinlock(&ProcessQueues.qlock);
f0107f5a:	83 ec 0c             	sub    $0xc,%esp
f0107f5d:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107f62:	e8 de b5 00 00       	call   f0113545 <acquire_kspinlock>
f0107f67:	83 c4 10             	add    $0x10,%esp
						sched_remove_ready(env);
f0107f6a:	83 ec 0c             	sub    $0xc,%esp
f0107f6d:	ff 75 f0             	pushl  -0x10(%ebp)
f0107f70:	e8 e9 e3 ff ff       	call   f010635e <sched_remove_ready>
f0107f75:	83 c4 10             	add    $0x10,%esp
						env->priority=i-1;
f0107f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f7b:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107f7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f81:	89 50 1c             	mov    %edx,0x1c(%eax)
						env->ticks_of_starv=0;
f0107f84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f87:	c7 80 74 06 00 00 00 	movl   $0x0,0x674(%eax)
f0107f8e:	00 00 00 
						sched_insert_ready(env);
f0107f91:	83 ec 0c             	sub    $0xc,%esp
f0107f94:	ff 75 f0             	pushl  -0x10(%ebp)
f0107f97:	e8 45 e3 ff ff       	call   f01062e1 <sched_insert_ready>
f0107f9c:	83 c4 10             	add    $0x10,%esp
						release_kspinlock(&(ProcessQueues.qlock));
f0107f9f:	83 ec 0c             	sub    $0xc,%esp
f0107fa2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0107fa7:	e8 3e b6 00 00       	call   f01135ea <release_kspinlock>
f0107fac:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			struct Env* env;
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				LIST_FOREACH(env, &(ProcessQueues.env_ready_queues[i]))
f0107faf:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107fb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fb7:	c1 e2 04             	shl    $0x4,%edx
f0107fba:	01 d0                	add    %edx,%eax
f0107fbc:	8b 40 08             	mov    0x8(%eax),%eax
f0107fbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107fc2:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0107fc7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fca:	c1 e2 04             	shl    $0x4,%edx
f0107fcd:	01 d0                	add    %edx,%eax
f0107fcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107fd3:	74 08                	je     f0107fdd <clock_interrupt_handler+0xfd>
f0107fd5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107fd8:	8b 52 08             	mov    0x8(%edx),%edx
f0107fdb:	eb 05                	jmp    f0107fe2 <clock_interrupt_handler+0x102>
f0107fdd:	ba 00 00 00 00       	mov    $0x0,%edx
f0107fe2:	89 50 08             	mov    %edx,0x8(%eax)
f0107fe5:	8b 40 08             	mov    0x8(%eax),%eax
f0107fe8:	85 c0                	test   %eax,%eax
f0107fea:	0f 85 3d ff ff ff    	jne    f0107f2d <clock_interrupt_handler+0x4d>
f0107ff0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107ff4:	0f 85 33 ff ff ff    	jne    f0107f2d <clock_interrupt_handler+0x4d>
	if (isSchedMethodPRIRR())
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #4 clock_interrupt_handler
		//Your code is here
#if USE_KHEAP
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107ffa:	ff 45 f4             	incl   -0xc(%ebp)
f0107ffd:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0108002:	0f b6 c0             	movzbl %al,%eax
f0108005:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108008:	0f 8f f1 fe ff ff    	jg     f0107eff <clock_interrupt_handler+0x1f>
		//Comment the following line
		//panic("clock_interrupt_handler() is not implemented yet...!!");
	}

	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f010800e:	a1 c8 52 96 f1       	mov    0xf19652c8,%eax
f0108013:	8b 15 cc 52 96 f1    	mov    0xf19652cc,%edx
f0108019:	83 c0 01             	add    $0x1,%eax
f010801c:	83 d2 00             	adc    $0x0,%edx
f010801f:	a3 c8 52 96 f1       	mov    %eax,0xf19652c8
f0108024:	89 15 cc 52 96 f1    	mov    %edx,0xf19652cc
	struct Env* p = get_cpu_proc();
f010802a:	e8 19 56 00 00       	call   f010d648 <get_cpu_proc>
f010802f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (p == NULL)
f0108032:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108036:	74 30                	je     f0108068 <clock_interrupt_handler+0x188>
//		cprintf("scheduler status = %d\n", mycpu()->scheduler_status) ;
		//panic("clock_interrupt_handler: no running process at the cpu! unexpected clock interrupt in the kernel!");
	}
	else
	{
		p->nClocks++ ;
f0108038:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010803b:	8b 80 a0 06 00 00    	mov    0x6a0(%eax),%eax
f0108041:	8d 50 01             	lea    0x1(%eax),%edx
f0108044:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108047:	89 90 a0 06 00 00    	mov    %edx,0x6a0(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010804d:	83 ec 0c             	sub    $0xc,%esp
f0108050:	6a 01                	push   $0x1
f0108052:	e8 27 96 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0108057:	83 c4 10             	add    $0x10,%esp
f010805a:	85 c0                	test   %eax,%eax
f010805c:	74 05                	je     f0108063 <clock_interrupt_handler+0x183>
		{
			update_WS_time_stamps();
f010805e:	e8 08 00 00 00       	call   f010806b <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0108063:	e8 fb 56 00 00       	call   f010d763 <yield>
	}
	/*****************************************/
}
f0108068:	90                   	nop
f0108069:	c9                   	leave  
f010806a:	c3                   	ret    

f010806b <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f010806b:	55                   	push   %ebp
f010806c:	89 e5                	mov    %esp,%ebp
f010806e:	83 ec 38             	sub    $0x38,%esp
	//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #1 update_WS_time_stamps
	//Your code is here

	struct Env *cur_env = get_cpu_proc();
f0108071:	e8 d2 55 00 00       	call   f010d648 <get_cpu_proc>
f0108076:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env == NULL)
f0108079:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010807d:	0f 84 6f 01 00 00    	je     f01081f2 <update_WS_time_stamps+0x187>
	// --------------------------------------------
	// 1) PAGE WORKING SET AGING
	// --------------------------------------------
#if USE_KHEAP
	// When USE_KHEAP is defined, iterate through page_WS_list
	struct WorkingSetElement *ws = NULL;
f0108083:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ws, &(cur_env->page_WS_list))
f010808a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010808d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0108093:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108096:	eb 76                	jmp    f010810e <update_WS_time_stamps+0xa3>
	{
		uint32 va = ws->virtual_address;
f0108098:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010809b:	8b 00                	mov    (%eax),%eax
f010809d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 old_ts = ws->time_stamp;
f01080a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080a3:	8b 40 08             	mov    0x8(%eax),%eax
f01080a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		uint32 perms = pt_get_page_permissions(cur_env->env_page_directory, va);
f01080a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01080ac:	8b 40 64             	mov    0x64(%eax),%eax
f01080af:	83 ec 08             	sub    $0x8,%esp
f01080b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01080b5:	50                   	push   %eax
f01080b6:	e8 66 35 00 00       	call   f010b621 <pt_get_page_permissions>
f01080bb:	83 c4 10             	add    $0x10,%esp
f01080be:	89 45 e0             	mov    %eax,-0x20(%ebp)

		if (perms & PERM_USED)
f01080c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01080c4:	83 e0 20             	and    $0x20,%eax
f01080c7:	85 c0                	test   %eax,%eax
f01080c9:	74 2a                	je     f01080f5 <update_WS_time_stamps+0x8a>
		{
			ws->time_stamp = (old_ts >> 1) | 0x80000000;
f01080cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01080ce:	d1 e8                	shr    %eax
f01080d0:	0d 00 00 00 80       	or     $0x80000000,%eax
f01080d5:	89 c2                	mov    %eax,%edx
f01080d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080da:	89 50 08             	mov    %edx,0x8(%eax)

			// clear USED bit in the PTE
			pt_set_page_permissions(cur_env->env_page_directory, va, 0, PERM_USED);
f01080dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01080e0:	8b 40 64             	mov    0x64(%eax),%eax
f01080e3:	6a 20                	push   $0x20
f01080e5:	6a 00                	push   $0x0
f01080e7:	ff 75 e8             	pushl  -0x18(%ebp)
f01080ea:	50                   	push   %eax
f01080eb:	e8 6c 34 00 00       	call   f010b55c <pt_set_page_permissions>
f01080f0:	83 c4 10             	add    $0x10,%esp
f01080f3:	eb 0d                	jmp    f0108102 <update_WS_time_stamps+0x97>
		}
		else
		{
			// no reference  shift only
			ws->time_stamp = (old_ts >> 1);
f01080f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01080f8:	d1 e8                	shr    %eax
f01080fa:	89 c2                	mov    %eax,%edx
f01080fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080ff:	89 50 08             	mov    %edx,0x8(%eax)
	// 1) PAGE WORKING SET AGING
	// --------------------------------------------
#if USE_KHEAP
	// When USE_KHEAP is defined, iterate through page_WS_list
	struct WorkingSetElement *ws = NULL;
	LIST_FOREACH(ws, &(cur_env->page_WS_list))
f0108102:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108105:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010810b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010810e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108112:	74 08                	je     f010811c <update_WS_time_stamps+0xb1>
f0108114:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108117:	8b 40 10             	mov    0x10(%eax),%eax
f010811a:	eb 05                	jmp    f0108121 <update_WS_time_stamps+0xb6>
f010811c:	b8 00 00 00 00       	mov    $0x0,%eax
f0108121:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108124:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010812a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010812d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0108133:	85 c0                	test   %eax,%eax
f0108135:	0f 85 5d ff ff ff    	jne    f0108098 <update_WS_time_stamps+0x2d>
f010813b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010813f:	0f 85 53 ff ff ff    	jne    f0108098 <update_WS_time_stamps+0x2d>


	// --------------------------------------------
	// 2) TABLE WORKING SET AGING
	// --------------------------------------------
	for (uint32 t = 0; t < __TWS_MAX_SIZE; t++)
f0108145:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010814c:	e9 95 00 00 00       	jmp    f01081e6 <update_WS_time_stamps+0x17b>
	{
		struct WorkingSetElement *tws = &(cur_env->__ptr_tws[t]);
f0108151:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108154:	89 d0                	mov    %edx,%eax
f0108156:	01 c0                	add    %eax,%eax
f0108158:	01 d0                	add    %edx,%eax
f010815a:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f0108161:	01 c8                	add    %ecx,%eax
f0108163:	01 d0                	add    %edx,%eax
f0108165:	8d 90 c0 00 00 00    	lea    0xc0(%eax),%edx
f010816b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010816e:	01 d0                	add    %edx,%eax
f0108170:	83 c0 08             	add    $0x8,%eax
f0108173:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if (tws->empty == 1)
f0108176:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108179:	8a 40 04             	mov    0x4(%eax),%al
f010817c:	3c 01                	cmp    $0x1,%al
f010817e:	74 62                	je     f01081e2 <update_WS_time_stamps+0x177>
			continue;

		uint32 va = tws->virtual_address;
f0108180:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108183:	8b 00                	mov    (%eax),%eax
f0108185:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32 old_ts = tws->time_stamp;
f0108188:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010818b:	8b 40 08             	mov    0x8(%eax),%eax
f010818e:	89 45 d4             	mov    %eax,-0x2c(%ebp)

		if (pd_is_table_used(cur_env->env_page_directory, va))
f0108191:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108194:	8b 40 64             	mov    0x64(%eax),%eax
f0108197:	83 ec 08             	sub    $0x8,%esp
f010819a:	ff 75 d8             	pushl  -0x28(%ebp)
f010819d:	50                   	push   %eax
f010819e:	e8 58 36 00 00       	call   f010b7fb <pd_is_table_used>
f01081a3:	83 c4 10             	add    $0x10,%esp
f01081a6:	85 c0                	test   %eax,%eax
f01081a8:	74 29                	je     f01081d3 <update_WS_time_stamps+0x168>
		{
			tws->time_stamp = (old_ts >> 1) | 0x80000000;
f01081aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01081ad:	d1 e8                	shr    %eax
f01081af:	0d 00 00 00 80       	or     $0x80000000,%eax
f01081b4:	89 c2                	mov    %eax,%edx
f01081b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01081b9:	89 50 08             	mov    %edx,0x8(%eax)

			// clear USED bit in the page directory entry
			pd_set_table_unused(cur_env->env_page_directory, va);
f01081bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081bf:	8b 40 64             	mov    0x64(%eax),%eax
f01081c2:	83 ec 08             	sub    $0x8,%esp
f01081c5:	ff 75 d8             	pushl  -0x28(%ebp)
f01081c8:	50                   	push   %eax
f01081c9:	e8 51 36 00 00       	call   f010b81f <pd_set_table_unused>
f01081ce:	83 c4 10             	add    $0x10,%esp
f01081d1:	eb 10                	jmp    f01081e3 <update_WS_time_stamps+0x178>
		}
		else
		{
			tws->time_stamp = (old_ts >> 1);
f01081d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01081d6:	d1 e8                	shr    %eax
f01081d8:	89 c2                	mov    %eax,%edx
f01081da:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01081dd:	89 50 08             	mov    %edx,0x8(%eax)
f01081e0:	eb 01                	jmp    f01081e3 <update_WS_time_stamps+0x178>
	for (uint32 t = 0; t < __TWS_MAX_SIZE; t++)
	{
		struct WorkingSetElement *tws = &(cur_env->__ptr_tws[t]);

		if (tws->empty == 1)
			continue;
f01081e2:	90                   	nop


	// --------------------------------------------
	// 2) TABLE WORKING SET AGING
	// --------------------------------------------
	for (uint32 t = 0; t < __TWS_MAX_SIZE; t++)
f01081e3:	ff 45 f0             	incl   -0x10(%ebp)
f01081e6:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f01081ea:	0f 86 61 ff ff ff    	jbe    f0108151 <update_WS_time_stamps+0xe6>
f01081f0:	eb 01                	jmp    f01081f3 <update_WS_time_stamps+0x188>
	//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #1 update_WS_time_stamps
	//Your code is here

	struct Env *cur_env = get_cpu_proc();
	if (cur_env == NULL)
		return;
f01081f2:	90                   	nop
		}
	}

	//Comment the following line
	//panic("update_WS_time_stamps is not implemented yet...!!");
}
f01081f3:	c9                   	leave  
f01081f4:	c3                   	ret    

f01081f5 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f01081f5:	55                   	push   %ebp
f01081f6:	89 e5                	mov    %esp,%ebp
f01081f8:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f01081fb:	c7 05 2c 40 92 f0 01 	movl   $0x1,0xf092402c
f0108202:	00 00 00 
f0108205:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f010820c:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0108210:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0108213:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108216:	ee                   	out    %al,(%dx)
f0108217:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f010821e:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0108222:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0108225:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108228:	ee                   	out    %al,(%dx)
f0108229:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0108230:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0108234:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0108237:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010823a:	ee                   	out    %al,(%dx)
f010823b:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0108242:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0108246:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0108249:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010824c:	ee                   	out    %al,(%dx)
f010824d:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0108254:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0108258:	8a 45 b6             	mov    -0x4a(%ebp),%al
f010825b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010825e:	ee                   	out    %al,(%dx)
f010825f:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0108266:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f010826a:	8a 45 b7             	mov    -0x49(%ebp),%al
f010826d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108270:	ee                   	out    %al,(%dx)
f0108271:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0108278:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f010827c:	8a 45 b8             	mov    -0x48(%ebp),%al
f010827f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108282:	ee                   	out    %al,(%dx)
f0108283:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f010828a:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f010828e:	8a 45 b9             	mov    -0x47(%ebp),%al
f0108291:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0108294:	ee                   	out    %al,(%dx)
f0108295:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f010829c:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f01082a0:	8a 45 ba             	mov    -0x46(%ebp),%al
f01082a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01082a6:	ee                   	out    %al,(%dx)
f01082a7:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f01082ae:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f01082b2:	8a 45 bb             	mov    -0x45(%ebp),%al
f01082b5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01082b8:	ee                   	out    %al,(%dx)
f01082b9:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f01082c0:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f01082c4:	8a 45 bc             	mov    -0x44(%ebp),%al
f01082c7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01082ca:	ee                   	out    %al,(%dx)
f01082cb:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f01082d2:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f01082d6:	8a 45 bd             	mov    -0x43(%ebp),%al
f01082d9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01082dc:	ee                   	out    %al,(%dx)
f01082dd:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f01082e4:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f01082e8:	8a 45 be             	mov    -0x42(%ebp),%al
f01082eb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01082ee:	ee                   	out    %al,(%dx)
f01082ef:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f01082f6:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f01082fa:	8a 45 bf             	mov    -0x41(%ebp),%al
f01082fd:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0108300:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0108301:	66 a1 bc 7b 19 f0    	mov    0xf0197bbc,%ax
f0108307:	66 83 f8 ff          	cmp    $0xffff,%ax
f010830b:	74 15                	je     f0108322 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f010830d:	66 a1 bc 7b 19 f0    	mov    0xf0197bbc,%ax
f0108313:	0f b7 c0             	movzwl %ax,%eax
f0108316:	83 ec 0c             	sub    $0xc,%esp
f0108319:	50                   	push   %eax
f010831a:	e8 06 00 00 00       	call   f0108325 <irq_setmask_8259A>
f010831f:	83 c4 10             	add    $0x10,%esp
}
f0108322:	90                   	nop
f0108323:	c9                   	leave  
f0108324:	c3                   	ret    

f0108325 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0108325:	55                   	push   %ebp
f0108326:	89 e5                	mov    %esp,%ebp
f0108328:	83 ec 14             	sub    $0x14,%esp
f010832b:	8b 45 08             	mov    0x8(%ebp),%eax
f010832e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0108332:	a1 2c 40 92 f0       	mov    0xf092402c,%eax
f0108337:	85 c0                	test   %eax,%eax
f0108339:	74 34                	je     f010836f <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f010833b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010833e:	0f b6 c0             	movzbl %al,%eax
f0108341:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0108348:	88 45 f6             	mov    %al,-0xa(%ebp)
f010834b:	8a 45 f6             	mov    -0xa(%ebp),%al
f010834e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0108351:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0108352:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108355:	66 c1 e8 08          	shr    $0x8,%ax
f0108359:	0f b6 c0             	movzbl %al,%eax
f010835c:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0108363:	88 45 f7             	mov    %al,-0x9(%ebp)
f0108366:	8a 45 f7             	mov    -0x9(%ebp),%al
f0108369:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010836c:	ee                   	out    %al,(%dx)
f010836d:	eb 01                	jmp    f0108370 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f010836f:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0108370:	c9                   	leave  
f0108371:	c3                   	ret    

f0108372 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0108372:	55                   	push   %ebp
f0108373:	89 e5                	mov    %esp,%ebp
f0108375:	53                   	push   %ebx
f0108376:	83 ec 14             	sub    $0x14,%esp
f0108379:	8b 45 08             	mov    0x8(%ebp),%eax
f010837c:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010837f:	a1 2c 40 92 f0       	mov    0xf092402c,%eax
f0108384:	85 c0                	test   %eax,%eax
f0108386:	74 58                	je     f01083e0 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0108388:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010838c:	77 08                	ja     f0108396 <irq_set_mask+0x24>
		port = PIC1_DATA;
f010838e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0108394:	eb 0a                	jmp    f01083a0 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0108396:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010839c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f01083a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01083a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01083a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083aa:	89 c2                	mov    %eax,%edx
f01083ac:	ec                   	in     (%dx),%al
f01083ad:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f01083b0:	8a 45 ee             	mov    -0x12(%ebp),%al
f01083b3:	88 c2                	mov    %al,%dl
f01083b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01083b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01083be:	88 c1                	mov    %al,%cl
f01083c0:	d3 e3                	shl    %cl,%ebx
f01083c2:	89 d8                	mov    %ebx,%eax
f01083c4:	09 d0                	or     %edx,%eax
f01083c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f01083c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f01083cd:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f01083d1:	89 55 f0             	mov    %edx,-0x10(%ebp)
f01083d4:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01083d7:	8a 45 ef             	mov    -0x11(%ebp),%al
f01083da:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01083dd:	ee                   	out    %al,(%dx)
f01083de:	eb 01                	jmp    f01083e1 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f01083e0:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f01083e1:	83 c4 14             	add    $0x14,%esp
f01083e4:	5b                   	pop    %ebx
f01083e5:	5d                   	pop    %ebp
f01083e6:	c3                   	ret    

f01083e7 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f01083e7:	55                   	push   %ebp
f01083e8:	89 e5                	mov    %esp,%ebp
f01083ea:	53                   	push   %ebx
f01083eb:	83 ec 14             	sub    $0x14,%esp
f01083ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01083f1:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01083f4:	a1 2c 40 92 f0       	mov    0xf092402c,%eax
f01083f9:	85 c0                	test   %eax,%eax
f01083fb:	74 5a                	je     f0108457 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01083fd:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0108401:	77 08                	ja     f010840b <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0108403:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0108409:	eb 0a                	jmp    f0108415 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f010840b:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0108411:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0108415:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0108419:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010841c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010841f:	89 c2                	mov    %eax,%edx
f0108421:	ec                   	in     (%dx),%al
f0108422:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0108425:	8a 45 ee             	mov    -0x12(%ebp),%al
f0108428:	88 c2                	mov    %al,%dl
f010842a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010842e:	bb 01 00 00 00       	mov    $0x1,%ebx
f0108433:	88 c1                	mov    %al,%cl
f0108435:	d3 e3                	shl    %cl,%ebx
f0108437:	89 d8                	mov    %ebx,%eax
f0108439:	f7 d0                	not    %eax
f010843b:	21 d0                	and    %edx,%eax
f010843d:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0108440:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0108444:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0108448:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010844b:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010844e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0108451:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108454:	ee                   	out    %al,(%dx)
f0108455:	eb 01                	jmp    f0108458 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0108457:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0108458:	83 c4 14             	add    $0x14,%esp
f010845b:	5b                   	pop    %ebx
f010845c:	5d                   	pop    %ebp
f010845d:	c3                   	ret    

f010845e <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010845e:	55                   	push   %ebp
f010845f:	89 e5                	mov    %esp,%ebp
f0108461:	53                   	push   %ebx
f0108462:	83 ec 14             	sub    $0x14,%esp
f0108465:	8b 45 08             	mov    0x8(%ebp),%eax
f0108468:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010846b:	a1 2c 40 92 f0       	mov    0xf092402c,%eax
f0108470:	85 c0                	test   %eax,%eax
f0108472:	75 07                	jne    f010847b <irq_get_mask+0x1d>
		return -1;
f0108474:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108479:	eb 45                	jmp    f01084c0 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010847b:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010847f:	77 08                	ja     f0108489 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0108481:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0108487:	eb 0a                	jmp    f0108493 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0108489:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010848f:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0108493:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0108497:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010849a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010849d:	89 c2                	mov    %eax,%edx
f010849f:	ec                   	in     (%dx),%al
f01084a0:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01084a3:	8a 45 f3             	mov    -0xd(%ebp),%al
f01084a6:	88 c2                	mov    %al,%dl
f01084a8:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01084ac:	bb 01 00 00 00       	mov    $0x1,%ebx
f01084b1:	88 c1                	mov    %al,%cl
f01084b3:	d3 e3                	shl    %cl,%ebx
f01084b5:	89 d8                	mov    %ebx,%eax
f01084b7:	21 d0                	and    %edx,%eax
f01084b9:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01084bc:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01084c0:	83 c4 14             	add    $0x14,%esp
f01084c3:	5b                   	pop    %ebx
f01084c4:	5d                   	pop    %ebp
f01084c5:	c3                   	ret    

f01084c6 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01084c6:	55                   	push   %ebp
f01084c7:	89 e5                	mov    %esp,%ebp
f01084c9:	83 ec 14             	sub    $0x14,%esp
f01084cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01084cf:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01084d2:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01084d6:	76 12                	jbe    f01084ea <pic_sendEOI+0x24>
f01084d8:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01084df:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01084e3:	8a 45 f7             	mov    -0x9(%ebp),%al
f01084e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01084e9:	ee                   	out    %al,(%dx)
f01084ea:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01084f1:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f01084f5:	8a 45 f6             	mov    -0xa(%ebp),%al
f01084f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01084fb:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f01084fc:	90                   	nop
f01084fd:	c9                   	leave  
f01084fe:	c3                   	ret    

f01084ff <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f01084ff:	55                   	push   %ebp
f0108500:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0108502:	b8 a0 cf 94 f1       	mov    $0xf194cfa0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0108507:	5d                   	pop    %ebp
f0108508:	c3                   	ret    

f0108509 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0108509:	55                   	push   %ebp
f010850a:	89 e5                	mov    %esp,%ebp
f010850c:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010850f:	e8 eb ff ff ff       	call   f01084ff <mycpu>
f0108514:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0108517:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010851a:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0108521:	00 00 00 
  c->ncli = 0;
f0108524:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108527:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010852e:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0108531:	9c                   	pushf  
f0108532:	58                   	pop    %eax
f0108533:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0108536:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0108539:	25 00 02 00 00       	and    $0x200,%eax
f010853e:	85 c0                	test   %eax,%eax
f0108540:	0f 95 c0             	setne  %al
f0108543:	0f b6 d0             	movzbl %al,%edx
f0108546:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108549:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010854f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108552:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0108559:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010855c:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0108563:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0108566:	8b 45 08             	mov    0x8(%ebp),%eax
f0108569:	40                   	inc    %eax
f010856a:	c1 e0 0f             	shl    $0xf,%eax
f010856d:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0108572:	29 c2                	sub    %eax,%edx
f0108574:	89 d0                	mov    %edx,%eax
f0108576:	89 c2                	mov    %eax,%edx
f0108578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010857b:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010857e:	e8 18 01 00 00       	call   f010869b <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0108583:	e8 3c 68 00 00       	call   f010edc4 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0108588:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010858b:	83 c0 0c             	add    $0xc,%eax
f010858e:	83 ec 04             	sub    $0x4,%esp
f0108591:	6a 68                	push   $0x68
f0108593:	6a 00                	push   $0x0
f0108595:	50                   	push   %eax
f0108596:	e8 82 aa 01 00       	call   f012301d <memset>
f010859b:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f010859e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085a1:	05 a4 00 00 00       	add    $0xa4,%eax
f01085a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085a9:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01085b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01085b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01085b6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01085b9:	f0 87 02             	lock xchg %eax,(%edx)
f01085bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01085bf:	90                   	nop
f01085c0:	c9                   	leave  
f01085c1:	c3                   	ret    

f01085c2 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01085c2:	55                   	push   %ebp
f01085c3:	89 e5                	mov    %esp,%ebp
f01085c5:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01085c8:	9c                   	pushf  
f01085c9:	58                   	pop    %eax
f01085ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01085cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01085d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01085d3:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01085d4:	e8 26 ff ff ff       	call   f01084ff <mycpu>
f01085d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01085dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085df:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01085e5:	85 c0                	test   %eax,%eax
f01085e7:	75 13                	jne    f01085fc <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01085e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01085ec:	25 00 02 00 00       	and    $0x200,%eax
f01085f1:	89 c2                	mov    %eax,%edx
f01085f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085f6:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f01085fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085ff:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108605:	8d 50 01             	lea    0x1(%eax),%edx
f0108608:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010860b:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0108611:	90                   	nop
f0108612:	c9                   	leave  
f0108613:	c3                   	ret    

f0108614 <popcli>:

void popcli(void)
{
f0108614:	55                   	push   %ebp
f0108615:	89 e5                	mov    %esp,%ebp
f0108617:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010861a:	9c                   	pushf  
f010861b:	58                   	pop    %eax
f010861c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010861f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0108622:	25 00 02 00 00       	and    $0x200,%eax
f0108627:	85 c0                	test   %eax,%eax
f0108629:	74 14                	je     f010863f <popcli+0x2b>
    panic("popcli - interruptible");
f010862b:	83 ec 04             	sub    $0x4,%esp
f010862e:	68 8f 75 13 f0       	push   $0xf013758f
f0108633:	6a 5e                	push   $0x5e
f0108635:	68 a6 75 13 f0       	push   $0xf01375a6
f010863a:	e8 70 88 ff ff       	call   f0100eaf <_panic>
  struct cpu* c = mycpu();
f010863f:	e8 bb fe ff ff       	call   f01084ff <mycpu>
f0108644:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0108647:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010864a:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108650:	8d 50 ff             	lea    -0x1(%eax),%edx
f0108653:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108656:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f010865c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010865f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108665:	85 c0                	test   %eax,%eax
f0108667:	79 14                	jns    f010867d <popcli+0x69>
    panic("popcli");
f0108669:	83 ec 04             	sub    $0x4,%esp
f010866c:	68 b5 75 13 f0       	push   $0xf01375b5
f0108671:	6a 61                	push   $0x61
f0108673:	68 a6 75 13 f0       	push   $0xf01375a6
f0108678:	e8 32 88 ff ff       	call   f0100eaf <_panic>
  if(c->ncli == 0 && c->intena)
f010867d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108680:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108686:	85 c0                	test   %eax,%eax
f0108688:	75 0e                	jne    f0108698 <popcli+0x84>
f010868a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010868d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0108693:	85 c0                	test   %eax,%eax
f0108695:	74 01                	je     f0108698 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0108697:	fb                   	sti    
    sti();
}
f0108698:	90                   	nop
f0108699:	c9                   	leave  
f010869a:	c3                   	ret    

f010869b <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f010869b:	55                   	push   %ebp
f010869c:	89 e5                	mov    %esp,%ebp
f010869e:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01086a1:	e8 1c ff ff ff       	call   f01085c2 <pushcli>

	c = mycpu();
f01086a6:	e8 54 fe ff ff       	call   f01084ff <mycpu>
f01086ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01086ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086b1:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01086b8:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01086bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086c2:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01086c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086cb:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01086d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086d4:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01086db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086de:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01086e4:	83 e2 f0             	and    $0xfffffff0,%edx
f01086e7:	83 ca 0a             	or     $0xa,%edx
f01086ea:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01086f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086f3:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01086f9:	83 ca 10             	or     $0x10,%edx
f01086fc:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108702:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108705:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010870b:	83 e2 9f             	and    $0xffffff9f,%edx
f010870e:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108714:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108717:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010871d:	83 ca 80             	or     $0xffffff80,%edx
f0108720:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108726:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108729:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010872f:	83 ca 0f             	or     $0xf,%edx
f0108732:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0108738:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010873b:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0108741:	83 e2 ef             	and    $0xffffffef,%edx
f0108744:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010874a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010874d:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0108753:	83 e2 df             	and    $0xffffffdf,%edx
f0108756:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010875c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010875f:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0108765:	83 ca 40             	or     $0x40,%edx
f0108768:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010876e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108771:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0108777:	83 ca 80             	or     $0xffffff80,%edx
f010877a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0108780:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108783:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f010878a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010878d:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0108794:	ff ff 
f0108796:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108799:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01087a0:	00 00 
f01087a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087a5:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01087ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087af:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01087b5:	83 e2 f0             	and    $0xfffffff0,%edx
f01087b8:	83 ca 02             	or     $0x2,%edx
f01087bb:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01087c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087c4:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01087ca:	83 ca 10             	or     $0x10,%edx
f01087cd:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01087d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087d6:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01087dc:	83 e2 9f             	and    $0xffffff9f,%edx
f01087df:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01087e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087e8:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01087ee:	83 ca 80             	or     $0xffffff80,%edx
f01087f1:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01087f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087fa:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108800:	83 ca 0f             	or     $0xf,%edx
f0108803:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0108809:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010880c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108812:	83 e2 ef             	and    $0xffffffef,%edx
f0108815:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010881b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010881e:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108824:	83 e2 df             	and    $0xffffffdf,%edx
f0108827:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010882d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108830:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108836:	83 ca 40             	or     $0x40,%edx
f0108839:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010883f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108842:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108848:	83 ca 80             	or     $0xffffff80,%edx
f010884b:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0108851:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108854:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f010885b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010885e:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0108865:	ff ff 
f0108867:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010886a:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f0108871:	00 00 
f0108873:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108876:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010887d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108880:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0108886:	83 e2 f0             	and    $0xfffffff0,%edx
f0108889:	83 ca 0a             	or     $0xa,%edx
f010888c:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108892:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108895:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010889b:	83 ca 10             	or     $0x10,%edx
f010889e:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01088a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088a7:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01088ad:	83 ca 60             	or     $0x60,%edx
f01088b0:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01088b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088b9:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01088bf:	83 ca 80             	or     $0xffffff80,%edx
f01088c2:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01088c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088cb:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01088d1:	83 ca 0f             	or     $0xf,%edx
f01088d4:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01088da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088dd:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01088e3:	83 e2 ef             	and    $0xffffffef,%edx
f01088e6:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01088ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088ef:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01088f5:	83 e2 df             	and    $0xffffffdf,%edx
f01088f8:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01088fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108901:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108907:	83 ca 40             	or     $0x40,%edx
f010890a:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108913:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108919:	83 ca 80             	or     $0xffffff80,%edx
f010891c:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108922:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108925:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f010892c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010892f:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0108936:	ff ff 
f0108938:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010893b:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f0108942:	00 00 
f0108944:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108947:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010894e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108951:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0108957:	83 e2 f0             	and    $0xfffffff0,%edx
f010895a:	83 ca 02             	or     $0x2,%edx
f010895d:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0108963:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108966:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010896c:	83 ca 10             	or     $0x10,%edx
f010896f:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0108975:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108978:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010897e:	83 ca 60             	or     $0x60,%edx
f0108981:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0108987:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010898a:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0108990:	83 ca 80             	or     $0xffffff80,%edx
f0108993:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0108999:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010899c:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01089a2:	83 ca 0f             	or     $0xf,%edx
f01089a5:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01089ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089ae:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01089b4:	83 e2 ef             	and    $0xffffffef,%edx
f01089b7:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01089bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089c0:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01089c6:	83 e2 df             	and    $0xffffffdf,%edx
f01089c9:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01089cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089d2:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01089d8:	83 ca 40             	or     $0x40,%edx
f01089db:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01089e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089e4:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01089ea:	83 ca 80             	or     $0xffffff80,%edx
f01089ed:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01089f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089f6:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f01089fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a00:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0108a07:	00 00 00 
f0108a0a:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0108a11:	00 00 00 

	popcli();	//enable interrupt
f0108a14:	e8 fb fb ff ff       	call   f0108614 <popcli>


}
f0108a19:	90                   	nop
f0108a1a:	c9                   	leave  
f0108a1b:	c3                   	ret    

f0108a1c <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0108a1c:	55                   	push   %ebp
f0108a1d:	89 e5                	mov    %esp,%ebp
f0108a1f:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0108a22:	83 ec 08             	sub    $0x8,%esp
f0108a25:	68 00 10 00 00       	push   $0x1000
f0108a2a:	68 00 10 00 00       	push   $0x1000
f0108a2f:	e8 4a 02 00 00       	call   f0108c7e <boot_allocate_space>
f0108a34:	83 c4 10             	add    $0x10,%esp
f0108a37:	a3 78 53 96 f1       	mov    %eax,0xf1965378
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0108a3c:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108a41:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108a44:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108a4b:	77 14                	ja     f0108a61 <initialize_kernel_VM+0x45>
f0108a4d:	ff 75 e0             	pushl  -0x20(%ebp)
f0108a50:	68 bc 75 13 f0       	push   $0xf01375bc
f0108a55:	6a 57                	push   $0x57
f0108a57:	68 f0 75 13 f0       	push   $0xf01375f0
f0108a5c:	e8 4e 84 ff ff       	call   f0100eaf <_panic>
f0108a61:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a64:	05 00 00 00 10       	add    $0x10000000,%eax
f0108a69:	a3 80 54 96 f1       	mov    %eax,0xf1965480
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f0108a6e:	c7 45 dc 00 f0 18 f0 	movl   $0xf018f000,-0x24(%ebp)
f0108a75:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0108a7c:	77 14                	ja     f0108a92 <initialize_kernel_VM+0x76>
f0108a7e:	ff 75 dc             	pushl  -0x24(%ebp)
f0108a81:	68 bc 75 13 f0       	push   $0xf01375bc
f0108a86:	6a 63                	push   $0x63
f0108a88:	68 f0 75 13 f0       	push   $0xf01375f0
f0108a8d:	e8 1d 84 ff ff       	call   f0100eaf <_panic>
f0108a92:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a95:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108a9b:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108aa0:	83 ec 0c             	sub    $0xc,%esp
f0108aa3:	6a 02                	push   $0x2
f0108aa5:	52                   	push   %edx
f0108aa6:	68 00 80 00 00       	push   $0x8000
f0108aab:	68 00 80 bf ef       	push   $0xefbf8000
f0108ab0:	50                   	push   %eax
f0108ab1:	e8 3c 02 00 00       	call   f0108cf2 <boot_map_range>
f0108ab6:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108ab9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108ac0:	eb 24                	jmp    f0108ae6 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0108ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ac5:	40                   	inc    %eax
f0108ac6:	c1 e0 0f             	shl    $0xf,%eax
f0108ac9:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0108ace:	29 c2                	sub    %eax,%edx
f0108ad0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108ad5:	6a 01                	push   $0x1
f0108ad7:	6a 00                	push   $0x0
f0108ad9:	52                   	push   %edx
f0108ada:	50                   	push   %eax
f0108adb:	e8 7c 2a 00 00       	call   f010b55c <pt_set_page_permissions>
f0108ae0:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108ae3:	ff 45 f4             	incl   -0xc(%ebp)
f0108ae6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108aea:	7e d6                	jle    f0108ac2 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0108aec:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0108af3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0108afa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0108b01:	eb 25                	jmp    f0108b28 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0108b03:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0108b06:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108b09:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108b0e:	83 ec 04             	sub    $0x4,%esp
f0108b11:	6a 01                	push   $0x1
f0108b13:	52                   	push   %edx
f0108b14:	50                   	push   %eax
f0108b15:	e8 4c 02 00 00       	call   f0108d66 <boot_get_page_table>
f0108b1a:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0108b1d:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0108b24:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0108b28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108b2c:	72 d5                	jb     f0108b03 <initialize_kernel_VM+0xe7>
f0108b2e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108b32:	77 06                	ja     f0108b3a <initialize_kernel_VM+0x11e>
f0108b34:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0108b38:	76 c9                	jbe    f0108b03 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0108b3a:	8b 15 58 d0 94 f1    	mov    0xf194d058,%edx
f0108b40:	89 d0                	mov    %edx,%eax
f0108b42:	01 c0                	add    %eax,%eax
f0108b44:	01 d0                	add    %edx,%eax
f0108b46:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f0108b4d:	01 c8                	add    %ecx,%eax
f0108b4f:	01 d0                	add    %edx,%eax
f0108b51:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0108b54:	83 ec 08             	sub    $0x8,%esp
f0108b57:	68 00 10 00 00       	push   $0x1000
f0108b5c:	ff 75 d8             	pushl  -0x28(%ebp)
f0108b5f:	e8 1a 01 00 00       	call   f0108c7e <boot_allocate_space>
f0108b64:	83 c4 10             	add    $0x10,%esp
f0108b67:	a3 a8 51 96 f1       	mov    %eax,0xf19651a8
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0108b6c:	c7 45 d4 00 e0 38 00 	movl   $0x38e000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0108b73:	83 ec 08             	sub    $0x8,%esp
f0108b76:	68 00 10 00 00       	push   $0x1000
f0108b7b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108b7e:	e8 fb 00 00 00       	call   f0108c7e <boot_allocate_space>
f0108b83:	83 c4 10             	add    $0x10,%esp
f0108b86:	a3 e4 cb 94 f1       	mov    %eax,0xf194cbe4
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0108b8b:	e8 05 05 00 00       	call   f0109095 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0108b90:	83 ec 0c             	sub    $0xc,%esp
f0108b93:	68 68 02 00 00       	push   $0x268
f0108b98:	e8 0e 7d 01 00       	call   f01208ab <nearest_pow2_ceil>
f0108b9d:	83 c4 10             	add    $0x10,%esp
f0108ba0:	83 ec 04             	sub    $0x4,%esp
f0108ba3:	50                   	push   %eax
f0108ba4:	68 68 02 00 00       	push   $0x268
f0108ba9:	68 10 76 13 f0       	push   $0xf0137610
f0108bae:	e8 9a 8f ff ff       	call   f0101b4d <cprintf>
f0108bb3:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0108bb6:	c7 45 d0 a0 fa 0f 00 	movl   $0xffaa0,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0108bbd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108bc0:	83 ec 08             	sub    $0x8,%esp
f0108bc3:	68 00 10 00 00       	push   $0x1000
f0108bc8:	50                   	push   %eax
f0108bc9:	e8 b0 00 00 00       	call   f0108c7e <boot_allocate_space>
f0108bce:	83 c4 10             	add    $0x10,%esp
f0108bd1:	a3 d0 40 92 f0       	mov    %eax,0xf09240d0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0108bd6:	a1 d0 40 92 f0       	mov    0xf09240d0,%eax
f0108bdb:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0108bde:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f0108be5:	77 17                	ja     f0108bfe <initialize_kernel_VM+0x1e2>
f0108be7:	ff 75 cc             	pushl  -0x34(%ebp)
f0108bea:	68 bc 75 13 f0       	push   $0xf01375bc
f0108bef:	68 b1 00 00 00       	push   $0xb1
f0108bf4:	68 f0 75 13 f0       	push   $0xf01375f0
f0108bf9:	e8 b1 82 ff ff       	call   f0100eaf <_panic>
f0108bfe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108c01:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0108c07:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0108c0a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108c0f:	83 ec 0c             	sub    $0xc,%esp
f0108c12:	6a 04                	push   $0x4
f0108c14:	51                   	push   %ecx
f0108c15:	52                   	push   %edx
f0108c16:	68 00 00 c0 ee       	push   $0xeec00000
f0108c1b:	50                   	push   %eax
f0108c1c:	e8 d1 00 00 00       	call   f0108cf2 <boot_map_range>
f0108c21:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0108c24:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108c29:	05 ec 0e 00 00       	add    $0xeec,%eax
f0108c2e:	8b 15 78 53 96 f1    	mov    0xf1965378,%edx
f0108c34:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0108c3a:	8b 12                	mov    (%edx),%edx
f0108c3c:	83 ca 05             	or     $0x5,%edx
f0108c3f:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0108c41:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0108c46:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108c4c:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108c51:	83 ec 0c             	sub    $0xc,%esp
f0108c54:	6a 02                	push   $0x2
f0108c56:	6a 00                	push   $0x0
f0108c58:	52                   	push   %edx
f0108c59:	68 00 00 00 f0       	push   $0xf0000000
f0108c5e:	50                   	push   %eax
f0108c5f:	e8 8e 00 00 00       	call   f0108cf2 <boot_map_range>
f0108c64:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0108c67:	e8 4c 96 01 00       	call   f01222b8 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0108c6c:	c7 05 90 cf 94 f1 19 	movl   $0x19,0xf194cf90
f0108c73:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0108c76:	e8 e6 02 00 00       	call   f0108f61 <turn_on_paging>
}
f0108c7b:	90                   	nop
f0108c7c:	c9                   	leave  
f0108c7d:	c3                   	ret    

f0108c7e <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0108c7e:	55                   	push   %ebp
f0108c7f:	89 e5                	mov    %esp,%ebp
f0108c81:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0108c84:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0108c89:	85 c0                	test   %eax,%eax
f0108c8b:	75 0a                	jne    f0108c97 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0108c8d:	c7 05 70 53 96 f1 d0 	movl   $0xf19a85d0,0xf1965370
f0108c94:	85 9a f1 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0108c97:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c9d:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0108ca2:	89 c2                	mov    %eax,%edx
f0108ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ca7:	01 d0                	add    %edx,%eax
f0108ca9:	48                   	dec    %eax
f0108caa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108cad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0108cb5:	f7 75 f4             	divl   -0xc(%ebp)
f0108cb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108cbb:	29 d0                	sub    %edx,%eax
f0108cbd:	a3 70 53 96 f1       	mov    %eax,0xf1965370

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0108cc2:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0108cc7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0108cca:	8b 15 70 53 96 f1    	mov    0xf1965370,%edx
f0108cd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cd3:	01 d0                	add    %edx,%eax
f0108cd5:	a3 70 53 96 f1       	mov    %eax,0xf1965370

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0108cda:	83 ec 04             	sub    $0x4,%esp
f0108cdd:	ff 75 08             	pushl  0x8(%ebp)
f0108ce0:	6a 00                	push   $0x0
f0108ce2:	ff 75 ec             	pushl  -0x14(%ebp)
f0108ce5:	e8 33 a3 01 00       	call   f012301d <memset>
f0108cea:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0108ced:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0108cf0:	c9                   	leave  
f0108cf1:	c3                   	ret    

f0108cf2 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0108cf2:	55                   	push   %ebp
f0108cf3:	89 e5                	mov    %esp,%ebp
f0108cf5:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0108cf8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0108cff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d06:	eb 53                	jmp    f0108d5b <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f0108d08:	83 ec 04             	sub    $0x4,%esp
f0108d0b:	6a 01                	push   $0x1
f0108d0d:	ff 75 0c             	pushl  0xc(%ebp)
f0108d10:	ff 75 08             	pushl  0x8(%ebp)
f0108d13:	e8 4e 00 00 00       	call   f0108d66 <boot_get_page_table>
f0108d18:	83 c4 10             	add    $0x10,%esp
f0108d1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0108d1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d21:	c1 e8 0c             	shr    $0xc,%eax
f0108d24:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108d29:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0108d2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d2f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108d36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d39:	01 c2                	add    %eax,%edx
f0108d3b:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d3e:	0b 45 14             	or     0x14(%ebp),%eax
f0108d41:	83 c8 01             	or     $0x1,%eax
f0108d44:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0108d46:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0108d4d:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0108d54:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0108d5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d5e:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108d61:	72 a5                	jb     f0108d08 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0108d63:	90                   	nop
f0108d64:	c9                   	leave  
f0108d65:	c3                   	ret    

f0108d66 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0108d66:	55                   	push   %ebp
f0108d67:	89 e5                	mov    %esp,%ebp
f0108d69:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0108d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d6f:	c1 e8 16             	shr    $0x16,%eax
f0108d72:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0108d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d78:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108d7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d82:	01 d0                	add    %edx,%eax
f0108d84:	8b 00                	mov    (%eax),%eax
f0108d86:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0108d89:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d8c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108d91:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0108d94:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d97:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108d9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d9d:	c1 e8 0c             	shr    $0xc,%eax
f0108da0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108da3:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0108da8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108dab:	72 17                	jb     f0108dc4 <boot_get_page_table+0x5e>
f0108dad:	ff 75 e8             	pushl  -0x18(%ebp)
f0108db0:	68 38 76 13 f0       	push   $0xf0137638
f0108db5:	68 33 01 00 00       	push   $0x133
f0108dba:	68 f0 75 13 f0       	push   $0xf01375f0
f0108dbf:	e8 eb 80 ff ff       	call   f0100eaf <_panic>
f0108dc4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108dcc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0108dcf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108dd3:	75 72                	jne    f0108e47 <boot_get_page_table+0xe1>
	{
		if (create)
f0108dd5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0108dd9:	74 65                	je     f0108e40 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0108ddb:	83 ec 08             	sub    $0x8,%esp
f0108dde:	68 00 10 00 00       	push   $0x1000
f0108de3:	68 00 10 00 00       	push   $0x1000
f0108de8:	e8 91 fe ff ff       	call   f0108c7e <boot_allocate_space>
f0108ded:	83 c4 10             	add    $0x10,%esp
f0108df0:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f0108df3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108df6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108df9:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0108e00:	77 17                	ja     f0108e19 <boot_get_page_table+0xb3>
f0108e02:	ff 75 dc             	pushl  -0x24(%ebp)
f0108e05:	68 bc 75 13 f0       	push   $0xf01375bc
f0108e0a:	68 39 01 00 00       	push   $0x139
f0108e0f:	68 f0 75 13 f0       	push   $0xf01375f0
f0108e14:	e8 96 80 ff ff       	call   f0100eaf <_panic>
f0108e19:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108e1c:	05 00 00 00 10       	add    $0x10000000,%eax
f0108e21:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0108e24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e27:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108e2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e31:	01 d0                	add    %edx,%eax
f0108e33:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108e36:	83 ca 03             	or     $0x3,%edx
f0108e39:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0108e3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108e3e:	eb 0a                	jmp    f0108e4a <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0108e40:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e45:	eb 03                	jmp    f0108e4a <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0108e47:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0108e4a:	c9                   	leave  
f0108e4b:	c3                   	ret    

f0108e4c <nvram_read>:


int nvram_read(int r)
{
f0108e4c:	55                   	push   %ebp
f0108e4d:	89 e5                	mov    %esp,%ebp
f0108e4f:	53                   	push   %ebx
f0108e50:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0108e53:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e56:	83 ec 0c             	sub    $0xc,%esp
f0108e59:	50                   	push   %eax
f0108e5a:	e8 98 cd ff ff       	call   f0105bf7 <mc146818_read>
f0108e5f:	83 c4 10             	add    $0x10,%esp
f0108e62:	89 c3                	mov    %eax,%ebx
f0108e64:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e67:	40                   	inc    %eax
f0108e68:	83 ec 0c             	sub    $0xc,%esp
f0108e6b:	50                   	push   %eax
f0108e6c:	e8 86 cd ff ff       	call   f0105bf7 <mc146818_read>
f0108e71:	83 c4 10             	add    $0x10,%esp
f0108e74:	c1 e0 08             	shl    $0x8,%eax
f0108e77:	09 d8                	or     %ebx,%eax
}
f0108e79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108e7c:	c9                   	leave  
f0108e7d:	c3                   	ret    

f0108e7e <detect_memory>:

void detect_memory()
{
f0108e7e:	55                   	push   %ebp
f0108e7f:	89 e5                	mov    %esp,%ebp
f0108e81:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0108e84:	83 ec 0c             	sub    $0xc,%esp
f0108e87:	6a 15                	push   $0x15
f0108e89:	e8 be ff ff ff       	call   f0108e4c <nvram_read>
f0108e8e:	83 c4 10             	add    $0x10,%esp
f0108e91:	c1 e0 0a             	shl    $0xa,%eax
f0108e94:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108e97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e9a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108e9f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0108ea2:	83 ec 0c             	sub    $0xc,%esp
f0108ea5:	6a 17                	push   $0x17
f0108ea7:	e8 a0 ff ff ff       	call   f0108e4c <nvram_read>
f0108eac:	83 c4 10             	add    $0x10,%esp
f0108eaf:	c1 e0 0a             	shl    $0xa,%eax
f0108eb2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108eb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108eb8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ebd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0108ec0:	83 ec 0c             	sub    $0xc,%esp
f0108ec3:	6a 34                	push   $0x34
f0108ec5:	e8 82 ff ff ff       	call   f0108e4c <nvram_read>
f0108eca:	83 c4 10             	add    $0x10,%esp
f0108ecd:	c1 e0 10             	shl    $0x10,%eax
f0108ed0:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108ed3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108ed6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108edb:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0108ede:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0108ee2:	74 18                	je     f0108efc <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0108ee4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108ee7:	05 00 00 00 01       	add    $0x1000000,%eax
f0108eec:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0108eef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ef2:	2d 00 00 10 00       	sub    $0x100000,%eax
f0108ef7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108efa:	eb 19                	jmp    f0108f15 <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0108efc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108f00:	74 0d                	je     f0108f0f <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0108f02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f05:	05 00 00 10 00       	add    $0x100000,%eax
f0108f0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f0d:	eb 06                	jmp    f0108f15 <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0108f0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f12:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0108f15:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0108f1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f1f:	c1 e8 0c             	shr    $0xc,%eax
f0108f22:	a3 58 d0 94 f1       	mov    %eax,0xf194d058

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0108f27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f2a:	c1 e8 0a             	shr    $0xa,%eax
f0108f2d:	83 ec 08             	sub    $0x8,%esp
f0108f30:	50                   	push   %eax
f0108f31:	68 68 76 13 f0       	push   $0xf0137668
f0108f36:	e8 12 8c ff ff       	call   f0101b4d <cprintf>
f0108f3b:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0108f3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f41:	c1 e8 0a             	shr    $0xa,%eax
f0108f44:	89 c2                	mov    %eax,%edx
f0108f46:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108f49:	c1 e8 0a             	shr    $0xa,%eax
f0108f4c:	83 ec 04             	sub    $0x4,%esp
f0108f4f:	52                   	push   %edx
f0108f50:	50                   	push   %eax
f0108f51:	68 8b 76 13 f0       	push   $0xf013768b
f0108f56:	e8 f2 8b ff ff       	call   f0101b4d <cprintf>
f0108f5b:	83 c4 10             	add    $0x10,%esp
}
f0108f5e:	90                   	nop
f0108f5f:	c9                   	leave  
f0108f60:	c3                   	ret    

f0108f61 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0108f61:	55                   	push   %ebp
f0108f62:	89 e5                	mov    %esp,%ebp
f0108f64:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0108f67:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0108f6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108f75:	eb 24                	jmp    f0108f9b <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0108f77:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108f7f:	c1 e2 02             	shl    $0x2,%edx
f0108f82:	01 c2                	add    %eax,%edx
f0108f84:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0108f89:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108f8c:	c1 e1 02             	shl    $0x2,%ecx
f0108f8f:	01 c8                	add    %ecx,%eax
f0108f91:	8b 00                	mov    (%eax),%eax
f0108f93:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108f95:	ff 45 f4             	incl   -0xc(%ebp)
f0108f98:	ff 45 f0             	incl   -0x10(%ebp)
f0108f9b:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0108fa0:	c1 e8 16             	shr    $0x16,%eax
f0108fa3:	89 c2                	mov    %eax,%edx
f0108fa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108fa8:	39 c2                	cmp    %eax,%edx
f0108faa:	77 cb                	ja     f0108f77 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0108fac:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f0108fb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108fb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108fb7:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0108fba:	0f 20 c0             	mov    %cr0,%eax
f0108fbd:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0108fc0:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0108fc3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0108fc6:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0108fcd:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0108fd1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108fd4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0108fd7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108fda:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0108fdd:	e8 e0 f5 ff ff       	call   f01085c2 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0108fe2:	e8 18 f5 ff ff       	call   f01084ff <mycpu>
f0108fe7:	83 c0 74             	add    $0x74,%eax
f0108fea:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0108fed:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0108ff4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108ff7:	48                   	dec    %eax
f0108ff8:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0108ffc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108fff:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0109003:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109006:	c1 e8 10             	shr    $0x10,%eax
f0109009:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f010900d:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0109010:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0109013:	e8 fc f5 ff ff       	call   f0108614 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0109018:	b8 23 00 00 00       	mov    $0x23,%eax
f010901d:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f010901f:	b8 23 00 00 00       	mov    $0x23,%eax
f0109024:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0109026:	b8 10 00 00 00       	mov    $0x10,%eax
f010902b:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f010902d:	b8 10 00 00 00       	mov    $0x10,%eax
f0109032:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0109034:	b8 10 00 00 00       	mov    $0x10,%eax
f0109039:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f010903b:	ea 42 90 10 f0 08 00 	ljmp   $0x8,$0xf0109042
	asm volatile("lldt %%ax" :: "a" (0));
f0109042:	b8 00 00 00 00       	mov    $0x0,%eax
f0109047:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f010904a:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0109051:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0109058:	eb 19                	jmp    f0109073 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f010905a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010905f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109062:	c1 e2 02             	shl    $0x2,%edx
f0109065:	01 d0                	add    %edx,%eax
f0109067:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f010906d:	ff 45 ec             	incl   -0x14(%ebp)
f0109070:	ff 45 e8             	incl   -0x18(%ebp)
f0109073:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0109078:	c1 e8 16             	shr    $0x16,%eax
f010907b:	89 c2                	mov    %eax,%edx
f010907d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109080:	39 c2                	cmp    %eax,%edx
f0109082:	77 d6                	ja     f010905a <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0109084:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f0109089:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010908c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010908f:	0f 22 d8             	mov    %eax,%cr3

}
f0109092:	90                   	nop
f0109093:	c9                   	leave  
f0109094:	c3                   	ret    

f0109095 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0109095:	55                   	push   %ebp
f0109096:	89 e5                	mov    %esp,%ebp
f0109098:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f010909b:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01090a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01090a3:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f01090aa:	77 17                	ja     f01090c3 <setup_listing_to_all_page_tables_entries+0x2e>
f01090ac:	ff 75 f4             	pushl  -0xc(%ebp)
f01090af:	68 bc 75 13 f0       	push   $0xf01375bc
f01090b4:	68 cf 01 00 00       	push   $0x1cf
f01090b9:	68 f0 75 13 f0       	push   $0xf01375f0
f01090be:	e8 ec 7d ff ff       	call   f0100eaf <_panic>
f01090c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090c6:	05 00 00 00 10       	add    $0x10000000,%eax
f01090cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f01090ce:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01090d3:	05 fc 0e 00 00       	add    $0xefc,%eax
f01090d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01090db:	83 ca 03             	or     $0x3,%edx
f01090de:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f01090e0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01090e5:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f01090eb:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01090f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01090f3:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f01090fa:	77 17                	ja     f0109113 <setup_listing_to_all_page_tables_entries+0x7e>
f01090fc:	ff 75 ec             	pushl  -0x14(%ebp)
f01090ff:	68 bc 75 13 f0       	push   $0xf01375bc
f0109104:	68 d4 01 00 00       	push   $0x1d4
f0109109:	68 f0 75 13 f0       	push   $0xf01375f0
f010910e:	e8 9c 7d ff ff       	call   f0100eaf <_panic>
f0109113:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109116:	05 00 00 00 10       	add    $0x10000000,%eax
f010911b:	83 c8 05             	or     $0x5,%eax
f010911e:	89 02                	mov    %eax,(%edx)

}
f0109120:	90                   	nop
f0109121:	c9                   	leave  
f0109122:	c3                   	ret    

f0109123 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0109123:	55                   	push   %ebp
f0109124:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0109126:	8b 45 08             	mov    0x8(%ebp),%eax
f0109129:	8b 15 a8 51 96 f1    	mov    0xf19651a8,%edx
f010912f:	29 d0                	sub    %edx,%eax
f0109131:	c1 f8 02             	sar    $0x2,%eax
f0109134:	89 c2                	mov    %eax,%edx
f0109136:	89 d0                	mov    %edx,%eax
f0109138:	c1 e0 03             	shl    $0x3,%eax
f010913b:	01 d0                	add    %edx,%eax
f010913d:	c1 e0 03             	shl    $0x3,%eax
f0109140:	01 d0                	add    %edx,%eax
f0109142:	c1 e0 03             	shl    $0x3,%eax
f0109145:	01 d0                	add    %edx,%eax
f0109147:	c1 e0 03             	shl    $0x3,%eax
f010914a:	01 d0                	add    %edx,%eax
f010914c:	89 c1                	mov    %eax,%ecx
f010914e:	c1 e1 0f             	shl    $0xf,%ecx
f0109151:	01 c8                	add    %ecx,%eax
f0109153:	c1 e0 03             	shl    $0x3,%eax
f0109156:	01 d0                	add    %edx,%eax
f0109158:	f7 d8                	neg    %eax
}
f010915a:	5d                   	pop    %ebp
f010915b:	c3                   	ret    

f010915c <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010915c:	55                   	push   %ebp
f010915d:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010915f:	ff 75 08             	pushl  0x8(%ebp)
f0109162:	e8 bc ff ff ff       	call   f0109123 <to_frame_number>
f0109167:	83 c4 04             	add    $0x4,%esp
f010916a:	c1 e0 0c             	shl    $0xc,%eax
}
f010916d:	c9                   	leave  
f010916e:	c3                   	ret    

f010916f <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010916f:	55                   	push   %ebp
f0109170:	89 e5                	mov    %esp,%ebp
f0109172:	53                   	push   %ebx
f0109173:	83 ec 04             	sub    $0x4,%esp
	if (PPN(physical_address) >= number_of_frames)
f0109176:	8b 45 08             	mov    0x8(%ebp),%eax
f0109179:	c1 e8 0c             	shr    $0xc,%eax
f010917c:	89 c2                	mov    %eax,%edx
f010917e:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0109183:	39 c2                	cmp    %eax,%edx
f0109185:	72 14                	jb     f010919b <to_frame_info+0x2c>
		panic("to_frame_info called with invalid pa");
f0109187:	83 ec 04             	sub    $0x4,%esp
f010918a:	68 a8 76 13 f0       	push   $0xf01376a8
f010918f:	6a 4e                	push   $0x4e
f0109191:	68 cd 76 13 f0       	push   $0xf01376cd
f0109196:	e8 14 7d ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f010919b:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01091a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01091a4:	c1 e8 0c             	shr    $0xc,%eax
f01091a7:	89 c2                	mov    %eax,%edx
f01091a9:	89 d0                	mov    %edx,%eax
f01091ab:	01 c0                	add    %eax,%eax
f01091ad:	01 d0                	add    %edx,%eax
f01091af:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01091b6:	01 d8                	add    %ebx,%eax
f01091b8:	01 d0                	add    %edx,%eax
f01091ba:	01 c8                	add    %ecx,%eax
}
f01091bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01091bf:	c9                   	leave  
f01091c0:	c3                   	ret    

f01091c1 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f01091c1:	55                   	push   %ebp
f01091c2:	89 e5                	mov    %esp,%ebp
f01091c4:	83 ec 18             	sub    $0x18,%esp
	// Flush the entry only if we're modifying the current address space.
	/*2025*/ //check is added
	struct Env* e = get_cpu_proc();
f01091c7:	e8 7c 44 00 00       	call   f010d648 <get_cpu_proc>
f01091cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!e || e->env_page_directory == ptr_page_directory)
f01091cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01091d3:	74 0b                	je     f01091e0 <tlb_invalidate+0x1f>
f01091d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091d8:	8b 40 64             	mov    0x64(%eax),%eax
f01091db:	3b 45 08             	cmp    0x8(%ebp),%eax
f01091de:	75 0c                	jne    f01091ec <tlb_invalidate+0x2b>
f01091e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f01091e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091e9:	0f 01 38             	invlpg (%eax)
		invlpg(virtual_address);
}
f01091ec:	90                   	nop
f01091ed:	c9                   	leave  
f01091ee:	c3                   	ret    

f01091ef <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f01091ef:	55                   	push   %ebp
f01091f0:	89 e5                	mov    %esp,%ebp
f01091f2:	56                   	push   %esi
f01091f3:	53                   	push   %ebx
f01091f4:	83 ec 20             	sub    $0x20,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f01091f7:	c7 05 60 ce 94 f1 00 	movl   $0x0,0xf194ce60
f01091fe:	00 00 00 
f0109201:	c7 05 64 ce 94 f1 00 	movl   $0x0,0xf194ce64
f0109208:	00 00 00 
f010920b:	c7 05 6c ce 94 f1 00 	movl   $0x0,0xf194ce6c
f0109212:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0109215:	c7 05 70 ce 94 f1 00 	movl   $0x0,0xf194ce70
f010921c:	00 00 00 
f010921f:	c7 05 74 ce 94 f1 00 	movl   $0x0,0xf194ce74
f0109226:	00 00 00 
f0109229:	c7 05 7c ce 94 f1 00 	movl   $0x0,0xf194ce7c
f0109230:	00 00 00 

	//Initialize the corresponding lock
	init_kspinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0109233:	83 ec 08             	sub    $0x8,%esp
f0109236:	68 e7 76 13 f0       	push   $0xf01376e7
f010923b:	68 80 ce 94 f1       	push   $0xf194ce80
f0109240:	e8 cf a2 00 00       	call   f0113514 <init_kspinlock>
f0109245:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0109248:	a1 a8 51 96 f1       	mov    0xf19651a8,%eax
f010924d:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0109253:	a1 a8 51 96 f1       	mov    0xf19651a8,%eax
f0109258:	83 c0 1c             	add    $0x1c,%eax
f010925b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0109261:	a1 a8 51 96 f1       	mov    0xf19651a8,%eax
f0109266:	83 c0 38             	add    $0x38,%eax
f0109269:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f010926f:	c7 05 b8 51 96 f1 00 	movl   $0xf0001000,0xf19651b8
f0109276:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0109279:	c7 05 04 54 96 f1 00 	movl   $0xf0002000,0xf1965404
f0109280:	20 00 f0 
	i =0;
f0109283:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f010928a:	eb 1f                	jmp    f01092ab <initialize_paging+0xbc>
	{
		ptr_zero_page[i]=0;
f010928c:	8b 15 b8 51 96 f1    	mov    0xf19651b8,%edx
f0109292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109295:	01 d0                	add    %edx,%eax
f0109297:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f010929a:	8b 15 04 54 96 f1    	mov    0xf1965404,%edx
f01092a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092a3:	01 d0                	add    %edx,%eax
f01092a5:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f01092a8:	ff 45 f4             	incl   -0xc(%ebp)
f01092ab:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01092b2:	7e d8                	jle    f010928c <initialize_paging+0x9d>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f01092b4:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01092bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092be:	05 ff ff 09 00       	add    $0x9ffff,%eax
f01092c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01092c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01092c9:	ba 00 00 00 00       	mov    $0x0,%edx
f01092ce:	f7 75 f0             	divl   -0x10(%ebp)
f01092d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01092d4:	29 d0                	sub    %edx,%eax
f01092d6:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01092d9:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f01092e0:	e9 20 01 00 00       	jmp    f0109405 <initialize_paging+0x216>
	{

		initialize_frame_info(&(frames_info[i]));
f01092e5:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01092eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01092ee:	89 d0                	mov    %edx,%eax
f01092f0:	01 c0                	add    %eax,%eax
f01092f2:	01 d0                	add    %edx,%eax
f01092f4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01092fb:	01 d8                	add    %ebx,%eax
f01092fd:	01 d0                	add    %edx,%eax
f01092ff:	01 c8                	add    %ecx,%eax
f0109301:	83 ec 0c             	sub    $0xc,%esp
f0109304:	50                   	push   %eax
f0109305:	e8 31 03 00 00       	call   f010963b <initialize_frame_info>
f010930a:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f010930d:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f0109313:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109316:	89 d0                	mov    %edx,%eax
f0109318:	01 c0                	add    %eax,%eax
f010931a:	01 d0                	add    %edx,%eax
f010931c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0109323:	01 d8                	add    %ebx,%eax
f0109325:	01 d0                	add    %edx,%eax
f0109327:	01 c8                	add    %ecx,%eax
f0109329:	85 c0                	test   %eax,%eax
f010932b:	75 14                	jne    f0109341 <initialize_paging+0x152>
f010932d:	83 ec 04             	sub    $0x4,%esp
f0109330:	68 f8 76 13 f0       	push   $0xf01376f8
f0109335:	6a 62                	push   $0x62
f0109337:	68 1b 77 13 f0       	push   $0xf013771b
f010933c:	e8 6e 7b ff ff       	call   f0100eaf <_panic>
f0109341:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f0109347:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010934a:	89 d0                	mov    %edx,%eax
f010934c:	01 c0                	add    %eax,%eax
f010934e:	01 d0                	add    %edx,%eax
f0109350:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0109357:	01 d8                	add    %ebx,%eax
f0109359:	01 d0                	add    %edx,%eax
f010935b:	01 c8                	add    %ecx,%eax
f010935d:	8b 15 60 ce 94 f1    	mov    0xf194ce60,%edx
f0109363:	89 10                	mov    %edx,(%eax)
f0109365:	8b 00                	mov    (%eax),%eax
f0109367:	85 c0                	test   %eax,%eax
f0109369:	74 27                	je     f0109392 <initialize_paging+0x1a3>
f010936b:	8b 0d 60 ce 94 f1    	mov    0xf194ce60,%ecx
f0109371:	8b 1d a8 51 96 f1    	mov    0xf19651a8,%ebx
f0109377:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010937a:	89 d0                	mov    %edx,%eax
f010937c:	01 c0                	add    %eax,%eax
f010937e:	01 d0                	add    %edx,%eax
f0109380:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f0109387:	01 f0                	add    %esi,%eax
f0109389:	01 d0                	add    %edx,%eax
f010938b:	01 d8                	add    %ebx,%eax
f010938d:	89 41 04             	mov    %eax,0x4(%ecx)
f0109390:	eb 21                	jmp    f01093b3 <initialize_paging+0x1c4>
f0109392:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f0109398:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010939b:	89 d0                	mov    %edx,%eax
f010939d:	01 c0                	add    %eax,%eax
f010939f:	01 d0                	add    %edx,%eax
f01093a1:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01093a8:	01 d8                	add    %ebx,%eax
f01093aa:	01 d0                	add    %edx,%eax
f01093ac:	01 c8                	add    %ecx,%eax
f01093ae:	a3 64 ce 94 f1       	mov    %eax,0xf194ce64
f01093b3:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01093b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01093bc:	89 d0                	mov    %edx,%eax
f01093be:	01 c0                	add    %eax,%eax
f01093c0:	01 d0                	add    %edx,%eax
f01093c2:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01093c9:	01 d8                	add    %ebx,%eax
f01093cb:	01 d0                	add    %edx,%eax
f01093cd:	01 c8                	add    %ecx,%eax
f01093cf:	a3 60 ce 94 f1       	mov    %eax,0xf194ce60
f01093d4:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01093da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01093dd:	89 d0                	mov    %edx,%eax
f01093df:	01 c0                	add    %eax,%eax
f01093e1:	01 d0                	add    %edx,%eax
f01093e3:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01093ea:	01 d8                	add    %ebx,%eax
f01093ec:	01 d0                	add    %edx,%eax
f01093ee:	01 c8                	add    %ecx,%eax
f01093f0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01093f7:	a1 6c ce 94 f1       	mov    0xf194ce6c,%eax
f01093fc:	40                   	inc    %eax
f01093fd:	a3 6c ce 94 f1       	mov    %eax,0xf194ce6c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0109402:	ff 45 f4             	incl   -0xc(%ebp)
f0109405:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109408:	85 c0                	test   %eax,%eax
f010940a:	79 05                	jns    f0109411 <initialize_paging+0x222>
f010940c:	05 ff 0f 00 00       	add    $0xfff,%eax
f0109411:	c1 f8 0c             	sar    $0xc,%eax
f0109414:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109417:	0f 8f c8 fe ff ff    	jg     f01092e5 <initialize_paging+0xf6>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f010941d:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0109424:	eb 25                	jmp    f010944b <initialize_paging+0x25c>
	{
		frames_info[i].references = 1;
f0109426:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f010942c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010942f:	89 d0                	mov    %edx,%eax
f0109431:	01 c0                	add    %eax,%eax
f0109433:	01 d0                	add    %edx,%eax
f0109435:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010943c:	01 d8                	add    %ebx,%eax
f010943e:	01 d0                	add    %edx,%eax
f0109440:	01 c8                	add    %ecx,%eax
f0109442:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0109448:	ff 45 f4             	incl   -0xc(%ebp)
f010944b:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0109452:	7e d2                	jle    f0109426 <initialize_paging+0x237>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0109454:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f010945b:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0109460:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109463:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f010946a:	77 14                	ja     f0109480 <initialize_paging+0x291>
f010946c:	ff 75 e0             	pushl  -0x20(%ebp)
f010946f:	68 38 77 13 f0       	push   $0xf0137738
f0109474:	6a 6a                	push   $0x6a
f0109476:	68 1b 77 13 f0       	push   $0xf013771b
f010947b:	e8 2f 7a ff ff       	call   f0100eaf <_panic>
f0109480:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109483:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0109489:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010948c:	01 d0                	add    %edx,%eax
f010948e:	48                   	dec    %eax
f010948f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109492:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109495:	ba 00 00 00 00       	mov    $0x0,%edx
f010949a:	f7 75 e4             	divl   -0x1c(%ebp)
f010949d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01094a0:	29 d0                	sub    %edx,%eax
f01094a2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f01094a5:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f01094ac:	eb 25                	jmp    f01094d3 <initialize_paging+0x2e4>
	{
		frames_info[i].references = 1;
f01094ae:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01094b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01094b7:	89 d0                	mov    %edx,%eax
f01094b9:	01 c0                	add    %eax,%eax
f01094bb:	01 d0                	add    %edx,%eax
f01094bd:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01094c4:	01 d8                	add    %ebx,%eax
f01094c6:	01 d0                	add    %edx,%eax
f01094c8:	01 c8                	add    %ecx,%eax
f01094ca:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f01094d0:	ff 45 f4             	incl   -0xc(%ebp)
f01094d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01094d6:	85 c0                	test   %eax,%eax
f01094d8:	79 05                	jns    f01094df <initialize_paging+0x2f0>
f01094da:	05 ff 0f 00 00       	add    $0xfff,%eax
f01094df:	c1 f8 0c             	sar    $0xc,%eax
f01094e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01094e5:	7f c7                	jg     f01094ae <initialize_paging+0x2bf>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01094e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01094ea:	85 c0                	test   %eax,%eax
f01094ec:	79 05                	jns    f01094f3 <initialize_paging+0x304>
f01094ee:	05 ff 0f 00 00       	add    $0xfff,%eax
f01094f3:	c1 f8 0c             	sar    $0xc,%eax
f01094f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01094f9:	e9 20 01 00 00       	jmp    f010961e <initialize_paging+0x42f>
	{
		initialize_frame_info(&(frames_info[i]));
f01094fe:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f0109504:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109507:	89 d0                	mov    %edx,%eax
f0109509:	01 c0                	add    %eax,%eax
f010950b:	01 d0                	add    %edx,%eax
f010950d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0109514:	01 d8                	add    %ebx,%eax
f0109516:	01 d0                	add    %edx,%eax
f0109518:	01 c8                	add    %ecx,%eax
f010951a:	83 ec 0c             	sub    $0xc,%esp
f010951d:	50                   	push   %eax
f010951e:	e8 18 01 00 00       	call   f010963b <initialize_frame_info>
f0109523:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0109526:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f010952c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010952f:	89 d0                	mov    %edx,%eax
f0109531:	01 c0                	add    %eax,%eax
f0109533:	01 d0                	add    %edx,%eax
f0109535:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010953c:	01 d8                	add    %ebx,%eax
f010953e:	01 d0                	add    %edx,%eax
f0109540:	01 c8                	add    %ecx,%eax
f0109542:	85 c0                	test   %eax,%eax
f0109544:	75 14                	jne    f010955a <initialize_paging+0x36b>
f0109546:	83 ec 04             	sub    $0x4,%esp
f0109549:	68 f8 76 13 f0       	push   $0xf01376f8
f010954e:	6a 76                	push   $0x76
f0109550:	68 1b 77 13 f0       	push   $0xf013771b
f0109555:	e8 55 79 ff ff       	call   f0100eaf <_panic>
f010955a:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f0109560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109563:	89 d0                	mov    %edx,%eax
f0109565:	01 c0                	add    %eax,%eax
f0109567:	01 d0                	add    %edx,%eax
f0109569:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0109570:	01 d8                	add    %ebx,%eax
f0109572:	01 d0                	add    %edx,%eax
f0109574:	01 c8                	add    %ecx,%eax
f0109576:	8b 15 60 ce 94 f1    	mov    0xf194ce60,%edx
f010957c:	89 10                	mov    %edx,(%eax)
f010957e:	8b 00                	mov    (%eax),%eax
f0109580:	85 c0                	test   %eax,%eax
f0109582:	74 27                	je     f01095ab <initialize_paging+0x3bc>
f0109584:	8b 0d 60 ce 94 f1    	mov    0xf194ce60,%ecx
f010958a:	8b 1d a8 51 96 f1    	mov    0xf19651a8,%ebx
f0109590:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109593:	89 d0                	mov    %edx,%eax
f0109595:	01 c0                	add    %eax,%eax
f0109597:	01 d0                	add    %edx,%eax
f0109599:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f01095a0:	01 f0                	add    %esi,%eax
f01095a2:	01 d0                	add    %edx,%eax
f01095a4:	01 d8                	add    %ebx,%eax
f01095a6:	89 41 04             	mov    %eax,0x4(%ecx)
f01095a9:	eb 21                	jmp    f01095cc <initialize_paging+0x3dd>
f01095ab:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01095b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01095b4:	89 d0                	mov    %edx,%eax
f01095b6:	01 c0                	add    %eax,%eax
f01095b8:	01 d0                	add    %edx,%eax
f01095ba:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01095c1:	01 d8                	add    %ebx,%eax
f01095c3:	01 d0                	add    %edx,%eax
f01095c5:	01 c8                	add    %ecx,%eax
f01095c7:	a3 64 ce 94 f1       	mov    %eax,0xf194ce64
f01095cc:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01095d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01095d5:	89 d0                	mov    %edx,%eax
f01095d7:	01 c0                	add    %eax,%eax
f01095d9:	01 d0                	add    %edx,%eax
f01095db:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01095e2:	01 d8                	add    %ebx,%eax
f01095e4:	01 d0                	add    %edx,%eax
f01095e6:	01 c8                	add    %ecx,%eax
f01095e8:	a3 60 ce 94 f1       	mov    %eax,0xf194ce60
f01095ed:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f01095f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01095f6:	89 d0                	mov    %edx,%eax
f01095f8:	01 c0                	add    %eax,%eax
f01095fa:	01 d0                	add    %edx,%eax
f01095fc:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0109603:	01 d8                	add    %ebx,%eax
f0109605:	01 d0                	add    %edx,%eax
f0109607:	01 c8                	add    %ecx,%eax
f0109609:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109610:	a1 6c ce 94 f1       	mov    0xf194ce6c,%eax
f0109615:	40                   	inc    %eax
f0109616:	a3 6c ce 94 f1       	mov    %eax,0xf194ce6c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010961b:	ff 45 f4             	incl   -0xc(%ebp)
f010961e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109621:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0109626:	39 c2                	cmp    %eax,%edx
f0109628:	0f 82 d0 fe ff ff    	jb     f01094fe <initialize_paging+0x30f>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010962e:	e8 fd b5 ff ff       	call   f0104c30 <initialize_disk_page_file>
}
f0109633:	90                   	nop
f0109634:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109637:	5b                   	pop    %ebx
f0109638:	5e                   	pop    %esi
f0109639:	5d                   	pop    %ebp
f010963a:	c3                   	ret    

f010963b <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f010963b:	55                   	push   %ebp
f010963c:	89 e5                	mov    %esp,%ebp
f010963e:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0109641:	83 ec 04             	sub    $0x4,%esp
f0109644:	6a 1c                	push   $0x1c
f0109646:	6a 00                	push   $0x0
f0109648:	ff 75 08             	pushl  0x8(%ebp)
f010964b:	e8 cd 99 01 00       	call   f012301d <memset>
f0109650:	83 c4 10             	add    $0x10,%esp
}
f0109653:	90                   	nop
f0109654:	c9                   	leave  
f0109655:	c3                   	ret    

f0109656 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0109656:	55                   	push   %ebp
f0109657:	89 e5                	mov    %esp,%ebp
f0109659:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f010965c:	83 ec 0c             	sub    $0xc,%esp
f010965f:	68 80 ce 94 f1       	push   $0xf194ce80
f0109664:	e8 31 a1 00 00       	call   f011379a <holding_kspinlock>
f0109669:	83 c4 10             	add    $0x10,%esp
f010966c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010966f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109673:	75 10                	jne    f0109685 <allocate_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109675:	83 ec 0c             	sub    $0xc,%esp
f0109678:	68 80 ce 94 f1       	push   $0xf194ce80
f010967d:	e8 c3 9e 00 00       	call   f0113545 <acquire_kspinlock>
f0109682:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0109685:	8b 15 60 ce 94 f1    	mov    0xf194ce60,%edx
f010968b:	8b 45 08             	mov    0x8(%ebp),%eax
f010968e:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0109690:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (*ptr_frame_info == NULL)
f0109697:	8b 45 08             	mov    0x8(%ebp),%eax
f010969a:	8b 00                	mov    (%eax),%eax
f010969c:	85 c0                	test   %eax,%eax
f010969e:	75 17                	jne    f01096b7 <allocate_frame+0x61>
	{
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01096a0:	83 ec 04             	sub    $0x4,%esp
f01096a3:	68 6c 77 13 f0       	push   $0xf013776c
f01096a8:	68 a2 00 00 00       	push   $0xa2
f01096ad:	68 1b 77 13 f0       	push   $0xf013771b
f01096b2:	e8 f8 77 ff ff       	call   f0100eaf <_panic>
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01096b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01096ba:	8b 00                	mov    (%eax),%eax
f01096bc:	85 c0                	test   %eax,%eax
f01096be:	75 17                	jne    f01096d7 <allocate_frame+0x81>
f01096c0:	83 ec 04             	sub    $0x4,%esp
f01096c3:	68 b9 77 13 f0       	push   $0xf01377b9
f01096c8:	68 a5 00 00 00       	push   $0xa5
f01096cd:	68 1b 77 13 f0       	push   $0xf013771b
f01096d2:	e8 d8 77 ff ff       	call   f0100eaf <_panic>
f01096d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01096da:	8b 00                	mov    (%eax),%eax
f01096dc:	8b 00                	mov    (%eax),%eax
f01096de:	85 c0                	test   %eax,%eax
f01096e0:	74 14                	je     f01096f6 <allocate_frame+0xa0>
f01096e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01096e5:	8b 00                	mov    (%eax),%eax
f01096e7:	8b 00                	mov    (%eax),%eax
f01096e9:	8b 55 08             	mov    0x8(%ebp),%edx
f01096ec:	8b 12                	mov    (%edx),%edx
f01096ee:	8b 52 04             	mov    0x4(%edx),%edx
f01096f1:	89 50 04             	mov    %edx,0x4(%eax)
f01096f4:	eb 0d                	jmp    f0109703 <allocate_frame+0xad>
f01096f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01096f9:	8b 00                	mov    (%eax),%eax
f01096fb:	8b 40 04             	mov    0x4(%eax),%eax
f01096fe:	a3 64 ce 94 f1       	mov    %eax,0xf194ce64
f0109703:	8b 45 08             	mov    0x8(%ebp),%eax
f0109706:	8b 00                	mov    (%eax),%eax
f0109708:	8b 40 04             	mov    0x4(%eax),%eax
f010970b:	85 c0                	test   %eax,%eax
f010970d:	74 13                	je     f0109722 <allocate_frame+0xcc>
f010970f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109712:	8b 00                	mov    (%eax),%eax
f0109714:	8b 40 04             	mov    0x4(%eax),%eax
f0109717:	8b 55 08             	mov    0x8(%ebp),%edx
f010971a:	8b 12                	mov    (%edx),%edx
f010971c:	8b 12                	mov    (%edx),%edx
f010971e:	89 10                	mov    %edx,(%eax)
f0109720:	eb 0c                	jmp    f010972e <allocate_frame+0xd8>
f0109722:	8b 45 08             	mov    0x8(%ebp),%eax
f0109725:	8b 00                	mov    (%eax),%eax
f0109727:	8b 00                	mov    (%eax),%eax
f0109729:	a3 60 ce 94 f1       	mov    %eax,0xf194ce60
f010972e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109731:	8b 00                	mov    (%eax),%eax
f0109733:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109739:	8b 45 08             	mov    0x8(%ebp),%eax
f010973c:	8b 00                	mov    (%eax),%eax
f010973e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109745:	a1 6c ce 94 f1       	mov    0xf194ce6c,%eax
f010974a:	48                   	dec    %eax
f010974b:	a3 6c ce 94 f1       	mov    %eax,0xf194ce6c
	}

	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0109750:	8b 45 08             	mov    0x8(%ebp),%eax
f0109753:	8b 00                	mov    (%eax),%eax
f0109755:	83 ec 0c             	sub    $0xc,%esp
f0109758:	50                   	push   %eax
f0109759:	e8 dd fe ff ff       	call   f010963b <initialize_frame_info>
f010975e:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0109761:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109765:	75 10                	jne    f0109777 <allocate_frame+0x121>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109767:	83 ec 0c             	sub    $0xc,%esp
f010976a:	68 80 ce 94 f1       	push   $0xf194ce80
f010976f:	e8 76 9e 00 00       	call   f01135ea <release_kspinlock>
f0109774:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0109777:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010977c:	c9                   	leave  
f010977d:	c3                   	ret    

f010977e <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f010977e:	55                   	push   %ebp
f010977f:	89 e5                	mov    %esp,%ebp
f0109781:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109784:	83 ec 0c             	sub    $0xc,%esp
f0109787:	68 80 ce 94 f1       	push   $0xf194ce80
f010978c:	e8 09 a0 00 00       	call   f011379a <holding_kspinlock>
f0109791:	83 c4 10             	add    $0x10,%esp
f0109794:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0109797:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010979b:	75 10                	jne    f01097ad <free_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010979d:	83 ec 0c             	sub    $0xc,%esp
f01097a0:	68 80 ce 94 f1       	push   $0xf194ce80
f01097a5:	e8 9b 9d 00 00       	call   f0113545 <acquire_kspinlock>
f01097aa:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f01097ad:	83 ec 0c             	sub    $0xc,%esp
f01097b0:	ff 75 08             	pushl  0x8(%ebp)
f01097b3:	e8 83 fe ff ff       	call   f010963b <initialize_frame_info>
f01097b8:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f01097bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01097bf:	75 17                	jne    f01097d8 <free_frame+0x5a>
f01097c1:	83 ec 04             	sub    $0x4,%esp
f01097c4:	68 f8 76 13 f0       	push   $0xf01376f8
f01097c9:	68 ce 00 00 00       	push   $0xce
f01097ce:	68 1b 77 13 f0       	push   $0xf013771b
f01097d3:	e8 d7 76 ff ff       	call   f0100eaf <_panic>
f01097d8:	8b 15 60 ce 94 f1    	mov    0xf194ce60,%edx
f01097de:	8b 45 08             	mov    0x8(%ebp),%eax
f01097e1:	89 10                	mov    %edx,(%eax)
f01097e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01097e6:	8b 00                	mov    (%eax),%eax
f01097e8:	85 c0                	test   %eax,%eax
f01097ea:	74 0d                	je     f01097f9 <free_frame+0x7b>
f01097ec:	a1 60 ce 94 f1       	mov    0xf194ce60,%eax
f01097f1:	8b 55 08             	mov    0x8(%ebp),%edx
f01097f4:	89 50 04             	mov    %edx,0x4(%eax)
f01097f7:	eb 08                	jmp    f0109801 <free_frame+0x83>
f01097f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01097fc:	a3 64 ce 94 f1       	mov    %eax,0xf194ce64
f0109801:	8b 45 08             	mov    0x8(%ebp),%eax
f0109804:	a3 60 ce 94 f1       	mov    %eax,0xf194ce60
f0109809:	8b 45 08             	mov    0x8(%ebp),%eax
f010980c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109813:	a1 6c ce 94 f1       	mov    0xf194ce6c,%eax
f0109818:	40                   	inc    %eax
f0109819:	a3 6c ce 94 f1       	mov    %eax,0xf194ce6c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f010981e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109822:	75 10                	jne    f0109834 <free_frame+0xb6>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109824:	83 ec 0c             	sub    $0xc,%esp
f0109827:	68 80 ce 94 f1       	push   $0xf194ce80
f010982c:	e8 b9 9d 00 00       	call   f01135ea <release_kspinlock>
f0109831:	83 c4 10             	add    $0x10,%esp
	}
}
f0109834:	90                   	nop
f0109835:	c9                   	leave  
f0109836:	c3                   	ret    

f0109837 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0109837:	55                   	push   %ebp
f0109838:	89 e5                	mov    %esp,%ebp
f010983a:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f010983d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109840:	8b 40 08             	mov    0x8(%eax),%eax
f0109843:	48                   	dec    %eax
f0109844:	8b 55 08             	mov    0x8(%ebp),%edx
f0109847:	66 89 42 08          	mov    %ax,0x8(%edx)
f010984b:	8b 45 08             	mov    0x8(%ebp),%eax
f010984e:	8b 40 08             	mov    0x8(%eax),%eax
f0109851:	66 85 c0             	test   %ax,%ax
f0109854:	75 0e                	jne    f0109864 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0109856:	83 ec 0c             	sub    $0xc,%esp
f0109859:	ff 75 08             	pushl  0x8(%ebp)
f010985c:	e8 1d ff ff ff       	call   f010977e <free_frame>
f0109861:	83 c4 10             	add    $0x10,%esp
}
f0109864:	90                   	nop
f0109865:	c9                   	leave  
f0109866:	c3                   	ret    

f0109867 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109867:	55                   	push   %ebp
f0109868:	89 e5                	mov    %esp,%ebp
f010986a:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010986d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109870:	c1 e8 16             	shr    $0x16,%eax
f0109873:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010987a:	8b 45 08             	mov    0x8(%ebp),%eax
f010987d:	01 d0                	add    %edx,%eax
f010987f:	8b 00                	mov    (%eax),%eax
f0109881:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0109884:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109887:	83 e0 01             	and    $0x1,%eax
f010988a:	85 c0                	test   %eax,%eax
f010988c:	74 74                	je     f0109902 <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010988e:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109895:	77 1d                	ja     f01098b4 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109897:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010989a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010989f:	83 ec 0c             	sub    $0xc,%esp
f01098a2:	50                   	push   %eax
f01098a3:	e8 78 1b 00 00       	call   f010b420 <kheap_virtual_address>
f01098a8:	83 c4 10             	add    $0x10,%esp
f01098ab:	89 c2                	mov    %eax,%edx
f01098ad:	8b 45 10             	mov    0x10(%ebp),%eax
f01098b0:	89 10                	mov    %edx,(%eax)
f01098b2:	eb 44                	jmp    f01098f8 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01098b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01098b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01098bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01098bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098c2:	c1 e8 0c             	shr    $0xc,%eax
f01098c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01098c8:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f01098cd:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01098d0:	72 17                	jb     f01098e9 <get_page_table+0x82>
f01098d2:	ff 75 f0             	pushl  -0x10(%ebp)
f01098d5:	68 d8 77 13 f0       	push   $0xf01377d8
f01098da:	68 fa 00 00 00       	push   $0xfa
f01098df:	68 1b 77 13 f0       	push   $0xf013771b
f01098e4:	e8 c6 75 ff ff       	call   f0100eaf <_panic>
f01098e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098ec:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01098f1:	89 c2                	mov    %eax,%edx
f01098f3:	8b 45 10             	mov    0x10(%ebp),%eax
f01098f6:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01098f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01098fd:	e9 b9 00 00 00       	jmp    f01099bb <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0109902:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109906:	0f 84 a1 00 00 00    	je     f01099ad <get_page_table+0x146>
f010990c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010990f:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f0109912:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109915:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0109918:	83 ec 0c             	sub    $0xc,%esp
f010991b:	6a 00                	push   $0x0
f010991d:	e8 88 7e 00 00       	call   f01117aa <fault_handler>
f0109922:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109925:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109928:	c1 e8 16             	shr    $0x16,%eax
f010992b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109932:	8b 45 08             	mov    0x8(%ebp),%eax
f0109935:	01 d0                	add    %edx,%eax
f0109937:	8b 00                	mov    (%eax),%eax
f0109939:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010993c:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109943:	77 1d                	ja     f0109962 <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109945:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109948:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010994d:	83 ec 0c             	sub    $0xc,%esp
f0109950:	50                   	push   %eax
f0109951:	e8 ca 1a 00 00       	call   f010b420 <kheap_virtual_address>
f0109956:	83 c4 10             	add    $0x10,%esp
f0109959:	89 c2                	mov    %eax,%edx
f010995b:	8b 45 10             	mov    0x10(%ebp),%eax
f010995e:	89 10                	mov    %edx,(%eax)
f0109960:	eb 44                	jmp    f01099a6 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109962:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109965:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010996a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010996d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109970:	c1 e8 0c             	shr    $0xc,%eax
f0109973:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109976:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f010997b:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010997e:	72 17                	jb     f0109997 <get_page_table+0x130>
f0109980:	ff 75 e8             	pushl  -0x18(%ebp)
f0109983:	68 d8 77 13 f0       	push   $0xf01377d8
f0109988:	68 12 01 00 00       	push   $0x112
f010998d:	68 1b 77 13 f0       	push   $0xf013771b
f0109992:	e8 18 75 ff ff       	call   f0100eaf <_panic>
f0109997:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010999a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010999f:	89 c2                	mov    %eax,%edx
f01099a1:	8b 45 10             	mov    0x10(%ebp),%eax
f01099a4:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01099a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01099ab:	eb 0e                	jmp    f01099bb <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f01099ad:	8b 45 10             	mov    0x10(%ebp),%eax
f01099b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01099b6:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01099bb:	c9                   	leave  
f01099bc:	c3                   	ret    

f01099bd <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01099bd:	55                   	push   %ebp
f01099be:	89 e5                	mov    %esp,%ebp
f01099c0:	53                   	push   %ebx
f01099c1:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f01099c4:	83 ec 0c             	sub    $0xc,%esp
f01099c7:	68 00 10 00 00       	push   $0x1000
f01099cc:	e8 01 15 00 00       	call   f010aed2 <kmalloc>
f01099d1:	83 c4 10             	add    $0x10,%esp
f01099d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f01099d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01099db:	75 17                	jne    f01099f4 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f01099dd:	83 ec 04             	sub    $0x4,%esp
f01099e0:	68 07 78 13 f0       	push   $0xf0137807
f01099e5:	68 32 01 00 00       	push   $0x132
f01099ea:	68 1b 77 13 f0       	push   $0xf013771b
f01099ef:	e8 bb 74 ff ff       	call   f0100eaf <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01099f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01099f7:	c1 e8 16             	shr    $0x16,%eax
f01099fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109a01:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a04:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f0109a07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109a0a:	83 ec 0c             	sub    $0xc,%esp
f0109a0d:	50                   	push   %eax
f0109a0e:	e8 79 1a 00 00       	call   f010b48c <kheap_physical_address>
f0109a13:	83 c4 10             	add    $0x10,%esp
f0109a16:	83 c8 07             	or     $0x7,%eax
f0109a19:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0109a1b:	83 ec 04             	sub    $0x4,%esp
f0109a1e:	68 00 10 00 00       	push   $0x1000
f0109a23:	6a 00                	push   $0x0
f0109a25:	ff 75 f4             	pushl  -0xc(%ebp)
f0109a28:	e8 f0 95 01 00       	call   f012301d <memset>
f0109a2d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109a30:	0f 20 d8             	mov    %cr3,%eax
f0109a33:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109a36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a39:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0109a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109a3f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109a42:	c9                   	leave  
f0109a43:	c3                   	ret    

f0109a44 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109a44:	55                   	push   %ebp
f0109a45:	89 e5                	mov    %esp,%ebp
f0109a47:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0109a4a:	83 ec 0c             	sub    $0xc,%esp
f0109a4d:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0109a50:	50                   	push   %eax
f0109a51:	e8 00 fc ff ff       	call   f0109656 <allocate_frame>
f0109a56:	83 c4 10             	add    $0x10,%esp
f0109a59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0109a5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a5f:	83 ec 0c             	sub    $0xc,%esp
f0109a62:	50                   	push   %eax
f0109a63:	e8 f4 f6 ff ff       	call   f010915c <to_physical_address>
f0109a68:	83 c4 10             	add    $0x10,%esp
f0109a6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0109a6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a71:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109a74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109a77:	c1 e8 0c             	shr    $0xc,%eax
f0109a7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109a7d:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0109a82:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0109a85:	72 17                	jb     f0109a9e <__static_cpt+0x5a>
f0109a87:	ff 75 ec             	pushl  -0x14(%ebp)
f0109a8a:	68 d8 77 13 f0       	push   $0xf01377d8
f0109a8f:	68 4d 01 00 00       	push   $0x14d
f0109a94:	68 1b 77 13 f0       	push   $0xf013771b
f0109a99:	e8 11 74 ff ff       	call   f0100eaf <_panic>
f0109a9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109aa1:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109aa6:	89 c2                	mov    %eax,%edx
f0109aa8:	8b 45 10             	mov    0x10(%ebp),%eax
f0109aab:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0109aad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ab0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0109ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ab9:	c1 e8 16             	shr    $0x16,%eax
f0109abc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109ac3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ac6:	01 d0                	add    %edx,%eax
f0109ac8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109acb:	83 ca 07             	or     $0x7,%edx
f0109ace:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0109ad0:	8b 45 10             	mov    0x10(%ebp),%eax
f0109ad3:	8b 00                	mov    (%eax),%eax
f0109ad5:	83 ec 04             	sub    $0x4,%esp
f0109ad8:	68 00 10 00 00       	push   $0x1000
f0109add:	6a 00                	push   $0x0
f0109adf:	50                   	push   %eax
f0109ae0:	e8 38 95 01 00       	call   f012301d <memset>
f0109ae5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109ae8:	0f 20 d8             	mov    %cr3,%eax
f0109aeb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109aee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109af1:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109af4:	90                   	nop
f0109af5:	c9                   	leave  
f0109af6:	c3                   	ret    

f0109af7 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0109af7:	55                   	push   %ebp
f0109af8:	89 e5                	mov    %esp,%ebp
f0109afa:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0109afd:	ff 75 0c             	pushl  0xc(%ebp)
f0109b00:	e8 57 f6 ff ff       	call   f010915c <to_physical_address>
f0109b05:	83 c4 04             	add    $0x4,%esp
f0109b08:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_frame_info->va = virtual_address;
f0109b0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109b0e:	8b 55 10             	mov    0x10(%ebp),%edx
f0109b11:	89 50 10             	mov    %edx,0x10(%eax)
	uint32 *ptr_page_table;

	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0109b14:	83 ec 04             	sub    $0x4,%esp
f0109b17:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0109b1a:	50                   	push   %eax
f0109b1b:	ff 75 10             	pushl  0x10(%ebp)
f0109b1e:	ff 75 08             	pushl  0x8(%ebp)
f0109b21:	e8 41 fd ff ff       	call   f0109867 <get_page_table>
f0109b26:	83 c4 10             	add    $0x10,%esp
f0109b29:	83 f8 01             	cmp    $0x1,%eax
f0109b2c:	75 1b                	jne    f0109b49 <map_frame+0x52>
		//page_directory_entry = ptr_page_directory[PDX(virtual_address)];
		//ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
		=============================================================================================*/
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0109b2e:	83 ec 08             	sub    $0x8,%esp
f0109b31:	ff 75 10             	pushl  0x10(%ebp)
f0109b34:	ff 75 08             	pushl  0x8(%ebp)
f0109b37:	e8 81 fe ff ff       	call   f01099bd <create_page_table>
f0109b3c:	83 c4 10             	add    $0x10,%esp
f0109b3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0109b42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f0109b49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109b4c:	8b 55 10             	mov    0x10(%ebp),%edx
f0109b4f:	c1 ea 0c             	shr    $0xc,%edx
f0109b52:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109b58:	c1 e2 02             	shl    $0x2,%edx
f0109b5b:	01 d0                	add    %edx,%eax
f0109b5d:	8b 00                	mov    (%eax),%eax
f0109b5f:	89 45 ec             	mov    %eax,-0x14(%ebp)

	}*/

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0109b62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109b65:	83 e0 01             	and    $0x1,%eax
f0109b68:	85 c0                	test   %eax,%eax
f0109b6a:	74 25                	je     f0109b91 <map_frame+0x9a>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0109b6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109b6f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b74:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109b77:	75 07                	jne    f0109b80 <map_frame+0x89>
			return 0;
f0109b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0109b7e:	eb 68                	jmp    f0109be8 <map_frame+0xf1>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0109b80:	83 ec 08             	sub    $0x8,%esp
f0109b83:	ff 75 10             	pushl  0x10(%ebp)
f0109b86:	ff 75 08             	pushl  0x8(%ebp)
f0109b89:	e8 de 00 00 00       	call   f0109c6c <unmap_frame>
f0109b8e:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0109b91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109b94:	8b 40 08             	mov    0x8(%eax),%eax
f0109b97:	40                   	inc    %eax
f0109b98:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109b9b:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0109b9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109ba2:	8b 55 10             	mov    0x10(%ebp),%edx
f0109ba5:	c1 ea 0c             	shr    $0xc,%edx
f0109ba8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109bae:	c1 e2 02             	shl    $0x2,%edx
f0109bb1:	01 d0                	add    %edx,%eax
f0109bb3:	8b 00                	mov    (%eax),%eax
f0109bb5:	25 00 0e 00 00       	and    $0xe00,%eax
f0109bba:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f0109bbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109bc0:	8b 55 10             	mov    0x10(%ebp),%edx
f0109bc3:	c1 ea 0c             	shr    $0xc,%edx
f0109bc6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109bcc:	c1 e2 02             	shl    $0x2,%edx
f0109bcf:	01 c2                	add    %eax,%edx
f0109bd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109bd4:	0b 45 e8             	or     -0x18(%ebp),%eax
f0109bd7:	89 c1                	mov    %eax,%ecx
f0109bd9:	8b 45 14             	mov    0x14(%ebp),%eax
f0109bdc:	09 c8                	or     %ecx,%eax
f0109bde:	83 c8 01             	or     $0x1,%eax
f0109be1:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0109be3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109be8:	c9                   	leave  
f0109be9:	c3                   	ret    

f0109bea <get_frame_info>:
//	2. buffered to 'virtual_address'
// If the page table entry corresponding to 'virtual_address' exists, then we store a pointer to the table in 'ptr_page_table'
// Return 0 if there is no frame mapped/buffered at virtual_address.
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0109bea:	55                   	push   %ebp
f0109beb:	89 e5                	mov    %esp,%ebp
f0109bed:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0109bf0:	83 ec 04             	sub    $0x4,%esp
f0109bf3:	ff 75 10             	pushl  0x10(%ebp)
f0109bf6:	ff 75 0c             	pushl  0xc(%ebp)
f0109bf9:	ff 75 08             	pushl  0x8(%ebp)
f0109bfc:	e8 66 fc ff ff       	call   f0109867 <get_page_table>
f0109c01:	83 c4 10             	add    $0x10,%esp
f0109c04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if((*ptr_page_table) != 0)
f0109c07:	8b 45 10             	mov    0x10(%ebp),%eax
f0109c0a:	8b 00                	mov    (%eax),%eax
f0109c0c:	85 c0                	test   %eax,%eax
f0109c0e:	74 55                	je     f0109c65 <get_frame_info+0x7b>
	{
		uint32 index_page_table = PTX(virtual_address);
f0109c10:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c13:	c1 e8 0c             	shr    $0xc,%eax
f0109c16:	25 ff 03 00 00       	and    $0x3ff,%eax
f0109c1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0109c1e:	8b 45 10             	mov    0x10(%ebp),%eax
f0109c21:	8b 00                	mov    (%eax),%eax
f0109c23:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109c26:	c1 e2 02             	shl    $0x2,%edx
f0109c29:	01 d0                	add    %edx,%eax
f0109c2b:	8b 00                	mov    (%eax),%eax
f0109c2d:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		/*2025 el7:)*///or if it's 0, make sure it's either present or buffered
		//if( page_table_entry != 0)
		//if((page_table_entry & ~0xFFF) != 0)
		if( ((page_table_entry & ~0xFFF) != 0) || ((page_table_entry & (PERM_PRESENT|PERM_BUFFERED)) != 0))
f0109c30:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c33:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109c38:	85 c0                	test   %eax,%eax
f0109c3a:	75 0c                	jne    f0109c48 <get_frame_info+0x5e>
f0109c3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c3f:	25 01 02 00 00       	and    $0x201,%eax
f0109c44:	85 c0                	test   %eax,%eax
f0109c46:	74 16                	je     f0109c5e <get_frame_info+0x74>
		{
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0109c48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c4b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109c50:	83 ec 0c             	sub    $0xc,%esp
f0109c53:	50                   	push   %eax
f0109c54:	e8 16 f5 ff ff       	call   f010916f <to_frame_info>
f0109c59:	83 c4 10             	add    $0x10,%esp
f0109c5c:	eb 0c                	jmp    f0109c6a <get_frame_info+0x80>
		}
		return 0;
f0109c5e:	b8 00 00 00 00       	mov    $0x0,%eax
f0109c63:	eb 05                	jmp    f0109c6a <get_frame_info+0x80>
	}
	return 0;
f0109c65:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109c6a:	c9                   	leave  
f0109c6b:	c3                   	ret    

f0109c6c <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0109c6c:	55                   	push   %ebp
f0109c6d:	89 e5                	mov    %esp,%ebp
f0109c6f:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0109c72:	83 ec 04             	sub    $0x4,%esp
f0109c75:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0109c78:	50                   	push   %eax
f0109c79:	ff 75 0c             	pushl  0xc(%ebp)
f0109c7c:	ff 75 08             	pushl  0x8(%ebp)
f0109c7f:	e8 66 ff ff ff       	call   f0109bea <get_frame_info>
f0109c84:	83 c4 10             	add    $0x10,%esp
f0109c87:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0109c8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109c8e:	74 7d                	je     f0109d0d <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0109c90:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109c93:	8a 40 18             	mov    0x18(%eax),%al
f0109c96:	84 c0                	test   %al,%al
f0109c98:	74 1c                	je     f0109cb6 <unmap_frame+0x4a>
f0109c9a:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109ca1:	77 13                	ja     f0109cb6 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0109ca3:	83 ec 08             	sub    $0x8,%esp
f0109ca6:	ff 75 0c             	pushl  0xc(%ebp)
f0109ca9:	68 24 78 13 f0       	push   $0xf0137824
f0109cae:	e8 9a 7e ff ff       	call   f0101b4d <cprintf>
f0109cb3:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0109cb6:	83 ec 0c             	sub    $0xc,%esp
f0109cb9:	ff 75 f4             	pushl  -0xc(%ebp)
f0109cbc:	e8 76 fb ff ff       	call   f0109837 <decrement_references>
f0109cc1:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0109cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cc7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cca:	c1 ea 0c             	shr    $0xc,%edx
f0109ccd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109cd3:	c1 e2 02             	shl    $0x2,%edx
f0109cd6:	01 d0                	add    %edx,%eax
f0109cd8:	8b 00                	mov    (%eax),%eax
f0109cda:	25 00 0e 00 00       	and    $0xe00,%eax
f0109cdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0109ce2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ce5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109ce8:	c1 ea 0c             	shr    $0xc,%edx
f0109ceb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109cf1:	c1 e2 02             	shl    $0x2,%edx
f0109cf4:	01 c2                	add    %eax,%edx
f0109cf6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cf9:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0109cfb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109cfe:	83 ec 08             	sub    $0x8,%esp
f0109d01:	50                   	push   %eax
f0109d02:	ff 75 08             	pushl  0x8(%ebp)
f0109d05:	e8 b7 f4 ff ff       	call   f01091c1 <tlb_invalidate>
f0109d0a:	83 c4 10             	add    $0x10,%esp
	}
}
f0109d0d:	90                   	nop
f0109d0e:	c9                   	leave  
f0109d0f:	c3                   	ret    

f0109d10 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0109d10:	55                   	push   %ebp
f0109d11:	89 e5                	mov    %esp,%ebp
f0109d13:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0109d16:	ff 75 0c             	pushl  0xc(%ebp)
f0109d19:	e8 3e f4 ff ff       	call   f010915c <to_physical_address>
f0109d1e:	83 c4 04             	add    $0x4,%esp
f0109d21:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109d24:	8b 45 10             	mov    0x10(%ebp),%eax
f0109d27:	c1 e8 16             	shr    $0x16,%eax
f0109d2a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109d31:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d34:	01 d0                	add    %edx,%eax
f0109d36:	8b 00                	mov    (%eax),%eax
f0109d38:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0109d3b:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109d42:	77 19                	ja     f0109d5d <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109d44:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d47:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109d4c:	83 ec 0c             	sub    $0xc,%esp
f0109d4f:	50                   	push   %eax
f0109d50:	e8 cb 16 00 00       	call   f010b420 <kheap_virtual_address>
f0109d55:	83 c4 10             	add    $0x10,%esp
f0109d58:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109d5b:	eb 40                	jmp    f0109d9d <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109d5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d60:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109d65:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109d68:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109d6b:	c1 e8 0c             	shr    $0xc,%eax
f0109d6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109d71:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0109d76:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0109d79:	72 17                	jb     f0109d92 <loadtime_map_frame+0x82>
f0109d7b:	ff 75 e8             	pushl  -0x18(%ebp)
f0109d7e:	68 d8 77 13 f0       	push   $0xf01377d8
f0109d83:	68 0e 02 00 00       	push   $0x20e
f0109d88:	68 1b 77 13 f0       	push   $0xf013771b
f0109d8d:	e8 1d 71 ff ff       	call   f0100eaf <_panic>
f0109d92:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109d95:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109d9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0109d9d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109da1:	75 14                	jne    f0109db7 <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0109da3:	83 ec 08             	sub    $0x8,%esp
f0109da6:	ff 75 10             	pushl  0x10(%ebp)
f0109da9:	ff 75 08             	pushl  0x8(%ebp)
f0109dac:	e8 0c fc ff ff       	call   f01099bd <create_page_table>
f0109db1:	83 c4 10             	add    $0x10,%esp
f0109db4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f0109db7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109dba:	8b 40 08             	mov    0x8(%eax),%eax
f0109dbd:	40                   	inc    %eax
f0109dbe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109dc1:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0109dc5:	8b 45 10             	mov    0x10(%ebp),%eax
f0109dc8:	c1 e8 0c             	shr    $0xc,%eax
f0109dcb:	25 ff 03 00 00       	and    $0x3ff,%eax
f0109dd0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109dd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109dda:	01 c2                	add    %eax,%edx
f0109ddc:	8b 45 14             	mov    0x14(%ebp),%eax
f0109ddf:	0b 45 f0             	or     -0x10(%ebp),%eax
f0109de2:	83 c8 01             	or     $0x1,%eax
f0109de5:	89 02                	mov    %eax,(%edx)

	return 0;
f0109de7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109dec:	c9                   	leave  
f0109ded:	c3                   	ret    

f0109dee <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0109dee:	55                   	push   %ebp
f0109def:	89 e5                	mov    %esp,%ebp
f0109df1:	57                   	push   %edi
f0109df2:	56                   	push   %esi
f0109df3:	53                   	push   %ebx
f0109df4:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0109df7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0109dfe:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0109e05:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109e0c:	83 ec 0c             	sub    $0xc,%esp
f0109e0f:	68 80 ce 94 f1       	push   $0xf194ce80
f0109e14:	e8 81 99 00 00       	call   f011379a <holding_kspinlock>
f0109e19:	83 c4 10             	add    $0x10,%esp
f0109e1c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0109e1f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109e23:	75 10                	jne    f0109e35 <calculate_available_frames+0x47>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109e25:	83 ec 0c             	sub    $0xc,%esp
f0109e28:	68 80 ce 94 f1       	push   $0xf194ce80
f0109e2d:	e8 13 97 00 00       	call   f0113545 <acquire_kspinlock>
f0109e32:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109e35:	a1 60 ce 94 f1       	mov    0xf194ce60,%eax
f0109e3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109e3d:	eb 1a                	jmp    f0109e59 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0109e3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109e42:	8a 40 18             	mov    0x18(%eax),%al
f0109e45:	84 c0                	test   %al,%al
f0109e47:	74 05                	je     f0109e4e <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0109e49:	ff 45 dc             	incl   -0x24(%ebp)
f0109e4c:	eb 03                	jmp    f0109e51 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0109e4e:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109e51:	a1 68 ce 94 f1       	mov    0xf194ce68,%eax
f0109e56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109e59:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109e5d:	74 07                	je     f0109e66 <calculate_available_frames+0x78>
f0109e5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109e62:	8b 00                	mov    (%eax),%eax
f0109e64:	eb 05                	jmp    f0109e6b <calculate_available_frames+0x7d>
f0109e66:	b8 00 00 00 00       	mov    $0x0,%eax
f0109e6b:	a3 68 ce 94 f1       	mov    %eax,0xf194ce68
f0109e70:	a1 68 ce 94 f1       	mov    0xf194ce68,%eax
f0109e75:	85 c0                	test   %eax,%eax
f0109e77:	75 c6                	jne    f0109e3f <calculate_available_frames+0x51>
f0109e79:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109e7d:	75 c0                	jne    f0109e3f <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0109e7f:	a1 7c ce 94 f1       	mov    0xf194ce7c,%eax
f0109e84:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0109e87:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109e8b:	75 10                	jne    f0109e9d <calculate_available_frames+0xaf>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109e8d:	83 ec 0c             	sub    $0xc,%esp
f0109e90:	68 80 ce 94 f1       	push   $0xf194ce80
f0109e95:	e8 50 97 00 00       	call   f01135ea <release_kspinlock>
f0109e9a:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0109e9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109ea0:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0109ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ea6:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0109ea9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109eac:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0109eaf:	8b 45 08             	mov    0x8(%ebp),%eax
f0109eb2:	89 c3                	mov    %eax,%ebx
f0109eb4:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0109eb7:	ba 03 00 00 00       	mov    $0x3,%edx
f0109ebc:	89 df                	mov    %ebx,%edi
f0109ebe:	89 c6                	mov    %eax,%esi
f0109ec0:	89 d1                	mov    %edx,%ecx
f0109ec2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0109ec4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ec7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109eca:	5b                   	pop    %ebx
f0109ecb:	5e                   	pop    %esi
f0109ecc:	5f                   	pop    %edi
f0109ecd:	5d                   	pop    %ebp
f0109ece:	c2 04 00             	ret    $0x4

f0109ed1 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0109ed1:	55                   	push   %ebp
f0109ed2:	89 e5                	mov    %esp,%ebp
f0109ed4:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0109ed7:	c7 05 20 cd 94 f1 00 	movl   $0x0,0xf194cd20
f0109ede:	00 00 00 
f0109ee1:	c7 05 24 cd 94 f1 00 	movl   $0x0,0xf194cd24
f0109ee8:	00 00 00 
f0109eeb:	c7 05 2c cd 94 f1 00 	movl   $0x0,0xf194cd2c
f0109ef2:	00 00 00 
	init_kspinlock(&AllShares.shareslock, "shares lock");
f0109ef5:	83 ec 08             	sub    $0x8,%esp
f0109ef8:	68 54 78 13 f0       	push   $0xf0137854
f0109efd:	68 30 cd 94 f1       	push   $0xf194cd30
f0109f02:	e8 0d 96 00 00       	call   f0113514 <init_kspinlock>
f0109f07:	83 c4 10             	add    $0x10,%esp
	//init_sleeplock(&AllShares.sharessleeplock, "shares sleep lock");
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0109f0a:	90                   	nop
f0109f0b:	c9                   	leave  
f0109f0c:	c3                   	ret    

f0109f0d <find_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* find_share(int32 ownerID, char* name)
{
f0109f0d:	55                   	push   %ebp
f0109f0e:	89 e5                	mov    %esp,%ebp
f0109f10:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct Share * ret = NULL;
f0109f13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool wasHeld = holding_kspinlock(&(AllShares.shareslock));
f0109f1a:	83 ec 0c             	sub    $0xc,%esp
f0109f1d:	68 30 cd 94 f1       	push   $0xf194cd30
f0109f22:	e8 73 98 00 00       	call   f011379a <holding_kspinlock>
f0109f27:	83 c4 10             	add    $0x10,%esp
f0109f2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!wasHeld)
f0109f2d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109f31:	75 10                	jne    f0109f43 <find_share+0x36>
	{
		acquire_kspinlock(&(AllShares.shareslock));
f0109f33:	83 ec 0c             	sub    $0xc,%esp
f0109f36:	68 30 cd 94 f1       	push   $0xf194cd30
f0109f3b:	e8 05 96 00 00       	call   f0113545 <acquire_kspinlock>
f0109f40:	83 c4 10             	add    $0x10,%esp
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f0109f43:	a1 20 cd 94 f1       	mov    0xf194cd20,%eax
f0109f48:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109f4b:	eb 34                	jmp    f0109f81 <find_share+0x74>
		{
			//cprintf("shared var name = %s compared with %s\n", name, shr->name);
			if(shr->ownerID == ownerID && strcmp(name, shr->name)==0)
f0109f4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f50:	8b 40 04             	mov    0x4(%eax),%eax
f0109f53:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109f56:	75 21                	jne    f0109f79 <find_share+0x6c>
f0109f58:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f5b:	83 c0 08             	add    $0x8,%eax
f0109f5e:	83 ec 08             	sub    $0x8,%esp
f0109f61:	50                   	push   %eax
f0109f62:	ff 75 0c             	pushl  0xc(%ebp)
f0109f65:	e8 d1 8f 01 00       	call   f0122f3b <strcmp>
f0109f6a:	83 c4 10             	add    $0x10,%esp
f0109f6d:	85 c0                	test   %eax,%eax
f0109f6f:	75 08                	jne    f0109f79 <find_share+0x6c>
			{
				//cprintf("%s found\n", name);
				ret = shr;
f0109f71:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0109f77:	eb 2f                	jmp    f0109fa8 <find_share+0x9b>
	{
		acquire_kspinlock(&(AllShares.shareslock));
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f0109f79:	a1 28 cd 94 f1       	mov    0xf194cd28,%eax
f0109f7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109f81:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109f85:	74 08                	je     f0109f8f <find_share+0x82>
f0109f87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f8a:	8b 40 58             	mov    0x58(%eax),%eax
f0109f8d:	eb 05                	jmp    f0109f94 <find_share+0x87>
f0109f8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109f94:	a3 28 cd 94 f1       	mov    %eax,0xf194cd28
f0109f99:	a1 28 cd 94 f1       	mov    0xf194cd28,%eax
f0109f9e:	85 c0                	test   %eax,%eax
f0109fa0:	75 ab                	jne    f0109f4d <find_share+0x40>
f0109fa2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109fa6:	75 a5                	jne    f0109f4d <find_share+0x40>
				ret = shr;
				break;
			}
		}
	}
	if (!wasHeld)
f0109fa8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109fac:	75 10                	jne    f0109fbe <find_share+0xb1>
	{
		release_kspinlock(&(AllShares.shareslock));
f0109fae:	83 ec 0c             	sub    $0xc,%esp
f0109fb1:	68 30 cd 94 f1       	push   $0xf194cd30
f0109fb6:	e8 2f 96 00 00       	call   f01135ea <release_kspinlock>
f0109fbb:	83 c4 10             	add    $0x10,%esp
	}
	return ret;
f0109fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0109fc1:	c9                   	leave  
f0109fc2:	c3                   	ret    

f0109fc3 <size_of_shared_object>:

//==============================
// [3] Get Size of Share Object:
//==============================
int size_of_shared_object(int32 ownerID, char* shareName)
{
f0109fc3:	55                   	push   %ebp
f0109fc4:	89 e5                	mov    %esp,%ebp
f0109fc6:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = find_share(ownerID, shareName);
f0109fc9:	83 ec 08             	sub    $0x8,%esp
f0109fcc:	ff 75 0c             	pushl  0xc(%ebp)
f0109fcf:	ff 75 08             	pushl  0x8(%ebp)
f0109fd2:	e8 36 ff ff ff       	call   f0109f0d <find_share>
f0109fd7:	83 c4 10             	add    $0x10,%esp
f0109fda:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0109fdd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109fe1:	75 07                	jne    f0109fea <size_of_shared_object+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0109fe3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0109fe8:	eb 06                	jmp    f0109ff0 <size_of_shared_object+0x2d>
	else
		return ptr_share->size;
f0109fea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109fed:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0109ff0:	c9                   	leave  
f0109ff1:	c3                   	ret    

f0109ff2 <alloc_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* alloc_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0109ff2:	55                   	push   %ebp
f0109ff3:	89 e5                	mov    %esp,%ebp
f0109ff5:	83 ec 38             	sub    $0x38,%esp
f0109ff8:	8b 45 14             	mov    0x14(%ebp),%eax
f0109ffb:	88 45 d4             	mov    %al,-0x2c(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #1 alloc_share
	//Your code is here

#if USE_KHEAP
	uint32 alignedSize = size;
f0109ffe:	8b 45 10             	mov    0x10(%ebp),%eax
f010a001:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 remainder = size & (PAGE_SIZE - 1);
f010a004:	8b 45 10             	mov    0x10(%ebp),%eax
f010a007:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a00c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (remainder != 0)
f010a00f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010a013:	74 0e                	je     f010a023 <alloc_share+0x31>
	    alignedSize += (PAGE_SIZE - remainder);
f010a015:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a018:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f010a01b:	05 00 10 00 00       	add    $0x1000,%eax
f010a020:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 requiredPages = alignedSize / PAGE_SIZE;
f010a023:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a026:	c1 e8 0c             	shr    $0xc,%eax
f010a029:	89 45 e0             	mov    %eax,-0x20(%ebp)

	struct Share *shareobj = (struct Share *)kmalloc(sizeof(struct Share));
f010a02c:	83 ec 0c             	sub    $0xc,%esp
f010a02f:	6a 60                	push   $0x60
f010a031:	e8 9c 0e 00 00       	call   f010aed2 <kmalloc>
f010a036:	83 c4 10             	add    $0x10,%esp
f010a039:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (shareobj == NULL) return NULL;
f010a03c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010a040:	75 0a                	jne    f010a04c <alloc_share+0x5a>
f010a042:	b8 00 00 00 00       	mov    $0x0,%eax
f010a047:	e9 00 01 00 00       	jmp    f010a14c <alloc_share+0x15a>

	shareobj->framesStorage = (struct FrameInfo **)kmalloc(requiredPages * sizeof(struct FrameInfo *));
f010a04c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a04f:	c1 e0 02             	shl    $0x2,%eax
f010a052:	83 ec 0c             	sub    $0xc,%esp
f010a055:	50                   	push   %eax
f010a056:	e8 77 0e 00 00       	call   f010aed2 <kmalloc>
f010a05b:	83 c4 10             	add    $0x10,%esp
f010a05e:	89 c2                	mov    %eax,%edx
f010a060:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a063:	89 50 54             	mov    %edx,0x54(%eax)
	if (shareobj->framesStorage == NULL)
f010a066:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a069:	8b 40 54             	mov    0x54(%eax),%eax
f010a06c:	85 c0                	test   %eax,%eax
f010a06e:	75 18                	jne    f010a088 <alloc_share+0x96>
	{
		kfree(shareobj);
f010a070:	83 ec 0c             	sub    $0xc,%esp
f010a073:	ff 75 dc             	pushl  -0x24(%ebp)
f010a076:	e8 d8 11 00 00       	call   f010b253 <kfree>
f010a07b:	83 c4 10             	add    $0x10,%esp
		return NULL;
f010a07e:	b8 00 00 00 00       	mov    $0x0,%eax
f010a083:	e9 c4 00 00 00       	jmp    f010a14c <alloc_share+0x15a>
	}

	for (uint32 ind = 0; ind <requiredPages ; ind++)
f010a088:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010a08f:	eb 17                	jmp    f010a0a8 <alloc_share+0xb6>
	     shareobj->framesStorage[ind] = NULL;
f010a091:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a094:	8b 40 54             	mov    0x54(%eax),%eax
f010a097:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a09a:	c1 e2 02             	shl    $0x2,%edx
f010a09d:	01 d0                	add    %edx,%eax
f010a09f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	{
		kfree(shareobj);
		return NULL;
	}

	for (uint32 ind = 0; ind <requiredPages ; ind++)
f010a0a5:	ff 45 f0             	incl   -0x10(%ebp)
f010a0a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0ab:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f010a0ae:	72 e1                	jb     f010a091 <alloc_share+0x9f>
	     shareobj->framesStorage[ind] = NULL;

	 shareobj-> ownerID = ownerID;
f010a0b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a0b3:	8b 55 08             	mov    0x8(%ebp),%edx
f010a0b6:	89 50 04             	mov    %edx,0x4(%eax)
	 shareobj->size = size;
f010a0b9:	8b 55 10             	mov    0x10(%ebp),%edx
f010a0bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a0bf:	89 50 48             	mov    %edx,0x48(%eax)
	 shareobj->references = 1;
f010a0c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a0c5:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	 shareobj->isWritable = isWritable;
f010a0cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a0cf:	8a 55 d4             	mov    -0x2c(%ebp),%dl
f010a0d2:	88 50 50             	mov    %dl,0x50(%eax)

	for (int ind = 63; ind >= 0; ind--)
f010a0d5:	c7 45 ec 3f 00 00 00 	movl   $0x3f,-0x14(%ebp)
f010a0dc:	eb 11                	jmp    f010a0ef <alloc_share+0xfd>
	      shareobj->name[ind] = 0;
f010a0de:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010a0e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a0e4:	01 d0                	add    %edx,%eax
f010a0e6:	83 c0 08             	add    $0x8,%eax
f010a0e9:	c6 00 00             	movb   $0x0,(%eax)
	 shareobj-> ownerID = ownerID;
	 shareobj->size = size;
	 shareobj->references = 1;
	 shareobj->isWritable = isWritable;

	for (int ind = 63; ind >= 0; ind--)
f010a0ec:	ff 4d ec             	decl   -0x14(%ebp)
f010a0ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a0f3:	79 e9                	jns    f010a0de <alloc_share+0xec>
	      shareobj->name[ind] = 0;

	if (shareName != NULL)
f010a0f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010a0f9:	74 45                	je     f010a140 <alloc_share+0x14e>
	{
		int nameidx = 0;
f010a0fb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

		while (shareName[nameidx] != '\0' && nameidx < 63)
f010a102:	eb 1a                	jmp    f010a11e <alloc_share+0x12c>
		{
			shareobj->name[nameidx] = shareName[nameidx];
f010a104:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010a107:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a10a:	01 d0                	add    %edx,%eax
f010a10c:	8a 00                	mov    (%eax),%al
f010a10e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010a111:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010a114:	01 ca                	add    %ecx,%edx
f010a116:	83 c2 08             	add    $0x8,%edx
f010a119:	88 02                	mov    %al,(%edx)
			nameidx++;
f010a11b:	ff 45 e8             	incl   -0x18(%ebp)

	if (shareName != NULL)
	{
		int nameidx = 0;

		while (shareName[nameidx] != '\0' && nameidx < 63)
f010a11e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010a121:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a124:	01 d0                	add    %edx,%eax
f010a126:	8a 00                	mov    (%eax),%al
f010a128:	84 c0                	test   %al,%al
f010a12a:	74 06                	je     f010a132 <alloc_share+0x140>
f010a12c:	83 7d e8 3e          	cmpl   $0x3e,-0x18(%ebp)
f010a130:	7e d2                	jle    f010a104 <alloc_share+0x112>
		{
			shareobj->name[nameidx] = shareName[nameidx];
			nameidx++;
		}
		 shareobj->name[nameidx] = '\0';
f010a132:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010a135:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a138:	01 d0                	add    %edx,%eax
f010a13a:	83 c0 08             	add    $0x8,%eax
f010a13d:	c6 00 00             	movb   $0x0,(%eax)
	}

	shareobj->ID = 0;
f010a140:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a143:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return shareobj;
f010a149:	8b 45 dc             	mov    -0x24(%ebp),%eax
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

	//Comment the following line
	//panic("alloc_share() is not implemented yet...!!");
}
f010a14c:	c9                   	leave  
f010a14d:	c3                   	ret    

f010a14e <create_shared_object>:

//=========================
// [4] Create Share Object:
//=========================
int create_shared_object(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010a14e:	55                   	push   %ebp
f010a14f:	89 e5                	mov    %esp,%ebp
f010a151:	83 ec 58             	sub    $0x58,%esp
f010a154:	8b 45 14             	mov    0x14(%ebp),%eax
f010a157:	88 45 b4             	mov    %al,-0x4c(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #3 create_shared_object
	//Your code is here

#if USE_KHEAP
	struct Env* myenv = get_cpu_proc(); //The calling environment
f010a15a:	e8 e9 34 00 00       	call   f010d648 <get_cpu_proc>
f010a15f:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (myenv == NULL || shareName == NULL || size == 0 || virtual_address == NULL)
f010a162:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a166:	74 12                	je     f010a17a <create_shared_object+0x2c>
f010a168:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010a16c:	74 0c                	je     f010a17a <create_shared_object+0x2c>
f010a16e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a172:	74 06                	je     f010a17a <create_shared_object+0x2c>
f010a174:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f010a178:	75 0a                	jne    f010a184 <create_shared_object+0x36>
		return E_NO_SHARE;
f010a17a:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010a17f:	e9 f1 02 00 00       	jmp    f010a475 <create_shared_object+0x327>

	struct Share *existingobj = find_share(ownerID, shareName);
f010a184:	83 ec 08             	sub    $0x8,%esp
f010a187:	ff 75 0c             	pushl  0xc(%ebp)
f010a18a:	ff 75 08             	pushl  0x8(%ebp)
f010a18d:	e8 7b fd ff ff       	call   f0109f0d <find_share>
f010a192:	83 c4 10             	add    $0x10,%esp
f010a195:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (existingobj !=  NULL){
f010a198:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010a19c:	74 0a                	je     f010a1a8 <create_shared_object+0x5a>
		return E_SHARED_MEM_EXISTS;}
f010a19e:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f010a1a3:	e9 cd 02 00 00       	jmp    f010a475 <create_shared_object+0x327>

	struct Share *nshrobj = alloc_share(ownerID, shareName, size, isWritable);
f010a1a8:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
f010a1ac:	50                   	push   %eax
f010a1ad:	ff 75 10             	pushl  0x10(%ebp)
f010a1b0:	ff 75 0c             	pushl  0xc(%ebp)
f010a1b3:	ff 75 08             	pushl  0x8(%ebp)
f010a1b6:	e8 37 fe ff ff       	call   f0109ff2 <alloc_share>
f010a1bb:	83 c4 10             	add    $0x10,%esp
f010a1be:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (nshrobj == NULL) return E_NO_SHARE;
f010a1c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a1c5:	75 0a                	jne    f010a1d1 <create_shared_object+0x83>
f010a1c7:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010a1cc:	e9 a4 02 00 00       	jmp    f010a475 <create_shared_object+0x327>

	uint32 va_addr = (uint32)virtual_address;
f010a1d1:	8b 45 18             	mov    0x18(%ebp),%eax
f010a1d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	nshrobj->ID = (int32)(va_addr & 0x7FFFFFFF);
f010a1d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a1da:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
f010a1df:	89 c2                	mov    %eax,%edx
f010a1e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1e4:	89 10                	mov    %edx,(%eax)

	bool washeld = holding_kspinlock(&(AllShares.shareslock));
f010a1e6:	83 ec 0c             	sub    $0xc,%esp
f010a1e9:	68 30 cd 94 f1       	push   $0xf194cd30
f010a1ee:	e8 a7 95 00 00       	call   f011379a <holding_kspinlock>
f010a1f3:	83 c4 10             	add    $0x10,%esp
f010a1f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (!washeld) acquire_kspinlock(&(AllShares.shareslock));
f010a1f9:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010a1fd:	75 10                	jne    f010a20f <create_shared_object+0xc1>
f010a1ff:	83 ec 0c             	sub    $0xc,%esp
f010a202:	68 30 cd 94 f1       	push   $0xf194cd30
f010a207:	e8 39 93 00 00       	call   f0113545 <acquire_kspinlock>
f010a20c:	83 c4 10             	add    $0x10,%esp

	LIST_INSERT_HEAD(&(AllShares.shares_list), nshrobj);
f010a20f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a213:	75 17                	jne    f010a22c <create_shared_object+0xde>
f010a215:	83 ec 04             	sub    $0x4,%esp
f010a218:	68 60 78 13 f0       	push   $0xf0137860
f010a21d:	68 bc 00 00 00       	push   $0xbc
f010a222:	68 84 78 13 f0       	push   $0xf0137884
f010a227:	e8 83 6c ff ff       	call   f0100eaf <_panic>
f010a22c:	8b 15 20 cd 94 f1    	mov    0xf194cd20,%edx
f010a232:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a235:	89 50 58             	mov    %edx,0x58(%eax)
f010a238:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a23b:	8b 40 58             	mov    0x58(%eax),%eax
f010a23e:	85 c0                	test   %eax,%eax
f010a240:	74 0d                	je     f010a24f <create_shared_object+0x101>
f010a242:	a1 20 cd 94 f1       	mov    0xf194cd20,%eax
f010a247:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a24a:	89 50 5c             	mov    %edx,0x5c(%eax)
f010a24d:	eb 08                	jmp    f010a257 <create_shared_object+0x109>
f010a24f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a252:	a3 24 cd 94 f1       	mov    %eax,0xf194cd24
f010a257:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a25a:	a3 20 cd 94 f1       	mov    %eax,0xf194cd20
f010a25f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a262:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f010a269:	a1 2c cd 94 f1       	mov    0xf194cd2c,%eax
f010a26e:	40                   	inc    %eax
f010a26f:	a3 2c cd 94 f1       	mov    %eax,0xf194cd2c

	if (!washeld) release_kspinlock(&(AllShares.shareslock));
f010a274:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010a278:	75 10                	jne    f010a28a <create_shared_object+0x13c>
f010a27a:	83 ec 0c             	sub    $0xc,%esp
f010a27d:	68 30 cd 94 f1       	push   $0xf194cd30
f010a282:	e8 63 93 00 00       	call   f01135ea <release_kspinlock>
f010a287:	83 c4 10             	add    $0x10,%esp

	uint32 alignedSize = size;
f010a28a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a28d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 remainder = size & (PAGE_SIZE - 1);
f010a290:	8b 45 10             	mov    0x10(%ebp),%eax
f010a293:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a298:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (remainder != 0)
f010a29b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a29f:	74 0e                	je     f010a2af <create_shared_object+0x161>
	    alignedSize += (PAGE_SIZE - remainder);
f010a2a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a2a4:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f010a2a7:	05 00 10 00 00       	add    $0x1000,%eax
f010a2ac:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 requiredPages = alignedSize / PAGE_SIZE;
f010a2af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a2b2:	c1 e8 0c             	shr    $0xc,%eax
f010a2b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 va = ROUNDDOWN((uint32)virtual_address, PAGE_SIZE);
f010a2b8:	8b 45 18             	mov    0x18(%ebp),%eax
f010a2bb:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010a2be:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010a2c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a2c6:	89 45 c8             	mov    %eax,-0x38(%ebp)

	for (uint32 i = 0; i < requiredPages; i++)
f010a2c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010a2d0:	e9 8f 01 00 00       	jmp    f010a464 <create_shared_object+0x316>
	{
		struct FrameInfo *ptr_frame_info = NULL;
f010a2d5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
		allocate_frame(&ptr_frame_info);
f010a2dc:	83 ec 0c             	sub    $0xc,%esp
f010a2df:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010a2e2:	50                   	push   %eax
f010a2e3:	e8 6e f3 ff ff       	call   f0109656 <allocate_frame>
f010a2e8:	83 c4 10             	add    $0x10,%esp

		int map_ret = map_frame(myenv->env_page_directory, ptr_frame_info, va + i * PAGE_SIZE, PERM_USER | PERM_WRITEABLE);
f010a2eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2ee:	c1 e0 0c             	shl    $0xc,%eax
f010a2f1:	89 c2                	mov    %eax,%edx
f010a2f3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010a2f6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010a2f9:	8b 55 c0             	mov    -0x40(%ebp),%edx
f010a2fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a2ff:	8b 40 64             	mov    0x64(%eax),%eax
f010a302:	6a 06                	push   $0x6
f010a304:	51                   	push   %ecx
f010a305:	52                   	push   %edx
f010a306:	50                   	push   %eax
f010a307:	e8 eb f7 ff ff       	call   f0109af7 <map_frame>
f010a30c:	83 c4 10             	add    $0x10,%esp
f010a30f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (map_ret != 0)
f010a312:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a316:	0f 84 32 01 00 00    	je     f010a44e <create_shared_object+0x300>
		{
			for (uint32 j = 0; j < i; j++)
f010a31c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010a323:	eb 33                	jmp    f010a358 <create_shared_object+0x20a>
			{
				if (nshrobj->framesStorage[j] != NULL)
f010a325:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a328:	8b 40 54             	mov    0x54(%eax),%eax
f010a32b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a32e:	c1 e2 02             	shl    $0x2,%edx
f010a331:	01 d0                	add    %edx,%eax
f010a333:	8b 00                	mov    (%eax),%eax
f010a335:	85 c0                	test   %eax,%eax
f010a337:	74 1c                	je     f010a355 <create_shared_object+0x207>
				{
					free_frame(nshrobj->framesStorage[j]);
f010a339:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a33c:	8b 40 54             	mov    0x54(%eax),%eax
f010a33f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a342:	c1 e2 02             	shl    $0x2,%edx
f010a345:	01 d0                	add    %edx,%eax
f010a347:	8b 00                	mov    (%eax),%eax
f010a349:	83 ec 0c             	sub    $0xc,%esp
f010a34c:	50                   	push   %eax
f010a34d:	e8 2c f4 ff ff       	call   f010977e <free_frame>
f010a352:	83 c4 10             	add    $0x10,%esp
		allocate_frame(&ptr_frame_info);

		int map_ret = map_frame(myenv->env_page_directory, ptr_frame_info, va + i * PAGE_SIZE, PERM_USER | PERM_WRITEABLE);
		if (map_ret != 0)
		{
			for (uint32 j = 0; j < i; j++)
f010a355:	ff 45 ec             	incl   -0x14(%ebp)
f010a358:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a35b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010a35e:	72 c5                	jb     f010a325 <create_shared_object+0x1d7>
				if (nshrobj->framesStorage[j] != NULL)
				{
					free_frame(nshrobj->framesStorage[j]);
				}
			}
			washeld = holding_kspinlock(&(AllShares.shareslock));
f010a360:	83 ec 0c             	sub    $0xc,%esp
f010a363:	68 30 cd 94 f1       	push   $0xf194cd30
f010a368:	e8 2d 94 00 00       	call   f011379a <holding_kspinlock>
f010a36d:	83 c4 10             	add    $0x10,%esp
f010a370:	89 45 d8             	mov    %eax,-0x28(%ebp)

			if (!washeld)
f010a373:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010a377:	75 10                	jne    f010a389 <create_shared_object+0x23b>
				acquire_kspinlock(&(AllShares.shareslock));
f010a379:	83 ec 0c             	sub    $0xc,%esp
f010a37c:	68 30 cd 94 f1       	push   $0xf194cd30
f010a381:	e8 bf 91 00 00       	call   f0113545 <acquire_kspinlock>
f010a386:	83 c4 10             	add    $0x10,%esp

			LIST_REMOVE(&(AllShares.shares_list), nshrobj);
f010a389:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a38d:	75 17                	jne    f010a3a6 <create_shared_object+0x258>
f010a38f:	83 ec 04             	sub    $0x4,%esp
f010a392:	68 a5 78 13 f0       	push   $0xf01378a5
f010a397:	68 dc 00 00 00       	push   $0xdc
f010a39c:	68 84 78 13 f0       	push   $0xf0137884
f010a3a1:	e8 09 6b ff ff       	call   f0100eaf <_panic>
f010a3a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3a9:	8b 40 58             	mov    0x58(%eax),%eax
f010a3ac:	85 c0                	test   %eax,%eax
f010a3ae:	74 11                	je     f010a3c1 <create_shared_object+0x273>
f010a3b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3b3:	8b 40 58             	mov    0x58(%eax),%eax
f010a3b6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3b9:	8b 52 5c             	mov    0x5c(%edx),%edx
f010a3bc:	89 50 5c             	mov    %edx,0x5c(%eax)
f010a3bf:	eb 0b                	jmp    f010a3cc <create_shared_object+0x27e>
f010a3c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3c4:	8b 40 5c             	mov    0x5c(%eax),%eax
f010a3c7:	a3 24 cd 94 f1       	mov    %eax,0xf194cd24
f010a3cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3cf:	8b 40 5c             	mov    0x5c(%eax),%eax
f010a3d2:	85 c0                	test   %eax,%eax
f010a3d4:	74 11                	je     f010a3e7 <create_shared_object+0x299>
f010a3d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3d9:	8b 40 5c             	mov    0x5c(%eax),%eax
f010a3dc:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3df:	8b 52 58             	mov    0x58(%edx),%edx
f010a3e2:	89 50 58             	mov    %edx,0x58(%eax)
f010a3e5:	eb 0b                	jmp    f010a3f2 <create_shared_object+0x2a4>
f010a3e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3ea:	8b 40 58             	mov    0x58(%eax),%eax
f010a3ed:	a3 20 cd 94 f1       	mov    %eax,0xf194cd20
f010a3f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3f5:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f010a3fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3ff:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f010a406:	a1 2c cd 94 f1       	mov    0xf194cd2c,%eax
f010a40b:	48                   	dec    %eax
f010a40c:	a3 2c cd 94 f1       	mov    %eax,0xf194cd2c

			if (!washeld)
f010a411:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010a415:	75 10                	jne    f010a427 <create_shared_object+0x2d9>
				release_kspinlock(&(AllShares.shareslock));
f010a417:	83 ec 0c             	sub    $0xc,%esp
f010a41a:	68 30 cd 94 f1       	push   $0xf194cd30
f010a41f:	e8 c6 91 00 00       	call   f01135ea <release_kspinlock>
f010a424:	83 c4 10             	add    $0x10,%esp

			kfree(nshrobj->framesStorage);
f010a427:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a42a:	8b 40 54             	mov    0x54(%eax),%eax
f010a42d:	83 ec 0c             	sub    $0xc,%esp
f010a430:	50                   	push   %eax
f010a431:	e8 1d 0e 00 00       	call   f010b253 <kfree>
f010a436:	83 c4 10             	add    $0x10,%esp

			kfree(nshrobj);
f010a439:	83 ec 0c             	sub    $0xc,%esp
f010a43c:	ff 75 e0             	pushl  -0x20(%ebp)
f010a43f:	e8 0f 0e 00 00       	call   f010b253 <kfree>
f010a444:	83 c4 10             	add    $0x10,%esp
			return E_NO_SHARE;
f010a447:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010a44c:	eb 27                	jmp    f010a475 <create_shared_object+0x327>
		}

		nshrobj->framesStorage[i] = ptr_frame_info;
f010a44e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a451:	8b 40 54             	mov    0x54(%eax),%eax
f010a454:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a457:	c1 e2 02             	shl    $0x2,%edx
f010a45a:	01 c2                	add    %eax,%edx
f010a45c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a45f:	89 02                	mov    %eax,(%edx)
	    alignedSize += (PAGE_SIZE - remainder);

	uint32 requiredPages = alignedSize / PAGE_SIZE;
	uint32 va = ROUNDDOWN((uint32)virtual_address, PAGE_SIZE);

	for (uint32 i = 0; i < requiredPages; i++)
f010a461:	ff 45 f0             	incl   -0x10(%ebp)
f010a464:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a467:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010a46a:	0f 82 65 fe ff ff    	jb     f010a2d5 <create_shared_object+0x187>
		}

		nshrobj->framesStorage[i] = ptr_frame_info;
	}

	return nshrobj->ID;
f010a470:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a473:	8b 00                	mov    (%eax),%eax
	// and return the ShareObjectID
	// RETURN:
	//	a) ID of the shared object (its VA after masking out its msb) if success
	//	b) E_SHARED_MEM_EXISTS if the shared object already exists
	//	c) E_NO_SHARE if failed to create a shared object
}
f010a475:	c9                   	leave  
f010a476:	c3                   	ret    

f010a477 <get_shared_object>:

//======================
// [5] Get Share Object:
//======================
int get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f010a477:	55                   	push   %ebp
f010a478:	89 e5                	mov    %esp,%ebp
f010a47a:	83 ec 48             	sub    $0x48,%esp
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #5 get_shared_object
	//Your code is here

#if USE_KHEAP
	struct Env* myenv = get_cpu_proc(); //The calling environment
f010a47d:	e8 c6 31 00 00       	call   f010d648 <get_cpu_proc>
f010a482:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (myenv == NULL || shareName == NULL || virtual_address == NULL){
f010a485:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a489:	74 0c                	je     f010a497 <get_shared_object+0x20>
f010a48b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010a48f:	74 06                	je     f010a497 <get_shared_object+0x20>
f010a491:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a495:	75 0a                	jne    f010a4a1 <get_shared_object+0x2a>
		return E_SHARED_MEM_NOT_EXISTS;
f010a497:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f010a49c:	e9 94 01 00 00       	jmp    f010a635 <get_shared_object+0x1be>
	}

	struct Share *shrobjjj = find_share(ownerID, shareName);
f010a4a1:	83 ec 08             	sub    $0x8,%esp
f010a4a4:	ff 75 0c             	pushl  0xc(%ebp)
f010a4a7:	ff 75 08             	pushl  0x8(%ebp)
f010a4aa:	e8 5e fa ff ff       	call   f0109f0d <find_share>
f010a4af:	83 c4 10             	add    $0x10,%esp
f010a4b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (shrobjjj == NULL)
f010a4b5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010a4b9:	75 0a                	jne    f010a4c5 <get_shared_object+0x4e>
		return E_SHARED_MEM_NOT_EXISTS;
f010a4bb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f010a4c0:	e9 70 01 00 00       	jmp    f010a635 <get_shared_object+0x1be>

	bool washeld = holding_kspinlock(&(AllShares.shareslock));
f010a4c5:	83 ec 0c             	sub    $0xc,%esp
f010a4c8:	68 30 cd 94 f1       	push   $0xf194cd30
f010a4cd:	e8 c8 92 00 00       	call   f011379a <holding_kspinlock>
f010a4d2:	83 c4 10             	add    $0x10,%esp
f010a4d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!washeld)
f010a4d8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a4dc:	75 10                	jne    f010a4ee <get_shared_object+0x77>
		acquire_kspinlock(&(AllShares.shareslock));
f010a4de:	83 ec 0c             	sub    $0xc,%esp
f010a4e1:	68 30 cd 94 f1       	push   $0xf194cd30
f010a4e6:	e8 5a 90 00 00       	call   f0113545 <acquire_kspinlock>
f010a4eb:	83 c4 10             	add    $0x10,%esp

	shrobjjj->references++;
f010a4ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a4f1:	8b 40 4c             	mov    0x4c(%eax),%eax
f010a4f4:	8d 50 01             	lea    0x1(%eax),%edx
f010a4f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a4fa:	89 50 4c             	mov    %edx,0x4c(%eax)

	if (!washeld)
f010a4fd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a501:	75 10                	jne    f010a513 <get_shared_object+0x9c>
		release_kspinlock(&(AllShares.shareslock));
f010a503:	83 ec 0c             	sub    $0xc,%esp
f010a506:	68 30 cd 94 f1       	push   $0xf194cd30
f010a50b:	e8 da 90 00 00       	call   f01135ea <release_kspinlock>
f010a510:	83 c4 10             	add    $0x10,%esp

	uint32 sizeeee=shrobjjj->size;
f010a513:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a516:	8b 40 48             	mov    0x48(%eax),%eax
f010a519:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 alignedsize = sizeeee;
f010a51c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a51f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 remainder = alignedsize & (PAGE_SIZE - 1);
f010a522:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a525:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a52a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (remainder != 0) alignedsize += (PAGE_SIZE - remainder);
f010a52d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010a531:	74 0e                	je     f010a541 <get_shared_object+0xca>
f010a533:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a536:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010a539:	05 00 10 00 00       	add    $0x1000,%eax
f010a53e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 numFrames = alignedsize / PAGE_SIZE;
f010a541:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a544:	c1 e8 0c             	shr    $0xc,%eax
f010a547:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 va = ROUNDDOWN((uint32)virtual_address, PAGE_SIZE);
f010a54a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a54d:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a550:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a553:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a558:	89 45 cc             	mov    %eax,-0x34(%ebp)

	uint32 perms;
	if (shrobjjj->isWritable == 1)
f010a55b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a55e:	8a 40 50             	mov    0x50(%eax),%al
f010a561:	3c 01                	cmp    $0x1,%al
f010a563:	75 09                	jne    f010a56e <get_shared_object+0xf7>
		perms = PERM_USER | PERM_WRITEABLE;
f010a565:	c7 45 f0 06 00 00 00 	movl   $0x6,-0x10(%ebp)
f010a56c:	eb 07                	jmp    f010a575 <get_shared_object+0xfe>
	else
		perms = PERM_USER & ~PERM_WRITEABLE;
f010a56e:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)

	for (uint32 i = 0; i < numFrames; i++)
f010a575:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010a57c:	e9 a3 00 00 00       	jmp    f010a624 <get_shared_object+0x1ad>
	{
		struct FrameInfo *ptr_frame_info = shrobjjj->framesStorage[i];
f010a581:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a584:	8b 40 54             	mov    0x54(%eax),%eax
f010a587:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a58a:	c1 e2 02             	shl    $0x2,%edx
f010a58d:	01 d0                	add    %edx,%eax
f010a58f:	8b 00                	mov    (%eax),%eax
f010a591:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_frame_info == NULL) continue;
f010a594:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010a598:	0f 84 82 00 00 00    	je     f010a620 <get_shared_object+0x1a9>

		int map_ret = map_frame(myenv->env_page_directory, ptr_frame_info, va + i * PAGE_SIZE, perms);
f010a59e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a5a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5a4:	c1 e0 0c             	shl    $0xc,%eax
f010a5a7:	89 c1                	mov    %eax,%ecx
f010a5a9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010a5ac:	01 c1                	add    %eax,%ecx
f010a5ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a5b1:	8b 40 64             	mov    0x64(%eax),%eax
f010a5b4:	52                   	push   %edx
f010a5b5:	51                   	push   %ecx
f010a5b6:	ff 75 c8             	pushl  -0x38(%ebp)
f010a5b9:	50                   	push   %eax
f010a5ba:	e8 38 f5 ff ff       	call   f0109af7 <map_frame>
f010a5bf:	83 c4 10             	add    $0x10,%esp
f010a5c2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (map_ret != 0)
f010a5c5:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a5c9:	74 56                	je     f010a621 <get_shared_object+0x1aa>
		{
			washeld = holding_kspinlock(&(AllShares.shareslock));
f010a5cb:	83 ec 0c             	sub    $0xc,%esp
f010a5ce:	68 30 cd 94 f1       	push   $0xf194cd30
f010a5d3:	e8 c2 91 00 00       	call   f011379a <holding_kspinlock>
f010a5d8:	83 c4 10             	add    $0x10,%esp
f010a5db:	89 45 e0             	mov    %eax,-0x20(%ebp)

			if (!washeld)
f010a5de:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a5e2:	75 10                	jne    f010a5f4 <get_shared_object+0x17d>
				acquire_kspinlock(&(AllShares.shareslock));
f010a5e4:	83 ec 0c             	sub    $0xc,%esp
f010a5e7:	68 30 cd 94 f1       	push   $0xf194cd30
f010a5ec:	e8 54 8f 00 00       	call   f0113545 <acquire_kspinlock>
f010a5f1:	83 c4 10             	add    $0x10,%esp

			shrobjjj->references--;
f010a5f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a5f7:	8b 40 4c             	mov    0x4c(%eax),%eax
f010a5fa:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a5fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a600:	89 50 4c             	mov    %edx,0x4c(%eax)
			if (!washeld)
f010a603:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a607:	75 10                	jne    f010a619 <get_shared_object+0x1a2>
				release_kspinlock(&(AllShares.shareslock));
f010a609:	83 ec 0c             	sub    $0xc,%esp
f010a60c:	68 30 cd 94 f1       	push   $0xf194cd30
f010a611:	e8 d4 8f 00 00       	call   f01135ea <release_kspinlock>
f010a616:	83 c4 10             	add    $0x10,%esp
			return E_NO_SHARE;
f010a619:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010a61e:	eb 15                	jmp    f010a635 <get_shared_object+0x1be>
		perms = PERM_USER & ~PERM_WRITEABLE;

	for (uint32 i = 0; i < numFrames; i++)
	{
		struct FrameInfo *ptr_frame_info = shrobjjj->framesStorage[i];
		if (ptr_frame_info == NULL) continue;
f010a620:	90                   	nop
	if (shrobjjj->isWritable == 1)
		perms = PERM_USER | PERM_WRITEABLE;
	else
		perms = PERM_USER & ~PERM_WRITEABLE;

	for (uint32 i = 0; i < numFrames; i++)
f010a621:	ff 45 ec             	incl   -0x14(%ebp)
f010a624:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a627:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010a62a:	0f 82 51 ff ff ff    	jb     f010a581 <get_shared_object+0x10a>
				release_kspinlock(&(AllShares.shareslock));
			return E_NO_SHARE;
		}
	}

	return shrobjjj->ID;
f010a630:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a633:	8b 00                	mov    (%eax),%eax
	// 	and return the ShareObjectID
	// RETURN:
	//	a) ID of the shared object (its VA after masking out its msb) if success
	//	b) E_SHARED_MEM_NOT_EXISTS if the shared object is not exists

}
f010a635:	c9                   	leave  
f010a636:	c3                   	ret    

f010a637 <free_share>:
// [1] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f010a637:	55                   	push   %ebp
f010a638:	89 e5                	mov    %esp,%ebp
f010a63a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - free_share
	//Your code is here
	//Comment the following line
	panic("free_share() is not implemented yet...!!");
f010a63d:	83 ec 04             	sub    $0x4,%esp
f010a640:	68 c4 78 13 f0       	push   $0xf01378c4
f010a645:	68 56 01 00 00       	push   $0x156
f010a64a:	68 84 78 13 f0       	push   $0xf0137884
f010a64f:	e8 5b 68 ff ff       	call   f0100eaf <_panic>

f010a654 <delete_shared_object>:

//=========================
// [2] Free Share Object:
//=========================
int delete_shared_object(int32 sharedObjectID, void *startVA)
{
f010a654:	55                   	push   %ebp
f010a655:	89 e5                	mov    %esp,%ebp
f010a657:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - delete_shared_object
	//Your code is here
	//Comment the following line
	panic("delete_shared_object() is not implemented yet...!!");
f010a65a:	83 ec 04             	sub    $0x4,%esp
f010a65d:	68 f0 78 13 f0       	push   $0xf01378f0
f010a662:	68 61 01 00 00       	push   $0x161
f010a667:	68 84 78 13 f0       	push   $0xf0137884
f010a66c:	e8 3e 68 ff ff       	call   f0100eaf <_panic>

f010a671 <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f010a671:	55                   	push   %ebp
f010a672:	89 e5                	mov    %esp,%ebp
f010a674:	8b 45 08             	mov    0x8(%ebp),%eax
f010a677:	a3 64 50 96 f1       	mov    %eax,0xf1965064
f010a67c:	90                   	nop
f010a67d:	5d                   	pop    %ebp
f010a67e:	c3                   	ret    

f010a67f <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010a67f:	55                   	push   %ebp
f010a680:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010a682:	8b 45 08             	mov    0x8(%ebp),%eax
f010a685:	8b 15 a8 51 96 f1    	mov    0xf19651a8,%edx
f010a68b:	29 d0                	sub    %edx,%eax
f010a68d:	c1 f8 02             	sar    $0x2,%eax
f010a690:	89 c2                	mov    %eax,%edx
f010a692:	89 d0                	mov    %edx,%eax
f010a694:	c1 e0 03             	shl    $0x3,%eax
f010a697:	01 d0                	add    %edx,%eax
f010a699:	c1 e0 03             	shl    $0x3,%eax
f010a69c:	01 d0                	add    %edx,%eax
f010a69e:	c1 e0 03             	shl    $0x3,%eax
f010a6a1:	01 d0                	add    %edx,%eax
f010a6a3:	c1 e0 03             	shl    $0x3,%eax
f010a6a6:	01 d0                	add    %edx,%eax
f010a6a8:	89 c1                	mov    %eax,%ecx
f010a6aa:	c1 e1 0f             	shl    $0xf,%ecx
f010a6ad:	01 c8                	add    %ecx,%eax
f010a6af:	c1 e0 03             	shl    $0x3,%eax
f010a6b2:	01 d0                	add    %edx,%eax
f010a6b4:	f7 d8                	neg    %eax
}
f010a6b6:	5d                   	pop    %ebp
f010a6b7:	c3                   	ret    

f010a6b8 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010a6b8:	55                   	push   %ebp
f010a6b9:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010a6bb:	ff 75 08             	pushl  0x8(%ebp)
f010a6be:	e8 bc ff ff ff       	call   f010a67f <to_frame_number>
f010a6c3:	83 c4 04             	add    $0x4,%esp
f010a6c6:	c1 e0 0c             	shl    $0xc,%eax
}
f010a6c9:	c9                   	leave  
f010a6ca:	c3                   	ret    

f010a6cb <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010a6cb:	55                   	push   %ebp
f010a6cc:	89 e5                	mov    %esp,%ebp
f010a6ce:	53                   	push   %ebx
f010a6cf:	83 ec 04             	sub    $0x4,%esp
	if (PPN(physical_address) >= number_of_frames)
f010a6d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6d5:	c1 e8 0c             	shr    $0xc,%eax
f010a6d8:	89 c2                	mov    %eax,%edx
f010a6da:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f010a6df:	39 c2                	cmp    %eax,%edx
f010a6e1:	72 14                	jb     f010a6f7 <to_frame_info+0x2c>
		panic("to_frame_info called with invalid pa");
f010a6e3:	83 ec 04             	sub    $0x4,%esp
f010a6e6:	68 24 79 13 f0       	push   $0xf0137924
f010a6eb:	6a 4e                	push   $0x4e
f010a6ed:	68 49 79 13 f0       	push   $0xf0137949
f010a6f2:	e8 b8 67 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f010a6f7:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f010a6fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a700:	c1 e8 0c             	shr    $0xc,%eax
f010a703:	89 c2                	mov    %eax,%edx
f010a705:	89 d0                	mov    %edx,%eax
f010a707:	01 c0                	add    %eax,%eax
f010a709:	01 d0                	add    %edx,%eax
f010a70b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a712:	01 d8                	add    %ebx,%eax
f010a714:	01 d0                	add    %edx,%eax
f010a716:	01 c8                	add    %ecx,%eax
}
f010a718:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a71b:	c9                   	leave  
f010a71c:	c3                   	ret    

f010a71d <get_frame_info_safe>:


static struct kspinlock kheap_lock;

static inline struct FrameInfo* get_frame_info_safe(uint32 va, uint32 **pt)
{
f010a71d:	55                   	push   %ebp
f010a71e:	89 e5                	mov    %esp,%ebp
f010a720:	83 ec 08             	sub    $0x8,%esp

	return get_frame_info(ptr_page_directory, va, pt);
f010a723:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010a728:	83 ec 04             	sub    $0x4,%esp
f010a72b:	ff 75 0c             	pushl  0xc(%ebp)
f010a72e:	ff 75 08             	pushl  0x8(%ebp)
f010a731:	50                   	push   %eax
f010a732:	e8 b3 f4 ff ff       	call   f0109bea <get_frame_info>
f010a737:	83 c4 10             	add    $0x10,%esp
}
f010a73a:	c9                   	leave  
f010a73b:	c3                   	ret    

f010a73c <insert_free_block_sorted>:

static void insert_free_block_sorted(uint32 start_va, uint32 size)
{
f010a73c:	55                   	push   %ebp
f010a73d:	89 e5                	mov    %esp,%ebp
f010a73f:	83 ec 18             	sub    $0x18,%esp

	struct FreePageBlock *block = (struct FreePageBlock *)alloc_block(sizeof(struct FreePageBlock));
f010a742:	83 ec 0c             	sub    $0xc,%esp
f010a745:	6a 10                	push   $0x10
f010a747:	e8 3b 95 01 00       	call   f0123c87 <alloc_block>
f010a74c:	83 c4 10             	add    $0x10,%esp
f010a74f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (block == NULL)
f010a752:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a756:	75 14                	jne    f010a76c <insert_free_block_sorted+0x30>
	{
		panic("insert_free_block_sorted: failed to allocate metadata");
f010a758:	83 ec 04             	sub    $0x4,%esp
f010a75b:	68 68 79 13 f0       	push   $0xf0137968
f010a760:	6a 22                	push   $0x22
f010a762:	68 9e 79 13 f0       	push   $0xf013799e
f010a767:	e8 43 67 ff ff       	call   f0100eaf <_panic>
	}

	block->start_va = start_va;
f010a76c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a76f:	8b 55 08             	mov    0x8(%ebp),%edx
f010a772:	89 50 08             	mov    %edx,0x8(%eax)
	block->size = size;
f010a775:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a778:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a77b:	89 50 0c             	mov    %edx,0xc(%eax)

	if (LIST_EMPTY(&free_blocks_list)) {
f010a77e:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010a783:	85 c0                	test   %eax,%eax
f010a785:	75 65                	jne    f010a7ec <insert_free_block_sorted+0xb0>
		LIST_INSERT_HEAD(&free_blocks_list, block);
f010a787:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a78b:	75 14                	jne    f010a7a1 <insert_free_block_sorted+0x65>
f010a78d:	83 ec 04             	sub    $0x4,%esp
f010a790:	68 b0 79 13 f0       	push   $0xf01379b0
f010a795:	6a 29                	push   $0x29
f010a797:	68 9e 79 13 f0       	push   $0xf013799e
f010a79c:	e8 0e 67 ff ff       	call   f0100eaf <_panic>
f010a7a1:	8b 15 40 40 92 f0    	mov    0xf0924040,%edx
f010a7a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7aa:	89 10                	mov    %edx,(%eax)
f010a7ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7af:	8b 00                	mov    (%eax),%eax
f010a7b1:	85 c0                	test   %eax,%eax
f010a7b3:	74 0d                	je     f010a7c2 <insert_free_block_sorted+0x86>
f010a7b5:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010a7ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a7bd:	89 50 04             	mov    %edx,0x4(%eax)
f010a7c0:	eb 08                	jmp    f010a7ca <insert_free_block_sorted+0x8e>
f010a7c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7c5:	a3 44 40 92 f0       	mov    %eax,0xf0924044
f010a7ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7cd:	a3 40 40 92 f0       	mov    %eax,0xf0924040
f010a7d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7d5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010a7dc:	a1 4c 40 92 f0       	mov    0xf092404c,%eax
f010a7e1:	40                   	inc    %eax
f010a7e2:	a3 4c 40 92 f0       	mov    %eax,0xf092404c
		return;
f010a7e7:	e9 0d 02 00 00       	jmp    f010a9f9 <insert_free_block_sorted+0x2bd>
	}

	struct FreePageBlock *curr;
	struct FreePageBlock *prev = NULL;
f010a7ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	LIST_FOREACH(curr, &free_blocks_list) {
f010a7f3:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010a7f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a7fb:	e9 f8 00 00 00       	jmp    f010a8f8 <insert_free_block_sorted+0x1bc>


		if (start_va < curr->start_va) {
f010a800:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a803:	8b 40 08             	mov    0x8(%eax),%eax
f010a806:	3b 45 08             	cmp    0x8(%ebp),%eax
f010a809:	0f 86 db 00 00 00    	jbe    f010a8ea <insert_free_block_sorted+0x1ae>


			if (prev == NULL) {
f010a80f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a813:	75 65                	jne    f010a87a <insert_free_block_sorted+0x13e>


				LIST_INSERT_HEAD(&free_blocks_list, block);
f010a815:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a819:	75 14                	jne    f010a82f <insert_free_block_sorted+0xf3>
f010a81b:	83 ec 04             	sub    $0x4,%esp
f010a81e:	68 b0 79 13 f0       	push   $0xf01379b0
f010a823:	6a 39                	push   $0x39
f010a825:	68 9e 79 13 f0       	push   $0xf013799e
f010a82a:	e8 80 66 ff ff       	call   f0100eaf <_panic>
f010a82f:	8b 15 40 40 92 f0    	mov    0xf0924040,%edx
f010a835:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a838:	89 10                	mov    %edx,(%eax)
f010a83a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a83d:	8b 00                	mov    (%eax),%eax
f010a83f:	85 c0                	test   %eax,%eax
f010a841:	74 0d                	je     f010a850 <insert_free_block_sorted+0x114>
f010a843:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010a848:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a84b:	89 50 04             	mov    %edx,0x4(%eax)
f010a84e:	eb 08                	jmp    f010a858 <insert_free_block_sorted+0x11c>
f010a850:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a853:	a3 44 40 92 f0       	mov    %eax,0xf0924044
f010a858:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a85b:	a3 40 40 92 f0       	mov    %eax,0xf0924040
f010a860:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a863:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010a86a:	a1 4c 40 92 f0       	mov    0xf092404c,%eax
f010a86f:	40                   	inc    %eax
f010a870:	a3 4c 40 92 f0       	mov    %eax,0xf092404c
			} else {
				  LIST_INSERT_AFTER(&free_blocks_list, prev, block);
			}

			return;
f010a875:	e9 7f 01 00 00       	jmp    f010a9f9 <insert_free_block_sorted+0x2bd>
			if (prev == NULL) {


				LIST_INSERT_HEAD(&free_blocks_list, block);
			} else {
				  LIST_INSERT_AFTER(&free_blocks_list, prev, block);
f010a87a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a87e:	74 06                	je     f010a886 <insert_free_block_sorted+0x14a>
f010a880:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a884:	75 14                	jne    f010a89a <insert_free_block_sorted+0x15e>
f010a886:	83 ec 04             	sub    $0x4,%esp
f010a889:	68 d4 79 13 f0       	push   $0xf01379d4
f010a88e:	6a 3b                	push   $0x3b
f010a890:	68 9e 79 13 f0       	push   $0xf013799e
f010a895:	e8 15 66 ff ff       	call   f0100eaf <_panic>
f010a89a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a89d:	8b 10                	mov    (%eax),%edx
f010a89f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8a2:	89 10                	mov    %edx,(%eax)
f010a8a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8a7:	8b 00                	mov    (%eax),%eax
f010a8a9:	85 c0                	test   %eax,%eax
f010a8ab:	74 0b                	je     f010a8b8 <insert_free_block_sorted+0x17c>
f010a8ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a8b0:	8b 00                	mov    (%eax),%eax
f010a8b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a8b5:	89 50 04             	mov    %edx,0x4(%eax)
f010a8b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a8bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a8be:	89 10                	mov    %edx,(%eax)
f010a8c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a8c6:	89 50 04             	mov    %edx,0x4(%eax)
f010a8c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8cc:	8b 00                	mov    (%eax),%eax
f010a8ce:	85 c0                	test   %eax,%eax
f010a8d0:	75 08                	jne    f010a8da <insert_free_block_sorted+0x19e>
f010a8d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8d5:	a3 44 40 92 f0       	mov    %eax,0xf0924044
f010a8da:	a1 4c 40 92 f0       	mov    0xf092404c,%eax
f010a8df:	40                   	inc    %eax
f010a8e0:	a3 4c 40 92 f0       	mov    %eax,0xf092404c
			}

			return;
f010a8e5:	e9 0f 01 00 00       	jmp    f010a9f9 <insert_free_block_sorted+0x2bd>
		}
		 prev = curr;
f010a8ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}

	struct FreePageBlock *curr;
	struct FreePageBlock *prev = NULL;

	LIST_FOREACH(curr, &free_blocks_list) {
f010a8f0:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010a8f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a8f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a8fc:	74 07                	je     f010a905 <insert_free_block_sorted+0x1c9>
f010a8fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a901:	8b 00                	mov    (%eax),%eax
f010a903:	eb 05                	jmp    f010a90a <insert_free_block_sorted+0x1ce>
f010a905:	b8 00 00 00 00       	mov    $0x0,%eax
f010a90a:	a3 48 40 92 f0       	mov    %eax,0xf0924048
f010a90f:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010a914:	85 c0                	test   %eax,%eax
f010a916:	0f 85 e4 fe ff ff    	jne    f010a800 <insert_free_block_sorted+0xc4>
f010a91c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a920:	0f 85 da fe ff ff    	jne    f010a800 <insert_free_block_sorted+0xc4>
			return;
		}
		 prev = curr;
	}

	if (prev != NULL) {
f010a926:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a92a:	74 6d                	je     f010a999 <insert_free_block_sorted+0x25d>



		      LIST_INSERT_AFTER(&free_blocks_list, prev, block);
f010a92c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a930:	74 06                	je     f010a938 <insert_free_block_sorted+0x1fc>
f010a932:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a936:	75 14                	jne    f010a94c <insert_free_block_sorted+0x210>
f010a938:	83 ec 04             	sub    $0x4,%esp
f010a93b:	68 d4 79 13 f0       	push   $0xf01379d4
f010a940:	6a 47                	push   $0x47
f010a942:	68 9e 79 13 f0       	push   $0xf013799e
f010a947:	e8 63 65 ff ff       	call   f0100eaf <_panic>
f010a94c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a94f:	8b 10                	mov    (%eax),%edx
f010a951:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a954:	89 10                	mov    %edx,(%eax)
f010a956:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a959:	8b 00                	mov    (%eax),%eax
f010a95b:	85 c0                	test   %eax,%eax
f010a95d:	74 0b                	je     f010a96a <insert_free_block_sorted+0x22e>
f010a95f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a962:	8b 00                	mov    (%eax),%eax
f010a964:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a967:	89 50 04             	mov    %edx,0x4(%eax)
f010a96a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a96d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a970:	89 10                	mov    %edx,(%eax)
f010a972:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a975:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a978:	89 50 04             	mov    %edx,0x4(%eax)
f010a97b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a97e:	8b 00                	mov    (%eax),%eax
f010a980:	85 c0                	test   %eax,%eax
f010a982:	75 08                	jne    f010a98c <insert_free_block_sorted+0x250>
f010a984:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a987:	a3 44 40 92 f0       	mov    %eax,0xf0924044
f010a98c:	a1 4c 40 92 f0       	mov    0xf092404c,%eax
f010a991:	40                   	inc    %eax
f010a992:	a3 4c 40 92 f0       	mov    %eax,0xf092404c
f010a997:	eb 60                	jmp    f010a9f9 <insert_free_block_sorted+0x2bd>
	}  else {
		LIST_INSERT_HEAD(&free_blocks_list, block);
f010a999:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a99d:	75 14                	jne    f010a9b3 <insert_free_block_sorted+0x277>
f010a99f:	83 ec 04             	sub    $0x4,%esp
f010a9a2:	68 b0 79 13 f0       	push   $0xf01379b0
f010a9a7:	6a 49                	push   $0x49
f010a9a9:	68 9e 79 13 f0       	push   $0xf013799e
f010a9ae:	e8 fc 64 ff ff       	call   f0100eaf <_panic>
f010a9b3:	8b 15 40 40 92 f0    	mov    0xf0924040,%edx
f010a9b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a9bc:	89 10                	mov    %edx,(%eax)
f010a9be:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a9c1:	8b 00                	mov    (%eax),%eax
f010a9c3:	85 c0                	test   %eax,%eax
f010a9c5:	74 0d                	je     f010a9d4 <insert_free_block_sorted+0x298>
f010a9c7:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010a9cc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a9cf:	89 50 04             	mov    %edx,0x4(%eax)
f010a9d2:	eb 08                	jmp    f010a9dc <insert_free_block_sorted+0x2a0>
f010a9d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a9d7:	a3 44 40 92 f0       	mov    %eax,0xf0924044
f010a9dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a9df:	a3 40 40 92 f0       	mov    %eax,0xf0924040
f010a9e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a9e7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010a9ee:	a1 4c 40 92 f0       	mov    0xf092404c,%eax
f010a9f3:	40                   	inc    %eax
f010a9f4:	a3 4c 40 92 f0       	mov    %eax,0xf092404c
	}
}
f010a9f9:	c9                   	leave  
f010a9fa:	c3                   	ret    

f010a9fb <remove_free_block>:

static void remove_free_block(struct FreePageBlock *block)
{
f010a9fb:	55                   	push   %ebp
f010a9fc:	89 e5                	mov    %esp,%ebp
f010a9fe:	83 ec 08             	sub    $0x8,%esp
	LIST_REMOVE(&free_blocks_list, block);
f010aa01:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aa05:	75 14                	jne    f010aa1b <remove_free_block+0x20>
f010aa07:	83 ec 04             	sub    $0x4,%esp
f010aa0a:	68 08 7a 13 f0       	push   $0xf0137a08
f010aa0f:	6a 4f                	push   $0x4f
f010aa11:	68 9e 79 13 f0       	push   $0xf013799e
f010aa16:	e8 94 64 ff ff       	call   f0100eaf <_panic>
f010aa1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa1e:	8b 00                	mov    (%eax),%eax
f010aa20:	85 c0                	test   %eax,%eax
f010aa22:	74 10                	je     f010aa34 <remove_free_block+0x39>
f010aa24:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa27:	8b 00                	mov    (%eax),%eax
f010aa29:	8b 55 08             	mov    0x8(%ebp),%edx
f010aa2c:	8b 52 04             	mov    0x4(%edx),%edx
f010aa2f:	89 50 04             	mov    %edx,0x4(%eax)
f010aa32:	eb 0b                	jmp    f010aa3f <remove_free_block+0x44>
f010aa34:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa37:	8b 40 04             	mov    0x4(%eax),%eax
f010aa3a:	a3 44 40 92 f0       	mov    %eax,0xf0924044
f010aa3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa42:	8b 40 04             	mov    0x4(%eax),%eax
f010aa45:	85 c0                	test   %eax,%eax
f010aa47:	74 0f                	je     f010aa58 <remove_free_block+0x5d>
f010aa49:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa4c:	8b 40 04             	mov    0x4(%eax),%eax
f010aa4f:	8b 55 08             	mov    0x8(%ebp),%edx
f010aa52:	8b 12                	mov    (%edx),%edx
f010aa54:	89 10                	mov    %edx,(%eax)
f010aa56:	eb 0a                	jmp    f010aa62 <remove_free_block+0x67>
f010aa58:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa5b:	8b 00                	mov    (%eax),%eax
f010aa5d:	a3 40 40 92 f0       	mov    %eax,0xf0924040
f010aa62:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa65:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010aa6b:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa6e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010aa75:	a1 4c 40 92 f0       	mov    0xf092404c,%eax
f010aa7a:	48                   	dec    %eax
f010aa7b:	a3 4c 40 92 f0       	mov    %eax,0xf092404c
	free_block(block);
f010aa80:	83 ec 0c             	sub    $0xc,%esp
f010aa83:	ff 75 08             	pushl  0x8(%ebp)
f010aa86:	e8 56 97 01 00       	call   f01241e1 <free_block>
f010aa8b:	83 c4 10             	add    $0x10,%esp
}
f010aa8e:	90                   	nop
f010aa8f:	c9                   	leave  
f010aa90:	c3                   	ret    

f010aa91 <merge_adjacent_blocks>:

static void merge_adjacent_blocks()
{
f010aa91:	55                   	push   %ebp
f010aa92:	89 e5                	mov    %esp,%ebp
f010aa94:	83 ec 18             	sub    $0x18,%esp
	struct FreePageBlock *curr = LIST_FIRST(&free_blocks_list);
f010aa97:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010aa9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while (curr != NULL) {
f010aa9f:	eb 52                	jmp    f010aaf3 <merge_adjacent_blocks+0x62>

		struct FreePageBlock *next = LIST_NEXT(curr);
f010aaa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaa4:	8b 00                	mov    (%eax),%eax
f010aaa6:	89 45 f0             	mov    %eax,-0x10(%ebp)


		if (next != NULL && curr->start_va + curr->size == next->start_va) {
f010aaa9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010aaad:	74 3c                	je     f010aaeb <merge_adjacent_blocks+0x5a>
f010aaaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aab2:	8b 50 08             	mov    0x8(%eax),%edx
f010aab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aab8:	8b 40 0c             	mov    0xc(%eax),%eax
f010aabb:	01 c2                	add    %eax,%edx
f010aabd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010aac0:	8b 40 08             	mov    0x8(%eax),%eax
f010aac3:	39 c2                	cmp    %eax,%edx
f010aac5:	75 24                	jne    f010aaeb <merge_adjacent_blocks+0x5a>

			curr->size += next->size;
f010aac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaca:	8b 50 0c             	mov    0xc(%eax),%edx
f010aacd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010aad0:	8b 40 0c             	mov    0xc(%eax),%eax
f010aad3:	01 c2                	add    %eax,%edx
f010aad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aad8:	89 50 0c             	mov    %edx,0xc(%eax)

			remove_free_block(next);
f010aadb:	83 ec 0c             	sub    $0xc,%esp
f010aade:	ff 75 f0             	pushl  -0x10(%ebp)
f010aae1:	e8 15 ff ff ff       	call   f010a9fb <remove_free_block>
f010aae6:	83 c4 10             	add    $0x10,%esp
f010aae9:	eb 08                	jmp    f010aaf3 <merge_adjacent_blocks+0x62>

		} else {
			curr = LIST_NEXT(curr);
f010aaeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaee:	8b 00                	mov    (%eax),%eax
f010aaf0:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static void merge_adjacent_blocks()
{
	struct FreePageBlock *curr = LIST_FIRST(&free_blocks_list);
	while (curr != NULL) {
f010aaf3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010aaf7:	75 a8                	jne    f010aaa1 <merge_adjacent_blocks+0x10>

		} else {
			curr = LIST_NEXT(curr);
		}
	}
}
f010aaf9:	90                   	nop
f010aafa:	c9                   	leave  
f010aafb:	c3                   	ret    

f010aafc <update_break>:

static void update_break()
{
f010aafc:	55                   	push   %ebp
f010aafd:	89 e5                	mov    %esp,%ebp
f010aaff:	83 ec 48             	sub    $0x48,%esp
	uint32 max_end = kheapPageAllocStart;
f010ab02:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010ab07:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 check_va = kheapPageAllocStart;
f010ab0a:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010ab0f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	uint32 max_scan = kheapPageAllocBreak;
f010ab12:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f010ab17:	89 45 ec             	mov    %eax,-0x14(%ebp)


	uint32 consecutive_unmapped = 0;
f010ab1a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32 max_consecutive = 100;
f010ab21:	c7 45 cc 64 00 00 00 	movl   $0x64,-0x34(%ebp)

	while (check_va < max_scan && check_va < KERNEL_HEAP_MAX) {
f010ab28:	e9 0f 02 00 00       	jmp    f010ad3c <update_break+0x240>
		uint32 *pt = NULL;
f010ab2d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
		struct FrameInfo *fi = get_frame_info_safe(check_va, &pt);
f010ab34:	83 ec 08             	sub    $0x8,%esp
f010ab37:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010ab3a:	50                   	push   %eax
f010ab3b:	ff 75 f0             	pushl  -0x10(%ebp)
f010ab3e:	e8 da fb ff ff       	call   f010a71d <get_frame_info_safe>
f010ab43:	83 c4 10             	add    $0x10,%esp
f010ab46:	89 45 c8             	mov    %eax,-0x38(%ebp)

		if (fi != NULL && fi->size > 0) {
f010ab49:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010ab4d:	74 4a                	je     f010ab99 <update_break+0x9d>
f010ab4f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010ab52:	8b 40 14             	mov    0x14(%eax),%eax
f010ab55:	85 c0                	test   %eax,%eax
f010ab57:	74 40                	je     f010ab99 <update_break+0x9d>
			uint32 block_end = check_va + fi->size;
f010ab59:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010ab5c:	8b 50 14             	mov    0x14(%eax),%edx
f010ab5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ab62:	01 d0                	add    %edx,%eax
f010ab64:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if (block_end > max_end)
f010ab67:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ab6a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ab6d:	76 06                	jbe    f010ab75 <update_break+0x79>
				max_end = block_end;
f010ab6f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ab72:	89 45 f4             	mov    %eax,-0xc(%ebp)


			check_va = block_end;
f010ab75:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ab78:	89 45 f0             	mov    %eax,-0x10(%ebp)


			consecutive_unmapped = 0;
f010ab7b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)


			if (block_end > max_scan)
f010ab82:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ab85:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010ab88:	0f 86 a0 01 00 00    	jbe    f010ad2e <update_break+0x232>
				max_scan = block_end;
f010ab8e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ab91:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (check_va < max_scan && check_va < KERNEL_HEAP_MAX) {
		uint32 *pt = NULL;
		struct FrameInfo *fi = get_frame_info_safe(check_va, &pt);

		if (fi != NULL && fi->size > 0) {
f010ab94:	e9 95 01 00 00       	jmp    f010ad2e <update_break+0x232>


			if (block_end > max_scan)
				max_scan = block_end;
		} else {
			int found_free = 0;
f010ab99:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)


			struct FreePageBlock *curr;


			LIST_FOREACH(curr, &free_blocks_list) {
f010aba0:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010aba5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010aba8:	eb 34                	jmp    f010abde <update_break+0xe2>

				if (curr->start_va == check_va) {
f010abaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abad:	8b 40 08             	mov    0x8(%eax),%eax
f010abb0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010abb3:	75 21                	jne    f010abd6 <update_break+0xda>

					check_va = curr->start_va + curr->size;
f010abb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abb8:	8b 50 08             	mov    0x8(%eax),%edx
f010abbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abbe:	8b 40 0c             	mov    0xc(%eax),%eax
f010abc1:	01 d0                	add    %edx,%eax
f010abc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
					found_free = 1;
f010abc6:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					consecutive_unmapped = 0;
f010abcd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
					break;
f010abd4:	eb 2e                	jmp    f010ac04 <update_break+0x108>


			struct FreePageBlock *curr;


			LIST_FOREACH(curr, &free_blocks_list) {
f010abd6:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010abdb:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010abde:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010abe2:	74 07                	je     f010abeb <update_break+0xef>
f010abe4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abe7:	8b 00                	mov    (%eax),%eax
f010abe9:	eb 05                	jmp    f010abf0 <update_break+0xf4>
f010abeb:	b8 00 00 00 00       	mov    $0x0,%eax
f010abf0:	a3 48 40 92 f0       	mov    %eax,0xf0924048
f010abf5:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010abfa:	85 c0                	test   %eax,%eax
f010abfc:	75 ac                	jne    f010abaa <update_break+0xae>
f010abfe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ac02:	75 a6                	jne    f010abaa <update_break+0xae>
					consecutive_unmapped = 0;
					break;
				}
			}

			if (!found_free) {
f010ac04:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010ac08:	0f 85 21 01 00 00    	jne    f010ad2f <update_break+0x233>

				uint32 next_block = KERNEL_HEAP_MAX;
f010ac0e:	c7 45 dc 00 f0 ff ff 	movl   $0xfffff000,-0x24(%ebp)

				LIST_FOREACH(curr, &free_blocks_list) {
f010ac15:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010ac1a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010ac1d:	eb 27                	jmp    f010ac46 <update_break+0x14a>
					if (curr->start_va > check_va && curr->start_va < next_block)
f010ac1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ac22:	8b 40 08             	mov    0x8(%eax),%eax
f010ac25:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ac28:	76 14                	jbe    f010ac3e <update_break+0x142>
f010ac2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ac2d:	8b 40 08             	mov    0x8(%eax),%eax
f010ac30:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010ac33:	73 09                	jae    f010ac3e <update_break+0x142>
						next_block = curr->start_va;
f010ac35:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ac38:	8b 40 08             	mov    0x8(%eax),%eax
f010ac3b:	89 45 dc             	mov    %eax,-0x24(%ebp)

			if (!found_free) {

				uint32 next_block = KERNEL_HEAP_MAX;

				LIST_FOREACH(curr, &free_blocks_list) {
f010ac3e:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010ac43:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010ac46:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ac4a:	74 07                	je     f010ac53 <update_break+0x157>
f010ac4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ac4f:	8b 00                	mov    (%eax),%eax
f010ac51:	eb 05                	jmp    f010ac58 <update_break+0x15c>
f010ac53:	b8 00 00 00 00       	mov    $0x0,%eax
f010ac58:	a3 48 40 92 f0       	mov    %eax,0xf0924048
f010ac5d:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010ac62:	85 c0                	test   %eax,%eax
f010ac64:	75 b9                	jne    f010ac1f <update_break+0x123>
f010ac66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ac6a:	75 b3                	jne    f010ac1f <update_break+0x123>
					if (curr->start_va > check_va && curr->start_va < next_block)
						next_block = curr->start_va;
				}

				uint32 scan_va = check_va + PAGE_SIZE;
f010ac6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac6f:	05 00 10 00 00       	add    $0x1000,%eax
f010ac74:	89 45 d8             	mov    %eax,-0x28(%ebp)

				uint32 scan_limit = (next_block < KERNEL_HEAP_MAX) ? next_block : (check_va + (PAGE_SIZE * 1000));
f010ac77:	81 7d dc ff ef ff ff 	cmpl   $0xffffefff,-0x24(%ebp)
f010ac7e:	76 0a                	jbe    f010ac8a <update_break+0x18e>
f010ac80:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac83:	05 00 80 3e 00       	add    $0x3e8000,%eax
f010ac88:	eb 03                	jmp    f010ac8d <update_break+0x191>
f010ac8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ac8d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				if (scan_limit > KERNEL_HEAP_MAX)
f010ac90:	81 7d d4 00 f0 ff ff 	cmpl   $0xfffff000,-0x2c(%ebp)
f010ac97:	76 07                	jbe    f010aca0 <update_break+0x1a4>
					scan_limit = KERNEL_HEAP_MAX;
f010ac99:	c7 45 d4 00 f0 ff ff 	movl   $0xfffff000,-0x2c(%ebp)


				int found_alloc = 0;
f010aca0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
				while (scan_va < scan_limit) {
f010aca7:	eb 4b                	jmp    f010acf4 <update_break+0x1f8>
					pt = NULL;
f010aca9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
					fi = get_frame_info_safe(scan_va, &pt);
f010acb0:	83 ec 08             	sub    $0x8,%esp
f010acb3:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010acb6:	50                   	push   %eax
f010acb7:	ff 75 d8             	pushl  -0x28(%ebp)
f010acba:	e8 5e fa ff ff       	call   f010a71d <get_frame_info_safe>
f010acbf:	83 c4 10             	add    $0x10,%esp
f010acc2:	89 45 c8             	mov    %eax,-0x38(%ebp)

					if (fi != NULL && fi->size > 0) {
f010acc5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010acc9:	74 22                	je     f010aced <update_break+0x1f1>
f010accb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010acce:	8b 40 14             	mov    0x14(%eax),%eax
f010acd1:	85 c0                	test   %eax,%eax
f010acd3:	74 18                	je     f010aced <update_break+0x1f1>

						next_block = (scan_va < next_block) ? scan_va : next_block;
f010acd5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010acd8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010acdb:	39 d0                	cmp    %edx,%eax
f010acdd:	76 02                	jbe    f010ace1 <update_break+0x1e5>
f010acdf:	89 d0                	mov    %edx,%eax
f010ace1:	89 45 dc             	mov    %eax,-0x24(%ebp)
						found_alloc = 1;
f010ace4:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
						break;
f010aceb:	eb 0f                	jmp    f010acfc <update_break+0x200>
					}
					scan_va += PAGE_SIZE;
f010aced:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
				if (scan_limit > KERNEL_HEAP_MAX)
					scan_limit = KERNEL_HEAP_MAX;


				int found_alloc = 0;
				while (scan_va < scan_limit) {
f010acf4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010acf7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010acfa:	72 ad                	jb     f010aca9 <update_break+0x1ad>
						break;
					}
					scan_va += PAGE_SIZE;
				}

				if (found_alloc || next_block < KERNEL_HEAP_MAX) {
f010acfc:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f010ad00:	75 09                	jne    f010ad0b <update_break+0x20f>
f010ad02:	81 7d dc ff ef ff ff 	cmpl   $0xffffefff,-0x24(%ebp)
f010ad09:	77 0f                	ja     f010ad1a <update_break+0x21e>

					check_va = next_block;
f010ad0b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ad0e:	89 45 f0             	mov    %eax,-0x10(%ebp)

					consecutive_unmapped = 0;
f010ad11:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010ad18:	eb 15                	jmp    f010ad2f <update_break+0x233>
				} else {
					consecutive_unmapped++;
f010ad1a:	ff 45 e8             	incl   -0x18(%ebp)

					if (consecutive_unmapped >= max_consecutive)
f010ad1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ad20:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010ad23:	73 2e                	jae    f010ad53 <update_break+0x257>
						break;

					check_va += PAGE_SIZE;
f010ad25:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f010ad2c:	eb 01                	jmp    f010ad2f <update_break+0x233>

	while (check_va < max_scan && check_va < KERNEL_HEAP_MAX) {
		uint32 *pt = NULL;
		struct FrameInfo *fi = get_frame_info_safe(check_va, &pt);

		if (fi != NULL && fi->size > 0) {
f010ad2e:	90                   	nop
					check_va += PAGE_SIZE;
				}
			}
		}

		if (check_va > max_scan + (PAGE_SIZE * 1000))
f010ad2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad32:	05 00 80 3e 00       	add    $0x3e8000,%eax
f010ad37:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ad3a:	72 1a                	jb     f010ad56 <update_break+0x25a>


	uint32 consecutive_unmapped = 0;
	uint32 max_consecutive = 100;

	while (check_va < max_scan && check_va < KERNEL_HEAP_MAX) {
f010ad3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ad3f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010ad42:	73 13                	jae    f010ad57 <update_break+0x25b>
f010ad44:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010ad4b:	0f 86 dc fd ff ff    	jbe    f010ab2d <update_break+0x31>
f010ad51:	eb 04                	jmp    f010ad57 <update_break+0x25b>
					consecutive_unmapped = 0;
				} else {
					consecutive_unmapped++;

					if (consecutive_unmapped >= max_consecutive)
						break;
f010ad53:	90                   	nop
f010ad54:	eb 01                	jmp    f010ad57 <update_break+0x25b>
				}
			}
		}

		if (check_va > max_scan + (PAGE_SIZE * 1000))
			break;
f010ad56:	90                   	nop
	}

	kheapPageAllocBreak = max_end;
f010ad57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad5a:	a3 b0 51 96 f1       	mov    %eax,0xf19651b0
}
f010ad5f:	90                   	nop
f010ad60:	c9                   	leave  
f010ad61:	c3                   	ret    

f010ad62 <kheap_init>:
//==============================================
//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #0 kheap_init [GIVEN]
//Remember to initialize locks (if any)

void kheap_init()
{
f010ad62:	55                   	push   %ebp
f010ad63:	89 e5                	mov    %esp,%ebp
f010ad65:	83 ec 08             	sub    $0x8,%esp
	initialize_dynamic_allocator(KERNEL_HEAP_START, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010ad68:	83 ec 08             	sub    $0x8,%esp
f010ad6b:	68 00 00 00 f8       	push   $0xf8000000
f010ad70:	68 00 00 00 f6       	push   $0xf6000000
f010ad75:	e8 be 8c 01 00       	call   f0123a38 <initialize_dynamic_allocator>
f010ad7a:	83 c4 10             	add    $0x10,%esp

	set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f010ad7d:	83 ec 0c             	sub    $0xc,%esp
f010ad80:	6a 05                	push   $0x5
f010ad82:	e8 ea f8 ff ff       	call   f010a671 <set_kheap_strategy>
f010ad87:	83 c4 10             	add    $0x10,%esp

	kheapPageAllocStart = dynAllocEnd + PAGE_SIZE;
f010ad8a:	a1 e0 cb 94 f1       	mov    0xf194cbe0,%eax
f010ad8f:	05 00 10 00 00       	add    $0x1000,%eax
f010ad94:	a3 9c cf 94 f1       	mov    %eax,0xf194cf9c
	 kheapPageAllocBreak = kheapPageAllocStart;
f010ad99:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010ad9e:	a3 b0 51 96 f1       	mov    %eax,0xf19651b0

	LIST_INIT(&free_blocks_list);
f010ada3:	c7 05 40 40 92 f0 00 	movl   $0x0,0xf0924040
f010adaa:	00 00 00 
f010adad:	c7 05 44 40 92 f0 00 	movl   $0x0,0xf0924044
f010adb4:	00 00 00 
f010adb7:	c7 05 4c 40 92 f0 00 	movl   $0x0,0xf092404c
f010adbe:	00 00 00 


	init_kspinlock(&kheap_lock, "kheap lock");
f010adc1:	83 ec 08             	sub    $0x8,%esp
f010adc4:	68 26 7a 13 f0       	push   $0xf0137a26
f010adc9:	68 60 40 92 f0       	push   $0xf0924060
f010adce:	e8 41 87 00 00       	call   f0113514 <init_kspinlock>
f010add3:	83 c4 10             	add    $0x10,%esp
}
f010add6:	90                   	nop
f010add7:	c9                   	leave  
f010add8:	c3                   	ret    

f010add9 <get_page>:

int get_page(void* va)
{
f010add9:	55                   	push   %ebp
f010adda:	89 e5                	mov    %esp,%ebp
f010addc:	83 ec 28             	sub    $0x28,%esp
	uint32 page_va = ROUNDDOWN((uint32)va, PAGE_SIZE);
f010addf:	8b 45 08             	mov    0x8(%ebp),%eax
f010ade2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ade5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ade8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010aded:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ret = alloc_page(ptr_page_directory, page_va, PERM_WRITEABLE, 1);
f010adf0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010adf5:	6a 01                	push   $0x1
f010adf7:	6a 02                	push   $0x2
f010adf9:	ff 75 f0             	pushl  -0x10(%ebp)
f010adfc:	50                   	push   %eax
f010adfd:	e8 d8 08 00 00       	call   f010b6da <alloc_page>
f010ae02:	83 c4 10             	add    $0x10,%esp
f010ae05:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ret < 0) {
f010ae08:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ae0c:	79 17                	jns    f010ae25 <get_page+0x4c>
		panic("get_page() in kern: failed to allocate page from the kernel");
f010ae0e:	83 ec 04             	sub    $0x4,%esp
f010ae11:	68 34 7a 13 f0       	push   $0xf0137a34
f010ae16:	68 e9 00 00 00       	push   $0xe9
f010ae1b:	68 9e 79 13 f0       	push   $0xf013799e
f010ae20:	e8 8a 60 ff ff       	call   f0100eaf <_panic>
	}


	if (ret == 0 || ret == 1) {
f010ae25:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ae29:	74 06                	je     f010ae31 <get_page+0x58>
f010ae2b:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
f010ae2f:	75 40                	jne    f010ae71 <get_page+0x98>
		uint32 *pt = NULL;
f010ae31:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct FrameInfo *fi = get_frame_info_safe(page_va, &pt);
f010ae38:	83 ec 08             	sub    $0x8,%esp
f010ae3b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010ae3e:	50                   	push   %eax
f010ae3f:	ff 75 f0             	pushl  -0x10(%ebp)
f010ae42:	e8 d6 f8 ff ff       	call   f010a71d <get_frame_info_safe>
f010ae47:	83 c4 10             	add    $0x10,%esp
f010ae4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (fi != NULL) {
f010ae4d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010ae51:	74 1e                	je     f010ae71 <get_page+0x98>
			if (fi->va == 0 || fi->va != page_va) {
f010ae53:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ae56:	8b 40 10             	mov    0x10(%eax),%eax
f010ae59:	85 c0                	test   %eax,%eax
f010ae5b:	74 0b                	je     f010ae68 <get_page+0x8f>
f010ae5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ae60:	8b 40 10             	mov    0x10(%eax),%eax
f010ae63:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ae66:	74 09                	je     f010ae71 <get_page+0x98>
				fi->va = page_va;
f010ae68:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ae6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ae6e:	89 50 10             	mov    %edx,0x10(%eax)
			}
		}
	}

	return 0;
f010ae71:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ae76:	c9                   	leave  
f010ae77:	c3                   	ret    

f010ae78 <return_page>:

void return_page(void* va)
{
f010ae78:	55                   	push   %ebp
f010ae79:	89 e5                	mov    %esp,%ebp
f010ae7b:	83 ec 18             	sub    $0x18,%esp
	uint32 page_va = ROUNDDOWN((uint32)va, PAGE_SIZE);
f010ae7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae81:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ae84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ae8c:	89 45 f0             	mov    %eax,-0x10(%ebp)


	uint32 *pt = NULL;
f010ae8f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *fi = get_frame_info_safe(page_va, &pt);
f010ae96:	83 ec 08             	sub    $0x8,%esp
f010ae99:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010ae9c:	50                   	push   %eax
f010ae9d:	ff 75 f0             	pushl  -0x10(%ebp)
f010aea0:	e8 78 f8 ff ff       	call   f010a71d <get_frame_info_safe>
f010aea5:	83 c4 10             	add    $0x10,%esp
f010aea8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (fi != NULL) {
f010aeab:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010aeaf:	74 0a                	je     f010aebb <return_page+0x43>
		fi->va = 0;
f010aeb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010aeb4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	}

	unmap_frame(ptr_page_directory, page_va);
f010aebb:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010aec0:	83 ec 08             	sub    $0x8,%esp
f010aec3:	ff 75 f0             	pushl  -0x10(%ebp)
f010aec6:	50                   	push   %eax
f010aec7:	e8 a0 ed ff ff       	call   f0109c6c <unmap_frame>
f010aecc:	83 c4 10             	add    $0x10,%esp
}
f010aecf:	90                   	nop
f010aed0:	c9                   	leave  
f010aed1:	c3                   	ret    

f010aed2 <kmalloc>:

void* kmalloc(unsigned int size)
{
f010aed2:	55                   	push   %ebp
f010aed3:	89 e5                	mov    %esp,%ebp
f010aed5:	83 ec 58             	sub    $0x58,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #1 kmalloc
		//Your code is here
		//Comment the following line
		//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
#if USE_KHEAP
	if (size == 0)
f010aed8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aedc:	75 0a                	jne    f010aee8 <kmalloc+0x16>
		return NULL;
f010aede:	b8 00 00 00 00       	mov    $0x0,%eax
f010aee3:	e9 69 03 00 00       	jmp    f010b251 <kmalloc+0x37f>

	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE) {
f010aee8:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f010aeef:	77 13                	ja     f010af04 <kmalloc+0x32>
		return alloc_block(size);
f010aef1:	83 ec 0c             	sub    $0xc,%esp
f010aef4:	ff 75 08             	pushl  0x8(%ebp)
f010aef7:	e8 8b 8d 01 00       	call   f0123c87 <alloc_block>
f010aefc:	83 c4 10             	add    $0x10,%esp
f010aeff:	e9 4d 03 00 00       	jmp    f010b251 <kmalloc+0x37f>
	}

	int held = holding_kspinlock(&kheap_lock);
f010af04:	83 ec 0c             	sub    $0xc,%esp
f010af07:	68 60 40 92 f0       	push   $0xf0924060
f010af0c:	e8 89 88 00 00       	call   f011379a <holding_kspinlock>
f010af11:	83 c4 10             	add    $0x10,%esp
f010af14:	89 45 cc             	mov    %eax,-0x34(%ebp)



	if (!held)
f010af17:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010af1b:	75 10                	jne    f010af2d <kmalloc+0x5b>
		acquire_kspinlock(&kheap_lock);
f010af1d:	83 ec 0c             	sub    $0xc,%esp
f010af20:	68 60 40 92 f0       	push   $0xf0924060
f010af25:	e8 1b 86 00 00       	call   f0113545 <acquire_kspinlock>
f010af2a:	83 c4 10             	add    $0x10,%esp


	uint32 req_size;


	if (size % PAGE_SIZE == 0) {
f010af2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010af30:	25 ff 0f 00 00       	and    $0xfff,%eax
f010af35:	85 c0                	test   %eax,%eax
f010af37:	75 08                	jne    f010af41 <kmalloc+0x6f>
		req_size = size;
f010af39:	8b 45 08             	mov    0x8(%ebp),%eax
f010af3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010af3f:	eb 0d                	jmp    f010af4e <kmalloc+0x7c>
	} else {
		req_size = ((size / PAGE_SIZE) + 1) * PAGE_SIZE;
f010af41:	8b 45 08             	mov    0x8(%ebp),%eax
f010af44:	c1 e8 0c             	shr    $0xc,%eax
f010af47:	40                   	inc    %eax
f010af48:	c1 e0 0c             	shl    $0xc,%eax
f010af4b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	}
	uint32 npages = req_size / PAGE_SIZE;
f010af4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af51:	c1 e8 0c             	shr    $0xc,%eax
f010af54:	89 45 c8             	mov    %eax,-0x38(%ebp)

	if (kheapPageAllocStart == 0) {
f010af57:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010af5c:	85 c0                	test   %eax,%eax
f010af5e:	75 20                	jne    f010af80 <kmalloc+0xae>

		if (!held) {
f010af60:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010af64:	75 10                	jne    f010af76 <kmalloc+0xa4>
			release_kspinlock(&kheap_lock);}
f010af66:	83 ec 0c             	sub    $0xc,%esp
f010af69:	68 60 40 92 f0       	push   $0xf0924060
f010af6e:	e8 77 86 00 00       	call   f01135ea <release_kspinlock>
f010af73:	83 c4 10             	add    $0x10,%esp

		return NULL;
f010af76:	b8 00 00 00 00       	mov    $0x0,%eax
f010af7b:	e9 d1 02 00 00       	jmp    f010b251 <kmalloc+0x37f>

	}

	if (kheapPageAllocBreak == 0 || kheapPageAllocBreak < kheapPageAllocStart) {
f010af80:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f010af85:	85 c0                	test   %eax,%eax
f010af87:	74 0f                	je     f010af98 <kmalloc+0xc6>
f010af89:	8b 15 b0 51 96 f1    	mov    0xf19651b0,%edx
f010af8f:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010af94:	39 c2                	cmp    %eax,%edx
f010af96:	73 0a                	jae    f010afa2 <kmalloc+0xd0>

		kheapPageAllocBreak = kheapPageAllocStart;
f010af98:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010af9d:	a3 b0 51 96 f1       	mov    %eax,0xf19651b0
	}

	void* allocated_va = NULL;
f010afa2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	struct FreePageBlock *best_block = NULL;
f010afa9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	   uint32 best_block_start = 0;
f010afb0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	uint32 best_block_size = 0;
f010afb7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	int from_free_list = 0;
f010afbe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	struct FreePageBlock *curr;


	LIST_FOREACH(curr, &free_blocks_list) {
f010afc5:	a1 40 40 92 f0       	mov    0xf0924040,%eax
f010afca:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010afcd:	eb 69                	jmp    f010b038 <kmalloc+0x166>

		if (curr->size >= req_size) {
f010afcf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010afd2:	8b 40 0c             	mov    0xc(%eax),%eax
f010afd5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010afd8:	72 56                	jb     f010b030 <kmalloc+0x15e>

			if (curr->size == req_size) {
f010afda:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010afdd:	8b 40 0c             	mov    0xc(%eax),%eax
f010afe0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010afe3:	75 21                	jne    f010b006 <kmalloc+0x134>

				best_block = curr;
f010afe5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010afe8:	89 45 ec             	mov    %eax,-0x14(%ebp)
			     	best_block_start = curr->start_va;
f010afeb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010afee:	8b 40 08             	mov    0x8(%eax),%eax
f010aff1:	89 45 e8             	mov    %eax,-0x18(%ebp)
				best_block_size = curr->size;
f010aff4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aff7:	8b 40 0c             	mov    0xc(%eax),%eax
f010affa:	89 45 e4             	mov    %eax,-0x1c(%ebp)

				from_free_list = 1;
f010affd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
				break;
f010b004:	eb 60                	jmp    f010b066 <kmalloc+0x194>
			}
			if (curr->size > best_block_size) {
f010b006:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b009:	8b 40 0c             	mov    0xc(%eax),%eax
f010b00c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010b00f:	76 1f                	jbe    f010b030 <kmalloc+0x15e>
				best_block = curr;
f010b011:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b014:	89 45 ec             	mov    %eax,-0x14(%ebp)


				best_block_start = curr->start_va;
f010b017:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b01a:	8b 40 08             	mov    0x8(%eax),%eax
f010b01d:	89 45 e8             	mov    %eax,-0x18(%ebp)


				best_block_size = curr->size;
f010b020:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b023:	8b 40 0c             	mov    0xc(%eax),%eax
f010b026:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				from_free_list = 1;
f010b029:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int from_free_list = 0;

	struct FreePageBlock *curr;


	LIST_FOREACH(curr, &free_blocks_list) {
f010b030:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010b035:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b038:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010b03c:	74 07                	je     f010b045 <kmalloc+0x173>
f010b03e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b041:	8b 00                	mov    (%eax),%eax
f010b043:	eb 05                	jmp    f010b04a <kmalloc+0x178>
f010b045:	b8 00 00 00 00       	mov    $0x0,%eax
f010b04a:	a3 48 40 92 f0       	mov    %eax,0xf0924048
f010b04f:	a1 48 40 92 f0       	mov    0xf0924048,%eax
f010b054:	85 c0                	test   %eax,%eax
f010b056:	0f 85 73 ff ff ff    	jne    f010afcf <kmalloc+0xfd>
f010b05c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010b060:	0f 85 69 ff ff ff    	jne    f010afcf <kmalloc+0xfd>

			}
		}
	}

	if (best_block != NULL) {
f010b066:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010b06a:	74 43                	je     f010b0af <kmalloc+0x1dd>

		  allocated_va = (void*)best_block_start;
f010b06c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b06f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		remove_free_block(best_block);
f010b072:	83 ec 0c             	sub    $0xc,%esp
f010b075:	ff 75 ec             	pushl  -0x14(%ebp)
f010b078:	e8 7e f9 ff ff       	call   f010a9fb <remove_free_block>
f010b07d:	83 c4 10             	add    $0x10,%esp

		if (best_block_size > req_size) {
f010b080:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b083:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010b086:	76 79                	jbe    f010b101 <kmalloc+0x22f>
		         	uint32 remainder_start = best_block_start + req_size;
f010b088:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b08b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b08e:	01 d0                	add    %edx,%eax
f010b090:	89 45 c4             	mov    %eax,-0x3c(%ebp)


			uint32 remainder_size = best_block_size - req_size;
f010b093:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b096:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010b099:	89 45 c0             	mov    %eax,-0x40(%ebp)


			insert_free_block_sorted(remainder_start, remainder_size);
f010b09c:	83 ec 08             	sub    $0x8,%esp
f010b09f:	ff 75 c0             	pushl  -0x40(%ebp)
f010b0a2:	ff 75 c4             	pushl  -0x3c(%ebp)
f010b0a5:	e8 92 f6 ff ff       	call   f010a73c <insert_free_block_sorted>
f010b0aa:	83 c4 10             	add    $0x10,%esp
f010b0ad:	eb 52                	jmp    f010b101 <kmalloc+0x22f>
		}
	} else {
		if (kheapPageAllocBreak > KERNEL_HEAP_MAX - req_size) {
f010b0af:	b8 00 f0 ff ff       	mov    $0xfffff000,%eax
f010b0b4:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010b0b7:	89 c2                	mov    %eax,%edx
f010b0b9:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f010b0be:	39 c2                	cmp    %eax,%edx
f010b0c0:	73 20                	jae    f010b0e2 <kmalloc+0x210>

			if (!held) {
f010b0c2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b0c6:	75 10                	jne    f010b0d8 <kmalloc+0x206>
				release_kspinlock(&kheap_lock);
f010b0c8:	83 ec 0c             	sub    $0xc,%esp
f010b0cb:	68 60 40 92 f0       	push   $0xf0924060
f010b0d0:	e8 15 85 00 00       	call   f01135ea <release_kspinlock>
f010b0d5:	83 c4 10             	add    $0x10,%esp
			}
			return NULL;
f010b0d8:	b8 00 00 00 00       	mov    $0x0,%eax
f010b0dd:	e9 6f 01 00 00       	jmp    f010b251 <kmalloc+0x37f>
		}

		allocated_va = (void*)kheapPageAllocBreak;
f010b0e2:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f010b0e7:	89 45 f0             	mov    %eax,-0x10(%ebp)


		kheapPageAllocBreak += req_size;
f010b0ea:	8b 15 b0 51 96 f1    	mov    0xf19651b0,%edx
f010b0f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b0f3:	01 d0                	add    %edx,%eax
f010b0f5:	a3 b0 51 96 f1       	mov    %eax,0xf19651b0
		from_free_list = 0;
f010b0fa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}

	uint32 va_to_map = (uint32)allocated_va;
f010b101:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b104:	89 45 d8             	mov    %eax,-0x28(%ebp)
	for (uint32 i = 0; i < npages; i++) {
f010b107:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010b10e:	e9 ed 00 00 00       	jmp    f010b200 <kmalloc+0x32e>

		int ret = alloc_page(ptr_page_directory, va_to_map, PERM_WRITEABLE, 1);
f010b113:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010b118:	6a 01                	push   $0x1
f010b11a:	6a 02                	push   $0x2
f010b11c:	ff 75 d8             	pushl  -0x28(%ebp)
f010b11f:	50                   	push   %eax
f010b120:	e8 b5 05 00 00       	call   f010b6da <alloc_page>
f010b125:	83 c4 10             	add    $0x10,%esp
f010b128:	89 45 bc             	mov    %eax,-0x44(%ebp)

		if (ret < 0) {
f010b12b:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b12f:	79 79                	jns    f010b1aa <kmalloc+0x2d8>

			for (uint32 j = 0; j < i; j++) {
f010b131:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010b138:	eb 22                	jmp    f010b15c <kmalloc+0x28a>

				unmap_frame(ptr_page_directory, (uint32)allocated_va + j * PAGE_SIZE);
f010b13a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b13d:	c1 e0 0c             	shl    $0xc,%eax
f010b140:	89 c2                	mov    %eax,%edx
f010b142:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b145:	01 c2                	add    %eax,%edx
f010b147:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010b14c:	83 ec 08             	sub    $0x8,%esp
f010b14f:	52                   	push   %edx
f010b150:	50                   	push   %eax
f010b151:	e8 16 eb ff ff       	call   f0109c6c <unmap_frame>
f010b156:	83 c4 10             	add    $0x10,%esp

		int ret = alloc_page(ptr_page_directory, va_to_map, PERM_WRITEABLE, 1);

		if (ret < 0) {

			for (uint32 j = 0; j < i; j++) {
f010b159:	ff 45 d0             	incl   -0x30(%ebp)
f010b15c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b15f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b162:	72 d6                	jb     f010b13a <kmalloc+0x268>

				unmap_frame(ptr_page_directory, (uint32)allocated_va + j * PAGE_SIZE);
			}
			if (from_free_list) {
f010b164:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010b168:	74 13                	je     f010b17d <kmalloc+0x2ab>
				insert_free_block_sorted(best_block_start, best_block_size);
f010b16a:	83 ec 08             	sub    $0x8,%esp
f010b16d:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b170:	ff 75 e8             	pushl  -0x18(%ebp)
f010b173:	e8 c4 f5 ff ff       	call   f010a73c <insert_free_block_sorted>
f010b178:	83 c4 10             	add    $0x10,%esp
f010b17b:	eb 0d                	jmp    f010b18a <kmalloc+0x2b8>
			} else {
				kheapPageAllocBreak -= req_size;
f010b17d:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f010b182:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010b185:	a3 b0 51 96 f1       	mov    %eax,0xf19651b0
			}
			if (!held) {
f010b18a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b18e:	75 10                	jne    f010b1a0 <kmalloc+0x2ce>
				release_kspinlock(&kheap_lock);
f010b190:	83 ec 0c             	sub    $0xc,%esp
f010b193:	68 60 40 92 f0       	push   $0xf0924060
f010b198:	e8 4d 84 00 00       	call   f01135ea <release_kspinlock>
f010b19d:	83 c4 10             	add    $0x10,%esp
			}
			return NULL;
f010b1a0:	b8 00 00 00 00       	mov    $0x0,%eax
f010b1a5:	e9 a7 00 00 00       	jmp    f010b251 <kmalloc+0x37f>
		}

		if (ret == 0 || ret == 1) {
f010b1aa:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b1ae:	74 06                	je     f010b1b6 <kmalloc+0x2e4>
f010b1b0:	83 7d bc 01          	cmpl   $0x1,-0x44(%ebp)
f010b1b4:	75 40                	jne    f010b1f6 <kmalloc+0x324>
			uint32 *pt = NULL;
f010b1b6:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
			struct FrameInfo *fi = get_frame_info_safe(va_to_map, &pt);
f010b1bd:	83 ec 08             	sub    $0x8,%esp
f010b1c0:	8d 45 ac             	lea    -0x54(%ebp),%eax
f010b1c3:	50                   	push   %eax
f010b1c4:	ff 75 d8             	pushl  -0x28(%ebp)
f010b1c7:	e8 51 f5 ff ff       	call   f010a71d <get_frame_info_safe>
f010b1cc:	83 c4 10             	add    $0x10,%esp
f010b1cf:	89 45 b8             	mov    %eax,-0x48(%ebp)
			if (fi != NULL) {
f010b1d2:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010b1d6:	74 1e                	je     f010b1f6 <kmalloc+0x324>

				if (fi->va == 0 || fi->va != va_to_map) {
f010b1d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b1db:	8b 40 10             	mov    0x10(%eax),%eax
f010b1de:	85 c0                	test   %eax,%eax
f010b1e0:	74 0b                	je     f010b1ed <kmalloc+0x31b>
f010b1e2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b1e5:	8b 40 10             	mov    0x10(%eax),%eax
f010b1e8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b1eb:	74 09                	je     f010b1f6 <kmalloc+0x324>
					fi->va = va_to_map;
f010b1ed:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b1f0:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010b1f3:	89 50 10             	mov    %edx,0x10(%eax)
				}
			}
		}

		va_to_map += PAGE_SIZE;
f010b1f6:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
		kheapPageAllocBreak += req_size;
		from_free_list = 0;
	}

	uint32 va_to_map = (uint32)allocated_va;
	for (uint32 i = 0; i < npages; i++) {
f010b1fd:	ff 45 d4             	incl   -0x2c(%ebp)
f010b200:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b203:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010b206:	0f 82 07 ff ff ff    	jb     f010b113 <kmalloc+0x241>
		}

		va_to_map += PAGE_SIZE;
	}

	uint32 *pt = NULL;
f010b20c:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
	struct FrameInfo *fi = get_frame_info_safe((uint32)allocated_va, &pt);
f010b213:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b216:	83 ec 08             	sub    $0x8,%esp
f010b219:	8d 55 b0             	lea    -0x50(%ebp),%edx
f010b21c:	52                   	push   %edx
f010b21d:	50                   	push   %eax
f010b21e:	e8 fa f4 ff ff       	call   f010a71d <get_frame_info_safe>
f010b223:	83 c4 10             	add    $0x10,%esp
f010b226:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (fi != NULL) {
f010b229:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f010b22d:	74 09                	je     f010b238 <kmalloc+0x366>
		fi->size = req_size;
f010b22f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b232:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b235:	89 50 14             	mov    %edx,0x14(%eax)
	}

	if (!held) {
f010b238:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b23c:	75 10                	jne    f010b24e <kmalloc+0x37c>
		release_kspinlock(&kheap_lock);
f010b23e:	83 ec 0c             	sub    $0xc,%esp
f010b241:	68 60 40 92 f0       	push   $0xf0924060
f010b246:	e8 9f 83 00 00       	call   f01135ea <release_kspinlock>
f010b24b:	83 c4 10             	add    $0x10,%esp
	}

	return allocated_va;
f010b24e:	8b 45 f0             	mov    -0x10(%ebp),%eax
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

	//TODO: [PROJECT'25.BONUS#3] FAST PAGE ALLOCATOR
}
f010b251:	c9                   	leave  
f010b252:	c3                   	ret    

f010b253 <kfree>:

void kfree(void* va)
{
f010b253:	55                   	push   %ebp
f010b254:	89 e5                	mov    %esp,%ebp
f010b256:	83 ec 38             	sub    $0x38,%esp
#if USE_KHEAP
	if (!va) return;
f010b259:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b25d:	0f 84 b4 01 00 00    	je     f010b417 <kfree+0x1c4>

	uint32 vAddr = (uint32)va;
f010b263:	8b 45 08             	mov    0x8(%ebp),%eax
f010b266:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (vAddr >= KERNEL_HEAP_START && vAddr < dynAllocEnd) {
f010b269:	81 7d f0 ff ff ff f5 	cmpl   $0xf5ffffff,-0x10(%ebp)
f010b270:	76 1d                	jbe    f010b28f <kfree+0x3c>
f010b272:	a1 e0 cb 94 f1       	mov    0xf194cbe0,%eax
f010b277:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f010b27a:	73 13                	jae    f010b28f <kfree+0x3c>
		free_block(va);
f010b27c:	83 ec 0c             	sub    $0xc,%esp
f010b27f:	ff 75 08             	pushl  0x8(%ebp)
f010b282:	e8 5a 8f 01 00       	call   f01241e1 <free_block>
f010b287:	83 c4 10             	add    $0x10,%esp
		return;
f010b28a:	e9 8f 01 00 00       	jmp    f010b41e <kfree+0x1cb>
	}

	if (vAddr >= kheapPageAllocStart && vAddr < KERNEL_HEAP_MAX) {
f010b28f:	a1 9c cf 94 f1       	mov    0xf194cf9c,%eax
f010b294:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f010b297:	0f 82 63 01 00 00    	jb     f010b400 <kfree+0x1ad>
f010b29d:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010b2a4:	0f 87 56 01 00 00    	ja     f010b400 <kfree+0x1ad>
		     int lock_already_held = holding_kspinlock(&kheap_lock);
f010b2aa:	83 ec 0c             	sub    $0xc,%esp
f010b2ad:	68 60 40 92 f0       	push   $0xf0924060
f010b2b2:	e8 e3 84 00 00       	call   f011379a <holding_kspinlock>
f010b2b7:	83 c4 10             	add    $0x10,%esp
f010b2ba:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (!lock_already_held) {
f010b2bd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010b2c1:	75 10                	jne    f010b2d3 <kfree+0x80>
			acquire_kspinlock(&kheap_lock);
f010b2c3:	83 ec 0c             	sub    $0xc,%esp
f010b2c6:	68 60 40 92 f0       	push   $0xf0924060
f010b2cb:	e8 75 82 00 00       	call   f0113545 <acquire_kspinlock>
f010b2d0:	83 c4 10             	add    $0x10,%esp
		}

		if (vAddr % PAGE_SIZE != 0) {
f010b2d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b2d6:	25 ff 0f 00 00       	and    $0xfff,%eax
f010b2db:	85 c0                	test   %eax,%eax
f010b2dd:	74 2d                	je     f010b30c <kfree+0xb9>
			if (!lock_already_held) {
f010b2df:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010b2e3:	75 10                	jne    f010b2f5 <kfree+0xa2>
				release_kspinlock(&kheap_lock);
f010b2e5:	83 ec 0c             	sub    $0xc,%esp
f010b2e8:	68 60 40 92 f0       	push   $0xf0924060
f010b2ed:	e8 f8 82 00 00       	call   f01135ea <release_kspinlock>
f010b2f2:	83 c4 10             	add    $0x10,%esp
			}
			panic("kfree: address not page-aligned");
f010b2f5:	83 ec 04             	sub    $0x4,%esp
f010b2f8:	68 70 7a 13 f0       	push   $0xf0137a70
f010b2fd:	68 cb 01 00 00       	push   $0x1cb
f010b302:	68 9e 79 13 f0       	push   $0xf013799e
f010b307:	e8 a3 5b ff ff       	call   f0100eaf <_panic>
		}

		uint32* pt = NULL;
f010b30c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		struct FrameInfo* fi = get_frame_info_safe(vAddr, &pt);
f010b313:	83 ec 08             	sub    $0x8,%esp
f010b316:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010b319:	50                   	push   %eax
f010b31a:	ff 75 f0             	pushl  -0x10(%ebp)
f010b31d:	e8 fb f3 ff ff       	call   f010a71d <get_frame_info_safe>
f010b322:	83 c4 10             	add    $0x10,%esp
f010b325:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (!fi || fi->size == 0) {
f010b328:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010b32c:	74 0a                	je     f010b338 <kfree+0xe5>
f010b32e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b331:	8b 40 14             	mov    0x14(%eax),%eax
f010b334:	85 c0                	test   %eax,%eax
f010b336:	75 1f                	jne    f010b357 <kfree+0x104>

			if (!lock_already_held) {
f010b338:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010b33c:	0f 85 d8 00 00 00    	jne    f010b41a <kfree+0x1c7>
				release_kspinlock(&kheap_lock);
f010b342:	83 ec 0c             	sub    $0xc,%esp
f010b345:	68 60 40 92 f0       	push   $0xf0924060
f010b34a:	e8 9b 82 00 00       	call   f01135ea <release_kspinlock>
f010b34f:	83 c4 10             	add    $0x10,%esp
			}
			return;
f010b352:	e9 c3 00 00 00       	jmp    f010b41a <kfree+0x1c7>
		}

		uint32 size = fi->size;
f010b357:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b35a:	8b 40 14             	mov    0x14(%eax),%eax
f010b35d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 end = vAddr + size;
f010b360:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b363:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b366:	01 d0                	add    %edx,%eax
f010b368:	89 45 e0             	mov    %eax,-0x20(%ebp)

		for (uint32 addr = vAddr; addr < end; addr += PAGE_SIZE) {
f010b36b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b36e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b371:	eb 47                	jmp    f010b3ba <kfree+0x167>
			uint32 *pt_temp = NULL;
f010b373:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			struct FrameInfo *fi_page = get_frame_info_safe(addr, &pt_temp);
f010b37a:	83 ec 08             	sub    $0x8,%esp
f010b37d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010b380:	50                   	push   %eax
f010b381:	ff 75 f4             	pushl  -0xc(%ebp)
f010b384:	e8 94 f3 ff ff       	call   f010a71d <get_frame_info_safe>
f010b389:	83 c4 10             	add    $0x10,%esp
f010b38c:	89 45 dc             	mov    %eax,-0x24(%ebp)
			if (fi_page != NULL) {
f010b38f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010b393:	74 0a                	je     f010b39f <kfree+0x14c>
				fi_page->va = 0;
f010b395:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b398:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
			}
			unmap_frame(ptr_page_directory, addr);
f010b39f:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010b3a4:	83 ec 08             	sub    $0x8,%esp
f010b3a7:	ff 75 f4             	pushl  -0xc(%ebp)
f010b3aa:	50                   	push   %eax
f010b3ab:	e8 bc e8 ff ff       	call   f0109c6c <unmap_frame>
f010b3b0:	83 c4 10             	add    $0x10,%esp
		}

		uint32 size = fi->size;
		uint32 end = vAddr + size;

		for (uint32 addr = vAddr; addr < end; addr += PAGE_SIZE) {
f010b3b3:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b3ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3bd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f010b3c0:	72 b1                	jb     f010b373 <kfree+0x120>
				fi_page->va = 0;
			}
			unmap_frame(ptr_page_directory, addr);
		}

		fi->size = 0;
f010b3c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3c5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

		insert_free_block_sorted(vAddr, size);
f010b3cc:	83 ec 08             	sub    $0x8,%esp
f010b3cf:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b3d2:	ff 75 f0             	pushl  -0x10(%ebp)
f010b3d5:	e8 62 f3 ff ff       	call   f010a73c <insert_free_block_sorted>
f010b3da:	83 c4 10             	add    $0x10,%esp

		merge_adjacent_blocks();
f010b3dd:	e8 af f6 ff ff       	call   f010aa91 <merge_adjacent_blocks>

		update_break();
f010b3e2:	e8 15 f7 ff ff       	call   f010aafc <update_break>

		if (!lock_already_held) {
f010b3e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010b3eb:	75 30                	jne    f010b41d <kfree+0x1ca>
			release_kspinlock(&kheap_lock);
f010b3ed:	83 ec 0c             	sub    $0xc,%esp
f010b3f0:	68 60 40 92 f0       	push   $0xf0924060
f010b3f5:	e8 f0 81 00 00       	call   f01135ea <release_kspinlock>
f010b3fa:	83 c4 10             	add    $0x10,%esp
		}

		return;
f010b3fd:	90                   	nop
f010b3fe:	eb 1d                	jmp    f010b41d <kfree+0x1ca>
	}

	panic("kfree: invalid address");
f010b400:	83 ec 04             	sub    $0x4,%esp
f010b403:	68 90 7a 13 f0       	push   $0xf0137a90
f010b408:	68 f3 01 00 00       	push   $0x1f3
f010b40d:	68 9e 79 13 f0       	push   $0xf013799e
f010b412:	e8 98 5a ff ff       	call   f0100eaf <_panic>
}

void kfree(void* va)
{
#if USE_KHEAP
	if (!va) return;
f010b417:	90                   	nop
f010b418:	eb 04                	jmp    f010b41e <kfree+0x1cb>
		if (!fi || fi->size == 0) {

			if (!lock_already_held) {
				release_kspinlock(&kheap_lock);
			}
			return;
f010b41a:	90                   	nop
f010b41b:	eb 01                	jmp    f010b41e <kfree+0x1cb>

		if (!lock_already_held) {
			release_kspinlock(&kheap_lock);
		}

		return;
f010b41d:	90                   	nop
	panic("kfree: invalid address");
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

}
f010b41e:	c9                   	leave  
f010b41f:	c3                   	ret    

f010b420 <kheap_virtual_address>:

//=================================
// [3] FIND VA OF GIVEN PA:
//=================================
unsigned int kheap_virtual_address(unsigned int physical_address)
{
f010b420:	55                   	push   %ebp
f010b421:	89 e5                	mov    %esp,%ebp
f010b423:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #3 kheap_virtual_address
	//Your code is here
#if USE_KHEAP
	struct FrameInfo *fi = to_frame_info(physical_address);
f010b426:	83 ec 0c             	sub    $0xc,%esp
f010b429:	ff 75 08             	pushl  0x8(%ebp)
f010b42c:	e8 9a f2 ff ff       	call   f010a6cb <to_frame_info>
f010b431:	83 c4 10             	add    $0x10,%esp
f010b434:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (fi == NULL) {
f010b437:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b43b:	75 07                	jne    f010b444 <kheap_virtual_address+0x24>
		return 0;
f010b43d:	b8 00 00 00 00       	mov    $0x0,%eax
f010b442:	eb 46                	jmp    f010b48a <kheap_virtual_address+0x6a>
	}

	if (fi->va == 0) {
f010b444:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b447:	8b 40 10             	mov    0x10(%eax),%eax
f010b44a:	85 c0                	test   %eax,%eax
f010b44c:	75 07                	jne    f010b455 <kheap_virtual_address+0x35>
		return 0;
f010b44e:	b8 00 00 00 00       	mov    $0x0,%eax
f010b453:	eb 35                	jmp    f010b48a <kheap_virtual_address+0x6a>
	}

	uint32 va = fi->va;
f010b455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b458:	8b 40 10             	mov    0x10(%eax),%eax
f010b45b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (va < KERNEL_HEAP_START || va >= KERNEL_HEAP_MAX) {
f010b45e:	81 7d f0 ff ff ff f5 	cmpl   $0xf5ffffff,-0x10(%ebp)
f010b465:	76 09                	jbe    f010b470 <kheap_virtual_address+0x50>
f010b467:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010b46e:	76 07                	jbe    f010b477 <kheap_virtual_address+0x57>
		return 0;
f010b470:	b8 00 00 00 00       	mov    $0x0,%eax
f010b475:	eb 13                	jmp    f010b48a <kheap_virtual_address+0x6a>
	}

	uint32 offset = PGOFF(physical_address);
f010b477:	8b 45 08             	mov    0x8(%ebp),%eax
f010b47a:	25 ff 0f 00 00       	and    $0xfff,%eax
f010b47f:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Return virtual address with offset
	return va + offset;
f010b482:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b485:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b488:	01 d0                	add    %edx,%eax

	//Comment the following line
	//panic("kheap_virtual_address() is not implemented yet...!!");

	/*EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED */
}
f010b48a:	c9                   	leave  
f010b48b:	c3                   	ret    

f010b48c <kheap_physical_address>:

//=================================
// [4] FIND PA OF GIVEN VA:
//=================================
unsigned int kheap_physical_address(unsigned int virtual_address)
{
f010b48c:	55                   	push   %ebp
f010b48d:	89 e5                	mov    %esp,%ebp
f010b48f:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #4 kheap_physical_address
	//Your code is here
#if USE_KHEAP
	unsigned int *ptr_page_table = NULL;
f010b492:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f010b499:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010b49e:	83 ec 04             	sub    $0x4,%esp
f010b4a1:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f010b4a4:	52                   	push   %edx
f010b4a5:	ff 75 08             	pushl  0x8(%ebp)
f010b4a8:	50                   	push   %eax
f010b4a9:	e8 3c e7 ff ff       	call   f0109bea <get_frame_info>
f010b4ae:	83 c4 10             	add    $0x10,%esp
f010b4b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) {
f010b4b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b4b8:	75 07                	jne    f010b4c1 <kheap_physical_address+0x35>
		return 0;
f010b4ba:	b8 00 00 00 00       	mov    $0x0,%eax
f010b4bf:	eb 2a                	jmp    f010b4eb <kheap_physical_address+0x5f>
	}

	unsigned int frame = to_physical_address(ptr_frame_info);
f010b4c1:	83 ec 0c             	sub    $0xc,%esp
f010b4c4:	ff 75 f4             	pushl  -0xc(%ebp)
f010b4c7:	e8 ec f1 ff ff       	call   f010a6b8 <to_physical_address>
f010b4cc:	83 c4 10             	add    $0x10,%esp
f010b4cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned int offset = PGOFF(virtual_address);
f010b4d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4d5:	25 ff 0f 00 00       	and    $0xfff,%eax
f010b4da:	89 45 ec             	mov    %eax,-0x14(%ebp)
	unsigned int pa = frame + offset;
f010b4dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b4e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b4e3:	01 d0                	add    %edx,%eax
f010b4e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return pa;
f010b4e8:	8b 45 e8             	mov    -0x18(%ebp),%eax

	//Comment the following line
	//panic("kheap_physical_address() is not implemented yet...!!");

	/*EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED */
}
f010b4eb:	c9                   	leave  
f010b4ec:	c3                   	ret    

f010b4ed <krealloc>:

//  A call with virtual_address = null is equivalent to kmalloc().
//  A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f010b4ed:	55                   	push   %ebp
f010b4ee:	89 e5                	mov    %esp,%ebp
f010b4f0:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - krealloc
	//Your code is here
	//Comment the following line

	panic("krealloc() is not implemented yet...!!");
f010b4f3:	83 ec 04             	sub    $0x4,%esp
f010b4f6:	68 a8 7a 13 f0       	push   $0xf0137aa8
f010b4fb:	68 4d 02 00 00       	push   $0x24d
f010b500:	68 9e 79 13 f0       	push   $0xf013799e
f010b505:	e8 a5 59 ff ff       	call   f0100eaf <_panic>

f010b50a <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010b50a:	55                   	push   %ebp
f010b50b:	89 e5                	mov    %esp,%ebp
f010b50d:	53                   	push   %ebx
f010b50e:	83 ec 04             	sub    $0x4,%esp
	if (PPN(physical_address) >= number_of_frames)
f010b511:	8b 45 08             	mov    0x8(%ebp),%eax
f010b514:	c1 e8 0c             	shr    $0xc,%eax
f010b517:	89 c2                	mov    %eax,%edx
f010b519:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f010b51e:	39 c2                	cmp    %eax,%edx
f010b520:	72 14                	jb     f010b536 <to_frame_info+0x2c>
		panic("to_frame_info called with invalid pa");
f010b522:	83 ec 04             	sub    $0x4,%esp
f010b525:	68 d0 7a 13 f0       	push   $0xf0137ad0
f010b52a:	6a 4e                	push   $0x4e
f010b52c:	68 f5 7a 13 f0       	push   $0xf0137af5
f010b531:	e8 79 59 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f010b536:	8b 0d a8 51 96 f1    	mov    0xf19651a8,%ecx
f010b53c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b53f:	c1 e8 0c             	shr    $0xc,%eax
f010b542:	89 c2                	mov    %eax,%edx
f010b544:	89 d0                	mov    %edx,%eax
f010b546:	01 c0                	add    %eax,%eax
f010b548:	01 d0                	add    %edx,%eax
f010b54a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b551:	01 d8                	add    %ebx,%eax
f010b553:	01 d0                	add    %edx,%eax
f010b555:	01 c8                	add    %ecx,%eax
}
f010b557:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b55a:	c9                   	leave  
f010b55b:	c3                   	ret    

f010b55c <pt_set_page_permissions>:
//	1. Set to 1 all "permissions_to_set"
//	2. Set to 0 all "permissions_to_reset"
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_set_page_permissions(uint32* directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f010b55c:	55                   	push   %ebp
f010b55d:	89 e5                	mov    %esp,%ebp
f010b55f:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(directory, virtual_address, &ptr_page_table);
f010b562:	83 ec 04             	sub    $0x4,%esp
f010b565:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010b568:	50                   	push   %eax
f010b569:	ff 75 0c             	pushl  0xc(%ebp)
f010b56c:	ff 75 08             	pushl  0x8(%ebp)
f010b56f:	e8 f3 e2 ff ff       	call   f0109867 <get_page_table>
f010b574:	83 c4 10             	add    $0x10,%esp
f010b577:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010b57a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b57d:	85 c0                	test   %eax,%eax
f010b57f:	74 64                	je     f010b5e5 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f010b581:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b584:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b587:	c1 ea 0c             	shr    $0xc,%edx
f010b58a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b590:	c1 e2 02             	shl    $0x2,%edx
f010b593:	01 c2                	add    %eax,%edx
f010b595:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b598:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010b59b:	c1 e9 0c             	shr    $0xc,%ecx
f010b59e:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b5a4:	c1 e1 02             	shl    $0x2,%ecx
f010b5a7:	01 c8                	add    %ecx,%eax
f010b5a9:	8b 00                	mov    (%eax),%eax
f010b5ab:	0b 45 10             	or     0x10(%ebp),%eax
f010b5ae:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010b5b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b5b3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b5b6:	c1 ea 0c             	shr    $0xc,%edx
f010b5b9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b5bf:	c1 e2 02             	shl    $0x2,%edx
f010b5c2:	01 d0                	add    %edx,%eax
f010b5c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b5c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010b5ca:	c1 e9 0c             	shr    $0xc,%ecx
f010b5cd:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b5d3:	c1 e1 02             	shl    $0x2,%ecx
f010b5d6:	01 ca                	add    %ecx,%edx
f010b5d8:	8b 12                	mov    (%edx),%edx
f010b5da:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010b5dd:	f7 d1                	not    %ecx
f010b5df:	21 ca                	and    %ecx,%edx
f010b5e1:	89 10                	mov    %edx,(%eax)
f010b5e3:	eb 27                	jmp    f010b60c <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f010b5e5:	83 ec 08             	sub    $0x8,%esp
f010b5e8:	ff 75 0c             	pushl  0xc(%ebp)
f010b5eb:	68 10 7b 13 f0       	push   $0xf0137b10
f010b5f0:	e8 58 65 ff ff       	call   f0101b4d <cprintf>
f010b5f5:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010b5f8:	83 ec 04             	sub    $0x4,%esp
f010b5fb:	68 38 7b 13 f0       	push   $0xf0137b38
f010b600:	6a 27                	push   $0x27
f010b602:	68 ac 7b 13 f0       	push   $0xf0137bac
f010b607:	e8 a3 58 ff ff       	call   f0100eaf <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	//tlb_invalidate(NULL, (void *)virtual_address);
	tlb_invalidate(directory, (void *)virtual_address);
f010b60c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b60f:	83 ec 08             	sub    $0x8,%esp
f010b612:	50                   	push   %eax
f010b613:	ff 75 08             	pushl  0x8(%ebp)
f010b616:	e8 a6 db ff ff       	call   f01091c1 <tlb_invalidate>
f010b61b:	83 c4 10             	add    $0x10,%esp
}
f010b61e:	90                   	nop
f010b61f:	c9                   	leave  
f010b620:	c3                   	ret    

f010b621 <pt_get_page_permissions>:
//2) GET PAGE PERMISSIONS
//===============================
//Should get ALL page permissions of the given VA
//If the page table not exist, return -1
inline int pt_get_page_permissions(uint32* directory, uint32 virtual_address )
{
f010b621:	55                   	push   %ebp
f010b622:	89 e5                	mov    %esp,%ebp
f010b624:	83 ec 18             	sub    $0x18,%esp
	//TODO: PRACTICE: fill this function.

	uint32* ptr_page_table ;
	int ret = get_page_table(directory, virtual_address, &ptr_page_table);
f010b627:	83 ec 04             	sub    $0x4,%esp
f010b62a:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010b62d:	50                   	push   %eax
f010b62e:	ff 75 0c             	pushl  0xc(%ebp)
f010b631:	ff 75 08             	pushl  0x8(%ebp)
f010b634:	e8 2e e2 ff ff       	call   f0109867 <get_page_table>
f010b639:	83 c4 10             	add    $0x10,%esp
f010b63c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (ptr_page_table != NULL)
f010b63f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b642:	85 c0                	test   %eax,%eax
f010b644:	74 1d                	je     f010b663 <pt_get_page_permissions+0x42>
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f010b646:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b649:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b64c:	c1 ea 0c             	shr    $0xc,%edx
f010b64f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b655:	c1 e2 02             	shl    $0x2,%edx
f010b658:	01 d0                	add    %edx,%eax
f010b65a:	8b 00                	mov    (%eax),%eax
f010b65c:	25 ff 0f 00 00       	and    $0xfff,%eax
f010b661:	eb 05                	jmp    f010b668 <pt_get_page_permissions+0x47>
	else
		return -1;
f010b663:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	//Comment the following line
	//panic("pt_get_page_permissions() is not implemented yet!");
}
f010b668:	c9                   	leave  
f010b669:	c3                   	ret    

f010b66a <pt_clear_page_table_entry>:
//Should clear the entire entry of the page table for the given VA
//If the page table not exist, return -1
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_clear_page_table_entry(uint32* directory, uint32 virtual_address)
{
f010b66a:	55                   	push   %ebp
f010b66b:	89 e5                	mov    %esp,%ebp
f010b66d:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_clear_page_table_entry() is not implemented yet!");
f010b670:	83 ec 04             	sub    $0x4,%esp
f010b673:	68 c8 7b 13 f0       	push   $0xf0137bc8
f010b678:	6a 4f                	push   $0x4f
f010b67a:	68 ac 7b 13 f0       	push   $0xf0137bac
f010b67f:	e8 2b 58 ff ff       	call   f0100eaf <_panic>

f010b684 <virtual_to_physical>:
//1) ADDRESS CONVERTION (VA->PA)
//===============================
//return the physical address corresponding to given virtual_address
//If the page or the page table is not present, return -1
inline uint32 virtual_to_physical(uint32* directory, uint32 virtual_address)
{
f010b684:	55                   	push   %ebp
f010b685:	89 e5                	mov    %esp,%ebp
f010b687:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f010b68a:	83 ec 04             	sub    $0x4,%esp
f010b68d:	68 fc 7b 13 f0       	push   $0xf0137bfc
f010b692:	6a 61                	push   $0x61
f010b694:	68 ac 7b 13 f0       	push   $0xf0137bac
f010b699:	e8 11 58 ff ff       	call   f0100eaf <_panic>

f010b69e <physical_to_virtual>:
//===============================
//return the VIRTUAL address corresponding to given physical address
//If multiple VA's, return the first occurrence
//If not found, return 0xFFFFFFFF
inline uint32 physical_to_virtual(uint32* directory, uint32 physical_address)
{
f010b69e:	55                   	push   %ebp
f010b69f:	89 e5                	mov    %esp,%ebp
f010b6a1:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f010b6a4:	83 ec 04             	sub    $0x4,%esp
f010b6a7:	68 fc 7b 13 f0       	push   $0xf0137bfc
f010b6ac:	6a 6e                	push   $0x6e
f010b6ae:	68 ac 7b 13 f0       	push   $0xf0137bac
f010b6b3:	e8 f7 57 ff ff       	call   f0100eaf <_panic>

f010b6b8 <num_of_references>:
//===============================
//3) NUMBER OF REFERENCES
//===============================
//return the number of page references on the frame at the given physical address
inline uint32 num_of_references(uint32 physical_address)
{
f010b6b8:	55                   	push   %ebp
f010b6b9:	89 e5                	mov    %esp,%ebp
f010b6bb:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: fill this function.
	//Comment the following line
//	panic("Function is not implemented yet!");
	struct FrameInfo* ptr_fi = to_frame_info(physical_address);
f010b6be:	83 ec 0c             	sub    $0xc,%esp
f010b6c1:	ff 75 08             	pushl  0x8(%ebp)
f010b6c4:	e8 41 fe ff ff       	call   f010b50a <to_frame_info>
f010b6c9:	83 c4 10             	add    $0x10,%esp
f010b6cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ptr_fi->references;
f010b6cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6d2:	8b 40 08             	mov    0x8(%eax),%eax
f010b6d5:	0f b7 c0             	movzwl %ax,%eax
}
f010b6d8:	c9                   	leave  
f010b6d9:	c3                   	ret    

f010b6da <alloc_page>:
//	0 on success,
//	1 if already mapped
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_page(uint32* directory, uint32 va, uint32 perms, bool set_to_zero)
{
f010b6da:	55                   	push   %ebp
f010b6db:	89 e5                	mov    %esp,%ebp
f010b6dd:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: fill this function.
	//Comment the following line
	//panic("Function is not implemented yet!");
	uint32* ptr_table ;
	struct FrameInfo* ptr_fi = get_frame_info(directory, va, &ptr_table);
f010b6e0:	83 ec 04             	sub    $0x4,%esp
f010b6e3:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010b6e6:	50                   	push   %eax
f010b6e7:	ff 75 0c             	pushl  0xc(%ebp)
f010b6ea:	ff 75 08             	pushl  0x8(%ebp)
f010b6ed:	e8 f8 e4 ff ff       	call   f0109bea <get_frame_info>
f010b6f2:	83 c4 10             	add    $0x10,%esp
f010b6f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ptr_fi != NULL) {
f010b6f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b6fb:	85 c0                	test   %eax,%eax
f010b6fd:	74 07                	je     f010b706 <alloc_page+0x2c>
		return 1;
f010b6ff:	b8 01 00 00 00       	mov    $0x1,%eax
f010b704:	eb 75                	jmp    f010b77b <alloc_page+0xa1>
	}
	else {
		int ret = allocate_frame(&ptr_fi);
f010b706:	83 ec 0c             	sub    $0xc,%esp
f010b709:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010b70c:	50                   	push   %eax
f010b70d:	e8 44 df ff ff       	call   f0109656 <allocate_frame>
f010b712:	83 c4 10             	add    $0x10,%esp
f010b715:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f010b718:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f010b71c:	75 07                	jne    f010b725 <alloc_page+0x4b>
			return E_NO_MEM;
f010b71e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f010b723:	eb 56                	jmp    f010b77b <alloc_page+0xa1>
		}
		ret = map_frame(directory, ptr_fi, va, perms);
f010b725:	8b 55 10             	mov    0x10(%ebp),%edx
f010b728:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b72b:	52                   	push   %edx
f010b72c:	ff 75 0c             	pushl  0xc(%ebp)
f010b72f:	50                   	push   %eax
f010b730:	ff 75 08             	pushl  0x8(%ebp)
f010b733:	e8 bf e3 ff ff       	call   f0109af7 <map_frame>
f010b738:	83 c4 10             	add    $0x10,%esp
f010b73b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f010b73e:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f010b742:	75 16                	jne    f010b75a <alloc_page+0x80>
			free_frame(ptr_fi);
f010b744:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b747:	83 ec 0c             	sub    $0xc,%esp
f010b74a:	50                   	push   %eax
f010b74b:	e8 2e e0 ff ff       	call   f010977e <free_frame>
f010b750:	83 c4 10             	add    $0x10,%esp
			return E_NO_MEM;
f010b753:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f010b758:	eb 21                	jmp    f010b77b <alloc_page+0xa1>
		}
		if (set_to_zero) {
f010b75a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b75e:	74 16                	je     f010b776 <alloc_page+0x9c>
			memset((void*)va, 0, PAGE_SIZE);
f010b760:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b763:	83 ec 04             	sub    $0x4,%esp
f010b766:	68 00 10 00 00       	push   $0x1000
f010b76b:	6a 00                	push   $0x0
f010b76d:	50                   	push   %eax
f010b76e:	e8 aa 78 01 00       	call   f012301d <memset>
f010b773:	83 c4 10             	add    $0x10,%esp
		}
		return 0;
f010b776:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010b77b:	c9                   	leave  
f010b77c:	c3                   	ret    

f010b77d <alloc_shared_page>:
//Return
//	0 on success,
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_shared_page(uint32* page_dir1, uint32 va1,uint32* page_dir2, uint32 va2, uint32 perms)
{
f010b77d:	55                   	push   %ebp
f010b77e:	89 e5                	mov    %esp,%ebp
f010b780:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f010b783:	83 ec 04             	sub    $0x4,%esp
f010b786:	68 fc 7b 13 f0       	push   $0xf0137bfc
f010b78b:	68 b2 00 00 00       	push   $0xb2
f010b790:	68 ac 7b 13 f0       	push   $0xf0137bac
f010b795:	e8 15 57 ff ff       	call   f0100eaf <_panic>

f010b79a <del_page_table>:
//	1. removing the link between the directory and the table and
//	2. adding the frame of the table to the free frame list.

//REMEMBER: to invalidate the TLB cache
inline void del_page_table(uint32* page_dir, uint32 va)
{
f010b79a:	55                   	push   %ebp
f010b79b:	89 e5                	mov    %esp,%ebp
f010b79d:	83 ec 18             	sub    $0x18,%esp
	//Comment the following line
	//panic("Function is not implemented yet!");

	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);
f010b7a0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010b7a5:	83 ec 04             	sub    $0x4,%esp
f010b7a8:	8d 55 ec             	lea    -0x14(%ebp),%edx
f010b7ab:	52                   	push   %edx
f010b7ac:	ff 75 0c             	pushl  0xc(%ebp)
f010b7af:	50                   	push   %eax
f010b7b0:	e8 b2 e0 ff ff       	call   f0109867 <get_page_table>
f010b7b5:	83 c4 10             	add    $0x10,%esp

	if (ptr_page_table == NULL)
f010b7b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b7bb:	85 c0                	test   %eax,%eax
f010b7bd:	74 39                	je     f010b7f8 <del_page_table+0x5e>
		return ;

#if USE_KHEAP
	// directly remove the page table from the kernel heap
	kfree(ptr_page_table);
f010b7bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b7c2:	83 ec 0c             	sub    $0xc,%esp
f010b7c5:	50                   	push   %eax
f010b7c6:	e8 88 fa ff ff       	call   f010b253 <kfree>
f010b7cb:	83 c4 10             	add    $0x10,%esp
	table_frame_info->references = 0;
	free_frame(table_frame_info);
#endif

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f010b7ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b7d1:	c1 e8 16             	shr    $0x16,%eax
f010b7d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_page_directory[dir_index] = 0;
f010b7d7:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010b7dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7df:	c1 e2 02             	shl    $0x2,%edx
f010b7e2:	01 d0                	add    %edx,%eax
f010b7e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010b7ea:	0f 20 d8             	mov    %cr3,%eax
f010b7ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010b7f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b7f3:	0f 22 d8             	mov    %eax,%cr3
f010b7f6:	eb 01                	jmp    f010b7f9 <del_page_table+0x5f>
	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);

	if (ptr_page_table == NULL)
		return ;
f010b7f8:	90                   	nop
	uint32 dir_index = PDX(va);
	ptr_page_directory[dir_index] = 0;

	//clear the TLB cache
	tlbflush();
}
f010b7f9:	c9                   	leave  
f010b7fa:	c3                   	ret    

f010b7fb <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* directory, uint32 virtual_address)
{
f010b7fb:	55                   	push   %ebp
f010b7fc:	89 e5                	mov    %esp,%ebp
	return ( (directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010b7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b801:	c1 e8 16             	shr    $0x16,%eax
f010b804:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b80b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b80e:	01 d0                	add    %edx,%eax
f010b810:	8b 00                	mov    (%eax),%eax
f010b812:	83 e0 20             	and    $0x20,%eax
f010b815:	85 c0                	test   %eax,%eax
f010b817:	0f 95 c0             	setne  %al
f010b81a:	0f b6 c0             	movzbl %al,%eax
}
f010b81d:	5d                   	pop    %ebp
f010b81e:	c3                   	ret    

f010b81f <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* directory, uint32 virtual_address)
{
f010b81f:	55                   	push   %ebp
f010b820:	89 e5                	mov    %esp,%ebp
f010b822:	83 ec 08             	sub    $0x8,%esp
	directory[PDX(virtual_address)] &= (~PERM_USED);
f010b825:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b828:	c1 e8 16             	shr    $0x16,%eax
f010b82b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b832:	8b 45 08             	mov    0x8(%ebp),%eax
f010b835:	01 d0                	add    %edx,%eax
f010b837:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b83a:	c1 ea 16             	shr    $0x16,%edx
f010b83d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f010b844:	8b 55 08             	mov    0x8(%ebp),%edx
f010b847:	01 ca                	add    %ecx,%edx
f010b849:	8b 12                	mov    (%edx),%edx
f010b84b:	83 e2 df             	and    $0xffffffdf,%edx
f010b84e:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010b850:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b853:	83 ec 08             	sub    $0x8,%esp
f010b856:	50                   	push   %eax
f010b857:	6a 00                	push   $0x0
f010b859:	e8 63 d9 ff ff       	call   f01091c1 <tlb_invalidate>
f010b85e:	83 c4 10             	add    $0x10,%esp
}
f010b861:	90                   	nop
f010b862:	c9                   	leave  
f010b863:	c3                   	ret    

f010b864 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* directory, uint32 virtual_address)
{
f010b864:	55                   	push   %ebp
f010b865:	89 e5                	mov    %esp,%ebp
f010b867:	83 ec 10             	sub    $0x10,%esp
	directory[PDX(virtual_address)] = 0 ;
f010b86a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b86d:	c1 e8 16             	shr    $0x16,%eax
f010b870:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b877:	8b 45 08             	mov    0x8(%ebp),%eax
f010b87a:	01 d0                	add    %edx,%eax
f010b87c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010b882:	0f 20 d8             	mov    %cr3,%eax
f010b885:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010b888:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010b88b:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010b88e:	90                   	nop
f010b88f:	c9                   	leave  
f010b890:	c3                   	ret    

f010b891 <env_page_ws_list_create_element>:
//==============================
// [1] CREATE A NEW WS ELEMENT
//==============================
//If failed to create a new one, kernel should panic()!
inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f010b891:	55                   	push   %ebp
f010b892:	89 e5                	mov    %esp,%ebp
f010b894:	83 ec 18             	sub    $0x18,%esp
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010b897:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010b89e:	76 16                	jbe    f010b8b6 <env_page_ws_list_create_element+0x25>
f010b8a0:	68 20 7c 13 f0       	push   $0xf0137c20
f010b8a5:	68 53 7c 13 f0       	push   $0xf0137c53
f010b8aa:	6a 18                	push   $0x18
f010b8ac:	68 68 7c 13 f0       	push   $0xf0137c68
f010b8b1:	e8 f9 55 ff ff       	call   f0100eaf <_panic>
	struct WorkingSetElement *wse = kmalloc(sizeof(struct WorkingSetElement)) ;
f010b8b6:	83 ec 0c             	sub    $0xc,%esp
f010b8b9:	6a 1c                	push   $0x1c
f010b8bb:	e8 12 f6 ff ff       	call   f010aed2 <kmalloc>
f010b8c0:	83 c4 10             	add    $0x10,%esp
f010b8c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (wse == NULL)
f010b8c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b8ca:	75 14                	jne    f010b8e0 <env_page_ws_list_create_element+0x4f>
	{
		panic("can't create a new WS element");
f010b8cc:	83 ec 04             	sub    $0x4,%esp
f010b8cf:	68 87 7c 13 f0       	push   $0xf0137c87
f010b8d4:	6a 1c                	push   $0x1c
f010b8d6:	68 68 7c 13 f0       	push   $0xf0137c68
f010b8db:	e8 cf 55 ff ff       	call   f0100eaf <_panic>
	}
	wse->virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f010b8e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010b8e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8e9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b8ee:	89 c2                	mov    %eax,%edx
f010b8f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b8f3:	89 10                	mov    %edx,(%eax)
	wse->sweeps_counter = 0;
f010b8f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b8f8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	wse->time_stamp = 0x00000000;
f010b8ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b902:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    wse->id = next_ws_id++;
f010b909:	a1 c0 7b 19 f0       	mov    0xf0197bc0,%eax
f010b90e:	8d 50 01             	lea    0x1(%eax),%edx
f010b911:	89 15 c0 7b 19 f0    	mov    %edx,0xf0197bc0
f010b917:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b91a:	89 42 18             	mov    %eax,0x18(%edx)
	return wse;
f010b91d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010b920:	c9                   	leave  
f010b921:	c3                   	ret    

f010b922 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010b922:	55                   	push   %ebp
f010b923:	89 e5                	mov    %esp,%ebp
f010b925:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b928:	83 ec 0c             	sub    $0xc,%esp
f010b92b:	6a 02                	push   $0x2
f010b92d:	e8 4c 5d 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010b932:	83 c4 10             	add    $0x10,%esp
f010b935:	85 c0                	test   %eax,%eax
f010b937:	0f 84 e5 03 00 00    	je     f010bd22 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010b93d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010b944:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010b94b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b94e:	8b 80 44 06 00 00    	mov    0x644(%eax),%eax
f010b954:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010b957:	e9 3b 02 00 00       	jmp    f010bb97 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010b95c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b95f:	8b 00                	mov    (%eax),%eax
f010b961:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b964:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b967:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b96c:	89 c2                	mov    %eax,%edx
f010b96e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b971:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b974:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b977:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b97c:	39 c2                	cmp    %eax,%edx
f010b97e:	0f 85 07 02 00 00    	jne    f010bb8b <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f010b984:	8b 45 08             	mov    0x8(%ebp),%eax
f010b987:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f010b98d:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010b990:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b993:	8b 10                	mov    (%eax),%edx
f010b995:	8b 45 08             	mov    0x8(%ebp),%eax
f010b998:	8b 40 64             	mov    0x64(%eax),%eax
f010b99b:	83 ec 08             	sub    $0x8,%esp
f010b99e:	52                   	push   %edx
f010b99f:	50                   	push   %eax
f010b9a0:	e8 c7 e2 ff ff       	call   f0109c6c <unmap_frame>
f010b9a5:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010b9a8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010b9ac:	75 14                	jne    f010b9c2 <env_page_ws_invalidate+0xa0>
f010b9ae:	83 ec 04             	sub    $0x4,%esp
f010b9b1:	68 a5 7c 13 f0       	push   $0xf0137ca5
f010b9b6:	6a 31                	push   $0x31
f010b9b8:	68 68 7c 13 f0       	push   $0xf0137c68
f010b9bd:	e8 ed 54 ff ff       	call   f0100eaf <_panic>
f010b9c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b9c5:	8b 40 10             	mov    0x10(%eax),%eax
f010b9c8:	85 c0                	test   %eax,%eax
f010b9ca:	74 11                	je     f010b9dd <env_page_ws_invalidate+0xbb>
f010b9cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b9cf:	8b 40 10             	mov    0x10(%eax),%eax
f010b9d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b9d5:	8b 52 14             	mov    0x14(%edx),%edx
f010b9d8:	89 50 14             	mov    %edx,0x14(%eax)
f010b9db:	eb 0f                	jmp    f010b9ec <env_page_ws_invalidate+0xca>
f010b9dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b9e0:	8b 50 14             	mov    0x14(%eax),%edx
f010b9e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9e6:	89 90 48 06 00 00    	mov    %edx,0x648(%eax)
f010b9ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b9ef:	8b 40 14             	mov    0x14(%eax),%eax
f010b9f2:	85 c0                	test   %eax,%eax
f010b9f4:	74 11                	je     f010ba07 <env_page_ws_invalidate+0xe5>
f010b9f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b9f9:	8b 40 14             	mov    0x14(%eax),%eax
f010b9fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b9ff:	8b 52 10             	mov    0x10(%edx),%edx
f010ba02:	89 50 10             	mov    %edx,0x10(%eax)
f010ba05:	eb 0f                	jmp    f010ba16 <env_page_ws_invalidate+0xf4>
f010ba07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba0a:	8b 50 10             	mov    0x10(%eax),%edx
f010ba0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba10:	89 90 44 06 00 00    	mov    %edx,0x644(%eax)
f010ba16:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba19:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010ba20:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba23:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba2a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba2d:	8b 80 50 06 00 00    	mov    0x650(%eax),%eax
f010ba33:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ba36:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba39:	89 90 50 06 00 00    	mov    %edx,0x650(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010ba3f:	83 ec 0c             	sub    $0xc,%esp
f010ba42:	ff 75 f0             	pushl  -0x10(%ebp)
f010ba45:	e8 09 f8 ff ff       	call   f010b253 <kfree>
f010ba4a:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010ba4d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ba51:	0f 84 2b 01 00 00    	je     f010bb82 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010ba57:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ba5b:	75 14                	jne    f010ba71 <env_page_ws_invalidate+0x14f>
f010ba5d:	83 ec 04             	sub    $0x4,%esp
f010ba60:	68 a5 7c 13 f0       	push   $0xf0137ca5
f010ba65:	6a 37                	push   $0x37
f010ba67:	68 68 7c 13 f0       	push   $0xf0137c68
f010ba6c:	e8 3e 54 ff ff       	call   f0100eaf <_panic>
f010ba71:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba74:	8b 40 10             	mov    0x10(%eax),%eax
f010ba77:	85 c0                	test   %eax,%eax
f010ba79:	74 11                	je     f010ba8c <env_page_ws_invalidate+0x16a>
f010ba7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba7e:	8b 40 10             	mov    0x10(%eax),%eax
f010ba81:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010ba84:	8b 52 14             	mov    0x14(%edx),%edx
f010ba87:	89 50 14             	mov    %edx,0x14(%eax)
f010ba8a:	eb 0f                	jmp    f010ba9b <env_page_ws_invalidate+0x179>
f010ba8c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba8f:	8b 50 14             	mov    0x14(%eax),%edx
f010ba92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba95:	89 90 58 06 00 00    	mov    %edx,0x658(%eax)
f010ba9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba9e:	8b 40 14             	mov    0x14(%eax),%eax
f010baa1:	85 c0                	test   %eax,%eax
f010baa3:	74 11                	je     f010bab6 <env_page_ws_invalidate+0x194>
f010baa5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010baa8:	8b 40 14             	mov    0x14(%eax),%eax
f010baab:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010baae:	8b 52 10             	mov    0x10(%edx),%edx
f010bab1:	89 50 10             	mov    %edx,0x10(%eax)
f010bab4:	eb 0f                	jmp    f010bac5 <env_page_ws_invalidate+0x1a3>
f010bab6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bab9:	8b 50 10             	mov    0x10(%eax),%edx
f010babc:	8b 45 08             	mov    0x8(%ebp),%eax
f010babf:	89 90 54 06 00 00    	mov    %edx,0x654(%eax)
f010bac5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bac8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bacf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bad2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bad9:	8b 45 08             	mov    0x8(%ebp),%eax
f010badc:	8b 80 60 06 00 00    	mov    0x660(%eax),%eax
f010bae2:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bae5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bae8:	89 90 60 06 00 00    	mov    %edx,0x660(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010baee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010baf2:	75 14                	jne    f010bb08 <env_page_ws_invalidate+0x1e6>
f010baf4:	83 ec 04             	sub    $0x4,%esp
f010baf7:	68 c4 7c 13 f0       	push   $0xf0137cc4
f010bafc:	6a 38                	push   $0x38
f010bafe:	68 68 7c 13 f0       	push   $0xf0137c68
f010bb03:	e8 a7 53 ff ff       	call   f0100eaf <_panic>
f010bb08:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb0b:	8b 90 48 06 00 00    	mov    0x648(%eax),%edx
f010bb11:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bb14:	89 50 14             	mov    %edx,0x14(%eax)
f010bb17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bb1a:	8b 40 14             	mov    0x14(%eax),%eax
f010bb1d:	85 c0                	test   %eax,%eax
f010bb1f:	74 11                	je     f010bb32 <env_page_ws_invalidate+0x210>
f010bb21:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb24:	8b 80 48 06 00 00    	mov    0x648(%eax),%eax
f010bb2a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010bb2d:	89 50 10             	mov    %edx,0x10(%eax)
f010bb30:	eb 0c                	jmp    f010bb3e <env_page_ws_invalidate+0x21c>
f010bb32:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb35:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010bb38:	89 90 44 06 00 00    	mov    %edx,0x644(%eax)
f010bb3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb41:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010bb44:	89 90 48 06 00 00    	mov    %edx,0x648(%eax)
f010bb4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bb4d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bb54:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb57:	8b 80 50 06 00 00    	mov    0x650(%eax),%eax
f010bb5d:	8d 50 01             	lea    0x1(%eax),%edx
f010bb60:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb63:	89 90 50 06 00 00    	mov    %edx,0x650(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010bb69:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bb6c:	8b 10                	mov    (%eax),%edx
f010bb6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb71:	8b 40 64             	mov    0x64(%eax),%eax
f010bb74:	6a 00                	push   $0x0
f010bb76:	6a 01                	push   $0x1
f010bb78:	52                   	push   %edx
f010bb79:	50                   	push   %eax
f010bb7a:	e8 dd f9 ff ff       	call   f010b55c <pt_set_page_permissions>
f010bb7f:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010bb82:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010bb89:	eb 43                	jmp    f010bbce <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010bb8b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb8e:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f010bb94:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010bb97:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bb9b:	74 08                	je     f010bba5 <env_page_ws_invalidate+0x283>
f010bb9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bba0:	8b 40 10             	mov    0x10(%eax),%eax
f010bba3:	eb 05                	jmp    f010bbaa <env_page_ws_invalidate+0x288>
f010bba5:	b8 00 00 00 00       	mov    $0x0,%eax
f010bbaa:	8b 55 08             	mov    0x8(%ebp),%edx
f010bbad:	89 82 4c 06 00 00    	mov    %eax,0x64c(%edx)
f010bbb3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbb6:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f010bbbc:	85 c0                	test   %eax,%eax
f010bbbe:	0f 85 98 fd ff ff    	jne    f010b95c <env_page_ws_invalidate+0x3a>
f010bbc4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bbc8:	0f 85 8e fd ff ff    	jne    f010b95c <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010bbce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bbd2:	0f 85 a4 02 00 00    	jne    f010be7c <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010bbd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010bbdf:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbe2:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f010bbe8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010bbeb:	e9 f6 00 00 00       	jmp    f010bce6 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010bbf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbf3:	8b 00                	mov    (%eax),%eax
f010bbf5:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010bbf8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bbfb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bc00:	89 c2                	mov    %eax,%edx
f010bc02:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc05:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bc08:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bc0b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bc10:	39 c2                	cmp    %eax,%edx
f010bc12:	0f 85 c2 00 00 00    	jne    f010bcda <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010bc18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc1b:	8b 10                	mov    (%eax),%edx
f010bc1d:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc20:	8b 40 64             	mov    0x64(%eax),%eax
f010bc23:	83 ec 08             	sub    $0x8,%esp
f010bc26:	52                   	push   %edx
f010bc27:	50                   	push   %eax
f010bc28:	e8 3f e0 ff ff       	call   f0109c6c <unmap_frame>
f010bc2d:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010bc30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bc34:	75 14                	jne    f010bc4a <env_page_ws_invalidate+0x328>
f010bc36:	83 ec 04             	sub    $0x4,%esp
f010bc39:	68 a5 7c 13 f0       	push   $0xf0137ca5
f010bc3e:	6a 48                	push   $0x48
f010bc40:	68 68 7c 13 f0       	push   $0xf0137c68
f010bc45:	e8 65 52 ff ff       	call   f0100eaf <_panic>
f010bc4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc4d:	8b 40 10             	mov    0x10(%eax),%eax
f010bc50:	85 c0                	test   %eax,%eax
f010bc52:	74 11                	je     f010bc65 <env_page_ws_invalidate+0x343>
f010bc54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc57:	8b 40 10             	mov    0x10(%eax),%eax
f010bc5a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bc5d:	8b 52 14             	mov    0x14(%edx),%edx
f010bc60:	89 50 14             	mov    %edx,0x14(%eax)
f010bc63:	eb 0f                	jmp    f010bc74 <env_page_ws_invalidate+0x352>
f010bc65:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc68:	8b 50 14             	mov    0x14(%eax),%edx
f010bc6b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc6e:	89 90 58 06 00 00    	mov    %edx,0x658(%eax)
f010bc74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc77:	8b 40 14             	mov    0x14(%eax),%eax
f010bc7a:	85 c0                	test   %eax,%eax
f010bc7c:	74 11                	je     f010bc8f <env_page_ws_invalidate+0x36d>
f010bc7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc81:	8b 40 14             	mov    0x14(%eax),%eax
f010bc84:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bc87:	8b 52 10             	mov    0x10(%edx),%edx
f010bc8a:	89 50 10             	mov    %edx,0x10(%eax)
f010bc8d:	eb 0f                	jmp    f010bc9e <env_page_ws_invalidate+0x37c>
f010bc8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc92:	8b 50 10             	mov    0x10(%eax),%edx
f010bc95:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc98:	89 90 54 06 00 00    	mov    %edx,0x654(%eax)
f010bc9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bca1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bca8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bcab:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bcb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcb5:	8b 80 60 06 00 00    	mov    0x660(%eax),%eax
f010bcbb:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bcbe:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcc1:	89 90 60 06 00 00    	mov    %edx,0x660(%eax)

					kfree(ptr_WS_element);
f010bcc7:	83 ec 0c             	sub    $0xc,%esp
f010bcca:	ff 75 f0             	pushl  -0x10(%ebp)
f010bccd:	e8 81 f5 ff ff       	call   f010b253 <kfree>
f010bcd2:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010bcd5:	e9 a2 01 00 00       	jmp    f010be7c <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010bcda:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcdd:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f010bce3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010bce6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bcea:	74 08                	je     f010bcf4 <env_page_ws_invalidate+0x3d2>
f010bcec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bcef:	8b 40 10             	mov    0x10(%eax),%eax
f010bcf2:	eb 05                	jmp    f010bcf9 <env_page_ws_invalidate+0x3d7>
f010bcf4:	b8 00 00 00 00       	mov    $0x0,%eax
f010bcf9:	8b 55 08             	mov    0x8(%ebp),%edx
f010bcfc:	89 82 5c 06 00 00    	mov    %eax,0x65c(%edx)
f010bd02:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd05:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f010bd0b:	85 c0                	test   %eax,%eax
f010bd0d:	0f 85 dd fe ff ff    	jne    f010bbf0 <env_page_ws_invalidate+0x2ce>
f010bd13:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bd17:	0f 85 d3 fe ff ff    	jne    f010bbf0 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010bd1d:	e9 5a 01 00 00       	jmp    f010be7c <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010bd22:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd25:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010bd2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010bd2e:	e9 10 01 00 00       	jmp    f010be43 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010bd33:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bd36:	8b 00                	mov    (%eax),%eax
f010bd38:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010bd3b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bd3e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bd43:	89 c2                	mov    %eax,%edx
f010bd45:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd48:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010bd4b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bd4e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bd53:	39 c2                	cmp    %eax,%edx
f010bd55:	0f 85 dc 00 00 00    	jne    f010be37 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010bd5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bd5e:	8b 10                	mov    (%eax),%edx
f010bd60:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd63:	8b 40 64             	mov    0x64(%eax),%eax
f010bd66:	83 ec 08             	sub    $0x8,%esp
f010bd69:	52                   	push   %edx
f010bd6a:	50                   	push   %eax
f010bd6b:	e8 fc de ff ff       	call   f0109c6c <unmap_frame>
f010bd70:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010bd73:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd76:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bd7c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010bd7f:	75 0f                	jne    f010bd90 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010bd81:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bd84:	8b 50 10             	mov    0x10(%eax),%edx
f010bd87:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd8a:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010bd90:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010bd94:	75 14                	jne    f010bdaa <env_page_ws_invalidate+0x488>
f010bd96:	83 ec 04             	sub    $0x4,%esp
f010bd99:	68 a5 7c 13 f0       	push   $0xf0137ca5
f010bd9e:	6a 5e                	push   $0x5e
f010bda0:	68 68 7c 13 f0       	push   $0xf0137c68
f010bda5:	e8 05 51 ff ff       	call   f0100eaf <_panic>
f010bdaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bdad:	8b 40 10             	mov    0x10(%eax),%eax
f010bdb0:	85 c0                	test   %eax,%eax
f010bdb2:	74 11                	je     f010bdc5 <env_page_ws_invalidate+0x4a3>
f010bdb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bdb7:	8b 40 10             	mov    0x10(%eax),%eax
f010bdba:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010bdbd:	8b 52 14             	mov    0x14(%edx),%edx
f010bdc0:	89 50 14             	mov    %edx,0x14(%eax)
f010bdc3:	eb 0f                	jmp    f010bdd4 <env_page_ws_invalidate+0x4b2>
f010bdc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bdc8:	8b 50 14             	mov    0x14(%eax),%edx
f010bdcb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdce:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010bdd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bdd7:	8b 40 14             	mov    0x14(%eax),%eax
f010bdda:	85 c0                	test   %eax,%eax
f010bddc:	74 11                	je     f010bdef <env_page_ws_invalidate+0x4cd>
f010bdde:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bde1:	8b 40 14             	mov    0x14(%eax),%eax
f010bde4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010bde7:	8b 52 10             	mov    0x10(%edx),%edx
f010bdea:	89 50 10             	mov    %edx,0x10(%eax)
f010bded:	eb 0f                	jmp    f010bdfe <env_page_ws_invalidate+0x4dc>
f010bdef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bdf2:	8b 50 10             	mov    0x10(%eax),%edx
f010bdf5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdf8:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010bdfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be01:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010be08:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be0b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010be12:	8b 45 08             	mov    0x8(%ebp),%eax
f010be15:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010be1b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010be1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010be21:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f010be27:	83 ec 0c             	sub    $0xc,%esp
f010be2a:	ff 75 ec             	pushl  -0x14(%ebp)
f010be2d:	e8 21 f4 ff ff       	call   f010b253 <kfree>
f010be32:	83 c4 10             	add    $0x10,%esp

				break;
f010be35:	eb 45                	jmp    f010be7c <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010be37:	8b 45 08             	mov    0x8(%ebp),%eax
f010be3a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010be40:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010be43:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010be47:	74 08                	je     f010be51 <env_page_ws_invalidate+0x52f>
f010be49:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be4c:	8b 40 10             	mov    0x10(%eax),%eax
f010be4f:	eb 05                	jmp    f010be56 <env_page_ws_invalidate+0x534>
f010be51:	b8 00 00 00 00       	mov    $0x0,%eax
f010be56:	8b 55 08             	mov    0x8(%ebp),%edx
f010be59:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010be5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010be62:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010be68:	85 c0                	test   %eax,%eax
f010be6a:	0f 85 c3 fe ff ff    	jne    f010bd33 <env_page_ws_invalidate+0x411>
f010be70:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010be74:	0f 85 b9 fe ff ff    	jne    f010bd33 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010be7a:	eb 00                	jmp    f010be7c <env_page_ws_invalidate+0x55a>
f010be7c:	90                   	nop
f010be7d:	c9                   	leave  
f010be7e:	c3                   	ret    

f010be7f <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010be7f:	55                   	push   %ebp
f010be80:	89 e5                	mov    %esp,%ebp
f010be82:	56                   	push   %esi
f010be83:	53                   	push   %ebx
f010be84:	83 ec 20             	sub    $0x20,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010be87:	83 ec 0c             	sub    $0xc,%esp
f010be8a:	6a 02                	push   $0x2
f010be8c:	e8 ed 57 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010be91:	83 c4 10             	add    $0x10,%esp
f010be94:	85 c0                	test   %eax,%eax
f010be96:	0f 84 fe 00 00 00    	je     f010bf9a <env_page_ws_print+0x11b>
	{
		int i = 0;
f010be9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010bea3:	83 ec 0c             	sub    $0xc,%esp
f010bea6:	68 e7 7c 13 f0       	push   $0xf0137ce7
f010beab:	e8 9d 5c ff ff       	call   f0101b4d <cprintf>
f010beb0:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010beb3:	8b 45 08             	mov    0x8(%ebp),%eax
f010beb6:	8b 80 44 06 00 00    	mov    0x644(%eax),%eax
f010bebc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010bebf:	eb 2c                	jmp    f010beed <env_page_ws_print+0x6e>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010bec1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bec4:	8b 10                	mov    (%eax),%edx
f010bec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bec9:	8d 48 01             	lea    0x1(%eax),%ecx
f010becc:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010becf:	83 ec 04             	sub    $0x4,%esp
f010bed2:	52                   	push   %edx
f010bed3:	50                   	push   %eax
f010bed4:	68 01 7d 13 f0       	push   $0xf0137d01
f010bed9:	e8 6f 5c ff ff       	call   f0101b4d <cprintf>
f010bede:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010bee1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bee4:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f010beea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010beed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bef1:	74 08                	je     f010befb <env_page_ws_print+0x7c>
f010bef3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bef6:	8b 40 10             	mov    0x10(%eax),%eax
f010bef9:	eb 05                	jmp    f010bf00 <env_page_ws_print+0x81>
f010befb:	b8 00 00 00 00       	mov    $0x0,%eax
f010bf00:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf03:	89 82 4c 06 00 00    	mov    %eax,0x64c(%edx)
f010bf09:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf0c:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f010bf12:	85 c0                	test   %eax,%eax
f010bf14:	75 ab                	jne    f010bec1 <env_page_ws_print+0x42>
f010bf16:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bf1a:	75 a5                	jne    f010bec1 <env_page_ws_print+0x42>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010bf1c:	83 ec 0c             	sub    $0xc,%esp
f010bf1f:	68 09 7d 13 f0       	push   $0xf0137d09
f010bf24:	e8 24 5c ff ff       	call   f0101b4d <cprintf>
f010bf29:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010bf2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf2f:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f010bf35:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010bf38:	eb 2c                	jmp    f010bf66 <env_page_ws_print+0xe7>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010bf3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bf3d:	8b 10                	mov    (%eax),%edx
f010bf3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf42:	8d 48 01             	lea    0x1(%eax),%ecx
f010bf45:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010bf48:	83 ec 04             	sub    $0x4,%esp
f010bf4b:	52                   	push   %edx
f010bf4c:	50                   	push   %eax
f010bf4d:	68 01 7d 13 f0       	push   $0xf0137d01
f010bf52:	e8 f6 5b ff ff       	call   f0101b4d <cprintf>
f010bf57:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010bf5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf5d:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f010bf63:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010bf66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bf6a:	74 08                	je     f010bf74 <env_page_ws_print+0xf5>
f010bf6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bf6f:	8b 40 10             	mov    0x10(%eax),%eax
f010bf72:	eb 05                	jmp    f010bf79 <env_page_ws_print+0xfa>
f010bf74:	b8 00 00 00 00       	mov    $0x0,%eax
f010bf79:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf7c:	89 82 5c 06 00 00    	mov    %eax,0x65c(%edx)
f010bf82:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf85:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f010bf8b:	85 c0                	test   %eax,%eax
f010bf8d:	75 ab                	jne    f010bf3a <env_page_ws_print+0xbb>
f010bf8f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010bf93:	75 a5                	jne    f010bf3a <env_page_ws_print+0xbb>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010bf95:	e9 61 01 00 00       	jmp    f010c0fb <env_page_ws_print+0x27c>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010bf9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010bfa1:	83 ec 0c             	sub    $0xc,%esp
f010bfa4:	68 24 7d 13 f0       	push   $0xf0137d24
f010bfa9:	e8 9f 5b ff ff       	call   f0101b4d <cprintf>
f010bfae:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010bfb1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010bfb8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfbb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010bfc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010bfc4:	e9 d8 00 00 00       	jmp    f010c0a1 <env_page_ws_print+0x222>
		{
			uint32 virtual_address = wse->virtual_address;
f010bfc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bfcc:	8b 00                	mov    (%eax),%eax
f010bfce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010bfd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bfd4:	8b 40 08             	mov    0x8(%eax),%eax
f010bfd7:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010bfda:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfdd:	8b 40 64             	mov    0x64(%eax),%eax
f010bfe0:	83 ec 08             	sub    $0x8,%esp
f010bfe3:	ff 75 e4             	pushl  -0x1c(%ebp)
f010bfe6:	50                   	push   %eax
f010bfe7:	e8 35 f6 ff ff       	call   f010b621 <pt_get_page_permissions>
f010bfec:	83 c4 10             	add    $0x10,%esp
f010bfef:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010bff2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bff5:	83 e0 40             	and    $0x40,%eax
f010bff8:	85 c0                	test   %eax,%eax
f010bffa:	0f 95 c0             	setne  %al
f010bffd:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010c000:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c003:	83 e0 20             	and    $0x20,%eax
f010c006:	85 c0                	test   %eax,%eax
f010c008:	0f 95 c0             	setne  %al
f010c00b:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010c00e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c011:	25 00 02 00 00       	and    $0x200,%eax
f010c016:	85 c0                	test   %eax,%eax
f010c018:	0f 95 c0             	setne  %al
f010c01b:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010c01e:	83 ec 04             	sub    $0x4,%esp
f010c021:	ff 75 e4             	pushl  -0x1c(%ebp)
f010c024:	ff 75 ec             	pushl  -0x14(%ebp)
f010c027:	68 2e 7d 13 f0       	push   $0xf0137d2e
f010c02c:	e8 1c 5b ff ff       	call   f0101b4d <cprintf>
f010c031:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d, id = %d",
f010c034:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c037:	8b 70 18             	mov    0x18(%eax),%esi
f010c03a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c03d:	8b 58 0c             	mov    0xc(%eax),%ebx
f010c040:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010c044:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010c048:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010c04c:	83 ec 04             	sub    $0x4,%esp
f010c04f:	56                   	push   %esi
f010c050:	53                   	push   %ebx
f010c051:	ff 75 e0             	pushl  -0x20(%ebp)
f010c054:	51                   	push   %ecx
f010c055:	52                   	push   %edx
f010c056:	50                   	push   %eax
f010c057:	68 38 7d 13 f0       	push   $0xf0137d38
f010c05c:	e8 ec 5a ff ff       	call   f0101b4d <cprintf>
f010c061:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter,  wse->id) ;

			if(wse == e->page_last_WS_element)
f010c064:	8b 45 08             	mov    0x8(%ebp),%eax
f010c067:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010c06d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010c070:	75 10                	jne    f010c082 <env_page_ws_print+0x203>
			{
				cprintf(" <--");
f010c072:	83 ec 0c             	sub    $0xc,%esp
f010c075:	68 88 7d 13 f0       	push   $0xf0137d88
f010c07a:	e8 ce 5a ff ff       	call   f0101b4d <cprintf>
f010c07f:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010c082:	83 ec 0c             	sub    $0xc,%esp
f010c085:	68 8d 7d 13 f0       	push   $0xf0137d8d
f010c08a:	e8 be 5a ff ff       	call   f0101b4d <cprintf>
f010c08f:	83 c4 10             	add    $0x10,%esp
			i++;
f010c092:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010c095:	8b 45 08             	mov    0x8(%ebp),%eax
f010c098:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c09e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c0a1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010c0a5:	74 08                	je     f010c0af <env_page_ws_print+0x230>
f010c0a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c0aa:	8b 40 10             	mov    0x10(%eax),%eax
f010c0ad:	eb 05                	jmp    f010c0b4 <env_page_ws_print+0x235>
f010c0af:	b8 00 00 00 00       	mov    $0x0,%eax
f010c0b4:	8b 55 08             	mov    0x8(%ebp),%edx
f010c0b7:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010c0bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0c0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c0c6:	85 c0                	test   %eax,%eax
f010c0c8:	0f 85 fb fe ff ff    	jne    f010bfc9 <env_page_ws_print+0x14a>
f010c0ce:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010c0d2:	0f 85 f1 fe ff ff    	jne    f010bfc9 <env_page_ws_print+0x14a>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010c0d8:	eb 13                	jmp    f010c0ed <env_page_ws_print+0x26e>
		{
			cprintf("EMPTY LOCATION\n");
f010c0da:	83 ec 0c             	sub    $0xc,%esp
f010c0dd:	68 8f 7d 13 f0       	push   $0xf0137d8f
f010c0e2:	e8 66 5a ff ff       	call   f0101b4d <cprintf>
f010c0e7:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010c0ea:	ff 45 ec             	incl   -0x14(%ebp)
f010c0ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0f0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010c0f6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010c0f9:	77 df                	ja     f010c0da <env_page_ws_print+0x25b>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010c0fb:	90                   	nop
f010c0fc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010c0ff:	5b                   	pop    %ebx
f010c100:	5e                   	pop    %esi
f010c101:	5d                   	pop    %ebp
f010c102:	c3                   	ret    

f010c103 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010c103:	55                   	push   %ebp
f010c104:	89 e5                	mov    %esp,%ebp
f010c106:	53                   	push   %ebx
f010c107:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010c10a:	83 ec 0c             	sub    $0xc,%esp
f010c10d:	68 a0 7d 13 f0       	push   $0xf0137da0
f010c112:	e8 36 5a ff ff       	call   f0101b4d <cprintf>
f010c117:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010c11a:	83 ec 0c             	sub    $0xc,%esp
f010c11d:	68 d5 7d 13 f0       	push   $0xf0137dd5
f010c122:	e8 26 5a ff ff       	call   f0101b4d <cprintf>
f010c127:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010c12a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c131:	e9 36 01 00 00       	jmp    f010c26c <env_table_ws_print+0x169>
	{
		if (e->__ptr_tws[i].empty)
f010c136:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c139:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c13c:	89 d0                	mov    %edx,%eax
f010c13e:	01 c0                	add    %eax,%eax
f010c140:	01 d0                	add    %edx,%eax
f010c142:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c149:	01 d8                	add    %ebx,%eax
f010c14b:	01 d0                	add    %edx,%eax
f010c14d:	01 c8                	add    %ecx,%eax
f010c14f:	05 cc 00 00 00       	add    $0xcc,%eax
f010c154:	8a 00                	mov    (%eax),%al
f010c156:	84 c0                	test   %al,%al
f010c158:	74 43                	je     f010c19d <env_table_ws_print+0x9a>
		{
			cprintf("EMPTY LOCATION");
f010c15a:	83 ec 0c             	sub    $0xc,%esp
f010c15d:	68 e0 7d 13 f0       	push   $0xf0137de0
f010c162:	e8 e6 59 ff ff       	call   f0101b4d <cprintf>
f010c167:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010c16a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c16d:	8b 80 40 06 00 00    	mov    0x640(%eax),%eax
f010c173:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c176:	75 10                	jne    f010c188 <env_table_ws_print+0x85>
			{
				cprintf("		<--");
f010c178:	83 ec 0c             	sub    $0xc,%esp
f010c17b:	68 ef 7d 13 f0       	push   $0xf0137def
f010c180:	e8 c8 59 ff ff       	call   f0101b4d <cprintf>
f010c185:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010c188:	83 ec 0c             	sub    $0xc,%esp
f010c18b:	68 8d 7d 13 f0       	push   $0xf0137d8d
f010c190:	e8 b8 59 ff ff       	call   f0101b4d <cprintf>
f010c195:	83 c4 10             	add    $0x10,%esp
			continue;
f010c198:	e9 cc 00 00 00       	jmp    f010c269 <env_table_ws_print+0x166>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010c19d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c1a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c1a3:	89 d0                	mov    %edx,%eax
f010c1a5:	01 c0                	add    %eax,%eax
f010c1a7:	01 d0                	add    %edx,%eax
f010c1a9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c1b0:	01 d8                	add    %ebx,%eax
f010c1b2:	01 d0                	add    %edx,%eax
f010c1b4:	01 c8                	add    %ecx,%eax
f010c1b6:	05 c8 00 00 00       	add    $0xc8,%eax
f010c1bb:	8b 00                	mov    (%eax),%eax
f010c1bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010c1c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c1c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c1c6:	89 d0                	mov    %edx,%eax
f010c1c8:	01 c0                	add    %eax,%eax
f010c1ca:	01 d0                	add    %edx,%eax
f010c1cc:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c1d3:	01 d8                	add    %ebx,%eax
f010c1d5:	01 d0                	add    %edx,%eax
f010c1d7:	01 c8                	add    %ecx,%eax
f010c1d9:	05 c8 00 00 00       	add    $0xc8,%eax
f010c1de:	8b 00                	mov    (%eax),%eax
f010c1e0:	83 ec 04             	sub    $0x4,%esp
f010c1e3:	50                   	push   %eax
f010c1e4:	ff 75 f4             	pushl  -0xc(%ebp)
f010c1e7:	68 f5 7d 13 f0       	push   $0xf0137df5
f010c1ec:	e8 5c 59 ff ff       	call   f0101b4d <cprintf>
f010c1f1:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010c1f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c1f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c1fa:	89 d0                	mov    %edx,%eax
f010c1fc:	01 c0                	add    %eax,%eax
f010c1fe:	01 d0                	add    %edx,%eax
f010c200:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c207:	01 d8                	add    %ebx,%eax
f010c209:	01 d0                	add    %edx,%eax
f010c20b:	01 c8                	add    %ecx,%eax
f010c20d:	05 d0 00 00 00       	add    $0xd0,%eax
f010c212:	8b 18                	mov    (%eax),%ebx
f010c214:	8b 45 08             	mov    0x8(%ebp),%eax
f010c217:	8b 40 64             	mov    0x64(%eax),%eax
f010c21a:	83 ec 08             	sub    $0x8,%esp
f010c21d:	ff 75 f0             	pushl  -0x10(%ebp)
f010c220:	50                   	push   %eax
f010c221:	e8 d5 f5 ff ff       	call   f010b7fb <pd_is_table_used>
f010c226:	83 c4 10             	add    $0x10,%esp
f010c229:	83 ec 04             	sub    $0x4,%esp
f010c22c:	53                   	push   %ebx
f010c22d:	50                   	push   %eax
f010c22e:	68 0c 7e 13 f0       	push   $0xf0137e0c
f010c233:	e8 15 59 ff ff       	call   f0101b4d <cprintf>
f010c238:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010c23b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23e:	8b 80 40 06 00 00    	mov    0x640(%eax),%eax
f010c244:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c247:	75 10                	jne    f010c259 <env_table_ws_print+0x156>
		{
			cprintf(" <--");
f010c249:	83 ec 0c             	sub    $0xc,%esp
f010c24c:	68 88 7d 13 f0       	push   $0xf0137d88
f010c251:	e8 f7 58 ff ff       	call   f0101b4d <cprintf>
f010c256:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010c259:	83 ec 0c             	sub    $0xc,%esp
f010c25c:	68 8d 7d 13 f0       	push   $0xf0137d8d
f010c261:	e8 e7 58 ff ff       	call   f0101b4d <cprintf>
f010c266:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010c269:	ff 45 f4             	incl   -0xc(%ebp)
f010c26c:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c270:	0f 86 c0 fe ff ff    	jbe    f010c136 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010c276:	90                   	nop
f010c277:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c27a:	c9                   	leave  
f010c27b:	c3                   	ret    

f010c27c <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010c27c:	55                   	push   %ebp
f010c27d:	89 e5                	mov    %esp,%ebp
f010c27f:	53                   	push   %ebx
f010c280:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010c283:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f010c28a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010c291:	eb 2a                	jmp    f010c2bd <env_table_ws_get_size+0x41>
f010c293:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c296:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010c299:	89 d0                	mov    %edx,%eax
f010c29b:	01 c0                	add    %eax,%eax
f010c29d:	01 d0                	add    %edx,%eax
f010c29f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c2a6:	01 d8                	add    %ebx,%eax
f010c2a8:	01 d0                	add    %edx,%eax
f010c2aa:	01 c8                	add    %ecx,%eax
f010c2ac:	05 cc 00 00 00       	add    $0xcc,%eax
f010c2b1:	8a 00                	mov    (%eax),%al
f010c2b3:	84 c0                	test   %al,%al
f010c2b5:	75 03                	jne    f010c2ba <env_table_ws_get_size+0x3e>
f010c2b7:	ff 45 f4             	incl   -0xc(%ebp)
f010c2ba:	ff 45 f8             	incl   -0x8(%ebp)
f010c2bd:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
f010c2c1:	7e d0                	jle    f010c293 <env_table_ws_get_size+0x17>
	return counter;
f010c2c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010c2c6:	83 c4 10             	add    $0x10,%esp
f010c2c9:	5b                   	pop    %ebx
f010c2ca:	5d                   	pop    %ebp
f010c2cb:	c3                   	ret    

f010c2cc <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010c2cc:	55                   	push   %ebp
f010c2cd:	89 e5                	mov    %esp,%ebp
f010c2cf:	53                   	push   %ebx
f010c2d0:	83 ec 14             	sub    $0x14,%esp
	int i=0;
f010c2d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010c2da:	eb 56                	jmp    f010c332 <env_table_ws_invalidate+0x66>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010c2dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c2df:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c2e2:	89 d0                	mov    %edx,%eax
f010c2e4:	01 c0                	add    %eax,%eax
f010c2e6:	01 d0                	add    %edx,%eax
f010c2e8:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c2ef:	01 d8                	add    %ebx,%eax
f010c2f1:	01 d0                	add    %edx,%eax
f010c2f3:	01 c8                	add    %ecx,%eax
f010c2f5:	05 c8 00 00 00       	add    $0xc8,%eax
f010c2fa:	8b 00                	mov    (%eax),%eax
f010c2fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010c2ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c302:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c307:	89 c2                	mov    %eax,%edx
f010c309:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c30c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010c30f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c312:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c317:	39 c2                	cmp    %eax,%edx
f010c319:	75 14                	jne    f010c32f <env_table_ws_invalidate+0x63>
		{
			env_table_ws_clear_entry(e, i);
f010c31b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c31e:	83 ec 08             	sub    $0x8,%esp
f010c321:	50                   	push   %eax
f010c322:	ff 75 08             	pushl  0x8(%ebp)
f010c325:	e8 da 00 00 00       	call   f010c404 <env_table_ws_clear_entry>
f010c32a:	83 c4 10             	add    $0x10,%esp
			break;
f010c32d:	eb 09                	jmp    f010c338 <env_table_ws_invalidate+0x6c>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010c32f:	ff 45 f4             	incl   -0xc(%ebp)
f010c332:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c336:	7e a4                	jle    f010c2dc <env_table_ws_invalidate+0x10>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010c338:	90                   	nop
f010c339:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c33c:	c9                   	leave  
f010c33d:	c3                   	ret    

f010c33e <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010c33e:	55                   	push   %ebp
f010c33f:	89 e5                	mov    %esp,%ebp
f010c341:	56                   	push   %esi
f010c342:	53                   	push   %ebx
f010c343:	83 ec 10             	sub    $0x10,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010c346:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010c34a:	76 19                	jbe    f010c365 <env_table_ws_set_entry+0x27>
f010c34c:	68 30 7e 13 f0       	push   $0xf0137e30
f010c351:	68 53 7c 13 f0       	push   $0xf0137c53
f010c356:	68 41 01 00 00       	push   $0x141
f010c35b:	68 68 7c 13 f0       	push   $0xf0137c68
f010c360:	e8 4a 4b ff ff       	call   f0100eaf <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010c365:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010c36c:	76 19                	jbe    f010c387 <env_table_ws_set_entry+0x49>
f010c36e:	68 20 7c 13 f0       	push   $0xf0137c20
f010c373:	68 53 7c 13 f0       	push   $0xf0137c53
f010c378:	68 42 01 00 00       	push   $0x142
f010c37d:	68 68 7c 13 f0       	push   $0xf0137c68
f010c382:	e8 28 4b ff ff       	call   f0100eaf <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010c387:	8b 45 10             	mov    0x10(%ebp),%eax
f010c38a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c38d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c390:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c395:	89 c1                	mov    %eax,%ecx
f010c397:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c39a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c39d:	89 d0                	mov    %edx,%eax
f010c39f:	01 c0                	add    %eax,%eax
f010c3a1:	01 d0                	add    %edx,%eax
f010c3a3:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010c3aa:	01 f0                	add    %esi,%eax
f010c3ac:	01 d0                	add    %edx,%eax
f010c3ae:	01 d8                	add    %ebx,%eax
f010c3b0:	05 c8 00 00 00       	add    $0xc8,%eax
f010c3b5:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010c3b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c3ba:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c3bd:	89 d0                	mov    %edx,%eax
f010c3bf:	01 c0                	add    %eax,%eax
f010c3c1:	01 d0                	add    %edx,%eax
f010c3c3:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c3ca:	01 d8                	add    %ebx,%eax
f010c3cc:	01 d0                	add    %edx,%eax
f010c3ce:	01 c8                	add    %ecx,%eax
f010c3d0:	05 cc 00 00 00       	add    $0xcc,%eax
f010c3d5:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x00000000;
f010c3d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c3db:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c3de:	89 d0                	mov    %edx,%eax
f010c3e0:	01 c0                	add    %eax,%eax
f010c3e2:	01 d0                	add    %edx,%eax
f010c3e4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c3eb:	01 d8                	add    %ebx,%eax
f010c3ed:	01 d0                	add    %edx,%eax
f010c3ef:	01 c8                	add    %ecx,%eax
f010c3f1:	05 d0 00 00 00       	add    $0xd0,%eax
f010c3f6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return;
f010c3fc:	90                   	nop
}
f010c3fd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010c400:	5b                   	pop    %ebx
f010c401:	5e                   	pop    %esi
f010c402:	5d                   	pop    %ebp
f010c403:	c3                   	ret    

f010c404 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010c404:	55                   	push   %ebp
f010c405:	89 e5                	mov    %esp,%ebp
f010c407:	53                   	push   %ebx
f010c408:	83 ec 04             	sub    $0x4,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010c40b:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010c40f:	76 19                	jbe    f010c42a <env_table_ws_clear_entry+0x26>
f010c411:	68 30 7e 13 f0       	push   $0xf0137e30
f010c416:	68 53 7c 13 f0       	push   $0xf0137c53
f010c41b:	68 4d 01 00 00       	push   $0x14d
f010c420:	68 68 7c 13 f0       	push   $0xf0137c68
f010c425:	e8 85 4a ff ff       	call   f0100eaf <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010c42a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c42d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c430:	89 d0                	mov    %edx,%eax
f010c432:	01 c0                	add    %eax,%eax
f010c434:	01 d0                	add    %edx,%eax
f010c436:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c43d:	01 d8                	add    %ebx,%eax
f010c43f:	01 d0                	add    %edx,%eax
f010c441:	01 c8                	add    %ecx,%eax
f010c443:	05 c8 00 00 00       	add    $0xc8,%eax
f010c448:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010c44e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c451:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c454:	89 d0                	mov    %edx,%eax
f010c456:	01 c0                	add    %eax,%eax
f010c458:	01 d0                	add    %edx,%eax
f010c45a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c461:	01 d8                	add    %ebx,%eax
f010c463:	01 d0                	add    %edx,%eax
f010c465:	01 c8                	add    %ecx,%eax
f010c467:	05 cc 00 00 00       	add    $0xcc,%eax
f010c46c:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010c46f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c472:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c475:	89 d0                	mov    %edx,%eax
f010c477:	01 c0                	add    %eax,%eax
f010c479:	01 d0                	add    %edx,%eax
f010c47b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c482:	01 d8                	add    %ebx,%eax
f010c484:	01 d0                	add    %edx,%eax
f010c486:	01 c8                	add    %ecx,%eax
f010c488:	05 d0 00 00 00       	add    $0xd0,%eax
f010c48d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010c493:	90                   	nop
f010c494:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c497:	c9                   	leave  
f010c498:	c3                   	ret    

f010c499 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010c499:	55                   	push   %ebp
f010c49a:	89 e5                	mov    %esp,%ebp
f010c49c:	53                   	push   %ebx
f010c49d:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010c4a0:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010c4a4:	76 19                	jbe    f010c4bf <env_table_ws_get_virtual_address+0x26>
f010c4a6:	68 30 7e 13 f0       	push   $0xf0137e30
f010c4ab:	68 53 7c 13 f0       	push   $0xf0137c53
f010c4b0:	68 55 01 00 00       	push   $0x155
f010c4b5:	68 68 7c 13 f0       	push   $0xf0137c68
f010c4ba:	e8 f0 49 ff ff       	call   f0100eaf <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010c4bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c4c2:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c4c5:	89 d0                	mov    %edx,%eax
f010c4c7:	01 c0                	add    %eax,%eax
f010c4c9:	01 d0                	add    %edx,%eax
f010c4cb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c4d2:	01 d8                	add    %ebx,%eax
f010c4d4:	01 d0                	add    %edx,%eax
f010c4d6:	01 c8                	add    %ecx,%eax
f010c4d8:	05 c8 00 00 00       	add    $0xc8,%eax
f010c4dd:	8b 00                	mov    (%eax),%eax
f010c4df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c4e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4e5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010c4ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c4ed:	c9                   	leave  
f010c4ee:	c3                   	ret    

f010c4ef <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010c4ef:	55                   	push   %ebp
f010c4f0:	89 e5                	mov    %esp,%ebp
f010c4f2:	53                   	push   %ebx
f010c4f3:	83 ec 04             	sub    $0x4,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010c4f6:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010c4fa:	76 19                	jbe    f010c515 <env_table_ws_get_time_stamp+0x26>
f010c4fc:	68 30 7e 13 f0       	push   $0xf0137e30
f010c501:	68 53 7c 13 f0       	push   $0xf0137c53
f010c506:	68 5c 01 00 00       	push   $0x15c
f010c50b:	68 68 7c 13 f0       	push   $0xf0137c68
f010c510:	e8 9a 49 ff ff       	call   f0100eaf <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010c515:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c518:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c51b:	89 d0                	mov    %edx,%eax
f010c51d:	01 c0                	add    %eax,%eax
f010c51f:	01 d0                	add    %edx,%eax
f010c521:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c528:	01 d8                	add    %ebx,%eax
f010c52a:	01 d0                	add    %edx,%eax
f010c52c:	01 c8                	add    %ecx,%eax
f010c52e:	05 d0 00 00 00       	add    $0xd0,%eax
f010c533:	8b 00                	mov    (%eax),%eax
}
f010c535:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c538:	c9                   	leave  
f010c539:	c3                   	ret    

f010c53a <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010c53a:	55                   	push   %ebp
f010c53b:	89 e5                	mov    %esp,%ebp
f010c53d:	53                   	push   %ebx
	return e->__ptr_tws[entry_index].empty;
f010c53e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c541:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c544:	89 d0                	mov    %edx,%eax
f010c546:	01 c0                	add    %eax,%eax
f010c548:	01 d0                	add    %edx,%eax
f010c54a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010c551:	01 d8                	add    %ebx,%eax
f010c553:	01 d0                	add    %edx,%eax
f010c555:	01 c8                	add    %ecx,%eax
f010c557:	05 cc 00 00 00       	add    $0xcc,%eax
f010c55c:	8a 00                	mov    (%eax),%al
f010c55e:	0f b6 c0             	movzbl %al,%eax
}
f010c561:	5b                   	pop    %ebx
f010c562:	5d                   	pop    %ebp
f010c563:	c3                   	ret    

f010c564 <cut_paste_WS>:
///=================================================================================================

// Change WS Sizes For PRIORITY  =========================================================

void cut_paste_WS(struct WorkingSetElement* newWS, int newSize, struct Env* e)
{
f010c564:	55                   	push   %ebp
f010c565:	89 e5                	mov    %esp,%ebp
f010c567:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010c56a:	83 ec 04             	sub    $0x4,%esp
f010c56d:	68 61 7e 13 f0       	push   $0xf0137e61
f010c572:	68 6e 01 00 00       	push   $0x16e
f010c577:	68 68 7c 13 f0       	push   $0xf0137c68
f010c57c:	e8 2e 49 ff ff       	call   f0100eaf <_panic>

f010c581 <double_WS_Size>:
}

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010c581:	55                   	push   %ebp
f010c582:	89 e5                	mov    %esp,%ebp
f010c584:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010c587:	83 ec 04             	sub    $0x4,%esp
f010c58a:	68 61 7e 13 f0       	push   $0xf0137e61
f010c58f:	68 73 01 00 00       	push   $0x173
f010c594:	68 68 7c 13 f0       	push   $0xf0137c68
f010c599:	e8 11 49 ff ff       	call   f0100eaf <_panic>

f010c59e <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010c59e:	55                   	push   %ebp
f010c59f:	89 e5                	mov    %esp,%ebp
f010c5a1:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010c5a4:	83 ec 04             	sub    $0x4,%esp
f010c5a7:	68 61 7e 13 f0       	push   $0xf0137e61
f010c5ac:	68 78 01 00 00       	push   $0x178
f010c5b1:	68 68 7c 13 f0       	push   $0xf0137c68
f010c5b6:	e8 f4 48 ff ff       	call   f0100eaf <_panic>

f010c5bb <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010c5bb:	55                   	push   %ebp
f010c5bc:	89 e5                	mov    %esp,%ebp
f010c5be:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("cut_paste_pages() is not implemented yet...!!");
f010c5c1:	83 ec 04             	sub    $0x4,%esp
f010c5c4:	68 74 7e 13 f0       	push   $0xf0137e74
f010c5c9:	6a 21                	push   $0x21
f010c5cb:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c5d0:	e8 da 48 ff ff       	call   f0100eaf <_panic>

f010c5d5 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010c5d5:	55                   	push   %ebp
f010c5d6:	89 e5                	mov    %esp,%ebp
f010c5d8:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("copy_paste_chunk() is not implemented yet...!!");
f010c5db:	83 ec 04             	sub    $0x4,%esp
f010c5de:	68 c0 7e 13 f0       	push   $0xf0137ec0
f010c5e3:	6a 34                	push   $0x34
f010c5e5:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c5ea:	e8 c0 48 ff ff       	call   f0100eaf <_panic>

f010c5ef <share_chunk>:
//	Otherwise, share the required range and return 0
//	During the share process:
//		1. If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010c5ef:	55                   	push   %ebp
f010c5f0:	89 e5                	mov    %esp,%ebp
f010c5f2:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("share_chunk() is not implemented yet...!!");
f010c5f5:	83 ec 04             	sub    $0x4,%esp
f010c5f8:	68 f0 7e 13 f0       	push   $0xf0137ef0
f010c5fd:	6a 46                	push   $0x46
f010c5ff:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c604:	e8 a6 48 ff ff       	call   f0100eaf <_panic>

f010c609 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010c609:	55                   	push   %ebp
f010c60a:	89 e5                	mov    %esp,%ebp
f010c60c:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("allocate_chunk() is not implemented yet...!!");
f010c60f:	83 ec 04             	sub    $0x4,%esp
f010c612:	68 1c 7f 13 f0       	push   $0xf0137f1c
f010c617:	6a 54                	push   $0x54
f010c619:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c61e:	e8 8c 48 ff ff       	call   f0100eaf <_panic>

f010c623 <calculate_free_space>:
//=====================================
//It should count the number of free pages in the given range [va1, va2)
//(i.e. number of pages that are not mapped).
//Addresses may not be aligned on page boundaries
uint32 calculate_free_space(uint32* page_directory, uint32 sva, uint32 eva)
{
f010c623:	55                   	push   %ebp
f010c624:	89 e5                	mov    %esp,%ebp
f010c626:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_free_space() is not implemented yet...!!");
f010c629:	83 ec 04             	sub    $0x4,%esp
f010c62c:	68 4c 7f 13 f0       	push   $0xf0137f4c
f010c631:	6a 62                	push   $0x62
f010c633:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c638:	e8 72 48 ff ff       	call   f0100eaf <_panic>

f010c63d <calculate_allocated_space>:

//=====================================
// 6) CALCULATE ALLOCATED SPACE:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010c63d:	55                   	push   %ebp
f010c63e:	89 e5                	mov    %esp,%ebp
f010c640:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_allocated_space() is not implemented yet...!!");
f010c643:	83 ec 04             	sub    $0x4,%esp
f010c646:	68 80 7f 13 f0       	push   $0xf0137f80
f010c64b:	6a 6c                	push   $0x6c
f010c64d:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c652:	e8 58 48 ff ff       	call   f0100eaf <_panic>

f010c657 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010c657:	55                   	push   %ebp
f010c658:	89 e5                	mov    %esp,%ebp
f010c65a:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_required_frames() is not implemented yet...!!");
f010c65d:	83 ec 04             	sub    $0x4,%esp
f010c660:	68 b8 7f 13 f0       	push   $0xf0137fb8
f010c665:	6a 79                	push   $0x79
f010c667:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c66c:	e8 3e 48 ff ff       	call   f0100eaf <_panic>

f010c671 <sys_sbrk>:
//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================

void* sys_sbrk(int numOfPages)
{
f010c671:	55                   	push   %ebp
f010c672:	89 e5                	mov    %esp,%ebp
f010c674:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f010c677:	83 ec 04             	sub    $0x4,%esp
f010c67a:	68 f0 7f 13 f0       	push   $0xf0137ff0
f010c67f:	68 8e 00 00 00       	push   $0x8e
f010c684:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c689:	e8 21 48 ff ff       	call   f0100eaf <_panic>

f010c68e <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010c68e:	55                   	push   %ebp
f010c68f:	89 e5                	mov    %esp,%ebp
f010c691:	83 ec 38             	sub    $0x38,%esp

	//TODO: [PROJECT'25.IM#2] USER HEAP - #2 allocate_user_mem
	//Your code is here
#if USE_KHEAP

    if (!e || size == 0) return;
f010c694:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c698:	0f 84 3d 01 00 00    	je     f010c7db <allocate_user_mem+0x14d>
f010c69e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010c6a2:	0f 84 33 01 00 00    	je     f010c7db <allocate_user_mem+0x14d>

    uint32 start_va = ROUNDDOWN(virtual_address, PAGE_SIZE);
f010c6a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c6ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010c6ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c6b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c6b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32 end_va = ROUNDUP(virtual_address + size, PAGE_SIZE);
f010c6b9:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010c6c0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c6c3:	8b 45 10             	mov    0x10(%ebp),%eax
f010c6c6:	01 c2                	add    %eax,%edx
f010c6c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c6cb:	01 d0                	add    %edx,%eax
f010c6cd:	48                   	dec    %eax
f010c6ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010c6d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c6d4:	ba 00 00 00 00       	mov    $0x0,%edx
f010c6d9:	f7 75 e8             	divl   -0x18(%ebp)
f010c6dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c6df:	29 d0                	sub    %edx,%eax
f010c6e1:	89 45 e0             	mov    %eax,-0x20(%ebp)

    for (uint32 cur = start_va; cur < end_va; cur += PAGE_SIZE) {
f010c6e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c6e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c6ea:	e9 de 00 00 00       	jmp    f010c7cd <allocate_user_mem+0x13f>
        uint32 *pageTable = NULL;
f010c6ef:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
        int ret = get_page_table(e->env_page_directory, cur, &pageTable);
f010c6f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6f9:	8b 40 64             	mov    0x64(%eax),%eax
f010c6fc:	83 ec 04             	sub    $0x4,%esp
f010c6ff:	8d 55 d4             	lea    -0x2c(%ebp),%edx
f010c702:	52                   	push   %edx
f010c703:	ff 75 f4             	pushl  -0xc(%ebp)
f010c706:	50                   	push   %eax
f010c707:	e8 5b d1 ff ff       	call   f0109867 <get_page_table>
f010c70c:	83 c4 10             	add    $0x10,%esp
f010c70f:	89 45 dc             	mov    %eax,-0x24(%ebp)

        if (ret == TABLE_NOT_EXIST) {
f010c712:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010c716:	75 4a                	jne    f010c762 <allocate_user_mem+0xd4>

            if (create_page_table(e->env_page_directory, cur) == NULL) {
f010c718:	8b 45 08             	mov    0x8(%ebp),%eax
f010c71b:	8b 40 64             	mov    0x64(%eax),%eax
f010c71e:	83 ec 08             	sub    $0x8,%esp
f010c721:	ff 75 f4             	pushl  -0xc(%ebp)
f010c724:	50                   	push   %eax
f010c725:	e8 93 d2 ff ff       	call   f01099bd <create_page_table>
f010c72a:	83 c4 10             	add    $0x10,%esp
f010c72d:	85 c0                	test   %eax,%eax
f010c72f:	0f 84 a9 00 00 00    	je     f010c7de <allocate_user_mem+0x150>

                return;
            }

            ret = get_page_table(e->env_page_directory, cur, &pageTable);
f010c735:	8b 45 08             	mov    0x8(%ebp),%eax
f010c738:	8b 40 64             	mov    0x64(%eax),%eax
f010c73b:	83 ec 04             	sub    $0x4,%esp
f010c73e:	8d 55 d4             	lea    -0x2c(%ebp),%edx
f010c741:	52                   	push   %edx
f010c742:	ff 75 f4             	pushl  -0xc(%ebp)
f010c745:	50                   	push   %eax
f010c746:	e8 1c d1 ff ff       	call   f0109867 <get_page_table>
f010c74b:	83 c4 10             	add    $0x10,%esp
f010c74e:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if (ret == TABLE_NOT_EXIST || pageTable == NULL) {
f010c751:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010c755:	0f 84 86 00 00 00    	je     f010c7e1 <allocate_user_mem+0x153>
f010c75b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010c75e:	85 c0                	test   %eax,%eax
f010c760:	74 7f                	je     f010c7e1 <allocate_user_mem+0x153>
                return;
            }
        }


        uint32 ptx = PTX(cur);
f010c762:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c765:	c1 e8 0c             	shr    $0xc,%eax
f010c768:	25 ff 03 00 00       	and    $0x3ff,%eax
f010c76d:	89 45 d8             	mov    %eax,-0x28(%ebp)


        if ((pageTable[ptx] & PERM_PRESENT) == 0) {
f010c770:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010c773:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010c776:	c1 e2 02             	shl    $0x2,%edx
f010c779:	01 d0                	add    %edx,%eax
f010c77b:	8b 00                	mov    (%eax),%eax
f010c77d:	83 e0 01             	and    $0x1,%eax
f010c780:	85 c0                	test   %eax,%eax
f010c782:	75 29                	jne    f010c7ad <allocate_user_mem+0x11f>

            pageTable[ptx] = CONSTRUCT_ENTRY(0, PERM_UHPAGE);
f010c784:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010c787:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010c78a:	c1 e2 02             	shl    $0x2,%edx
f010c78d:	01 d0                	add    %edx,%eax
f010c78f:	c7 00 00 04 00 00    	movl   $0x400,(%eax)

            tlb_invalidate(e->env_page_directory, (void*)cur);
f010c795:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c798:	8b 45 08             	mov    0x8(%ebp),%eax
f010c79b:	8b 40 64             	mov    0x64(%eax),%eax
f010c79e:	83 ec 08             	sub    $0x8,%esp
f010c7a1:	52                   	push   %edx
f010c7a2:	50                   	push   %eax
f010c7a3:	e8 19 ca ff ff       	call   f01091c1 <tlb_invalidate>
f010c7a8:	83 c4 10             	add    $0x10,%esp
f010c7ab:	eb 19                	jmp    f010c7c6 <allocate_user_mem+0x138>
        } else {

            pt_set_page_permissions(e->env_page_directory, cur, PERM_UHPAGE, 0);
f010c7ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7b0:	8b 40 64             	mov    0x64(%eax),%eax
f010c7b3:	6a 00                	push   $0x0
f010c7b5:	68 00 04 00 00       	push   $0x400
f010c7ba:	ff 75 f4             	pushl  -0xc(%ebp)
f010c7bd:	50                   	push   %eax
f010c7be:	e8 99 ed ff ff       	call   f010b55c <pt_set_page_permissions>
f010c7c3:	83 c4 10             	add    $0x10,%esp
    if (!e || size == 0) return;

    uint32 start_va = ROUNDDOWN(virtual_address, PAGE_SIZE);
    uint32 end_va = ROUNDUP(virtual_address + size, PAGE_SIZE);

    for (uint32 cur = start_va; cur < end_va; cur += PAGE_SIZE) {
f010c7c6:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c7cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c7d0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f010c7d3:	0f 82 16 ff ff ff    	jb     f010c6ef <allocate_user_mem+0x61>
f010c7d9:	eb 07                	jmp    f010c7e2 <allocate_user_mem+0x154>

	//TODO: [PROJECT'25.IM#2] USER HEAP - #2 allocate_user_mem
	//Your code is here
#if USE_KHEAP

    if (!e || size == 0) return;
f010c7db:	90                   	nop
f010c7dc:	eb 04                	jmp    f010c7e2 <allocate_user_mem+0x154>

        if (ret == TABLE_NOT_EXIST) {

            if (create_page_table(e->env_page_directory, cur) == NULL) {

                return;
f010c7de:	90                   	nop
f010c7df:	eb 01                	jmp    f010c7e2 <allocate_user_mem+0x154>
            }

            ret = get_page_table(e->env_page_directory, cur, &pageTable);
            if (ret == TABLE_NOT_EXIST || pageTable == NULL) {
                return;
f010c7e1:	90                   	nop

#endif

	//Comment the following line
	//panic("allocate_user_mem() is not implemented yet...!!");
}
f010c7e2:	c9                   	leave  
f010c7e3:	c3                   	ret    

f010c7e4 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010c7e4:	55                   	push   %ebp
f010c7e5:	89 e5                	mov    %esp,%ebp
f010c7e7:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'25.IM#2] USER HEAP - #4 free_user_mem
	//Your code is here

#if USE_KHEAP

    if (!e || size == 0) return;
f010c7ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c7ee:	0f 84 c5 00 00 00    	je     f010c8b9 <free_user_mem+0xd5>
f010c7f4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010c7f8:	0f 84 bb 00 00 00    	je     f010c8b9 <free_user_mem+0xd5>

    uint32 start_va = ROUNDDOWN(virtual_address, PAGE_SIZE);
f010c7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c801:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010c804:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c807:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c80c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32 end_va = ROUNDUP(virtual_address + size, PAGE_SIZE);
f010c80f:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010c816:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c819:	8b 45 10             	mov    0x10(%ebp),%eax
f010c81c:	01 c2                	add    %eax,%edx
f010c81e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c821:	01 d0                	add    %edx,%eax
f010c823:	48                   	dec    %eax
f010c824:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010c827:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c82a:	ba 00 00 00 00       	mov    $0x0,%edx
f010c82f:	f7 75 e8             	divl   -0x18(%ebp)
f010c832:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c835:	29 d0                	sub    %edx,%eax
f010c837:	89 45 e0             	mov    %eax,-0x20(%ebp)

    for (uint32 cur = start_va; cur < end_va; cur += PAGE_SIZE) {
f010c83a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c83d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c840:	eb 6d                	jmp    f010c8af <free_user_mem+0xcb>

        unmap_frame(e->env_page_directory, cur);
f010c842:	8b 45 08             	mov    0x8(%ebp),%eax
f010c845:	8b 40 64             	mov    0x64(%eax),%eax
f010c848:	83 ec 08             	sub    $0x8,%esp
f010c84b:	ff 75 f4             	pushl  -0xc(%ebp)
f010c84e:	50                   	push   %eax
f010c84f:	e8 18 d4 ff ff       	call   f0109c6c <unmap_frame>
f010c854:	83 c4 10             	add    $0x10,%esp


        pf_remove_env_page(e, cur);
f010c857:	83 ec 08             	sub    $0x8,%esp
f010c85a:	ff 75 f4             	pushl  -0xc(%ebp)
f010c85d:	ff 75 08             	pushl  0x8(%ebp)
f010c860:	e8 fa 8d ff ff       	call   f010565f <pf_remove_env_page>
f010c865:	83 c4 10             	add    $0x10,%esp


        env_page_ws_invalidate(e, cur);
f010c868:	83 ec 08             	sub    $0x8,%esp
f010c86b:	ff 75 f4             	pushl  -0xc(%ebp)
f010c86e:	ff 75 08             	pushl  0x8(%ebp)
f010c871:	e8 ac f0 ff ff       	call   f010b922 <env_page_ws_invalidate>
f010c876:	83 c4 10             	add    $0x10,%esp


        pt_set_page_permissions(e->env_page_directory, cur, 0, PERM_UHPAGE | PERM_PRESENT);
f010c879:	8b 45 08             	mov    0x8(%ebp),%eax
f010c87c:	8b 40 64             	mov    0x64(%eax),%eax
f010c87f:	68 01 04 00 00       	push   $0x401
f010c884:	6a 00                	push   $0x0
f010c886:	ff 75 f4             	pushl  -0xc(%ebp)
f010c889:	50                   	push   %eax
f010c88a:	e8 cd ec ff ff       	call   f010b55c <pt_set_page_permissions>
f010c88f:	83 c4 10             	add    $0x10,%esp


        tlb_invalidate(e->env_page_directory, (void*)cur);
f010c892:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c895:	8b 45 08             	mov    0x8(%ebp),%eax
f010c898:	8b 40 64             	mov    0x64(%eax),%eax
f010c89b:	83 ec 08             	sub    $0x8,%esp
f010c89e:	52                   	push   %edx
f010c89f:	50                   	push   %eax
f010c8a0:	e8 1c c9 ff ff       	call   f01091c1 <tlb_invalidate>
f010c8a5:	83 c4 10             	add    $0x10,%esp
    if (!e || size == 0) return;

    uint32 start_va = ROUNDDOWN(virtual_address, PAGE_SIZE);
    uint32 end_va = ROUNDUP(virtual_address + size, PAGE_SIZE);

    for (uint32 cur = start_va; cur < end_va; cur += PAGE_SIZE) {
f010c8a8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c8af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8b2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f010c8b5:	72 8b                	jb     f010c842 <free_user_mem+0x5e>
f010c8b7:	eb 01                	jmp    f010c8ba <free_user_mem+0xd6>
	//TODO: [PROJECT'25.IM#2] USER HEAP - #4 free_user_mem
	//Your code is here

#if USE_KHEAP

    if (!e || size == 0) return;
f010c8b9:	90                   	nop

#endif

	//Comment the following line
	//panic("free_user_mem() is not implemented yet...!!");
}
f010c8ba:	c9                   	leave  
f010c8bb:	c3                   	ret    

f010c8bc <__free_user_mem_with_buffering>:

//=====================================
// 4) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010c8bc:	55                   	push   %ebp
f010c8bd:	89 e5                	mov    %esp,%ebp
f010c8bf:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010c8c2:	83 ec 04             	sub    $0x4,%esp
f010c8c5:	68 0c 80 13 f0       	push   $0xf013800c
f010c8ca:	68 fd 00 00 00       	push   $0xfd
f010c8cf:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c8d4:	e8 d6 45 ff ff       	call   f0100eaf <_panic>

f010c8d9 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010c8d9:	55                   	push   %ebp
f010c8da:	89 e5                	mov    %esp,%ebp
f010c8dc:	83 ec 08             	sub    $0x8,%esp
	panic("move_user_mem() is not implemented yet...!!");
f010c8df:	83 ec 04             	sub    $0x4,%esp
f010c8e2:	68 4c 80 13 f0       	push   $0xf013804c
f010c8e7:	68 05 01 00 00       	push   $0x105
f010c8ec:	68 a2 7e 13 f0       	push   $0xf0137ea2
f010c8f1:	e8 b9 45 ff ff       	call   f0100eaf <_panic>

f010c8f6 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010c8f6:	55                   	push   %ebp
f010c8f7:	89 e5                	mov    %esp,%ebp
f010c8f9:	53                   	push   %ebx
f010c8fa:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010c8fd:	c7 45 f4 67 02 00 00 	movl   $0x267,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010c904:	e9 78 01 00 00       	jmp    f010ca81 <env_init+0x18b>
	{
		envs[iEnv].env_status = ENV_FREE;
f010c909:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010c90f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c912:	89 d0                	mov    %edx,%eax
f010c914:	01 c0                	add    %eax,%eax
f010c916:	01 d0                	add    %edx,%eax
f010c918:	c1 e0 02             	shl    $0x2,%eax
f010c91b:	01 d0                	add    %edx,%eax
f010c91d:	c1 e0 02             	shl    $0x2,%eax
f010c920:	01 d0                	add    %edx,%eax
f010c922:	c1 e0 03             	shl    $0x3,%eax
f010c925:	01 d0                	add    %edx,%eax
f010c927:	c1 e0 02             	shl    $0x2,%eax
f010c92a:	01 c8                	add    %ecx,%eax
f010c92c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010c933:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010c939:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c93c:	89 d0                	mov    %edx,%eax
f010c93e:	01 c0                	add    %eax,%eax
f010c940:	01 d0                	add    %edx,%eax
f010c942:	c1 e0 02             	shl    $0x2,%eax
f010c945:	01 d0                	add    %edx,%eax
f010c947:	c1 e0 02             	shl    $0x2,%eax
f010c94a:	01 d0                	add    %edx,%eax
f010c94c:	c1 e0 03             	shl    $0x3,%eax
f010c94f:	01 d0                	add    %edx,%eax
f010c951:	c1 e0 02             	shl    $0x2,%eax
f010c954:	01 c8                	add    %ecx,%eax
f010c956:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010c95d:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010c963:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c966:	89 d0                	mov    %edx,%eax
f010c968:	01 c0                	add    %eax,%eax
f010c96a:	01 d0                	add    %edx,%eax
f010c96c:	c1 e0 02             	shl    $0x2,%eax
f010c96f:	01 d0                	add    %edx,%eax
f010c971:	c1 e0 02             	shl    $0x2,%eax
f010c974:	01 d0                	add    %edx,%eax
f010c976:	c1 e0 03             	shl    $0x3,%eax
f010c979:	01 d0                	add    %edx,%eax
f010c97b:	c1 e0 02             	shl    $0x2,%eax
f010c97e:	01 c8                	add    %ecx,%eax
f010c980:	85 c0                	test   %eax,%eax
f010c982:	75 14                	jne    f010c998 <env_init+0xa2>
f010c984:	83 ec 04             	sub    $0x4,%esp
f010c987:	68 78 80 13 f0       	push   $0xf0138078
f010c98c:	6a 65                	push   $0x65
f010c98e:	68 9b 80 13 f0       	push   $0xf013809b
f010c993:	e8 17 45 ff ff       	call   f0100eaf <_panic>
f010c998:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010c99e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c9a1:	89 d0                	mov    %edx,%eax
f010c9a3:	01 c0                	add    %eax,%eax
f010c9a5:	01 d0                	add    %edx,%eax
f010c9a7:	c1 e0 02             	shl    $0x2,%eax
f010c9aa:	01 d0                	add    %edx,%eax
f010c9ac:	c1 e0 02             	shl    $0x2,%eax
f010c9af:	01 d0                	add    %edx,%eax
f010c9b1:	c1 e0 03             	shl    $0x3,%eax
f010c9b4:	01 d0                	add    %edx,%eax
f010c9b6:	c1 e0 02             	shl    $0x2,%eax
f010c9b9:	01 c8                	add    %ecx,%eax
f010c9bb:	8b 15 d4 40 92 f0    	mov    0xf09240d4,%edx
f010c9c1:	89 50 08             	mov    %edx,0x8(%eax)
f010c9c4:	8b 40 08             	mov    0x8(%eax),%eax
f010c9c7:	85 c0                	test   %eax,%eax
f010c9c9:	74 2e                	je     f010c9f9 <env_init+0x103>
f010c9cb:	8b 0d d4 40 92 f0    	mov    0xf09240d4,%ecx
f010c9d1:	8b 1d d0 40 92 f0    	mov    0xf09240d0,%ebx
f010c9d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c9da:	89 d0                	mov    %edx,%eax
f010c9dc:	01 c0                	add    %eax,%eax
f010c9de:	01 d0                	add    %edx,%eax
f010c9e0:	c1 e0 02             	shl    $0x2,%eax
f010c9e3:	01 d0                	add    %edx,%eax
f010c9e5:	c1 e0 02             	shl    $0x2,%eax
f010c9e8:	01 d0                	add    %edx,%eax
f010c9ea:	c1 e0 03             	shl    $0x3,%eax
f010c9ed:	01 d0                	add    %edx,%eax
f010c9ef:	c1 e0 02             	shl    $0x2,%eax
f010c9f2:	01 d8                	add    %ebx,%eax
f010c9f4:	89 41 0c             	mov    %eax,0xc(%ecx)
f010c9f7:	eb 28                	jmp    f010ca21 <env_init+0x12b>
f010c9f9:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010c9ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca02:	89 d0                	mov    %edx,%eax
f010ca04:	01 c0                	add    %eax,%eax
f010ca06:	01 d0                	add    %edx,%eax
f010ca08:	c1 e0 02             	shl    $0x2,%eax
f010ca0b:	01 d0                	add    %edx,%eax
f010ca0d:	c1 e0 02             	shl    $0x2,%eax
f010ca10:	01 d0                	add    %edx,%eax
f010ca12:	c1 e0 03             	shl    $0x3,%eax
f010ca15:	01 d0                	add    %edx,%eax
f010ca17:	c1 e0 02             	shl    $0x2,%eax
f010ca1a:	01 c8                	add    %ecx,%eax
f010ca1c:	a3 d8 40 92 f0       	mov    %eax,0xf09240d8
f010ca21:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010ca27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca2a:	89 d0                	mov    %edx,%eax
f010ca2c:	01 c0                	add    %eax,%eax
f010ca2e:	01 d0                	add    %edx,%eax
f010ca30:	c1 e0 02             	shl    $0x2,%eax
f010ca33:	01 d0                	add    %edx,%eax
f010ca35:	c1 e0 02             	shl    $0x2,%eax
f010ca38:	01 d0                	add    %edx,%eax
f010ca3a:	c1 e0 03             	shl    $0x3,%eax
f010ca3d:	01 d0                	add    %edx,%eax
f010ca3f:	c1 e0 02             	shl    $0x2,%eax
f010ca42:	01 c8                	add    %ecx,%eax
f010ca44:	a3 d4 40 92 f0       	mov    %eax,0xf09240d4
f010ca49:	8b 0d d0 40 92 f0    	mov    0xf09240d0,%ecx
f010ca4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca52:	89 d0                	mov    %edx,%eax
f010ca54:	01 c0                	add    %eax,%eax
f010ca56:	01 d0                	add    %edx,%eax
f010ca58:	c1 e0 02             	shl    $0x2,%eax
f010ca5b:	01 d0                	add    %edx,%eax
f010ca5d:	c1 e0 02             	shl    $0x2,%eax
f010ca60:	01 d0                	add    %edx,%eax
f010ca62:	c1 e0 03             	shl    $0x3,%eax
f010ca65:	01 d0                	add    %edx,%eax
f010ca67:	c1 e0 02             	shl    $0x2,%eax
f010ca6a:	01 c8                	add    %ecx,%eax
f010ca6c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ca73:	a1 e0 40 92 f0       	mov    0xf09240e0,%eax
f010ca78:	40                   	inc    %eax
f010ca79:	a3 e0 40 92 f0       	mov    %eax,0xf09240e0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010ca7e:	ff 4d f4             	decl   -0xc(%ebp)
f010ca81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ca85:	0f 89 7e fe ff ff    	jns    f010c909 <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010ca8b:	90                   	nop
f010ca8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ca8f:	c9                   	leave  
f010ca90:	c3                   	ret    

f010ca91 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ca91:	55                   	push   %ebp
f010ca92:	89 e5                	mov    %esp,%ebp
f010ca94:	57                   	push   %edi
f010ca95:	56                   	push   %esi
f010ca96:	53                   	push   %ebx
f010ca97:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[0] 2024: Disable the interrupt through the entire function to avoid concurrency issues while:
	//		1. switching the directories
	//		2. between allocate_environment and removing it later in complete_env..._initi...
	/*THANKS to T58 - 2024/2025*/

	struct Env* e = NULL;
f010ca9d:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
f010caa4:	00 00 00 

	pushcli();
f010caa7:	e8 16 bb ff ff       	call   f01085c2 <pushcli>
	{
		//[1] get pointer to the start of the "user_program_name" program in memory
		// Hint: use "get_user_program_info" function,
		// you should set the following "ptr_program_start" by the start address of the user program
		uint8* ptr_program_start = 0;
f010caac:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)

		struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010cab3:	83 ec 0c             	sub    $0xc,%esp
f010cab6:	ff 75 08             	pushl  0x8(%ebp)
f010cab9:	e8 8d 20 00 00       	call   f010eb4b <get_user_program_info>
f010cabe:	83 c4 10             	add    $0x10,%esp
f010cac1:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if(ptr_user_program_info == 0)
f010cac4:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f010cac8:	75 0f                	jne    f010cad9 <env_create+0x48>
		{
			popcli();
f010caca:	e8 45 bb ff ff       	call   f0108614 <popcli>
			return NULL;
f010cacf:	b8 00 00 00 00       	mov    $0x0,%eax
f010cad4:	e9 b6 0a 00 00       	jmp    f010d58f <env_create+0xafe>
		}
		ptr_program_start = ptr_user_program_info->ptr_start ;
f010cad9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010cadc:	8b 40 08             	mov    0x8(%eax),%eax
f010cadf:	89 45 b0             	mov    %eax,-0x50(%ebp)

		//[2] allocate new environment, (from the free environment list)
		//if there's no one, return NULL
		// Hint: use "allocate_environment" function
		if(allocate_environment(&e) < 0)
f010cae2:	83 ec 0c             	sub    $0xc,%esp
f010cae5:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010caeb:	50                   	push   %eax
f010caec:	e8 bd 0f 00 00       	call   f010daae <allocate_environment>
f010caf1:	83 c4 10             	add    $0x10,%esp
f010caf4:	85 c0                	test   %eax,%eax
f010caf6:	79 0f                	jns    f010cb07 <env_create+0x76>
		{
			popcli();
f010caf8:	e8 17 bb ff ff       	call   f0108614 <popcli>
			return NULL;
f010cafd:	b8 00 00 00 00       	mov    $0x0,%eax
f010cb02:	e9 88 0a 00 00       	jmp    f010d58f <env_create+0xafe>
		}

		//[2.5 - 2012] Set program name inside the environment
		//e->prog_name = ptr_user_program_info->name ;
		//2017: changed to fixed size array to be abale to access it from user side
		if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010cb07:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010cb0a:	8b 00                	mov    (%eax),%eax
f010cb0c:	83 ec 0c             	sub    $0xc,%esp
f010cb0f:	50                   	push   %eax
f010cb10:	e8 1a 63 01 00       	call   f0122e2f <strlen>
f010cb15:	83 c4 10             	add    $0x10,%esp
f010cb18:	83 f8 3f             	cmp    $0x3f,%eax
f010cb1b:	7f 1d                	jg     f010cb3a <env_create+0xa9>
			strcpy(e->prog_name, ptr_user_program_info->name);
f010cb1d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010cb20:	8b 00                	mov    (%eax),%eax
f010cb22:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010cb28:	83 c2 20             	add    $0x20,%edx
f010cb2b:	83 ec 08             	sub    $0x8,%esp
f010cb2e:	50                   	push   %eax
f010cb2f:	52                   	push   %edx
f010cb30:	e8 49 63 01 00       	call   f0122e7e <strcpy>
f010cb35:	83 c4 10             	add    $0x10,%esp
f010cb38:	eb 1d                	jmp    f010cb57 <env_create+0xc6>
		else
			strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010cb3a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010cb3d:	8b 00                	mov    (%eax),%eax
f010cb3f:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010cb45:	83 c2 20             	add    $0x20,%edx
f010cb48:	83 ec 04             	sub    $0x4,%esp
f010cb4b:	6a 3f                	push   $0x3f
f010cb4d:	50                   	push   %eax
f010cb4e:	52                   	push   %edx
f010cb4f:	e8 58 63 01 00       	call   f0122eac <strncpy>
f010cb54:	83 c4 10             	add    $0x10,%esp
		//REMEMBER: "allocate_frame" should always return a free frame
		uint32* ptr_user_page_directory;
		unsigned int phys_user_page_directory;
#if USE_KHEAP
		{
			ptr_user_page_directory = create_user_directory();
f010cb57:	e8 d4 15 00 00       	call   f010e130 <create_user_directory>
f010cb5c:	89 45 a8             	mov    %eax,-0x58(%ebp)
			phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010cb5f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010cb62:	83 ec 0c             	sub    $0xc,%esp
f010cb65:	50                   	push   %eax
f010cb66:	e8 21 e9 ff ff       	call   f010b48c <kheap_physical_address>
f010cb6b:	83 c4 10             	add    $0x10,%esp
f010cb6e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
		//[4] initialize the new environment by the virtual address of the page directory
		// Hint: use "initialize_environment" function

		//2016
		e->page_WS_max_size = page_WS_size;
f010cb71:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cb77:	8b 55 0c             	mov    0xc(%ebp),%edx
f010cb7a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

		//2020
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010cb80:	83 ec 0c             	sub    $0xc,%esp
f010cb83:	6a 02                	push   $0x2
f010cb85:	e8 f4 4a 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010cb8a:	83 c4 10             	add    $0x10,%esp
f010cb8d:	85 c0                	test   %eax,%eax
f010cb8f:	74 21                	je     f010cbb2 <env_create+0x121>
		{
			e->SecondListSize = LRU_second_list_size;
f010cb91:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cb97:	8b 55 10             	mov    0x10(%ebp),%edx
f010cb9a:	89 90 68 06 00 00    	mov    %edx,0x668(%eax)
			e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010cba0:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cba6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010cba9:	2b 55 10             	sub    0x10(%ebp),%edx
f010cbac:	89 90 64 06 00 00    	mov    %edx,0x664(%eax)
		}

		//2018
		if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010cbb2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010cbb6:	75 12                	jne    f010cbca <env_create+0x139>
			e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010cbb8:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cbbe:	c7 80 70 06 00 00 0a 	movl   $0xa,0x670(%eax)
f010cbc5:	00 00 00 
f010cbc8:	eb 0f                	jmp    f010cbd9 <env_create+0x148>
		else
			e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010cbca:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cbd0:	8b 55 14             	mov    0x14(%ebp),%edx
f010cbd3:	89 90 70 06 00 00    	mov    %edx,0x670(%eax)

		initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010cbd9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cbdf:	83 ec 04             	sub    $0x4,%esp
f010cbe2:	ff 75 a4             	pushl  -0x5c(%ebp)
f010cbe5:	ff 75 a8             	pushl  -0x58(%ebp)
f010cbe8:	50                   	push   %eax
f010cbe9:	e8 54 16 00 00       	call   f010e242 <initialize_environment>
f010cbee:	83 c4 10             	add    $0x10,%esp

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010cbf1:	0f 20 d8             	mov    %cr3,%eax
f010cbf4:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f010cbf7:	8b 45 98             	mov    -0x68(%ebp),%eax
		//	3- uint32 size_in_memory: actual size required by this segment in memory
		// 	usually size_in_file < or = size_in_memory
		//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010cbfa:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f010cbfd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cc03:	8b 40 68             	mov    0x68(%eax),%eax
f010cc06:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010cc0c:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010cc12:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010cc15:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f010cc1c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010cc23:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cc29:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010cc2f:	48                   	dec    %eax
f010cc30:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010cc33:	c7 85 40 ff ff ff ff 	movl   $0xffffffff,-0xc0(%ebp)
f010cc3a:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010cc3d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f010cc43:	83 ec 08             	sub    $0x8,%esp
f010cc46:	ff 75 b0             	pushl  -0x50(%ebp)
f010cc49:	50                   	push   %eax
f010cc4a:	e8 0b 1c 00 00       	call   f010e85a <PROGRAM_SEGMENT_FIRST>
f010cc4f:	83 c4 0c             	add    $0xc,%esp
f010cc52:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010cc58:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f010cc5e:	b9 05 00 00 00       	mov    $0x5,%ecx
f010cc63:	89 c7                	mov    %eax,%edi
f010cc65:	89 d6                	mov    %edx,%esi
f010cc67:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cc69:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010cc6f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cc72:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc75:	8b 40 10             	mov    0x10(%eax),%eax
f010cc78:	83 f8 ff             	cmp    $0xffffffff,%eax
f010cc7b:	75 07                	jne    f010cc84 <env_create+0x1f3>
f010cc7d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010cc84:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc87:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010cc8a:	e9 2d 03 00 00       	jmp    f010cfbc <env_create+0x52b>
		{
			segment_counter++;
f010cc8f:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010cc92:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
f010cc99:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010cc9c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cca2:	83 ec 0c             	sub    $0xc,%esp
f010cca5:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010ccab:	52                   	push   %edx
f010ccac:	ff 75 dc             	pushl  -0x24(%ebp)
f010ccaf:	8d 95 28 ff ff ff    	lea    -0xd8(%ebp),%edx
f010ccb5:	52                   	push   %edx
f010ccb6:	ff 75 e4             	pushl  -0x1c(%ebp)
f010ccb9:	50                   	push   %eax
f010ccba:	e8 ad 0e 00 00       	call   f010db6c <program_segment_alloc_map_copy_workingset>
f010ccbf:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010ccc2:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f010ccc8:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010cccb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ccce:	8b 00                	mov    (%eax),%eax
f010ccd0:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010ccd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ccd6:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccd9:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010ccdc:	8b 45 90             	mov    -0x70(%ebp),%eax
f010ccdf:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010cce2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010cce5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ccea:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010cced:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f010ccf4:	8b 55 90             	mov    -0x70(%ebp),%edx
f010ccf7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f010ccfa:	01 d0                	add    %edx,%eax
f010ccfc:	48                   	dec    %eax
f010ccfd:	89 45 80             	mov    %eax,-0x80(%ebp)
f010cd00:	8b 45 80             	mov    -0x80(%ebp),%eax
f010cd03:	ba 00 00 00 00       	mov    $0x0,%edx
f010cd08:	f7 75 84             	divl   -0x7c(%ebp)
f010cd0b:	8b 45 80             	mov    -0x80(%ebp),%eax
f010cd0e:	29 d0                	sub    %edx,%eax
f010cd10:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010cd16:	8b 45 90             	mov    -0x70(%ebp),%eax
f010cd19:	2b 45 88             	sub    -0x78(%ebp),%eax
f010cd1c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010cd22:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010cd25:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010cd28:	8b 15 04 54 96 f1    	mov    0xf1965404,%edx
f010cd2e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010cd34:	01 d0                	add    %edx,%eax
f010cd36:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			if (offset_first_page)
f010cd39:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f010cd40:	74 76                	je     f010cdb8 <env_create+0x327>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010cd42:	a1 04 54 96 f1       	mov    0xf1965404,%eax
f010cd47:	83 ec 04             	sub    $0x4,%esp
f010cd4a:	68 00 10 00 00       	push   $0x1000
f010cd4f:	6a 00                	push   $0x0
f010cd51:	50                   	push   %eax
f010cd52:	e8 c6 62 01 00       	call   f012301d <memset>
f010cd57:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010cd5a:	8b 45 90             	mov    -0x70(%ebp),%eax
f010cd5d:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010cd60:	eb 13                	jmp    f010cd75 <env_create+0x2e4>
				{
					*dst_ptr = *src_ptr ;
f010cd62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010cd65:	8a 10                	mov    (%eax),%dl
f010cd67:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010cd6a:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010cd6c:	ff 45 cc             	incl   -0x34(%ebp)
f010cd6f:	ff 45 d4             	incl   -0x2c(%ebp)
f010cd72:	ff 45 d0             	incl   -0x30(%ebp)
f010cd75:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010cd78:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f010cd7e:	72 e2                	jb     f010cd62 <env_create+0x2d1>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010cd80:	8b 15 04 54 96 f1    	mov    0xf1965404,%edx
f010cd86:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cd8c:	83 ec 04             	sub    $0x4,%esp
f010cd8f:	52                   	push   %edx
f010cd90:	ff 75 88             	pushl  -0x78(%ebp)
f010cd93:	50                   	push   %eax
f010cd94:	e8 b5 84 ff ff       	call   f010524e <pf_add_env_page>
f010cd99:	83 c4 10             	add    $0x10,%esp
f010cd9c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010cd9f:	75 17                	jne    f010cdb8 <env_create+0x327>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010cda1:	83 ec 04             	sub    $0x4,%esp
f010cda4:	68 b8 80 13 f0       	push   $0xf01380b8
f010cda9:	68 fe 00 00 00       	push   $0xfe
f010cdae:	68 9b 80 13 f0       	push   $0xf013809b
f010cdb3:	e8 f7 40 ff ff       	call   f0100eaf <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010cdb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cdbb:	8b 50 04             	mov    0x4(%eax),%edx
f010cdbe:	8b 45 90             	mov    -0x70(%ebp),%eax
f010cdc1:	01 d0                	add    %edx,%eax
f010cdc3:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010cdc9:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010cdcf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010cdd4:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010cdda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cddd:	8b 50 04             	mov    0x4(%eax),%edx
f010cde0:	8b 45 90             	mov    -0x70(%ebp),%eax
f010cde3:	01 d0                	add    %edx,%eax
f010cde5:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010cdeb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010cdf1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010cdf4:	eb 43                	jmp    f010ce39 <env_create+0x3a8>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010cdf6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010cdf9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cdff:	83 ec 04             	sub    $0x4,%esp
f010ce02:	ff 75 d4             	pushl  -0x2c(%ebp)
f010ce05:	52                   	push   %edx
f010ce06:	50                   	push   %eax
f010ce07:	e8 42 84 ff ff       	call   f010524e <pf_add_env_page>
f010ce0c:	83 c4 10             	add    $0x10,%esp
f010ce0f:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ce12:	75 17                	jne    f010ce2b <env_create+0x39a>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ce14:	83 ec 04             	sub    $0x4,%esp
f010ce17:	68 b8 80 13 f0       	push   $0xf01380b8
f010ce1c:	68 0b 01 00 00       	push   $0x10b
f010ce21:	68 9b 80 13 f0       	push   $0xf013809b
f010ce26:	e8 84 40 ff ff       	call   f0100eaf <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ce2b:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010ce32:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f010ce39:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ce3c:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f010ce42:	72 b2                	jb     f010cdf6 <env_create+0x365>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010ce44:	a1 04 54 96 f1       	mov    0xf1965404,%eax
f010ce49:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010ce4c:	83 ec 04             	sub    $0x4,%esp
f010ce4f:	68 00 10 00 00       	push   $0x1000
f010ce54:	6a 00                	push   $0x0
f010ce56:	ff 75 d0             	pushl  -0x30(%ebp)
f010ce59:	e8 bf 61 01 00       	call   f012301d <memset>
f010ce5e:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010ce61:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010ce67:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010ce6a:	eb 13                	jmp    f010ce7f <env_create+0x3ee>
			{
				*dst_ptr = *src_ptr;
f010ce6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ce6f:	8a 10                	mov    (%eax),%dl
f010ce71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ce74:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010ce76:	ff 45 cc             	incl   -0x34(%ebp)
f010ce79:	ff 45 d4             	incl   -0x2c(%ebp)
f010ce7c:	ff 45 d0             	incl   -0x30(%ebp)
f010ce7f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ce82:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f010ce88:	72 e2                	jb     f010ce6c <env_create+0x3db>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010ce8a:	8b 15 04 54 96 f1    	mov    0xf1965404,%edx
f010ce90:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010ce96:	83 ec 04             	sub    $0x4,%esp
f010ce99:	52                   	push   %edx
f010ce9a:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f010cea0:	50                   	push   %eax
f010cea1:	e8 a8 83 ff ff       	call   f010524e <pf_add_env_page>
f010cea6:	83 c4 10             	add    $0x10,%esp
f010cea9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ceac:	75 17                	jne    f010cec5 <env_create+0x434>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ceae:	83 ec 04             	sub    $0x4,%esp
f010ceb1:	68 b8 80 13 f0       	push   $0xf01380b8
f010ceb6:	68 1a 01 00 00       	push   $0x11a
f010cebb:	68 9b 80 13 f0       	push   $0xf013809b
f010cec0:	e8 ea 3f ff ff       	call   f0100eaf <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010cec5:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f010cecc:	10 00 00 
f010cecf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ced2:	8b 50 04             	mov    0x4(%eax),%edx
f010ced5:	8b 45 90             	mov    -0x70(%ebp),%eax
f010ced8:	01 c2                	add    %eax,%edx
f010ceda:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f010cee0:	01 d0                	add    %edx,%eax
f010cee2:	48                   	dec    %eax
f010cee3:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f010cee9:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010ceef:	ba 00 00 00 00       	mov    $0x0,%edx
f010cef4:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f010cefa:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010cf00:	29 d0                	sub    %edx,%eax
f010cf02:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010cf05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cf08:	8b 50 08             	mov    0x8(%eax),%edx
f010cf0b:	8b 45 90             	mov    -0x70(%ebp),%eax
f010cf0e:	01 d0                	add    %edx,%eax
f010cf10:	2b 45 c8             	sub    -0x38(%ebp),%eax
f010cf13:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010cf19:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010cf20:	eb 41                	jmp    f010cf63 <env_create+0x4d2>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010cf22:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cf28:	83 ec 04             	sub    $0x4,%esp
f010cf2b:	6a 01                	push   $0x1
f010cf2d:	ff 75 c8             	pushl  -0x38(%ebp)
f010cf30:	50                   	push   %eax
f010cf31:	e8 ea 81 ff ff       	call   f0105120 <pf_add_empty_env_page>
f010cf36:	83 c4 10             	add    $0x10,%esp
f010cf39:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010cf3c:	75 17                	jne    f010cf55 <env_create+0x4c4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010cf3e:	83 ec 04             	sub    $0x4,%esp
f010cf41:	68 b8 80 13 f0       	push   $0xf01380b8
f010cf46:	68 27 01 00 00       	push   $0x127
f010cf4b:	68 9b 80 13 f0       	push   $0xf013809b
f010cf50:	e8 5a 3f ff ff       	call   f0100eaf <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010cf55:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010cf5c:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f010cf63:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f010cf6a:	10 00 00 
f010cf6d:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f010cf73:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010cf79:	01 d0                	add    %edx,%eax
f010cf7b:	48                   	dec    %eax
f010cf7c:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f010cf82:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010cf88:	ba 00 00 00 00       	mov    $0x0,%edx
f010cf8d:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f010cf93:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010cf99:	29 d0                	sub    %edx,%eax
f010cf9b:	89 c2                	mov    %eax,%edx
f010cf9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010cfa0:	39 c2                	cmp    %eax,%edx
f010cfa2:	0f 87 7a ff ff ff    	ja     f010cf22 <env_create+0x491>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010cfa8:	83 ec 08             	sub    $0x8,%esp
f010cfab:	ff 75 b0             	pushl  -0x50(%ebp)
f010cfae:	ff 75 e4             	pushl  -0x1c(%ebp)
f010cfb1:	e8 99 17 00 00       	call   f010e74f <PROGRAM_SEGMENT_NEXT>
f010cfb6:	83 c4 10             	add    $0x10,%esp
f010cfb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010cfbc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010cfc0:	0f 85 c9 fc ff ff    	jne    f010cc8f <env_create+0x1fe>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010cfc6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cfcc:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010cfd2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010cfd5:	eb 77                	jmp    f010d04e <env_create+0x5bd>
		{
			uint32 virtual_address = wse->virtual_address;
f010cfd7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010cfda:	8b 00                	mov    (%eax),%eax
f010cfdc:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010cfe2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010cfe8:	8b 40 64             	mov    0x64(%eax),%eax
f010cfeb:	83 ec 04             	sub    $0x4,%esp
f010cfee:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
f010cff4:	52                   	push   %edx
f010cff5:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f010cffb:	50                   	push   %eax
f010cffc:	e8 66 c8 ff ff       	call   f0109867 <get_page_table>
f010d001:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010d004:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f010d00a:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f010d010:	c1 ea 0c             	shr    $0xc,%edx
f010d013:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010d019:	c1 e2 02             	shl    $0x2,%edx
f010d01c:	01 d0                	add    %edx,%eax
f010d01e:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f010d024:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f010d02a:	c1 e9 0c             	shr    $0xc,%ecx
f010d02d:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010d033:	c1 e1 02             	shl    $0x2,%ecx
f010d036:	01 ca                	add    %ecx,%edx
f010d038:	8b 12                	mov    (%edx),%edx
f010d03a:	83 e2 bf             	and    $0xffffffbf,%edx
f010d03d:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010d03f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d045:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d04b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010d04e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d054:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010d058:	74 08                	je     f010d062 <env_create+0x5d1>
f010d05a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d05d:	8b 52 10             	mov    0x10(%edx),%edx
f010d060:	eb 05                	jmp    f010d067 <env_create+0x5d6>
f010d062:	ba 00 00 00 00       	mov    $0x0,%edx
f010d067:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010d06d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d073:	85 c0                	test   %eax,%eax
f010d075:	0f 85 5c ff ff ff    	jne    f010cfd7 <env_create+0x546>
f010d07b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010d07f:	0f 85 52 ff ff ff    	jne    f010cfd7 <env_create+0x546>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010d085:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010d088:	8b 50 08             	mov    0x8(%eax),%edx
f010d08b:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d091:	83 ec 08             	sub    $0x8,%esp
f010d094:	52                   	push   %edx
f010d095:	50                   	push   %eax
f010d096:	e8 74 16 00 00       	call   f010e70f <set_environment_entry_point>
f010d09b:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010d09e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d0a4:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010d0ab:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f010d0b2:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010d0b5:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010d0bc:	e9 42 03 00 00       	jmp    f010d403 <env_create+0x972>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010d0c1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f010d0c8:	00 00 00 
			allocate_frame(&pp);
f010d0cb:	83 ec 0c             	sub    $0xc,%esp
f010d0ce:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f010d0d4:	50                   	push   %eax
f010d0d5:	e8 7c c5 ff ff       	call   f0109656 <allocate_frame>
f010d0da:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010d0dd:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f010d0e3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d0e9:	8b 40 64             	mov    0x64(%eax),%eax
f010d0ec:	6a 06                	push   $0x6
f010d0ee:	ff 75 c0             	pushl  -0x40(%ebp)
f010d0f1:	52                   	push   %edx
f010d0f2:	50                   	push   %eax
f010d0f3:	e8 18 cc ff ff       	call   f0109d10 <loadtime_map_frame>
f010d0f8:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010d0fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010d0fe:	83 ec 04             	sub    $0x4,%esp
f010d101:	68 00 10 00 00       	push   $0x1000
f010d106:	6a 00                	push   $0x0
f010d108:	50                   	push   %eax
f010d109:	e8 0f 5f 01 00       	call   f012301d <memset>
f010d10e:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010d111:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d117:	83 ec 08             	sub    $0x8,%esp
f010d11a:	ff 75 c0             	pushl  -0x40(%ebp)
f010d11d:	50                   	push   %eax
f010d11e:	e8 6e e7 ff ff       	call   f010b891 <env_page_ws_list_create_element>
f010d123:	83 c4 10             	add    $0x10,%esp
f010d126:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010d129:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010d12d:	75 17                	jne    f010d146 <env_create+0x6b5>
f010d12f:	83 ec 04             	sub    $0x4,%esp
f010d132:	68 00 81 13 f0       	push   $0xf0138100
f010d137:	68 66 01 00 00       	push   $0x166
f010d13c:	68 9b 80 13 f0       	push   $0xf013809b
f010d141:	e8 69 3d ff ff       	call   f0100eaf <_panic>
f010d146:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d14c:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010d152:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d155:	89 50 14             	mov    %edx,0x14(%eax)
f010d158:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d15b:	8b 40 14             	mov    0x14(%eax),%eax
f010d15e:	85 c0                	test   %eax,%eax
f010d160:	74 14                	je     f010d176 <env_create+0x6e5>
f010d162:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d168:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010d16e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d171:	89 50 10             	mov    %edx,0x10(%eax)
f010d174:	eb 0f                	jmp    f010d185 <env_create+0x6f4>
f010d176:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d17c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d17f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010d185:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d18b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d18e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010d194:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d197:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010d19e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d1a4:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010d1aa:	42                   	inc    %edx
f010d1ab:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010d1b1:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d1b7:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010d1bd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d1c3:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010d1c9:	39 c2                	cmp    %eax,%edx
f010d1cb:	75 1a                	jne    f010d1e7 <env_create+0x756>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010d1cd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d1d3:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010d1d9:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010d1df:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f010d1e5:	eb 10                	jmp    f010d1f7 <env_create+0x766>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010d1e7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d1ed:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f010d1f4:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010d1f7:	83 ec 0c             	sub    $0xc,%esp
f010d1fa:	6a 02                	push   $0x2
f010d1fc:	e8 7d 44 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010d201:	83 c4 10             	add    $0x10,%esp
f010d204:	85 c0                	test   %eax,%eax
f010d206:	0f 84 d3 01 00 00    	je     f010d3df <env_create+0x94e>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010d20c:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010d210:	75 17                	jne    f010d229 <env_create+0x798>
f010d212:	83 ec 04             	sub    $0x4,%esp
f010d215:	68 23 81 13 f0       	push   $0xf0138123
f010d21a:	68 73 01 00 00       	push   $0x173
f010d21f:	68 9b 80 13 f0       	push   $0xf013809b
f010d224:	e8 86 3c ff ff       	call   f0100eaf <_panic>
f010d229:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d22c:	8b 40 10             	mov    0x10(%eax),%eax
f010d22f:	85 c0                	test   %eax,%eax
f010d231:	74 11                	je     f010d244 <env_create+0x7b3>
f010d233:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d236:	8b 40 10             	mov    0x10(%eax),%eax
f010d239:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d23c:	8b 52 14             	mov    0x14(%edx),%edx
f010d23f:	89 50 14             	mov    %edx,0x14(%eax)
f010d242:	eb 12                	jmp    f010d256 <env_create+0x7c5>
f010d244:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d24a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d24d:	8b 52 14             	mov    0x14(%edx),%edx
f010d250:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010d256:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d259:	8b 40 14             	mov    0x14(%eax),%eax
f010d25c:	85 c0                	test   %eax,%eax
f010d25e:	74 11                	je     f010d271 <env_create+0x7e0>
f010d260:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d263:	8b 40 14             	mov    0x14(%eax),%eax
f010d266:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d269:	8b 52 10             	mov    0x10(%edx),%edx
f010d26c:	89 50 10             	mov    %edx,0x10(%eax)
f010d26f:	eb 12                	jmp    f010d283 <env_create+0x7f2>
f010d271:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d277:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d27a:	8b 52 10             	mov    0x10(%edx),%edx
f010d27d:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010d283:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d286:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010d28d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d290:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010d297:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d29d:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010d2a3:	4a                   	dec    %edx
f010d2a4:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010d2aa:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d2b0:	8b 90 50 06 00 00    	mov    0x650(%eax),%edx
f010d2b6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d2bc:	8b 80 64 06 00 00    	mov    0x664(%eax),%eax
f010d2c2:	39 c2                	cmp    %eax,%edx
f010d2c4:	0f 83 8d 00 00 00    	jae    f010d357 <env_create+0x8c6>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010d2ca:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010d2ce:	75 17                	jne    f010d2e7 <env_create+0x856>
f010d2d0:	83 ec 04             	sub    $0x4,%esp
f010d2d3:	68 78 80 13 f0       	push   $0xf0138078
f010d2d8:	68 78 01 00 00       	push   $0x178
f010d2dd:	68 9b 80 13 f0       	push   $0xf013809b
f010d2e2:	e8 c8 3b ff ff       	call   f0100eaf <_panic>
f010d2e7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d2ed:	8b 90 44 06 00 00    	mov    0x644(%eax),%edx
f010d2f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d2f6:	89 50 10             	mov    %edx,0x10(%eax)
f010d2f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d2fc:	8b 40 10             	mov    0x10(%eax),%eax
f010d2ff:	85 c0                	test   %eax,%eax
f010d301:	74 14                	je     f010d317 <env_create+0x886>
f010d303:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d309:	8b 80 44 06 00 00    	mov    0x644(%eax),%eax
f010d30f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d312:	89 50 14             	mov    %edx,0x14(%eax)
f010d315:	eb 0f                	jmp    f010d326 <env_create+0x895>
f010d317:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d31d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d320:	89 90 48 06 00 00    	mov    %edx,0x648(%eax)
f010d326:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d32c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d32f:	89 90 44 06 00 00    	mov    %edx,0x644(%eax)
f010d335:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d338:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010d33f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d345:	8b 90 50 06 00 00    	mov    0x650(%eax),%edx
f010d34b:	42                   	inc    %edx
f010d34c:	89 90 50 06 00 00    	mov    %edx,0x650(%eax)
f010d352:	e9 88 00 00 00       	jmp    f010d3df <env_create+0x94e>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010d357:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010d35b:	75 17                	jne    f010d374 <env_create+0x8e3>
f010d35d:	83 ec 04             	sub    $0x4,%esp
f010d360:	68 78 80 13 f0       	push   $0xf0138078
f010d365:	68 7c 01 00 00       	push   $0x17c
f010d36a:	68 9b 80 13 f0       	push   $0xf013809b
f010d36f:	e8 3b 3b ff ff       	call   f0100eaf <_panic>
f010d374:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d37a:	8b 90 54 06 00 00    	mov    0x654(%eax),%edx
f010d380:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d383:	89 50 10             	mov    %edx,0x10(%eax)
f010d386:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d389:	8b 40 10             	mov    0x10(%eax),%eax
f010d38c:	85 c0                	test   %eax,%eax
f010d38e:	74 14                	je     f010d3a4 <env_create+0x913>
f010d390:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d396:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f010d39c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d39f:	89 50 14             	mov    %edx,0x14(%eax)
f010d3a2:	eb 0f                	jmp    f010d3b3 <env_create+0x922>
f010d3a4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d3aa:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d3ad:	89 90 58 06 00 00    	mov    %edx,0x658(%eax)
f010d3b3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d3b9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010d3bc:	89 90 54 06 00 00    	mov    %edx,0x654(%eax)
f010d3c2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010d3c5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010d3cc:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d3d2:	8b 90 60 06 00 00    	mov    0x660(%eax),%edx
f010d3d8:	42                   	inc    %edx
f010d3d9:	89 90 60 06 00 00    	mov    %edx,0x660(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010d3df:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d3e5:	83 ec 04             	sub    $0x4,%esp
f010d3e8:	6a 01                	push   $0x1
f010d3ea:	ff 75 c0             	pushl  -0x40(%ebp)
f010d3ed:	50                   	push   %eax
f010d3ee:	e8 2d 7d ff ff       	call   f0105120 <pf_add_empty_env_page>
f010d3f3:	83 c4 10             	add    $0x10,%esp
f010d3f6:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010d3fc:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010d403:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010d406:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010d40c:	0f 83 af fc ff ff    	jae    f010d0c1 <env_create+0x630>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010d412:	83 ec 0c             	sub    $0xc,%esp
f010d415:	6a 02                	push   $0x2
f010d417:	e8 62 42 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010d41c:	83 c4 10             	add    $0x10,%esp
f010d41f:	85 c0                	test   %eax,%eax
f010d421:	74 72                	je     f010d495 <env_create+0xa04>
		{
			struct WorkingSetElement * elm = NULL;
f010d423:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010d42a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d430:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f010d436:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010d439:	eb 2b                	jmp    f010d466 <env_create+0x9d5>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010d43b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010d43e:	8b 10                	mov    (%eax),%edx
f010d440:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d446:	8b 40 64             	mov    0x64(%eax),%eax
f010d449:	6a 01                	push   $0x1
f010d44b:	6a 00                	push   $0x0
f010d44d:	52                   	push   %edx
f010d44e:	50                   	push   %eax
f010d44f:	e8 08 e1 ff ff       	call   f010b55c <pt_set_page_permissions>
f010d454:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010d457:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d45d:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f010d463:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010d466:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d46c:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010d470:	74 08                	je     f010d47a <env_create+0x9e9>
f010d472:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010d475:	8b 52 10             	mov    0x10(%edx),%edx
f010d478:	eb 05                	jmp    f010d47f <env_create+0x9ee>
f010d47a:	ba 00 00 00 00       	mov    $0x0,%edx
f010d47f:	89 90 5c 06 00 00    	mov    %edx,0x65c(%eax)
f010d485:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f010d48b:	85 c0                	test   %eax,%eax
f010d48d:	75 ac                	jne    f010d43b <env_create+0x9aa>
f010d48f:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010d493:	75 a6                	jne    f010d43b <env_create+0x9aa>
f010d495:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010d498:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010d49b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010d49e:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010d4a1:	e8 6e b1 ff ff       	call   f0108614 <popcli>

	//[13] Copy the prepaged VAs into the corresponding array
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
f010d4a6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d4ac:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010d4b2:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010d4b8:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
f010d4be:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f010d4c4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d4ca:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
f010d4d0:	c1 e0 02             	shl    $0x2,%eax
f010d4d3:	83 ec 0c             	sub    $0xc,%esp
f010d4d6:	50                   	push   %eax
f010d4d7:	e8 f6 d9 ff ff       	call   f010aed2 <kmalloc>
f010d4dc:	83 c4 10             	add    $0x10,%esp
f010d4df:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
	struct WorkingSetElement *ptrWSE;
	int w = 0;
f010d4e5:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010d4ec:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d4f2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010d4f8:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010d4fb:	eb 31                	jmp    f010d52e <env_create+0xa9d>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
f010d4fd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d503:	8b 88 c0 00 00 00    	mov    0xc0(%eax),%ecx
f010d509:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010d50c:	8d 50 01             	lea    0x1(%eax),%edx
f010d50f:	89 55 b4             	mov    %edx,-0x4c(%ebp)
f010d512:	c1 e0 02             	shl    $0x2,%eax
f010d515:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010d518:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010d51b:	8b 00                	mov    (%eax),%eax
f010d51d:	89 02                	mov    %eax,(%edx)
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
	struct WorkingSetElement *ptrWSE;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010d51f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d525:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d52b:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010d52e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d534:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010d538:	74 08                	je     f010d542 <env_create+0xab1>
f010d53a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010d53d:	8b 52 10             	mov    0x10(%edx),%edx
f010d540:	eb 05                	jmp    f010d547 <env_create+0xab6>
f010d542:	ba 00 00 00 00       	mov    $0x0,%edx
f010d547:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010d54d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d553:	85 c0                	test   %eax,%eax
f010d555:	75 a6                	jne    f010d4fd <env_create+0xa6c>
f010d557:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010d55b:	75 a0                	jne    f010d4fd <env_create+0xa6c>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
	}
	assert(w == e->numOfPrepagedVAs);
f010d55d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010d563:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
f010d569:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010d56c:	39 c2                	cmp    %eax,%edx
f010d56e:	74 19                	je     f010d589 <env_create+0xaf8>
f010d570:	68 41 81 13 f0       	push   $0xf0138141
f010d575:	68 5a 81 13 f0       	push   $0xf013815a
f010d57a:	68 b9 01 00 00       	push   $0x1b9
f010d57f:	68 9b 80 13 f0       	push   $0xf013809b
f010d584:	e8 26 39 ff ff       	call   f0100eaf <_panic>
		//env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010d589:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
}
f010d58f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d592:	5b                   	pop    %ebx
f010d593:	5e                   	pop    %esi
f010d594:	5f                   	pop    %edi
f010d595:	5d                   	pop    %ebp
f010d596:	c3                   	ret    

f010d597 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010d597:	55                   	push   %ebp
f010d598:	89 e5                	mov    %esp,%ebp
f010d59a:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_kspinlock(&ProcessQueues.qlock);
f010d59d:	83 ec 0c             	sub    $0xc,%esp
f010d5a0:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010d5a5:	e8 40 60 00 00       	call   f01135ea <release_kspinlock>
f010d5aa:	83 c4 10             	add    $0x10,%esp

	if (first)
f010d5ad:	a1 c8 7b 19 f0       	mov    0xf0197bc8,%eax
f010d5b2:	85 c0                	test   %eax,%eax
f010d5b4:	74 30                	je     f010d5e6 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010d5b6:	e8 8d 00 00 00       	call   f010d648 <get_cpu_proc>
f010d5bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010d5be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d5c1:	8b 40 10             	mov    0x10(%eax),%eax
f010d5c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d5c7:	83 c2 20             	add    $0x20,%edx
f010d5ca:	83 ec 04             	sub    $0x4,%esp
f010d5cd:	50                   	push   %eax
f010d5ce:	52                   	push   %edx
f010d5cf:	68 6f 81 13 f0       	push   $0xf013816f
f010d5d4:	e8 74 45 ff ff       	call   f0101b4d <cprintf>
f010d5d9:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010d5dc:	c7 05 c8 7b 19 f0 00 	movl   $0x0,0xf0197bc8
f010d5e3:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010d5e6:	90                   	nop
f010d5e7:	c9                   	leave  
f010d5e8:	c3                   	ret    

f010d5e9 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010d5e9:	55                   	push   %ebp
f010d5ea:	89 e5                	mov    %esp,%ebp
f010d5ec:	83 ec 08             	sub    $0x8,%esp
#endif
	/*****************************************/
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - env_free
	//Your code is here
	//Comment the following line
	panic("env_free() is not implemented yet...!!");
f010d5ef:	83 ec 04             	sub    $0x4,%esp
f010d5f2:	68 88 81 13 f0       	push   $0xf0138188
f010d5f7:	68 f3 01 00 00       	push   $0x1f3
f010d5fc:	68 9b 80 13 f0       	push   $0xf013809b
f010d601:	e8 a9 38 ff ff       	call   f0100eaf <_panic>

f010d606 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010d606:	55                   	push   %ebp
f010d607:	89 e5                	mov    %esp,%ebp
f010d609:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010d60c:	e8 37 00 00 00       	call   f010d648 <get_cpu_proc>
f010d611:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010d614:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d618:	75 19                	jne    f010d633 <env_exit+0x2d>
f010d61a:	68 af 81 13 f0       	push   $0xf01381af
f010d61f:	68 5a 81 13 f0       	push   $0xf013815a
f010d624:	68 0e 02 00 00       	push   $0x20e
f010d629:	68 9b 80 13 f0       	push   $0xf013809b
f010d62e:	e8 7c 38 ff ff       	call   f0100eaf <_panic>
	sched_exit_env(cur_env->env_id);
f010d633:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d636:	8b 40 10             	mov    0x10(%eax),%eax
f010d639:	83 ec 0c             	sub    $0xc,%esp
f010d63c:	50                   	push   %eax
f010d63d:	e8 5e 92 ff ff       	call   f01068a0 <sched_exit_env>
f010d642:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch in the sched() function which will be called in sched_exit_env()
	//fos_scheduler();
}
f010d645:	90                   	nop
f010d646:	c9                   	leave  
f010d647:	c3                   	ret    

f010d648 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010d648:	55                   	push   %ebp
f010d649:	89 e5                	mov    %esp,%ebp
f010d64b:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010d64e:	e8 6f af ff ff       	call   f01085c2 <pushcli>
	c = mycpu();
f010d653:	e8 a7 ae ff ff       	call   f01084ff <mycpu>
f010d658:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010d65b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d65e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010d664:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010d667:	e8 a8 af ff ff       	call   f0108614 <popcli>
	return p;
f010d66c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010d66f:	c9                   	leave  
f010d670:	c3                   	ret    

f010d671 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010d671:	55                   	push   %ebp
f010d672:	89 e5                	mov    %esp,%ebp
f010d674:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010d677:	e8 46 af ff ff       	call   f01085c2 <pushcli>
	c = mycpu();
f010d67c:	e8 7e ae ff ff       	call   f01084ff <mycpu>
f010d681:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010d684:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d687:	8b 55 08             	mov    0x8(%ebp),%edx
f010d68a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010d690:	e8 7f af ff ff       	call   f0108614 <popcli>
}
f010d695:	90                   	nop
f010d696:	c9                   	leave  
f010d697:	c3                   	ret    

f010d698 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010d698:	55                   	push   %ebp
f010d699:	89 e5                	mov    %esp,%ebp
f010d69b:	53                   	push   %ebx
f010d69c:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010d69f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d6a3:	75 16                	jne    f010d6bb <envid2env+0x23>
		*env_store = get_cpu_proc();
f010d6a5:	e8 9e ff ff ff       	call   f010d648 <get_cpu_proc>
f010d6aa:	89 c2                	mov    %eax,%edx
f010d6ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d6af:	89 10                	mov    %edx,(%eax)
		return 0;
f010d6b1:	b8 00 00 00 00       	mov    $0x0,%eax
f010d6b6:	e9 a3 00 00 00       	jmp    f010d75e <envid2env+0xc6>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010d6bb:	8b 1d d0 40 92 f0    	mov    0xf09240d0,%ebx
f010d6c1:	83 ec 0c             	sub    $0xc,%esp
f010d6c4:	68 68 02 00 00       	push   $0x268
f010d6c9:	e8 dd 31 01 00       	call   f01208ab <nearest_pow2_ceil>
f010d6ce:	83 c4 10             	add    $0x10,%esp
f010d6d1:	8d 50 ff             	lea    -0x1(%eax),%edx
f010d6d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d6d7:	21 c2                	and    %eax,%edx
f010d6d9:	89 d0                	mov    %edx,%eax
f010d6db:	01 c0                	add    %eax,%eax
f010d6dd:	01 d0                	add    %edx,%eax
f010d6df:	c1 e0 02             	shl    $0x2,%eax
f010d6e2:	01 d0                	add    %edx,%eax
f010d6e4:	c1 e0 02             	shl    $0x2,%eax
f010d6e7:	01 d0                	add    %edx,%eax
f010d6e9:	c1 e0 03             	shl    $0x3,%eax
f010d6ec:	01 d0                	add    %edx,%eax
f010d6ee:	c1 e0 02             	shl    $0x2,%eax
f010d6f1:	01 d8                	add    %ebx,%eax
f010d6f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010d6f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d6f9:	8b 40 18             	mov    0x18(%eax),%eax
f010d6fc:	85 c0                	test   %eax,%eax
f010d6fe:	74 0b                	je     f010d70b <envid2env+0x73>
f010d700:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d703:	8b 40 10             	mov    0x10(%eax),%eax
f010d706:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d709:	74 10                	je     f010d71b <envid2env+0x83>
		*env_store = 0;
f010d70b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d70e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010d714:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010d719:	eb 43                	jmp    f010d75e <envid2env+0xc6>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010d71b:	e8 28 ff ff ff       	call   f010d648 <get_cpu_proc>
f010d720:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010d723:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010d727:	74 28                	je     f010d751 <envid2env+0xb9>
f010d729:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d72c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010d72f:	74 20                	je     f010d751 <envid2env+0xb9>
f010d731:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d734:	8b 50 14             	mov    0x14(%eax),%edx
f010d737:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d73a:	8b 40 10             	mov    0x10(%eax),%eax
f010d73d:	39 c2                	cmp    %eax,%edx
f010d73f:	74 10                	je     f010d751 <envid2env+0xb9>
		*env_store = 0;
f010d741:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d744:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010d74a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010d74f:	eb 0d                	jmp    f010d75e <envid2env+0xc6>
	}

	*env_store = e;
f010d751:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d754:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d757:	89 10                	mov    %edx,(%eax)
	return 0;
f010d759:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d75e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010d761:	c9                   	leave  
f010d762:	c3                   	ret    

f010d763 <yield>:
// 7) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010d763:	55                   	push   %ebp
f010d764:	89 e5                	mov    %esp,%ebp
f010d766:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010d769:	83 ec 0c             	sub    $0xc,%esp
f010d76c:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010d771:	e8 cf 5d 00 00       	call   f0113545 <acquire_kspinlock>
f010d776:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010d779:	e8 ca fe ff ff       	call   f010d648 <get_cpu_proc>
f010d77e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010d781:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d785:	75 19                	jne    f010d7a0 <yield+0x3d>
f010d787:	68 bf 81 13 f0       	push   $0xf01381bf
f010d78c:	68 5a 81 13 f0       	push   $0xf013815a
f010d791:	68 6c 02 00 00       	push   $0x26c
f010d796:	68 9b 80 13 f0       	push   $0xf013809b
f010d79b:	e8 0f 37 ff ff       	call   f0100eaf <_panic>
		p->env_status = ENV_READY;
f010d7a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d7a3:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010d7aa:	e8 13 00 00 00       	call   f010d7c2 <sched>
	}
	release_kspinlock(&ProcessQueues.qlock); ////release lock
f010d7af:	83 ec 0c             	sub    $0xc,%esp
f010d7b2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010d7b7:	e8 2e 5e 00 00       	call   f01135ea <release_kspinlock>
f010d7bc:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010d7bf:	90                   	nop
f010d7c0:	c9                   	leave  
f010d7c1:	c3                   	ret    

f010d7c2 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010d7c2:	55                   	push   %ebp
f010d7c3:	89 e5                	mov    %esp,%ebp
f010d7c5:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010d7c8:	e8 7b fe ff ff       	call   f010d648 <get_cpu_proc>
f010d7cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010d7d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d7d4:	75 19                	jne    f010d7ef <sched+0x2d>
f010d7d6:	68 bf 81 13 f0       	push   $0xf01381bf
f010d7db:	68 5a 81 13 f0       	push   $0xf013815a
f010d7e0:	68 80 02 00 00       	push   $0x280
f010d7e5:	68 9b 80 13 f0       	push   $0xf013809b
f010d7ea:	e8 c0 36 ff ff       	call   f0100eaf <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010d7ef:	83 ec 0c             	sub    $0xc,%esp
f010d7f2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f010d7f7:	e8 9e 5f 00 00       	call   f011379a <holding_kspinlock>
f010d7fc:	83 c4 10             	add    $0x10,%esp
f010d7ff:	85 c0                	test   %eax,%eax
f010d801:	75 17                	jne    f010d81a <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010d803:	83 ec 04             	sub    $0x4,%esp
f010d806:	68 cc 81 13 f0       	push   $0xf01381cc
f010d80b:	68 84 02 00 00       	push   $0x284
f010d810:	68 9b 80 13 f0       	push   $0xf013809b
f010d815:	e8 95 36 ff ff       	call   f0100eaf <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010d81a:	e8 e0 ac ff ff       	call   f01084ff <mycpu>
f010d81f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010d825:	83 f8 01             	cmp    $0x1,%eax
f010d828:	74 20                	je     f010d84a <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010d82a:	e8 d0 ac ff ff       	call   f01084ff <mycpu>
f010d82f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010d835:	50                   	push   %eax
f010d836:	68 0e 82 13 f0       	push   $0xf013820e
f010d83b:	68 87 02 00 00       	push   $0x287
f010d840:	68 9b 80 13 f0       	push   $0xf013809b
f010d845:	e8 65 36 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010d84a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d84d:	8b 40 18             	mov    0x18(%eax),%eax
f010d850:	83 f8 02             	cmp    $0x2,%eax
f010d853:	75 17                	jne    f010d86c <sched+0xaa>
		panic("sched a running process");
f010d855:	83 ec 04             	sub    $0x4,%esp
f010d858:	68 25 82 13 f0       	push   $0xf0138225
f010d85d:	68 8a 02 00 00       	push   $0x28a
f010d862:	68 9b 80 13 f0       	push   $0xf013809b
f010d867:	e8 43 36 ff ff       	call   f0100eaf <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d86c:	9c                   	pushf  
f010d86d:	58                   	pop    %eax
f010d86e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d871:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010d874:	25 00 02 00 00       	and    $0x200,%eax
f010d879:	85 c0                	test   %eax,%eax
f010d87b:	74 17                	je     f010d894 <sched+0xd2>
		panic("sched is interruptible!");
f010d87d:	83 ec 04             	sub    $0x4,%esp
f010d880:	68 3d 82 13 f0       	push   $0xf013823d
f010d885:	68 8c 02 00 00       	push   $0x28c
f010d88a:	68 9b 80 13 f0       	push   $0xf013809b
f010d88f:	e8 1b 36 ff ff       	call   f0100eaf <_panic>
	intena = mycpu()->intena;
f010d894:	e8 66 ac ff ff       	call   f01084ff <mycpu>
f010d899:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010d89f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010d8a2:	e8 58 ac ff ff       	call   f01084ff <mycpu>
f010d8a7:	8b 40 04             	mov    0x4(%eax),%eax
f010d8aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d8ad:	83 c2 04             	add    $0x4,%edx
f010d8b0:	83 ec 08             	sub    $0x8,%esp
f010d8b3:	50                   	push   %eax
f010d8b4:	52                   	push   %edx
f010d8b5:	e8 22 83 ff ff       	call   f0105bdc <context_switch>
f010d8ba:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010d8bd:	e8 3d ac ff ff       	call   f01084ff <mycpu>
f010d8c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010d8c5:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010d8cb:	90                   	nop
f010d8cc:	c9                   	leave  
f010d8cd:	c3                   	ret    

f010d8ce <switchkvm>:
// 9) SWITCH VIRTUAL MEMORYs:
//===============================
// [9.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010d8ce:	55                   	push   %ebp
f010d8cf:	89 e5                	mov    %esp,%ebp
f010d8d1:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010d8d4:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f010d8d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010d8dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d8df:	0f 22 d8             	mov    %eax,%cr3
}
f010d8e2:	90                   	nop
f010d8e3:	c9                   	leave  
f010d8e4:	c3                   	ret    

f010d8e5 <switchuvm>:

// [9.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010d8e5:	55                   	push   %ebp
f010d8e6:	89 e5                	mov    %esp,%ebp
f010d8e8:	53                   	push   %ebx
f010d8e9:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010d8ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d8f0:	75 17                	jne    f010d909 <switchuvm+0x24>
		panic("switchuvm: no process");
f010d8f2:	83 ec 04             	sub    $0x4,%esp
f010d8f5:	68 55 82 13 f0       	push   $0xf0138255
f010d8fa:	68 a1 02 00 00       	push   $0x2a1
f010d8ff:	68 9b 80 13 f0       	push   $0xf013809b
f010d904:	e8 a6 35 ff ff       	call   f0100eaf <_panic>
	if(proc->kstack == 0)
f010d909:	8b 45 08             	mov    0x8(%ebp),%eax
f010d90c:	8b 40 70             	mov    0x70(%eax),%eax
f010d90f:	85 c0                	test   %eax,%eax
f010d911:	75 17                	jne    f010d92a <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010d913:	83 ec 04             	sub    $0x4,%esp
f010d916:	68 6b 82 13 f0       	push   $0xf013826b
f010d91b:	68 a3 02 00 00       	push   $0x2a3
f010d920:	68 9b 80 13 f0       	push   $0xf013809b
f010d925:	e8 85 35 ff ff       	call   f0100eaf <_panic>
	if(proc->env_page_directory == 0)
f010d92a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d92d:	8b 40 64             	mov    0x64(%eax),%eax
f010d930:	85 c0                	test   %eax,%eax
f010d932:	75 17                	jne    f010d94b <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010d934:	83 ec 04             	sub    $0x4,%esp
f010d937:	68 80 82 13 f0       	push   $0xf0138280
f010d93c:	68 a5 02 00 00       	push   $0x2a5
f010d941:	68 9b 80 13 f0       	push   $0xf013809b
f010d946:	e8 64 35 ff ff       	call   f0100eaf <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010d94b:	e8 72 ac ff ff       	call   f01085c2 <pushcli>
	struct cpu* c = mycpu();
f010d950:	e8 aa ab ff ff       	call   f01084ff <mycpu>
f010d955:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010d958:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d95b:	8b 55 08             	mov    0x8(%ebp),%edx
f010d95e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d967:	83 c0 0c             	add    $0xc,%eax
f010d96a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d96d:	83 c2 0c             	add    $0xc,%edx
f010d970:	c1 ea 10             	shr    $0x10,%edx
f010d973:	88 d3                	mov    %dl,%bl
f010d975:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d978:	83 c2 0c             	add    $0xc,%edx
f010d97b:	c1 ea 18             	shr    $0x18,%edx
f010d97e:	88 d1                	mov    %dl,%cl
f010d980:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d983:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d98a:	68 00 
f010d98c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d98f:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d996:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d999:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d99f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9a2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d9a8:	83 e2 f0             	and    $0xfffffff0,%edx
f010d9ab:	83 ca 09             	or     $0x9,%edx
f010d9ae:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d9b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9b7:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d9bd:	83 ca 10             	or     $0x10,%edx
f010d9c0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d9c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9c9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d9cf:	83 e2 9f             	and    $0xffffff9f,%edx
f010d9d2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d9d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9db:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d9e1:	83 ca 80             	or     $0xffffff80,%edx
f010d9e4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d9ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9ed:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d9f3:	83 e2 f0             	and    $0xfffffff0,%edx
f010d9f6:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d9fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9ff:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010da05:	83 e2 ef             	and    $0xffffffef,%edx
f010da08:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010da0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da11:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010da17:	83 e2 df             	and    $0xffffffdf,%edx
f010da1a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010da20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da23:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010da29:	83 ca 40             	or     $0x40,%edx
f010da2c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010da32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da35:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010da3b:	83 e2 7f             	and    $0x7f,%edx
f010da3e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010da44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da47:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010da4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da50:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010da56:	83 e2 ef             	and    $0xffffffef,%edx
f010da59:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010da5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da62:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010da68:	8b 40 70             	mov    0x70(%eax),%eax
f010da6b:	05 00 80 00 00       	add    $0x8000,%eax
f010da70:	89 c2                	mov    %eax,%edx
f010da72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da75:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010da78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da7b:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010da81:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010da87:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010da8b:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010da8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da91:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010da97:	8b 40 68             	mov    0x68(%eax),%eax
f010da9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010da9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010daa0:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010daa3:	e8 6c ab ff ff       	call   f0108614 <popcli>
}
f010daa8:	90                   	nop
f010daa9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010daac:	c9                   	leave  
f010daad:	c3                   	ret    

f010daae <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010daae:	55                   	push   %ebp
f010daaf:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010dab1:	8b 15 d4 40 92 f0    	mov    0xf09240d4,%edx
f010dab7:	8b 45 08             	mov    0x8(%ebp),%eax
f010daba:	89 10                	mov    %edx,(%eax)
f010dabc:	8b 45 08             	mov    0x8(%ebp),%eax
f010dabf:	8b 00                	mov    (%eax),%eax
f010dac1:	85 c0                	test   %eax,%eax
f010dac3:	75 07                	jne    f010dacc <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010dac5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010daca:	eb 11                	jmp    f010dadd <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010dacc:	8b 45 08             	mov    0x8(%ebp),%eax
f010dacf:	8b 00                	mov    (%eax),%eax
f010dad1:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	return 0;
f010dad8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010dadd:	5d                   	pop    %ebp
f010dade:	c3                   	ret    

f010dadf <free_environment>:
//===============================
// 3) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010dadf:	55                   	push   %ebp
f010dae0:	89 e5                	mov    %esp,%ebp
f010dae2:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010dae5:	83 ec 04             	sub    $0x4,%esp
f010dae8:	68 a4 06 00 00       	push   $0x6a4
f010daed:	6a 00                	push   $0x0
f010daef:	ff 75 08             	pushl  0x8(%ebp)
f010daf2:	e8 26 55 01 00       	call   f012301d <memset>
f010daf7:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010dafa:	8b 45 08             	mov    0x8(%ebp),%eax
f010dafd:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010db04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010db08:	75 17                	jne    f010db21 <free_environment+0x42>
f010db0a:	83 ec 04             	sub    $0x4,%esp
f010db0d:	68 78 80 13 f0       	push   $0xf0138078
f010db12:	68 e4 02 00 00       	push   $0x2e4
f010db17:	68 9b 80 13 f0       	push   $0xf013809b
f010db1c:	e8 8e 33 ff ff       	call   f0100eaf <_panic>
f010db21:	8b 15 d4 40 92 f0    	mov    0xf09240d4,%edx
f010db27:	8b 45 08             	mov    0x8(%ebp),%eax
f010db2a:	89 50 08             	mov    %edx,0x8(%eax)
f010db2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010db30:	8b 40 08             	mov    0x8(%eax),%eax
f010db33:	85 c0                	test   %eax,%eax
f010db35:	74 0d                	je     f010db44 <free_environment+0x65>
f010db37:	a1 d4 40 92 f0       	mov    0xf09240d4,%eax
f010db3c:	8b 55 08             	mov    0x8(%ebp),%edx
f010db3f:	89 50 0c             	mov    %edx,0xc(%eax)
f010db42:	eb 08                	jmp    f010db4c <free_environment+0x6d>
f010db44:	8b 45 08             	mov    0x8(%ebp),%eax
f010db47:	a3 d8 40 92 f0       	mov    %eax,0xf09240d8
f010db4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010db4f:	a3 d4 40 92 f0       	mov    %eax,0xf09240d4
f010db54:	8b 45 08             	mov    0x8(%ebp),%eax
f010db57:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010db5e:	a1 e0 40 92 f0       	mov    0xf09240e0,%eax
f010db63:	40                   	inc    %eax
f010db64:	a3 e0 40 92 f0       	mov    %eax,0xf09240e0
}
f010db69:	90                   	nop
f010db6a:	c9                   	leave  
f010db6b:	c3                   	ret    

f010db6c <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010db6c:	55                   	push   %ebp
f010db6d:	89 e5                	mov    %esp,%ebp
f010db6f:	56                   	push   %esi
f010db70:	53                   	push   %ebx
f010db71:	83 ec 40             	sub    $0x40,%esp
	void *vaddr = seg->virtual_address;
f010db74:	8b 45 0c             	mov    0xc(%ebp),%eax
f010db77:	8b 40 0c             	mov    0xc(%eax),%eax
f010db7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010db7d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010db80:	8b 40 08             	mov    0x8(%eax),%eax
f010db83:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010db86:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010db8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010db90:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010db93:	01 c2                	add    %eax,%edx
f010db95:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010db98:	01 d0                	add    %edx,%eax
f010db9a:	48                   	dec    %eax
f010db9b:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010db9e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010dba1:	ba 00 00 00 00       	mov    $0x0,%edx
f010dba6:	f7 75 dc             	divl   -0x24(%ebp)
f010dba9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010dbac:	29 d0                	sub    %edx,%eax
f010dbae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010dbb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010dbb4:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010dbb7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010dbba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010dbbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010dbc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010dbc9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010dbd0:	8b 45 10             	mov    0x10(%ebp),%eax
f010dbd3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
//	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
//		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	/*2025*/// DON'T Load segment that start with va = 200000 since it's for debugging stab and differ from QMUE to Bochs
	if (iVA == 0x200000)
f010dbd9:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010dbe0:	75 07                	jne    f010dbe9 <program_segment_alloc_map_copy_workingset+0x7d>
		remaining_ws_pages = 0 ;
f010dbe2:	c7 45 14 00 00 00 00 	movl   $0x0,0x14(%ebp)
	//In [tpp or tia's]: Load max of 9 pages only for the data segments that start with va = 803000
	if (iVA == 0x803000 && (strcmp(e->prog_name, "tpp")==0 || strcmp(e->prog_name, "tia") ==0
f010dbe9:	81 7d f4 00 30 80 00 	cmpl   $0x803000,-0xc(%ebp)
f010dbf0:	0f 85 98 04 00 00    	jne    f010e08e <program_segment_alloc_map_copy_workingset+0x522>
f010dbf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbf9:	83 c0 20             	add    $0x20,%eax
f010dbfc:	83 ec 08             	sub    $0x8,%esp
f010dbff:	68 94 82 13 f0       	push   $0xf0138294
f010dc04:	50                   	push   %eax
f010dc05:	e8 31 53 01 00       	call   f0122f3b <strcmp>
f010dc0a:	83 c4 10             	add    $0x10,%esp
f010dc0d:	85 c0                	test   %eax,%eax
f010dc0f:	0f 84 8b 00 00 00    	je     f010dca0 <program_segment_alloc_map_copy_workingset+0x134>
f010dc15:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc18:	83 c0 20             	add    $0x20,%eax
f010dc1b:	83 ec 08             	sub    $0x8,%esp
f010dc1e:	68 98 82 13 f0       	push   $0xf0138298
f010dc23:	50                   	push   %eax
f010dc24:	e8 12 53 01 00       	call   f0122f3b <strcmp>
f010dc29:	83 c4 10             	add    $0x10,%esp
f010dc2c:	85 c0                	test   %eax,%eax
f010dc2e:	74 70                	je     f010dca0 <program_segment_alloc_map_copy_workingset+0x134>
			|| strcmp(e->prog_name, "tia_slave1") == 0 || strcmp(e->prog_name, "tia_slave2") == 0
f010dc30:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc33:	83 c0 20             	add    $0x20,%eax
f010dc36:	83 ec 08             	sub    $0x8,%esp
f010dc39:	68 9c 82 13 f0       	push   $0xf013829c
f010dc3e:	50                   	push   %eax
f010dc3f:	e8 f7 52 01 00       	call   f0122f3b <strcmp>
f010dc44:	83 c4 10             	add    $0x10,%esp
f010dc47:	85 c0                	test   %eax,%eax
f010dc49:	74 55                	je     f010dca0 <program_segment_alloc_map_copy_workingset+0x134>
f010dc4b:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc4e:	83 c0 20             	add    $0x20,%eax
f010dc51:	83 ec 08             	sub    $0x8,%esp
f010dc54:	68 a7 82 13 f0       	push   $0xf01382a7
f010dc59:	50                   	push   %eax
f010dc5a:	e8 dc 52 01 00       	call   f0122f3b <strcmp>
f010dc5f:	83 c4 10             	add    $0x10,%esp
f010dc62:	85 c0                	test   %eax,%eax
f010dc64:	74 3a                	je     f010dca0 <program_segment_alloc_map_copy_workingset+0x134>
			|| strcmp(e->prog_name, "tia_slave3") == 0 || strcmp(e->prog_name, "tia_slave4") == 0))
f010dc66:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc69:	83 c0 20             	add    $0x20,%eax
f010dc6c:	83 ec 08             	sub    $0x8,%esp
f010dc6f:	68 b2 82 13 f0       	push   $0xf01382b2
f010dc74:	50                   	push   %eax
f010dc75:	e8 c1 52 01 00       	call   f0122f3b <strcmp>
f010dc7a:	83 c4 10             	add    $0x10,%esp
f010dc7d:	85 c0                	test   %eax,%eax
f010dc7f:	74 1f                	je     f010dca0 <program_segment_alloc_map_copy_workingset+0x134>
f010dc81:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc84:	83 c0 20             	add    $0x20,%eax
f010dc87:	83 ec 08             	sub    $0x8,%esp
f010dc8a:	68 bd 82 13 f0       	push   $0xf01382bd
f010dc8f:	50                   	push   %eax
f010dc90:	e8 a6 52 01 00       	call   f0122f3b <strcmp>
f010dc95:	83 c4 10             	add    $0x10,%esp
f010dc98:	85 c0                	test   %eax,%eax
f010dc9a:	0f 85 ee 03 00 00    	jne    f010e08e <program_segment_alloc_map_copy_workingset+0x522>
		remaining_ws_pages = remaining_ws_pages < 9 ? remaining_ws_pages:9;
f010dca0:	8b 45 14             	mov    0x14(%ebp),%eax
f010dca3:	83 f8 09             	cmp    $0x9,%eax
f010dca6:	76 05                	jbe    f010dcad <program_segment_alloc_map_copy_workingset+0x141>
f010dca8:	b8 09 00 00 00       	mov    $0x9,%eax
f010dcad:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010dcb0:	e9 d9 03 00 00       	jmp    f010e08e <program_segment_alloc_map_copy_workingset+0x522>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010dcb5:	83 ec 0c             	sub    $0xc,%esp
f010dcb8:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010dcbb:	50                   	push   %eax
f010dcbc:	e8 95 b9 ff ff       	call   f0109656 <allocate_frame>
f010dcc1:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010dcc4:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010dcc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010dcca:	8b 40 64             	mov    0x64(%eax),%eax
f010dccd:	6a 06                	push   $0x6
f010dccf:	ff 75 f4             	pushl  -0xc(%ebp)
f010dcd2:	52                   	push   %edx
f010dcd3:	50                   	push   %eax
f010dcd4:	e8 37 c0 ff ff       	call   f0109d10 <loadtime_map_frame>
f010dcd9:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010dcdc:	83 ec 08             	sub    $0x8,%esp
f010dcdf:	ff 75 f4             	pushl  -0xc(%ebp)
f010dce2:	ff 75 08             	pushl  0x8(%ebp)
f010dce5:	e8 a7 db ff ff       	call   f010b891 <env_page_ws_list_create_element>
f010dcea:	83 c4 10             	add    $0x10,%esp
f010dced:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010dcf0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010dcf3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010dcfa:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010dcfe:	75 17                	jne    f010dd17 <program_segment_alloc_map_copy_workingset+0x1ab>
f010dd00:	83 ec 04             	sub    $0x4,%esp
f010dd03:	68 00 81 13 f0       	push   $0xf0138100
f010dd08:	68 17 03 00 00       	push   $0x317
f010dd0d:	68 9b 80 13 f0       	push   $0xf013809b
f010dd12:	e8 98 31 ff ff       	call   f0100eaf <_panic>
f010dd17:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd1a:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010dd20:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010dd23:	89 50 14             	mov    %edx,0x14(%eax)
f010dd26:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010dd29:	8b 40 14             	mov    0x14(%eax),%eax
f010dd2c:	85 c0                	test   %eax,%eax
f010dd2e:	74 11                	je     f010dd41 <program_segment_alloc_map_copy_workingset+0x1d5>
f010dd30:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd33:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010dd39:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010dd3c:	89 50 10             	mov    %edx,0x10(%eax)
f010dd3f:	eb 0c                	jmp    f010dd4d <program_segment_alloc_map_copy_workingset+0x1e1>
f010dd41:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd44:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010dd47:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010dd4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd50:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010dd53:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010dd59:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010dd5c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010dd63:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd66:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010dd6c:	8d 50 01             	lea    0x1(%eax),%edx
f010dd6f:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd72:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010dd78:	83 ec 0c             	sub    $0xc,%esp
f010dd7b:	6a 02                	push   $0x2
f010dd7d:	e8 fc 38 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010dd82:	83 c4 10             	add    $0x10,%esp
f010dd85:	85 c0                	test   %eax,%eax
f010dd87:	0f 84 b3 01 00 00    	je     f010df40 <program_segment_alloc_map_copy_workingset+0x3d4>
		{
#if USE_KHEAP
			//Remove wse from page_WS_list
			LIST_REMOVE(&(e->page_WS_list), wse);
f010dd8d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010dd91:	75 17                	jne    f010ddaa <program_segment_alloc_map_copy_workingset+0x23e>
f010dd93:	83 ec 04             	sub    $0x4,%esp
f010dd96:	68 23 81 13 f0       	push   $0xf0138123
f010dd9b:	68 24 03 00 00       	push   $0x324
f010dda0:	68 9b 80 13 f0       	push   $0xf013809b
f010dda5:	e8 05 31 ff ff       	call   f0100eaf <_panic>
f010ddaa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ddad:	8b 40 10             	mov    0x10(%eax),%eax
f010ddb0:	85 c0                	test   %eax,%eax
f010ddb2:	74 11                	je     f010ddc5 <program_segment_alloc_map_copy_workingset+0x259>
f010ddb4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ddb7:	8b 40 10             	mov    0x10(%eax),%eax
f010ddba:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ddbd:	8b 52 14             	mov    0x14(%edx),%edx
f010ddc0:	89 50 14             	mov    %edx,0x14(%eax)
f010ddc3:	eb 0f                	jmp    f010ddd4 <program_segment_alloc_map_copy_workingset+0x268>
f010ddc5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ddc8:	8b 50 14             	mov    0x14(%eax),%edx
f010ddcb:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddce:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010ddd4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ddd7:	8b 40 14             	mov    0x14(%eax),%eax
f010ddda:	85 c0                	test   %eax,%eax
f010dddc:	74 11                	je     f010ddef <program_segment_alloc_map_copy_workingset+0x283>
f010ddde:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010dde1:	8b 40 14             	mov    0x14(%eax),%eax
f010dde4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010dde7:	8b 52 10             	mov    0x10(%edx),%edx
f010ddea:	89 50 10             	mov    %edx,0x10(%eax)
f010dded:	eb 0f                	jmp    f010ddfe <program_segment_alloc_map_copy_workingset+0x292>
f010ddef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ddf2:	8b 50 10             	mov    0x10(%eax),%edx
f010ddf5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddf8:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010ddfe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010de01:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010de08:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010de0b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010de12:	8b 45 08             	mov    0x8(%ebp),%eax
f010de15:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010de1b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010de1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010de21:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010de27:	8b 45 08             	mov    0x8(%ebp),%eax
f010de2a:	8b 90 50 06 00 00    	mov    0x650(%eax),%edx
f010de30:	8b 45 08             	mov    0x8(%ebp),%eax
f010de33:	8b 80 64 06 00 00    	mov    0x664(%eax),%eax
f010de39:	48                   	dec    %eax
f010de3a:	39 c2                	cmp    %eax,%edx
f010de3c:	0f 83 80 00 00 00    	jae    f010dec2 <program_segment_alloc_map_copy_workingset+0x356>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010de42:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010de46:	75 17                	jne    f010de5f <program_segment_alloc_map_copy_workingset+0x2f3>
f010de48:	83 ec 04             	sub    $0x4,%esp
f010de4b:	68 78 80 13 f0       	push   $0xf0138078
f010de50:	68 28 03 00 00       	push   $0x328
f010de55:	68 9b 80 13 f0       	push   $0xf013809b
f010de5a:	e8 50 30 ff ff       	call   f0100eaf <_panic>
f010de5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010de62:	8b 90 44 06 00 00    	mov    0x644(%eax),%edx
f010de68:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010de6b:	89 50 10             	mov    %edx,0x10(%eax)
f010de6e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010de71:	8b 40 10             	mov    0x10(%eax),%eax
f010de74:	85 c0                	test   %eax,%eax
f010de76:	74 11                	je     f010de89 <program_segment_alloc_map_copy_workingset+0x31d>
f010de78:	8b 45 08             	mov    0x8(%ebp),%eax
f010de7b:	8b 80 44 06 00 00    	mov    0x644(%eax),%eax
f010de81:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010de84:	89 50 14             	mov    %edx,0x14(%eax)
f010de87:	eb 0c                	jmp    f010de95 <program_segment_alloc_map_copy_workingset+0x329>
f010de89:	8b 45 08             	mov    0x8(%ebp),%eax
f010de8c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010de8f:	89 90 48 06 00 00    	mov    %edx,0x648(%eax)
f010de95:	8b 45 08             	mov    0x8(%ebp),%eax
f010de98:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010de9b:	89 90 44 06 00 00    	mov    %edx,0x644(%eax)
f010dea1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010dea4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010deab:	8b 45 08             	mov    0x8(%ebp),%eax
f010deae:	8b 80 50 06 00 00    	mov    0x650(%eax),%eax
f010deb4:	8d 50 01             	lea    0x1(%eax),%edx
f010deb7:	8b 45 08             	mov    0x8(%ebp),%eax
f010deba:	89 90 50 06 00 00    	mov    %edx,0x650(%eax)
f010dec0:	eb 7e                	jmp    f010df40 <program_segment_alloc_map_copy_workingset+0x3d4>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010dec2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010dec6:	75 17                	jne    f010dedf <program_segment_alloc_map_copy_workingset+0x373>
f010dec8:	83 ec 04             	sub    $0x4,%esp
f010decb:	68 78 80 13 f0       	push   $0xf0138078
f010ded0:	68 2d 03 00 00       	push   $0x32d
f010ded5:	68 9b 80 13 f0       	push   $0xf013809b
f010deda:	e8 d0 2f ff ff       	call   f0100eaf <_panic>
f010dedf:	8b 45 08             	mov    0x8(%ebp),%eax
f010dee2:	8b 90 54 06 00 00    	mov    0x654(%eax),%edx
f010dee8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010deeb:	89 50 10             	mov    %edx,0x10(%eax)
f010deee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010def1:	8b 40 10             	mov    0x10(%eax),%eax
f010def4:	85 c0                	test   %eax,%eax
f010def6:	74 11                	je     f010df09 <program_segment_alloc_map_copy_workingset+0x39d>
f010def8:	8b 45 08             	mov    0x8(%ebp),%eax
f010defb:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f010df01:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010df04:	89 50 14             	mov    %edx,0x14(%eax)
f010df07:	eb 0c                	jmp    f010df15 <program_segment_alloc_map_copy_workingset+0x3a9>
f010df09:	8b 45 08             	mov    0x8(%ebp),%eax
f010df0c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010df0f:	89 90 58 06 00 00    	mov    %edx,0x658(%eax)
f010df15:	8b 45 08             	mov    0x8(%ebp),%eax
f010df18:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010df1b:	89 90 54 06 00 00    	mov    %edx,0x654(%eax)
f010df21:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010df24:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010df2b:	8b 45 08             	mov    0x8(%ebp),%eax
f010df2e:	8b 80 60 06 00 00    	mov    0x660(%eax),%eax
f010df34:	8d 50 01             	lea    0x1(%eax),%edx
f010df37:	8b 45 08             	mov    0x8(%ebp),%eax
f010df3a:	89 90 60 06 00 00    	mov    %edx,0x660(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010df40:	8b 45 08             	mov    0x8(%ebp),%eax
f010df43:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010df49:	8b 45 08             	mov    0x8(%ebp),%eax
f010df4c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010df52:	39 c2                	cmp    %eax,%edx
f010df54:	75 14                	jne    f010df6a <program_segment_alloc_map_copy_workingset+0x3fe>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010df56:	8b 45 08             	mov    0x8(%ebp),%eax
f010df59:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010df5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010df62:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f010df68:	eb 0d                	jmp    f010df77 <program_segment_alloc_map_copy_workingset+0x40b>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010df6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010df6d:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f010df74:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010df77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010df7a:	c1 e8 16             	shr    $0x16,%eax
f010df7d:	89 c2                	mov    %eax,%edx
f010df7f:	8b 45 18             	mov    0x18(%ebp),%eax
f010df82:	8b 00                	mov    (%eax),%eax
f010df84:	39 c2                	cmp    %eax,%edx
f010df86:	0f 84 eb 00 00 00    	je     f010e077 <program_segment_alloc_map_copy_workingset+0x50b>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010df8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010df8f:	8b 90 40 06 00 00    	mov    0x640(%eax),%edx
f010df95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010df98:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010df9b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010df9e:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010dfa3:	89 c1                	mov    %eax,%ecx
f010dfa5:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010dfa8:	89 d0                	mov    %edx,%eax
f010dfaa:	01 c0                	add    %eax,%eax
f010dfac:	01 d0                	add    %edx,%eax
f010dfae:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010dfb5:	01 f0                	add    %esi,%eax
f010dfb7:	01 d0                	add    %edx,%eax
f010dfb9:	01 d8                	add    %ebx,%eax
f010dfbb:	05 c8 00 00 00       	add    $0xc8,%eax
f010dfc0:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010dfc2:	8b 45 08             	mov    0x8(%ebp),%eax
f010dfc5:	8b 90 40 06 00 00    	mov    0x640(%eax),%edx
f010dfcb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010dfce:	89 d0                	mov    %edx,%eax
f010dfd0:	01 c0                	add    %eax,%eax
f010dfd2:	01 d0                	add    %edx,%eax
f010dfd4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010dfdb:	01 d8                	add    %ebx,%eax
f010dfdd:	01 d0                	add    %edx,%eax
f010dfdf:	01 c8                	add    %ecx,%eax
f010dfe1:	05 cc 00 00 00       	add    $0xcc,%eax
f010dfe6:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010dfe9:	8b 45 08             	mov    0x8(%ebp),%eax
f010dfec:	8b 90 40 06 00 00    	mov    0x640(%eax),%edx
f010dff2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010dff5:	89 d0                	mov    %edx,%eax
f010dff7:	01 c0                	add    %eax,%eax
f010dff9:	01 d0                	add    %edx,%eax
f010dffb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010e002:	01 d8                	add    %ebx,%eax
f010e004:	01 d0                	add    %edx,%eax
f010e006:	01 c8                	add    %ecx,%eax
f010e008:	05 d0 00 00 00       	add    $0xd0,%eax
f010e00d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010e013:	8b 45 08             	mov    0x8(%ebp),%eax
f010e016:	8b 80 40 06 00 00    	mov    0x640(%eax),%eax
f010e01c:	8d 50 01             	lea    0x1(%eax),%edx
f010e01f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e022:	89 90 40 06 00 00    	mov    %edx,0x640(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010e028:	8b 45 08             	mov    0x8(%ebp),%eax
f010e02b:	8b 80 40 06 00 00    	mov    0x640(%eax),%eax
f010e031:	b9 32 00 00 00       	mov    $0x32,%ecx
f010e036:	ba 00 00 00 00       	mov    $0x0,%edx
f010e03b:	f7 f1                	div    %ecx
f010e03d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e040:	89 90 40 06 00 00    	mov    %edx,0x640(%eax)
			if (e->table_last_WS_index == 0)
f010e046:	8b 45 08             	mov    0x8(%ebp),%eax
f010e049:	8b 80 40 06 00 00    	mov    0x640(%eax),%eax
f010e04f:	85 c0                	test   %eax,%eax
f010e051:	75 17                	jne    f010e06a <program_segment_alloc_map_copy_workingset+0x4fe>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010e053:	83 ec 04             	sub    $0x4,%esp
f010e056:	68 c8 82 13 f0       	push   $0xf01382c8
f010e05b:	68 54 03 00 00       	push   $0x354
f010e060:	68 9b 80 13 f0       	push   $0xf013809b
f010e065:	e8 45 2e ff ff       	call   f0100eaf <_panic>
			(*lastTableNumber) = PDX(iVA);
f010e06a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e06d:	c1 e8 16             	shr    $0x16,%eax
f010e070:	89 c2                	mov    %eax,%edx
f010e072:	8b 45 18             	mov    0x18(%ebp),%eax
f010e075:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010e077:	8b 45 10             	mov    0x10(%ebp),%eax
f010e07a:	8b 00                	mov    (%eax),%eax
f010e07c:	8d 50 01             	lea    0x1(%eax),%edx
f010e07f:	8b 45 10             	mov    0x10(%ebp),%eax
f010e082:	89 10                	mov    %edx,(%eax)
	if (iVA == 0x803000 && (strcmp(e->prog_name, "tpp")==0 || strcmp(e->prog_name, "tia") ==0
			|| strcmp(e->prog_name, "tia_slave1") == 0 || strcmp(e->prog_name, "tia_slave2") == 0
			|| strcmp(e->prog_name, "tia_slave3") == 0 || strcmp(e->prog_name, "tia_slave4") == 0))
		remaining_ws_pages = remaining_ws_pages < 9 ? remaining_ws_pages:9;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010e084:	ff 45 f0             	incl   -0x10(%ebp)
f010e087:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010e08e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e091:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010e094:	73 0c                	jae    f010e0a2 <program_segment_alloc_map_copy_workingset+0x536>
f010e096:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e099:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e09c:	0f 82 13 fc ff ff    	jb     f010dcb5 <program_segment_alloc_map_copy_workingset+0x149>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010e0a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0a5:	8b 00                	mov    (%eax),%eax
f010e0a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010e0aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0ad:	8b 40 0c             	mov    0xc(%eax),%eax
f010e0b0:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010e0b3:	eb 10                	jmp    f010e0c5 <program_segment_alloc_map_copy_workingset+0x559>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010e0b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e0b8:	8a 10                	mov    (%eax),%dl
f010e0ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0bd:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010e0bf:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010e0c2:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010e0c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e0c8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010e0cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010e0ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010e0d3:	89 c2                	mov    %eax,%edx
f010e0d5:	8b 45 10             	mov    0x10(%ebp),%eax
f010e0d8:	8b 00                	mov    (%eax),%eax
f010e0da:	c1 e0 0c             	shl    $0xc,%eax
f010e0dd:	01 c2                	add    %eax,%edx
f010e0df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0e2:	39 c2                	cmp    %eax,%edx
f010e0e4:	76 1d                	jbe    f010e103 <program_segment_alloc_map_copy_workingset+0x597>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010e0e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0e9:	8b 50 04             	mov    0x4(%eax),%edx
f010e0ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e0ef:	01 c2                	add    %eax,%edx
f010e0f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010e0f4:	39 c2                	cmp    %eax,%edx
f010e0f6:	77 bd                	ja     f010e0b5 <program_segment_alloc_map_copy_workingset+0x549>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010e0f8:	eb 09                	jmp    f010e103 <program_segment_alloc_map_copy_workingset+0x597>
	{
		*dst_ptr = 0;
f010e0fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0fd:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010e100:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010e103:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e106:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010e109:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010e10c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010e111:	89 c2                	mov    %eax,%edx
f010e113:	8b 45 10             	mov    0x10(%ebp),%eax
f010e116:	8b 00                	mov    (%eax),%eax
f010e118:	c1 e0 0c             	shl    $0xc,%eax
f010e11b:	01 c2                	add    %eax,%edx
f010e11d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e120:	39 c2                	cmp    %eax,%edx
f010e122:	77 d6                	ja     f010e0fa <program_segment_alloc_map_copy_workingset+0x58e>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010e124:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e129:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e12c:	5b                   	pop    %ebx
f010e12d:	5e                   	pop    %esi
f010e12e:	5d                   	pop    %ebp
f010e12f:	c3                   	ret    

f010e130 <create_user_directory>:

//==================================================
// 5) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010e130:	55                   	push   %ebp
f010e131:	89 e5                	mov    %esp,%ebp
f010e133:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010e136:	83 ec 0c             	sub    $0xc,%esp
f010e139:	68 00 10 00 00       	push   $0x1000
f010e13e:	e8 8f cd ff ff       	call   f010aed2 <kmalloc>
f010e143:	83 c4 10             	add    $0x10,%esp
f010e146:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010e149:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e14d:	75 17                	jne    f010e166 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010e14f:	83 ec 04             	sub    $0x4,%esp
f010e152:	68 6b 83 13 f0       	push   $0xf013836b
f010e157:	68 84 03 00 00       	push   $0x384
f010e15c:	68 9b 80 13 f0       	push   $0xf013809b
f010e161:	e8 49 2d ff ff       	call   f0100eaf <_panic>
	}
	return ptr_user_page_directory;
f010e166:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010e169:	c9                   	leave  
f010e16a:	c3                   	ret    

f010e16b <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 6) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010e16b:	55                   	push   %ebp
f010e16c:	89 e5                	mov    %esp,%ebp
f010e16e:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #1 create_user_kern_stack
	//Your code is here
	for(int i=0;i<10;i++){
f010e171:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e178:	eb 03                	jmp    f010e17d <create_user_kern_stack+0x12>
f010e17a:	ff 45 f4             	incl   -0xc(%ebp)
f010e17d:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f010e181:	7e f7                	jle    f010e17a <create_user_kern_stack+0xf>

	}
#if USE_KHEAP
	void* iloveahmedsalah_base = kmalloc(KERNEL_STACK_SIZE);
f010e183:	83 ec 0c             	sub    $0xc,%esp
f010e186:	68 00 80 00 00       	push   $0x8000
f010e18b:	e8 42 cd ff ff       	call   f010aed2 <kmalloc>
f010e190:	83 c4 10             	add    $0x10,%esp
f010e193:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (iloveahmedsalah_base == NULL)
f010e196:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e19a:	75 17                	jne    f010e1b3 <create_user_kern_stack+0x48>
        panic("Failed to allocate memory for the kernel stack");
f010e19c:	83 ec 04             	sub    $0x4,%esp
f010e19f:	68 88 83 13 f0       	push   $0xf0138388
f010e1a4:	68 99 03 00 00       	push   $0x399
f010e1a9:	68 9b 80 13 f0       	push   $0xf013809b
f010e1ae:	e8 fc 2c ff ff       	call   f0100eaf <_panic>
    uint32 iloveahmedsalah_guard = (uint32)iloveahmedsalah_base;
f010e1b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e1b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *iloveahmedsalah_table = NULL;
f010e1b9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	int iloveahmedsalah_ret = get_page_table(ptr_user_page_directory, iloveahmedsalah_guard, &iloveahmedsalah_table);
f010e1c0:	83 ec 04             	sub    $0x4,%esp
f010e1c3:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010e1c6:	50                   	push   %eax
f010e1c7:	ff 75 ec             	pushl  -0x14(%ebp)
f010e1ca:	ff 75 08             	pushl  0x8(%ebp)
f010e1cd:	e8 95 b6 ff ff       	call   f0109867 <get_page_table>
f010e1d2:	83 c4 10             	add    $0x10,%esp
f010e1d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(iloveahmedsalah_ret == TABLE_NOT_EXIST)
f010e1d8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f010e1dc:	75 17                	jne    f010e1f5 <create_user_kern_stack+0x8a>
		panic("page table doesn't exist");
f010e1de:	83 ec 04             	sub    $0x4,%esp
f010e1e1:	68 b7 83 13 f0       	push   $0xf01383b7
f010e1e6:	68 9e 03 00 00       	push   $0x39e
f010e1eb:	68 9b 80 13 f0       	push   $0xf013809b
f010e1f0:	e8 ba 2c ff ff       	call   f0100eaf <_panic>
    int iloveahmedsalah_index = PTX(iloveahmedsalah_guard);
f010e1f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e1f8:	c1 e8 0c             	shr    $0xc,%eax
f010e1fb:	25 ff 03 00 00       	and    $0x3ff,%eax
f010e200:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    iloveahmedsalah_table[iloveahmedsalah_index] = iloveahmedsalah_table[iloveahmedsalah_index] & ~PERM_PRESENT;
f010e203:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e206:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e209:	c1 e2 02             	shl    $0x2,%edx
f010e20c:	01 d0                	add    %edx,%eax
f010e20e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e211:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010e214:	c1 e1 02             	shl    $0x2,%ecx
f010e217:	01 ca                	add    %ecx,%edx
f010e219:	8b 12                	mov    (%edx),%edx
f010e21b:	83 e2 fe             	and    $0xfffffffe,%edx
f010e21e:	89 10                	mov    %edx,(%eax)
    return iloveahmedsalah_base;
f010e220:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//panic("create_user_kern_stack() is not implemented yet...!!");

	//allocate space for the user kernel stack.
	//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
	//return a pointer to the start of the allocated space (including the GUARD PAGE)
}
f010e223:	c9                   	leave  
f010e224:	c3                   	ret    

f010e225 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010e225:	55                   	push   %ebp
f010e226:	89 e5                	mov    %esp,%ebp
f010e228:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - delete_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010e22b:	83 ec 04             	sub    $0x4,%esp
f010e22e:	68 d0 83 13 f0       	push   $0xf01383d0
f010e233:	68 b6 03 00 00       	push   $0x3b6
f010e238:	68 9b 80 13 f0       	push   $0xf013809b
f010e23d:	e8 6d 2c ff ff       	call   f0100eaf <_panic>

f010e242 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010e242:	55                   	push   %ebp
f010e243:	89 e5                	mov    %esp,%ebp
f010e245:	53                   	push   %ebx
f010e246:	83 ec 14             	sub    $0x14,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010e249:	8b 45 08             	mov    0x8(%ebp),%eax
f010e24c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e24f:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010e252:	8b 45 08             	mov    0x8(%ebp),%eax
f010e255:	8b 55 10             	mov    0x10(%ebp),%edx
f010e258:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010e25b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e262:	eb 17                	jmp    f010e27b <initialize_environment+0x39>
	{
		e->env_page_directory[i] = 0 ;
f010e264:	8b 45 08             	mov    0x8(%ebp),%eax
f010e267:	8b 40 64             	mov    0x64(%eax),%eax
f010e26a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e26d:	c1 e2 02             	shl    $0x2,%edx
f010e270:	01 d0                	add    %edx,%eax
f010e272:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010e278:	ff 45 f4             	incl   -0xc(%ebp)
f010e27b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e27e:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010e283:	76 df                	jbe    f010e264 <initialize_environment+0x22>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010e285:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010e28c:	eb 22                	jmp    f010e2b0 <initialize_environment+0x6e>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010e28e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e291:	8b 40 64             	mov    0x64(%eax),%eax
f010e294:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e297:	c1 e2 02             	shl    $0x2,%edx
f010e29a:	01 c2                	add    %eax,%edx
f010e29c:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f010e2a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010e2a4:	c1 e1 02             	shl    $0x2,%ecx
f010e2a7:	01 c8                	add    %ecx,%eax
f010e2a9:	8b 00                	mov    (%eax),%eax
f010e2ab:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010e2ad:	ff 45 f4             	incl   -0xc(%ebp)
f010e2b0:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010e2b7:	7e d5                	jle    f010e28e <initialize_environment+0x4c>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010e2b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2bc:	8b 40 64             	mov    0x64(%eax),%eax
f010e2bf:	83 ec 0c             	sub    $0xc,%esp
f010e2c2:	50                   	push   %eax
f010e2c3:	e8 a3 fe ff ff       	call   f010e16b <create_user_kern_stack>
f010e2c8:	83 c4 10             	add    $0x10,%esp
f010e2cb:	89 c2                	mov    %eax,%edx
f010e2cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d0:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010e2d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d6:	8b 40 70             	mov    0x70(%eax),%eax
f010e2d9:	05 00 80 00 00       	add    $0x8000,%eax
f010e2de:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010e2e1:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010e2e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e2eb:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010e2ed:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010e2f1:	ba 34 04 11 f0       	mov    $0xf0110434,%edx
f010e2f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2f9:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010e2fb:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010e2ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010e302:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e305:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010e308:	8b 45 08             	mov    0x8(%ebp),%eax
f010e30b:	8b 40 04             	mov    0x4(%eax),%eax
f010e30e:	83 ec 04             	sub    $0x4,%esp
f010e311:	6a 20                	push   $0x20
f010e313:	6a 00                	push   $0x0
f010e315:	50                   	push   %eax
f010e316:	e8 02 4d 01 00       	call   f012301d <memset>
f010e31b:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010e31e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e321:	8b 40 04             	mov    0x4(%eax),%eax
f010e324:	ba 97 d5 10 f0       	mov    $0xf010d597,%edx
f010e329:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010e32c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e32f:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010e336:	00 00 00 
f010e339:	8b 45 08             	mov    0x8(%ebp),%eax
f010e33c:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010e343:	00 00 00 
f010e346:	8b 45 08             	mov    0x8(%ebp),%eax
f010e349:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010e350:	00 00 00 
		LIST_INIT(&(e->referenceStreamList));
f010e353:	8b 45 08             	mov    0x8(%ebp),%eax
f010e356:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010e35d:	00 00 00 
f010e360:	8b 45 08             	mov    0x8(%ebp),%eax
f010e363:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010e36a:	00 00 00 
f010e36d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e370:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
f010e377:	00 00 00 
		LIST_INIT(&(e->simWS));
f010e37a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e37d:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010e384:	00 00 00 
f010e387:	8b 45 08             	mov    0x8(%ebp),%eax
f010e38a:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010e391:	00 00 00 
f010e394:	8b 45 08             	mov    0x8(%ebp),%eax
f010e397:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010e39e:	00 00 00 
		e->simWS_copy = 0;
f010e3a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3a4:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010e3ab:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010e3ae:	83 ec 0c             	sub    $0xc,%esp
f010e3b1:	6a 02                	push   $0x2
f010e3b3:	e8 c6 32 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f010e3b8:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010e3bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e3c2:	eb 6c                	jmp    f010e430 <initialize_environment+0x1ee>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010e3c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e3c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e3ca:	89 d0                	mov    %edx,%eax
f010e3cc:	01 c0                	add    %eax,%eax
f010e3ce:	01 d0                	add    %edx,%eax
f010e3d0:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010e3d7:	01 d8                	add    %ebx,%eax
f010e3d9:	01 d0                	add    %edx,%eax
f010e3db:	01 c8                	add    %ecx,%eax
f010e3dd:	05 c8 00 00 00       	add    $0xc8,%eax
f010e3e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010e3e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e3eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e3ee:	89 d0                	mov    %edx,%eax
f010e3f0:	01 c0                	add    %eax,%eax
f010e3f2:	01 d0                	add    %edx,%eax
f010e3f4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010e3fb:	01 d8                	add    %ebx,%eax
f010e3fd:	01 d0                	add    %edx,%eax
f010e3ff:	01 c8                	add    %ecx,%eax
f010e401:	05 cc 00 00 00       	add    $0xcc,%eax
f010e406:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010e409:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e40c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e40f:	89 d0                	mov    %edx,%eax
f010e411:	01 c0                	add    %eax,%eax
f010e413:	01 d0                	add    %edx,%eax
f010e415:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010e41c:	01 d8                	add    %ebx,%eax
f010e41e:	01 d0                	add    %edx,%eax
f010e420:	01 c8                	add    %ecx,%eax
f010e422:	05 d0 00 00 00       	add    $0xd0,%eax
f010e427:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010e42d:	ff 45 f4             	incl   -0xc(%ebp)
f010e430:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010e434:	7e 8e                	jle    f010e3c4 <initialize_environment+0x182>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010e436:	8b 45 08             	mov    0x8(%ebp),%eax
f010e439:	c7 80 40 06 00 00 00 	movl   $0x0,0x640(%eax)
f010e440:	00 00 00 

	e->pageFaultsCounter=0;
f010e443:	8b 45 08             	mov    0x8(%ebp),%eax
f010e446:	c7 80 78 06 00 00 00 	movl   $0x0,0x678(%eax)
f010e44d:	00 00 00 
	e->tableFaultsCounter=0;
f010e450:	8b 45 08             	mov    0x8(%ebp),%eax
f010e453:	c7 80 7c 06 00 00 00 	movl   $0x0,0x67c(%eax)
f010e45a:	00 00 00 

	e->freeingFullWSCounter = 0;
f010e45d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e460:	c7 80 80 06 00 00 00 	movl   $0x0,0x680(%eax)
f010e467:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010e46a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e46d:	c7 80 84 06 00 00 00 	movl   $0x0,0x684(%eax)
f010e474:	00 00 00 

	e->nModifiedPages=0;
f010e477:	8b 45 08             	mov    0x8(%ebp),%eax
f010e47a:	c7 80 88 06 00 00 00 	movl   $0x0,0x688(%eax)
f010e481:	00 00 00 
	e->nNotModifiedPages=0;
f010e484:	8b 45 08             	mov    0x8(%ebp),%eax
f010e487:	c7 80 8c 06 00 00 00 	movl   $0x0,0x68c(%eax)
f010e48e:	00 00 00 
	e->nClocks = 0;
f010e491:	8b 45 08             	mov    0x8(%ebp),%eax
f010e494:	c7 80 a0 06 00 00 00 	movl   $0x0,0x6a0(%eax)
f010e49b:	00 00 00 

	//2020
	e->nPageIn = 0;
f010e49e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4a1:	c7 80 94 06 00 00 00 	movl   $0x0,0x694(%eax)
f010e4a8:	00 00 00 
	e->nPageOut = 0;
f010e4ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4ae:	c7 80 98 06 00 00 00 	movl   $0x0,0x698(%eax)
f010e4b5:	00 00 00 
	e->nNewPageAdded = 0;
f010e4b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4bb:	c7 80 9c 06 00 00 00 	movl   $0x0,0x69c(%eax)
f010e4c2:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010e4c5:	83 ec 0c             	sub    $0xc,%esp
f010e4c8:	ff 75 08             	pushl  0x8(%ebp)
f010e4cb:	e8 09 00 00 00       	call   f010e4d9 <complete_environment_initialization>
f010e4d0:	83 c4 10             	add    $0x10,%esp
}
f010e4d3:	90                   	nop
f010e4d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e4d7:	c9                   	leave  
f010e4d8:	c3                   	ret    

f010e4d9 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010e4d9:	55                   	push   %ebp
f010e4da:	89 e5                	mov    %esp,%ebp
f010e4dc:	53                   	push   %ebx
f010e4dd:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010e4e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4e3:	8b 40 64             	mov    0x64(%eax),%eax
f010e4e6:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010e4ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4ef:	8b 40 68             	mov    0x68(%eax),%eax
f010e4f2:	83 c8 03             	or     $0x3,%eax
f010e4f5:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010e4f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4fa:	8b 40 64             	mov    0x64(%eax),%eax
f010e4fd:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010e503:	8b 45 08             	mov    0x8(%ebp),%eax
f010e506:	8b 40 68             	mov    0x68(%eax),%eax
f010e509:	83 c8 05             	or     $0x5,%eax
f010e50c:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010e50e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e511:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010e518:	8b 45 08             	mov    0x8(%ebp),%eax
f010e51b:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010e522:	8b 45 08             	mov    0x8(%ebp),%eax
f010e525:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010e52c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e52f:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010e536:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010e539:	8b 45 08             	mov    0x8(%ebp),%eax
f010e53c:	8b 58 10             	mov    0x10(%eax),%ebx
f010e53f:	83 ec 0c             	sub    $0xc,%esp
f010e542:	68 68 02 00 00       	push   $0x268
f010e547:	e8 94 23 01 00       	call   f01208e0 <log2_ceil>
f010e54c:	83 c4 10             	add    $0x10,%esp
f010e54f:	ba 01 00 00 00       	mov    $0x1,%edx
f010e554:	88 c1                	mov    %al,%cl
f010e556:	d3 e2                	shl    %cl,%edx
f010e558:	89 d0                	mov    %edx,%eax
f010e55a:	01 d8                	add    %ebx,%eax
f010e55c:	89 c3                	mov    %eax,%ebx
f010e55e:	83 ec 0c             	sub    $0xc,%esp
f010e561:	68 68 02 00 00       	push   $0x268
f010e566:	e8 40 23 01 00       	call   f01208ab <nearest_pow2_ceil>
f010e56b:	83 c4 10             	add    $0x10,%esp
f010e56e:	f7 d8                	neg    %eax
f010e570:	21 d8                	and    %ebx,%eax
f010e572:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010e575:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e579:	7f 1e                	jg     f010e599 <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010e57b:	83 ec 0c             	sub    $0xc,%esp
f010e57e:	68 68 02 00 00       	push   $0x268
f010e583:	e8 58 23 01 00       	call   f01208e0 <log2_ceil>
f010e588:	83 c4 10             	add    $0x10,%esp
f010e58b:	ba 01 00 00 00       	mov    $0x1,%edx
f010e590:	88 c1                	mov    %al,%cl
f010e592:	d3 e2                	shl    %cl,%edx
f010e594:	89 d0                	mov    %edx,%eax
f010e596:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010e599:	8b 45 08             	mov    0x8(%ebp),%eax
f010e59c:	8b 15 d0 40 92 f0    	mov    0xf09240d0,%edx
f010e5a2:	29 d0                	sub    %edx,%eax
f010e5a4:	c1 f8 02             	sar    $0x2,%eax
f010e5a7:	89 c2                	mov    %eax,%edx
f010e5a9:	89 d0                	mov    %edx,%eax
f010e5ab:	c1 e0 07             	shl    $0x7,%eax
f010e5ae:	01 d0                	add    %edx,%eax
f010e5b0:	c1 e0 03             	shl    $0x3,%eax
f010e5b3:	01 d0                	add    %edx,%eax
f010e5b5:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010e5bc:	01 c8                	add    %ecx,%eax
f010e5be:	01 c0                	add    %eax,%eax
f010e5c0:	01 d0                	add    %edx,%eax
f010e5c2:	89 c1                	mov    %eax,%ecx
f010e5c4:	c1 e1 04             	shl    $0x4,%ecx
f010e5c7:	01 c8                	add    %ecx,%eax
f010e5c9:	c1 e0 03             	shl    $0x3,%eax
f010e5cc:	01 d0                	add    %edx,%eax
f010e5ce:	89 c2                	mov    %eax,%edx
f010e5d0:	c1 e2 0a             	shl    $0xa,%edx
f010e5d3:	29 c2                	sub    %eax,%edx
f010e5d5:	89 d0                	mov    %edx,%eax
f010e5d7:	f7 d8                	neg    %eax
f010e5d9:	0b 45 f4             	or     -0xc(%ebp),%eax
f010e5dc:	89 c2                	mov    %eax,%edx
f010e5de:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5e1:	89 50 10             	mov    %edx,0x10(%eax)
	//cprintf("\n[%d] user kernel stack located in [%x,%x)\n", e->env_id, e->kstack, e->kstack + KERNEL_STACK_SIZE);
	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010e5e4:	e8 5f f0 ff ff       	call   f010d648 <get_cpu_proc>
f010e5e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010e5ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e5f0:	75 0c                	jne    f010e5fe <complete_environment_initialization+0x125>
		e->env_parent_id = 0;//no parent;
f010e5f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5f5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010e5fc:	eb 0c                	jmp    f010e60a <complete_environment_initialization+0x131>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010e5fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e601:	8b 50 10             	mov    0x10(%eax),%edx
f010e604:	8b 45 08             	mov    0x8(%ebp),%eax
f010e607:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010e60a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e60d:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010e614:	8b 45 08             	mov    0x8(%ebp),%eax
f010e617:	c7 80 90 06 00 00 00 	movl   $0x0,0x690(%eax)
f010e61e:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010e621:	8b 45 08             	mov    0x8(%ebp),%eax
f010e624:	8b 00                	mov    (%eax),%eax
f010e626:	83 ec 04             	sub    $0x4,%esp
f010e629:	6a 44                	push   $0x44
f010e62b:	6a 00                	push   $0x0
f010e62d:	50                   	push   %eax
f010e62e:	e8 ea 49 01 00       	call   f012301d <memset>
f010e633:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010e636:	8b 45 08             	mov    0x8(%ebp),%eax
f010e639:	8b 00                	mov    (%eax),%eax
f010e63b:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010e641:	8b 45 08             	mov    0x8(%ebp),%eax
f010e644:	8b 00                	mov    (%eax),%eax
f010e646:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010e64c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e64f:	8b 00                	mov    (%eax),%eax
f010e651:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010e657:	8b 45 08             	mov    0x8(%ebp),%eax
f010e65a:	8b 00                	mov    (%eax),%eax
f010e65c:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010e663:	8b 45 08             	mov    0x8(%ebp),%eax
f010e666:	8b 00                	mov    (%eax),%eax
f010e668:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010e66e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e671:	8b 00                	mov    (%eax),%eax
f010e673:	8b 55 08             	mov    0x8(%ebp),%edx
f010e676:	8b 12                	mov    (%edx),%edx
f010e678:	8b 52 38             	mov    0x38(%edx),%edx
f010e67b:	80 ce 02             	or     $0x2,%dh
f010e67e:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010e681:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e685:	75 17                	jne    f010e69e <complete_environment_initialization+0x1c5>
f010e687:	83 ec 04             	sub    $0x4,%esp
f010e68a:	68 23 81 13 f0       	push   $0xf0138123
f010e68f:	68 82 04 00 00       	push   $0x482
f010e694:	68 9b 80 13 f0       	push   $0xf013809b
f010e699:	e8 11 28 ff ff       	call   f0100eaf <_panic>
f010e69e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6a1:	8b 40 08             	mov    0x8(%eax),%eax
f010e6a4:	85 c0                	test   %eax,%eax
f010e6a6:	74 11                	je     f010e6b9 <complete_environment_initialization+0x1e0>
f010e6a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6ab:	8b 40 08             	mov    0x8(%eax),%eax
f010e6ae:	8b 55 08             	mov    0x8(%ebp),%edx
f010e6b1:	8b 52 0c             	mov    0xc(%edx),%edx
f010e6b4:	89 50 0c             	mov    %edx,0xc(%eax)
f010e6b7:	eb 0b                	jmp    f010e6c4 <complete_environment_initialization+0x1eb>
f010e6b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6bc:	8b 40 0c             	mov    0xc(%eax),%eax
f010e6bf:	a3 d8 40 92 f0       	mov    %eax,0xf09240d8
f010e6c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c7:	8b 40 0c             	mov    0xc(%eax),%eax
f010e6ca:	85 c0                	test   %eax,%eax
f010e6cc:	74 11                	je     f010e6df <complete_environment_initialization+0x206>
f010e6ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6d1:	8b 40 0c             	mov    0xc(%eax),%eax
f010e6d4:	8b 55 08             	mov    0x8(%ebp),%edx
f010e6d7:	8b 52 08             	mov    0x8(%edx),%edx
f010e6da:	89 50 08             	mov    %edx,0x8(%eax)
f010e6dd:	eb 0b                	jmp    f010e6ea <complete_environment_initialization+0x211>
f010e6df:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6e2:	8b 40 08             	mov    0x8(%eax),%eax
f010e6e5:	a3 d4 40 92 f0       	mov    %eax,0xf09240d4
f010e6ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6ed:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010e6f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6f7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010e6fe:	a1 e0 40 92 f0       	mov    0xf09240e0,%eax
f010e703:	48                   	dec    %eax
f010e704:	a3 e0 40 92 f0       	mov    %eax,0xf09240e0
	return ;
f010e709:	90                   	nop
}
f010e70a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e70d:	c9                   	leave  
f010e70e:	c3                   	ret    

f010e70f <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010e70f:	55                   	push   %ebp
f010e710:	89 e5                	mov    %esp,%ebp
f010e712:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010e715:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e718:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010e71b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e71e:	8b 00                	mov    (%eax),%eax
f010e720:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010e725:	74 17                	je     f010e73e <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010e727:	83 ec 04             	sub    $0x4,%esp
f010e72a:	68 05 84 13 f0       	push   $0xf0138405
f010e72f:	68 8e 04 00 00       	push   $0x48e
f010e734:	68 9b 80 13 f0       	push   $0xf013809b
f010e739:	e8 71 27 ff ff       	call   f0100eaf <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010e73e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e741:	8b 00                	mov    (%eax),%eax
f010e743:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e746:	8b 52 18             	mov    0x18(%edx),%edx
f010e749:	89 50 30             	mov    %edx,0x30(%eax)
}
f010e74c:	90                   	nop
f010e74d:	c9                   	leave  
f010e74e:	c3                   	ret    

f010e74f <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 13) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010e74f:	55                   	push   %ebp
f010e750:	89 e5                	mov    %esp,%ebp
f010e752:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010e755:	8b 45 08             	mov    0x8(%ebp),%eax
f010e758:	8b 40 10             	mov    0x10(%eax),%eax
f010e75b:	8d 48 01             	lea    0x1(%eax),%ecx
f010e75e:	8b 55 08             	mov    0x8(%ebp),%edx
f010e761:	89 4a 10             	mov    %ecx,0x10(%edx)
f010e764:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010e767:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e76a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010e76d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e770:	8b 00                	mov    (%eax),%eax
f010e772:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010e777:	74 17                	je     f010e790 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010e779:	83 ec 04             	sub    $0x4,%esp
f010e77c:	68 05 84 13 f0       	push   $0xf0138405
f010e781:	68 9c 04 00 00       	push   $0x49c
f010e786:	68 9b 80 13 f0       	push   $0xf013809b
f010e78b:	e8 1f 27 ff ff       	call   f0100eaf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010e790:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e793:	8b 50 1c             	mov    0x1c(%eax),%edx
f010e796:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e799:	01 d0                	add    %edx,%eax
f010e79b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010e79e:	eb 0f                	jmp    f010e7af <PROGRAM_SEGMENT_NEXT+0x60>
f010e7a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7a3:	8b 40 10             	mov    0x10(%eax),%eax
f010e7a6:	8d 50 01             	lea    0x1(%eax),%edx
f010e7a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7ac:	89 50 10             	mov    %edx,0x10(%eax)
f010e7af:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7b2:	8b 40 10             	mov    0x10(%eax),%eax
f010e7b5:	c1 e0 05             	shl    $0x5,%eax
f010e7b8:	89 c2                	mov    %eax,%edx
f010e7ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e7bd:	01 d0                	add    %edx,%eax
f010e7bf:	8b 00                	mov    (%eax),%eax
f010e7c1:	83 f8 01             	cmp    $0x1,%eax
f010e7c4:	74 13                	je     f010e7d9 <PROGRAM_SEGMENT_NEXT+0x8a>
f010e7c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7c9:	8b 50 10             	mov    0x10(%eax),%edx
f010e7cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7cf:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e7d2:	0f b7 c0             	movzwl %ax,%eax
f010e7d5:	39 c2                	cmp    %eax,%edx
f010e7d7:	72 c7                	jb     f010e7a0 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010e7d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7dc:	8b 40 10             	mov    0x10(%eax),%eax
f010e7df:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010e7e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7e5:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e7e8:	0f b7 c0             	movzwl %ax,%eax
f010e7eb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e7ee:	7e 63                	jle    f010e853 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010e7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7f3:	c1 e0 05             	shl    $0x5,%eax
f010e7f6:	89 c2                	mov    %eax,%edx
f010e7f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e7fb:	01 d0                	add    %edx,%eax
f010e7fd:	8b 50 04             	mov    0x4(%eax),%edx
f010e800:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e803:	01 c2                	add    %eax,%edx
f010e805:	8b 45 08             	mov    0x8(%ebp),%eax
f010e808:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010e80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e80d:	c1 e0 05             	shl    $0x5,%eax
f010e810:	89 c2                	mov    %eax,%edx
f010e812:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e815:	01 d0                	add    %edx,%eax
f010e817:	8b 50 14             	mov    0x14(%eax),%edx
f010e81a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e81d:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010e820:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e823:	c1 e0 05             	shl    $0x5,%eax
f010e826:	89 c2                	mov    %eax,%edx
f010e828:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e82b:	01 d0                	add    %edx,%eax
f010e82d:	8b 50 10             	mov    0x10(%eax),%edx
f010e830:	8b 45 08             	mov    0x8(%ebp),%eax
f010e833:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010e836:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e839:	c1 e0 05             	shl    $0x5,%eax
f010e83c:	89 c2                	mov    %eax,%edx
f010e83e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e841:	01 d0                	add    %edx,%eax
f010e843:	8b 40 08             	mov    0x8(%eax),%eax
f010e846:	89 c2                	mov    %eax,%edx
f010e848:	8b 45 08             	mov    0x8(%ebp),%eax
f010e84b:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010e84e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e851:	eb 05                	jmp    f010e858 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010e853:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e858:	c9                   	leave  
f010e859:	c3                   	ret    

f010e85a <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 14) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010e85a:	55                   	push   %ebp
f010e85b:	89 e5                	mov    %esp,%ebp
f010e85d:	57                   	push   %edi
f010e85e:	56                   	push   %esi
f010e85f:	53                   	push   %ebx
f010e860:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010e863:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010e86a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e86d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010e870:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e873:	8b 00                	mov    (%eax),%eax
f010e875:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010e87a:	74 17                	je     f010e893 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010e87c:	83 ec 04             	sub    $0x4,%esp
f010e87f:	68 05 84 13 f0       	push   $0xf0138405
f010e884:	68 b8 04 00 00       	push   $0x4b8
f010e889:	68 9b 80 13 f0       	push   $0xf013809b
f010e88e:	e8 1c 26 ff ff       	call   f0100eaf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010e893:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e896:	8b 50 1c             	mov    0x1c(%eax),%edx
f010e899:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e89c:	01 d0                	add    %edx,%eax
f010e89e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010e8a1:	eb 07                	jmp    f010e8aa <PROGRAM_SEGMENT_FIRST+0x50>
f010e8a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e8a6:	40                   	inc    %eax
f010e8a7:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010e8aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e8ad:	c1 e0 05             	shl    $0x5,%eax
f010e8b0:	89 c2                	mov    %eax,%edx
f010e8b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e8b5:	01 d0                	add    %edx,%eax
f010e8b7:	8b 00                	mov    (%eax),%eax
f010e8b9:	83 f8 01             	cmp    $0x1,%eax
f010e8bc:	74 10                	je     f010e8ce <PROGRAM_SEGMENT_FIRST+0x74>
f010e8be:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010e8c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e8c4:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e8c7:	0f b7 c0             	movzwl %ax,%eax
f010e8ca:	39 c2                	cmp    %eax,%edx
f010e8cc:	72 d5                	jb     f010e8a3 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010e8ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e8d1:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010e8d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e8d7:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e8da:	0f b7 c0             	movzwl %ax,%eax
f010e8dd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010e8e0:	7e 68                	jle    f010e94a <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010e8e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e8e5:	c1 e0 05             	shl    $0x5,%eax
f010e8e8:	89 c2                	mov    %eax,%edx
f010e8ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e8ed:	01 d0                	add    %edx,%eax
f010e8ef:	8b 50 04             	mov    0x4(%eax),%edx
f010e8f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8f5:	01 d0                	add    %edx,%eax
f010e8f7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010e8fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e8fd:	c1 e0 05             	shl    $0x5,%eax
f010e900:	89 c2                	mov    %eax,%edx
f010e902:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e905:	01 d0                	add    %edx,%eax
f010e907:	8b 40 14             	mov    0x14(%eax),%eax
f010e90a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010e90d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e910:	c1 e0 05             	shl    $0x5,%eax
f010e913:	89 c2                	mov    %eax,%edx
f010e915:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e918:	01 d0                	add    %edx,%eax
f010e91a:	8b 40 10             	mov    0x10(%eax),%eax
f010e91d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010e920:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e923:	c1 e0 05             	shl    $0x5,%eax
f010e926:	89 c2                	mov    %eax,%edx
f010e928:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e92b:	01 d0                	add    %edx,%eax
f010e92d:	8b 40 08             	mov    0x8(%eax),%eax
f010e930:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010e933:	8b 45 08             	mov    0x8(%ebp),%eax
f010e936:	89 c3                	mov    %eax,%ebx
f010e938:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010e93b:	ba 05 00 00 00       	mov    $0x5,%edx
f010e940:	89 df                	mov    %ebx,%edi
f010e942:	89 c6                	mov    %eax,%esi
f010e944:	89 d1                	mov    %edx,%ecx
f010e946:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010e948:	eb 1c                	jmp    f010e966 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010e94a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010e951:	8b 45 08             	mov    0x8(%ebp),%eax
f010e954:	89 c3                	mov    %eax,%ebx
f010e956:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010e959:	ba 05 00 00 00       	mov    $0x5,%edx
f010e95e:	89 df                	mov    %ebx,%edi
f010e960:	89 c6                	mov    %eax,%esi
f010e962:	89 d1                	mov    %edx,%ecx
f010e964:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010e966:	8b 45 08             	mov    0x8(%ebp),%eax
f010e969:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e96c:	5b                   	pop    %ebx
f010e96d:	5e                   	pop    %esi
f010e96e:	5f                   	pop    %edi
f010e96f:	5d                   	pop    %ebp
f010e970:	c2 04 00             	ret    $0x4

f010e973 <cleanup_buffers>:

//===============================================================================
// 15) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010e973:	55                   	push   %ebp
f010e974:	89 e5                	mov    %esp,%ebp
f010e976:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010e979:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f010e980:	83 ec 0c             	sub    $0xc,%esp
f010e983:	68 80 ce 94 f1       	push   $0xf194ce80
f010e988:	e8 0d 4e 00 00       	call   f011379a <holding_kspinlock>
f010e98d:	83 c4 10             	add    $0x10,%esp
f010e990:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!lock_already_held)
f010e993:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e997:	75 10                	jne    f010e9a9 <cleanup_buffers+0x36>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010e999:	83 ec 0c             	sub    $0xc,%esp
f010e99c:	68 80 ce 94 f1       	push   $0xf194ce80
f010e9a1:	e8 9f 4b 00 00       	call   f0113545 <acquire_kspinlock>
f010e9a6:	83 c4 10             	add    $0x10,%esp
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010e9a9:	a1 70 ce 94 f1       	mov    0xf194ce70,%eax
f010e9ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e9b1:	e9 a7 00 00 00       	jmp    f010ea5d <cleanup_buffers+0xea>
						{
			if(ptr_fi->proc == e)
f010e9b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9b9:	8b 40 0c             	mov    0xc(%eax),%eax
f010e9bc:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e9bf:	0f 85 90 00 00 00    	jne    f010ea55 <cleanup_buffers+0xe2>
				/*MUST UN-COMMENT THIS LINE*/
				//pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->va);

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010e9c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e9c9:	75 17                	jne    f010e9e2 <cleanup_buffers+0x6f>
f010e9cb:	83 ec 04             	sub    $0x4,%esp
f010e9ce:	68 23 81 13 f0       	push   $0xf0138123
f010e9d3:	68 e6 04 00 00       	push   $0x4e6
f010e9d8:	68 9b 80 13 f0       	push   $0xf013809b
f010e9dd:	e8 cd 24 ff ff       	call   f0100eaf <_panic>
f010e9e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9e5:	8b 00                	mov    (%eax),%eax
f010e9e7:	85 c0                	test   %eax,%eax
f010e9e9:	74 10                	je     f010e9fb <cleanup_buffers+0x88>
f010e9eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9ee:	8b 00                	mov    (%eax),%eax
f010e9f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e9f3:	8b 52 04             	mov    0x4(%edx),%edx
f010e9f6:	89 50 04             	mov    %edx,0x4(%eax)
f010e9f9:	eb 0b                	jmp    f010ea06 <cleanup_buffers+0x93>
f010e9fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9fe:	8b 40 04             	mov    0x4(%eax),%eax
f010ea01:	a3 74 ce 94 f1       	mov    %eax,0xf194ce74
f010ea06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea09:	8b 40 04             	mov    0x4(%eax),%eax
f010ea0c:	85 c0                	test   %eax,%eax
f010ea0e:	74 0f                	je     f010ea1f <cleanup_buffers+0xac>
f010ea10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea13:	8b 40 04             	mov    0x4(%eax),%eax
f010ea16:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ea19:	8b 12                	mov    (%edx),%edx
f010ea1b:	89 10                	mov    %edx,(%eax)
f010ea1d:	eb 0a                	jmp    f010ea29 <cleanup_buffers+0xb6>
f010ea1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea22:	8b 00                	mov    (%eax),%eax
f010ea24:	a3 70 ce 94 f1       	mov    %eax,0xf194ce70
f010ea29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea2c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010ea32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea35:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010ea3c:	a1 7c ce 94 f1       	mov    0xf194ce7c,%eax
f010ea41:	48                   	dec    %eax
f010ea42:	a3 7c ce 94 f1       	mov    %eax,0xf194ce7c

				free_frame(ptr_fi);
f010ea47:	83 ec 0c             	sub    $0xc,%esp
f010ea4a:	ff 75 f4             	pushl  -0xc(%ebp)
f010ea4d:	e8 2c ad ff ff       	call   f010977e <free_frame>
f010ea52:	83 c4 10             	add    $0x10,%esp
	if (!lock_already_held)
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010ea55:	a1 78 ce 94 f1       	mov    0xf194ce78,%eax
f010ea5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ea5d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ea61:	74 07                	je     f010ea6a <cleanup_buffers+0xf7>
f010ea63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea66:	8b 00                	mov    (%eax),%eax
f010ea68:	eb 05                	jmp    f010ea6f <cleanup_buffers+0xfc>
f010ea6a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea6f:	a3 78 ce 94 f1       	mov    %eax,0xf194ce78
f010ea74:	a1 78 ce 94 f1       	mov    0xf194ce78,%eax
f010ea79:	85 c0                	test   %eax,%eax
f010ea7b:	0f 85 35 ff ff ff    	jne    f010e9b6 <cleanup_buffers+0x43>
f010ea81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ea85:	0f 85 2b ff ff ff    	jne    f010e9b6 <cleanup_buffers+0x43>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
						}
	}
	if (!lock_already_held)
f010ea8b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ea8f:	75 10                	jne    f010eaa1 <cleanup_buffers+0x12e>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f010ea91:	83 ec 0c             	sub    $0xc,%esp
f010ea94:	68 80 ce 94 f1       	push   $0xf194ce80
f010ea99:	e8 4c 4b 00 00       	call   f01135ea <release_kspinlock>
f010ea9e:	83 c4 10             	add    $0x10,%esp
	}
	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010eaa1:	90                   	nop
f010eaa2:	c9                   	leave  
f010eaa3:	c3                   	ret    

f010eaa4 <set_program_priority>:
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"


void set_program_priority(struct Env* env, int priority)
{
f010eaa4:	55                   	push   %ebp
f010eaa5:	89 e5                	mov    %esp,%ebp
f010eaa7:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010eaaa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010eaae:	7e 06                	jle    f010eab6 <set_program_priority+0x12>
f010eab0:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010eab4:	7e 14                	jle    f010eaca <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010eab6:	83 ec 04             	sub    $0x4,%esp
f010eab9:	68 1c 84 13 f0       	push   $0xf013841c
f010eabe:	6a 11                	push   $0x11
f010eac0:	68 40 84 13 f0       	push   $0xf0138440
f010eac5:	e8 e5 23 ff ff       	call   f0100eaf <_panic>
		return;
	}
	if(env == NULL)
f010eaca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010eace:	74 78                	je     f010eb48 <set_program_priority+0xa4>
		return;
	switch(priority)
f010ead0:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ead4:	77 56                	ja     f010eb2c <set_program_priority+0x88>
f010ead6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ead9:	c1 e0 02             	shl    $0x2,%eax
f010eadc:	05 7c 84 13 f0       	add    $0xf013847c,%eax
f010eae1:	8b 00                	mov    (%eax),%eax
f010eae3:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010eae5:	83 ec 08             	sub    $0x8,%esp
f010eae8:	6a 01                	push   $0x1
f010eaea:	ff 75 08             	pushl  0x8(%ebp)
f010eaed:	e8 ac da ff ff       	call   f010c59e <half_WS_Size>
f010eaf2:	83 c4 10             	add    $0x10,%esp
			break;
f010eaf5:	eb 35                	jmp    f010eb2c <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010eaf7:	83 ec 08             	sub    $0x8,%esp
f010eafa:	6a 00                	push   $0x0
f010eafc:	ff 75 08             	pushl  0x8(%ebp)
f010eaff:	e8 9a da ff ff       	call   f010c59e <half_WS_Size>
f010eb04:	83 c4 10             	add    $0x10,%esp
			break;
f010eb07:	eb 23                	jmp    f010eb2c <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010eb09:	83 ec 08             	sub    $0x8,%esp
f010eb0c:	6a 01                	push   $0x1
f010eb0e:	ff 75 08             	pushl  0x8(%ebp)
f010eb11:	e8 6b da ff ff       	call   f010c581 <double_WS_Size>
f010eb16:	83 c4 10             	add    $0x10,%esp
			break;
f010eb19:	eb 11                	jmp    f010eb2c <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010eb1b:	83 ec 08             	sub    $0x8,%esp
f010eb1e:	6a 00                	push   $0x0
f010eb20:	ff 75 08             	pushl  0x8(%ebp)
f010eb23:	e8 59 da ff ff       	call   f010c581 <double_WS_Size>
f010eb28:	83 c4 10             	add    $0x10,%esp
			break;
f010eb2b:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010eb2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb2f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010eb35:	83 ec 08             	sub    $0x8,%esp
f010eb38:	50                   	push   %eax
f010eb39:	68 5d 84 13 f0       	push   $0xf013845d
f010eb3e:	e8 0a 30 ff ff       	call   f0101b4d <cprintf>
f010eb43:	83 c4 10             	add    $0x10,%esp
f010eb46:	eb 01                	jmp    f010eb49 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010eb48:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010eb49:	c9                   	leave  
f010eb4a:	c3                   	ret    

f010eb4b <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010eb4b:	55                   	push   %ebp
f010eb4c:	89 e5                	mov    %esp,%ebp
f010eb4e:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010eb51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010eb58:	eb 29                	jmp    f010eb83 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010eb5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010eb5d:	89 d0                	mov    %edx,%eax
f010eb5f:	01 c0                	add    %eax,%eax
f010eb61:	01 d0                	add    %edx,%eax
f010eb63:	c1 e0 02             	shl    $0x2,%eax
f010eb66:	05 e0 7b 19 f0       	add    $0xf0197be0,%eax
f010eb6b:	8b 00                	mov    (%eax),%eax
f010eb6d:	83 ec 08             	sub    $0x8,%esp
f010eb70:	50                   	push   %eax
f010eb71:	ff 75 08             	pushl  0x8(%ebp)
f010eb74:	e8 c2 43 01 00       	call   f0122f3b <strcmp>
f010eb79:	83 c4 10             	add    $0x10,%esp
f010eb7c:	85 c0                	test   %eax,%eax
f010eb7e:	74 0f                	je     f010eb8f <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010eb80:	ff 45 f4             	incl   -0xc(%ebp)
f010eb83:	a1 a0 80 19 f0       	mov    0xf01980a0,%eax
f010eb88:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010eb8b:	7c cd                	jl     f010eb5a <get_user_program_info+0xf>
f010eb8d:	eb 01                	jmp    f010eb90 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010eb8f:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010eb90:	a1 a0 80 19 f0       	mov    0xf01980a0,%eax
f010eb95:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010eb98:	75 1a                	jne    f010ebb4 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010eb9a:	83 ec 08             	sub    $0x8,%esp
f010eb9d:	ff 75 08             	pushl  0x8(%ebp)
f010eba0:	68 e0 95 13 f0       	push   $0xf01395e0
f010eba5:	e8 a3 2f ff ff       	call   f0101b4d <cprintf>
f010ebaa:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ebad:	b8 00 00 00 00       	mov    $0x0,%eax
f010ebb2:	eb 11                	jmp    f010ebc5 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010ebb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ebb7:	89 d0                	mov    %edx,%eax
f010ebb9:	01 c0                	add    %eax,%eax
f010ebbb:	01 d0                	add    %edx,%eax
f010ebbd:	c1 e0 02             	shl    $0x2,%eax
f010ebc0:	05 e0 7b 19 f0       	add    $0xf0197be0,%eax
}
f010ebc5:	c9                   	leave  
f010ebc6:	c3                   	ret    

f010ebc7 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010ebc7:	55                   	push   %ebp
f010ebc8:	89 e5                	mov    %esp,%ebp
f010ebca:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ebcd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ebd4:	eb 2d                	jmp    f010ec03 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010ebd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ebd9:	89 d0                	mov    %edx,%eax
f010ebdb:	01 c0                	add    %eax,%eax
f010ebdd:	01 d0                	add    %edx,%eax
f010ebdf:	c1 e0 02             	shl    $0x2,%eax
f010ebe2:	05 e0 7b 19 f0       	add    $0xf0197be0,%eax
f010ebe7:	8b 00                	mov    (%eax),%eax
f010ebe9:	8b 55 08             	mov    0x8(%ebp),%edx
f010ebec:	83 c2 20             	add    $0x20,%edx
f010ebef:	83 ec 08             	sub    $0x8,%esp
f010ebf2:	50                   	push   %eax
f010ebf3:	52                   	push   %edx
f010ebf4:	e8 42 43 01 00       	call   f0122f3b <strcmp>
f010ebf9:	83 c4 10             	add    $0x10,%esp
f010ebfc:	85 c0                	test   %eax,%eax
f010ebfe:	74 0f                	je     f010ec0f <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ec00:	ff 45 f4             	incl   -0xc(%ebp)
f010ec03:	a1 a0 80 19 f0       	mov    0xf01980a0,%eax
f010ec08:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ec0b:	7c c9                	jl     f010ebd6 <get_user_program_info_by_env+0xf>
f010ec0d:	eb 01                	jmp    f010ec10 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010ec0f:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010ec10:	a1 a0 80 19 f0       	mov    0xf01980a0,%eax
f010ec15:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ec18:	75 17                	jne    f010ec31 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010ec1a:	83 ec 0c             	sub    $0xc,%esp
f010ec1d:	68 fb 95 13 f0       	push   $0xf01395fb
f010ec22:	e8 26 2f ff ff       	call   f0101b4d <cprintf>
f010ec27:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ec2a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ec2f:	eb 11                	jmp    f010ec42 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010ec31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ec34:	89 d0                	mov    %edx,%eax
f010ec36:	01 c0                	add    %eax,%eax
f010ec38:	01 d0                	add    %edx,%eax
f010ec3a:	c1 e0 02             	shl    $0x2,%eax
f010ec3d:	05 e0 7b 19 f0       	add    $0xf0197be0,%eax
}
f010ec42:	c9                   	leave  
f010ec43:	c3                   	ret    

f010ec44 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010ec44:	55                   	push   %ebp
f010ec45:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010ec47:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec4a:	83 f8 13             	cmp    $0x13,%eax
f010ec4d:	77 0c                	ja     f010ec5b <trapname+0x17>
		return excnames[trapno];
f010ec4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec52:	8b 04 85 80 9a 13 f0 	mov    -0xfec6580(,%eax,4),%eax
f010ec59:	eb 2c                	jmp    f010ec87 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010ec5b:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010ec5f:	75 07                	jne    f010ec68 <trapname+0x24>
		return "System call";
f010ec61:	b8 20 96 13 f0       	mov    $0xf0139620,%eax
f010ec66:	eb 1f                	jmp    f010ec87 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010ec68:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010ec6c:	75 07                	jne    f010ec75 <trapname+0x31>
		return "Clock Interrupt";
f010ec6e:	b8 2c 96 13 f0       	mov    $0xf013962c,%eax
f010ec73:	eb 12                	jmp    f010ec87 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010ec75:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010ec79:	75 07                	jne    f010ec82 <trapname+0x3e>
		return "Keyboard Interrupt";
f010ec7b:	b8 3c 96 13 f0       	mov    $0xf013963c,%eax
f010ec80:	eb 05                	jmp    f010ec87 <trapname+0x43>
	return "(unknown trap)";
f010ec82:	b8 4f 96 13 f0       	mov    $0xf013964f,%eax
}
f010ec87:	5d                   	pop    %ebp
f010ec88:	c3                   	ret    

f010ec89 <ts_init>:


void ts_init(void)
{
f010ec89:	55                   	push   %ebp
f010ec8a:	89 e5                	mov    %esp,%ebp
f010ec8c:	53                   	push   %ebx
f010ec8d:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010ec90:	e8 2d 99 ff ff       	call   f01085c2 <pushcli>

	struct cpu* c = mycpu();
f010ec95:	e8 65 98 ff ff       	call   f01084ff <mycpu>
f010ec9a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010ec9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eca0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010eca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecaa:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010ecb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecb3:	83 c0 0c             	add    $0xc,%eax
f010ecb6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ecb9:	83 c2 0c             	add    $0xc,%edx
f010ecbc:	c1 ea 10             	shr    $0x10,%edx
f010ecbf:	88 d3                	mov    %dl,%bl
f010ecc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ecc4:	83 c2 0c             	add    $0xc,%edx
f010ecc7:	c1 ea 18             	shr    $0x18,%edx
f010ecca:	88 d1                	mov    %dl,%cl
f010eccc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010eccf:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010ecd6:	68 00 
f010ecd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ecdb:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010ece2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ece5:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010eceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecee:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ecf4:	83 e2 f0             	and    $0xfffffff0,%edx
f010ecf7:	83 ca 09             	or     $0x9,%edx
f010ecfa:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ed00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed03:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ed09:	83 ca 10             	or     $0x10,%edx
f010ed0c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ed12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed15:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ed1b:	83 e2 9f             	and    $0xffffff9f,%edx
f010ed1e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ed24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed27:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ed2d:	83 ca 80             	or     $0xffffff80,%edx
f010ed30:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010ed36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed39:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ed3f:	83 e2 f0             	and    $0xfffffff0,%edx
f010ed42:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ed48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed4b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ed51:	83 e2 ef             	and    $0xffffffef,%edx
f010ed54:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ed5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed5d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ed63:	83 e2 df             	and    $0xffffffdf,%edx
f010ed66:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ed6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed6f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ed75:	83 ca 40             	or     $0x40,%edx
f010ed78:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ed7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed81:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ed87:	83 e2 7f             	and    $0x7f,%edx
f010ed8a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ed90:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed93:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010ed99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed9c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010eda2:	83 e2 ef             	and    $0xffffffef,%edx
f010eda5:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010edab:	e8 64 98 ff ff       	call   f0108614 <popcli>
f010edb0:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010edb6:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010edba:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010edbd:	90                   	nop
f010edbe:	83 c4 14             	add    $0x14,%esp
f010edc1:	5b                   	pop    %ebx
f010edc2:	5d                   	pop    %ebp
f010edc3:	c3                   	ret    

f010edc4 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010edc4:	55                   	push   %ebp
f010edc5:	89 e5                	mov    %esp,%ebp
f010edc7:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010edca:	b8 2e 03 11 f0       	mov    $0xf011032e,%eax
f010edcf:	66 a3 40 41 92 f0    	mov    %ax,0xf0924140
f010edd5:	66 c7 05 42 41 92 f0 	movw   $0x8,0xf0924142
f010eddc:	08 00 
f010edde:	a0 44 41 92 f0       	mov    0xf0924144,%al
f010ede3:	83 e0 e0             	and    $0xffffffe0,%eax
f010ede6:	a2 44 41 92 f0       	mov    %al,0xf0924144
f010edeb:	a0 44 41 92 f0       	mov    0xf0924144,%al
f010edf0:	83 e0 1f             	and    $0x1f,%eax
f010edf3:	a2 44 41 92 f0       	mov    %al,0xf0924144
f010edf8:	a0 45 41 92 f0       	mov    0xf0924145,%al
f010edfd:	83 e0 f0             	and    $0xfffffff0,%eax
f010ee00:	83 c8 0e             	or     $0xe,%eax
f010ee03:	a2 45 41 92 f0       	mov    %al,0xf0924145
f010ee08:	a0 45 41 92 f0       	mov    0xf0924145,%al
f010ee0d:	83 e0 ef             	and    $0xffffffef,%eax
f010ee10:	a2 45 41 92 f0       	mov    %al,0xf0924145
f010ee15:	a0 45 41 92 f0       	mov    0xf0924145,%al
f010ee1a:	83 e0 9f             	and    $0xffffff9f,%eax
f010ee1d:	a2 45 41 92 f0       	mov    %al,0xf0924145
f010ee22:	a0 45 41 92 f0       	mov    0xf0924145,%al
f010ee27:	83 c8 80             	or     $0xffffff80,%eax
f010ee2a:	a2 45 41 92 f0       	mov    %al,0xf0924145
f010ee2f:	b8 2e 03 11 f0       	mov    $0xf011032e,%eax
f010ee34:	c1 e8 10             	shr    $0x10,%eax
f010ee37:	66 a3 46 41 92 f0    	mov    %ax,0xf0924146
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010ee3d:	b8 36 03 11 f0       	mov    $0xf0110336,%eax
f010ee42:	66 a3 70 41 92 f0    	mov    %ax,0xf0924170
f010ee48:	66 c7 05 72 41 92 f0 	movw   $0x8,0xf0924172
f010ee4f:	08 00 
f010ee51:	a0 74 41 92 f0       	mov    0xf0924174,%al
f010ee56:	83 e0 e0             	and    $0xffffffe0,%eax
f010ee59:	a2 74 41 92 f0       	mov    %al,0xf0924174
f010ee5e:	a0 74 41 92 f0       	mov    0xf0924174,%al
f010ee63:	83 e0 1f             	and    $0x1f,%eax
f010ee66:	a2 74 41 92 f0       	mov    %al,0xf0924174
f010ee6b:	a0 75 41 92 f0       	mov    0xf0924175,%al
f010ee70:	83 e0 f0             	and    $0xfffffff0,%eax
f010ee73:	83 c8 0e             	or     $0xe,%eax
f010ee76:	a2 75 41 92 f0       	mov    %al,0xf0924175
f010ee7b:	a0 75 41 92 f0       	mov    0xf0924175,%al
f010ee80:	83 e0 ef             	and    $0xffffffef,%eax
f010ee83:	a2 75 41 92 f0       	mov    %al,0xf0924175
f010ee88:	a0 75 41 92 f0       	mov    0xf0924175,%al
f010ee8d:	83 e0 9f             	and    $0xffffff9f,%eax
f010ee90:	a2 75 41 92 f0       	mov    %al,0xf0924175
f010ee95:	a0 75 41 92 f0       	mov    0xf0924175,%al
f010ee9a:	83 c8 80             	or     $0xffffff80,%eax
f010ee9d:	a2 75 41 92 f0       	mov    %al,0xf0924175
f010eea2:	b8 36 03 11 f0       	mov    $0xf0110336,%eax
f010eea7:	c1 e8 10             	shr    $0x10,%eax
f010eeaa:	66 a3 76 41 92 f0    	mov    %ax,0xf0924176
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010eeb0:	b8 3e 03 11 f0       	mov    $0xf011033e,%eax
f010eeb5:	66 a3 00 42 92 f0    	mov    %ax,0xf0924200
f010eebb:	66 c7 05 02 42 92 f0 	movw   $0x8,0xf0924202
f010eec2:	08 00 
f010eec4:	a0 04 42 92 f0       	mov    0xf0924204,%al
f010eec9:	83 e0 e0             	and    $0xffffffe0,%eax
f010eecc:	a2 04 42 92 f0       	mov    %al,0xf0924204
f010eed1:	a0 04 42 92 f0       	mov    0xf0924204,%al
f010eed6:	83 e0 1f             	and    $0x1f,%eax
f010eed9:	a2 04 42 92 f0       	mov    %al,0xf0924204
f010eede:	a0 05 42 92 f0       	mov    0xf0924205,%al
f010eee3:	83 e0 f0             	and    $0xfffffff0,%eax
f010eee6:	83 c8 0e             	or     $0xe,%eax
f010eee9:	a2 05 42 92 f0       	mov    %al,0xf0924205
f010eeee:	a0 05 42 92 f0       	mov    0xf0924205,%al
f010eef3:	83 e0 ef             	and    $0xffffffef,%eax
f010eef6:	a2 05 42 92 f0       	mov    %al,0xf0924205
f010eefb:	a0 05 42 92 f0       	mov    0xf0924205,%al
f010ef00:	83 c8 60             	or     $0x60,%eax
f010ef03:	a2 05 42 92 f0       	mov    %al,0xf0924205
f010ef08:	a0 05 42 92 f0       	mov    0xf0924205,%al
f010ef0d:	83 c8 80             	or     $0xffffff80,%eax
f010ef10:	a2 05 42 92 f0       	mov    %al,0xf0924205
f010ef15:	b8 3e 03 11 f0       	mov    $0xf011033e,%eax
f010ef1a:	c1 e8 10             	shr    $0x10,%eax
f010ef1d:	66 a3 06 42 92 f0    	mov    %ax,0xf0924206
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010ef23:	b8 48 03 11 f0       	mov    $0xf0110348,%eax
f010ef28:	66 a3 08 42 92 f0    	mov    %ax,0xf0924208
f010ef2e:	66 c7 05 0a 42 92 f0 	movw   $0x8,0xf092420a
f010ef35:	08 00 
f010ef37:	a0 0c 42 92 f0       	mov    0xf092420c,%al
f010ef3c:	83 e0 e0             	and    $0xffffffe0,%eax
f010ef3f:	a2 0c 42 92 f0       	mov    %al,0xf092420c
f010ef44:	a0 0c 42 92 f0       	mov    0xf092420c,%al
f010ef49:	83 e0 1f             	and    $0x1f,%eax
f010ef4c:	a2 0c 42 92 f0       	mov    %al,0xf092420c
f010ef51:	a0 0d 42 92 f0       	mov    0xf092420d,%al
f010ef56:	83 e0 f0             	and    $0xfffffff0,%eax
f010ef59:	83 c8 0e             	or     $0xe,%eax
f010ef5c:	a2 0d 42 92 f0       	mov    %al,0xf092420d
f010ef61:	a0 0d 42 92 f0       	mov    0xf092420d,%al
f010ef66:	83 e0 ef             	and    $0xffffffef,%eax
f010ef69:	a2 0d 42 92 f0       	mov    %al,0xf092420d
f010ef6e:	a0 0d 42 92 f0       	mov    0xf092420d,%al
f010ef73:	83 c8 60             	or     $0x60,%eax
f010ef76:	a2 0d 42 92 f0       	mov    %al,0xf092420d
f010ef7b:	a0 0d 42 92 f0       	mov    0xf092420d,%al
f010ef80:	83 c8 80             	or     $0xffffff80,%eax
f010ef83:	a2 0d 42 92 f0       	mov    %al,0xf092420d
f010ef88:	b8 48 03 11 f0       	mov    $0xf0110348,%eax
f010ef8d:	c1 e8 10             	shr    $0x10,%eax
f010ef90:	66 a3 0e 42 92 f0    	mov    %ax,0xf092420e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010ef96:	b8 52 03 11 f0       	mov    $0xf0110352,%eax
f010ef9b:	66 a3 80 42 92 f0    	mov    %ax,0xf0924280
f010efa1:	66 c7 05 82 42 92 f0 	movw   $0x8,0xf0924282
f010efa8:	08 00 
f010efaa:	a0 84 42 92 f0       	mov    0xf0924284,%al
f010efaf:	83 e0 e0             	and    $0xffffffe0,%eax
f010efb2:	a2 84 42 92 f0       	mov    %al,0xf0924284
f010efb7:	a0 84 42 92 f0       	mov    0xf0924284,%al
f010efbc:	83 e0 1f             	and    $0x1f,%eax
f010efbf:	a2 84 42 92 f0       	mov    %al,0xf0924284
f010efc4:	a0 85 42 92 f0       	mov    0xf0924285,%al
f010efc9:	83 e0 f0             	and    $0xfffffff0,%eax
f010efcc:	83 c8 0e             	or     $0xe,%eax
f010efcf:	a2 85 42 92 f0       	mov    %al,0xf0924285
f010efd4:	a0 85 42 92 f0       	mov    0xf0924285,%al
f010efd9:	83 e0 ef             	and    $0xffffffef,%eax
f010efdc:	a2 85 42 92 f0       	mov    %al,0xf0924285
f010efe1:	a0 85 42 92 f0       	mov    0xf0924285,%al
f010efe6:	83 c8 60             	or     $0x60,%eax
f010efe9:	a2 85 42 92 f0       	mov    %al,0xf0924285
f010efee:	a0 85 42 92 f0       	mov    0xf0924285,%al
f010eff3:	83 c8 80             	or     $0xffffff80,%eax
f010eff6:	a2 85 42 92 f0       	mov    %al,0xf0924285
f010effb:	b8 52 03 11 f0       	mov    $0xf0110352,%eax
f010f000:	c1 e8 10             	shr    $0x10,%eax
f010f003:	66 a3 86 42 92 f0    	mov    %ax,0xf0924286

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010f009:	b8 5c 03 11 f0       	mov    $0xf011035c,%eax
f010f00e:	66 a3 00 41 92 f0    	mov    %ax,0xf0924100
f010f014:	66 c7 05 02 41 92 f0 	movw   $0x8,0xf0924102
f010f01b:	08 00 
f010f01d:	a0 04 41 92 f0       	mov    0xf0924104,%al
f010f022:	83 e0 e0             	and    $0xffffffe0,%eax
f010f025:	a2 04 41 92 f0       	mov    %al,0xf0924104
f010f02a:	a0 04 41 92 f0       	mov    0xf0924104,%al
f010f02f:	83 e0 1f             	and    $0x1f,%eax
f010f032:	a2 04 41 92 f0       	mov    %al,0xf0924104
f010f037:	a0 05 41 92 f0       	mov    0xf0924105,%al
f010f03c:	83 e0 f0             	and    $0xfffffff0,%eax
f010f03f:	83 c8 0e             	or     $0xe,%eax
f010f042:	a2 05 41 92 f0       	mov    %al,0xf0924105
f010f047:	a0 05 41 92 f0       	mov    0xf0924105,%al
f010f04c:	83 e0 ef             	and    $0xffffffef,%eax
f010f04f:	a2 05 41 92 f0       	mov    %al,0xf0924105
f010f054:	a0 05 41 92 f0       	mov    0xf0924105,%al
f010f059:	83 c8 60             	or     $0x60,%eax
f010f05c:	a2 05 41 92 f0       	mov    %al,0xf0924105
f010f061:	a0 05 41 92 f0       	mov    0xf0924105,%al
f010f066:	83 c8 80             	or     $0xffffff80,%eax
f010f069:	a2 05 41 92 f0       	mov    %al,0xf0924105
f010f06e:	b8 5c 03 11 f0       	mov    $0xf011035c,%eax
f010f073:	c1 e8 10             	shr    $0x10,%eax
f010f076:	66 a3 06 41 92 f0    	mov    %ax,0xf0924106
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010f07c:	b8 66 03 11 f0       	mov    $0xf0110366,%eax
f010f081:	66 a3 08 41 92 f0    	mov    %ax,0xf0924108
f010f087:	66 c7 05 0a 41 92 f0 	movw   $0x8,0xf092410a
f010f08e:	08 00 
f010f090:	a0 0c 41 92 f0       	mov    0xf092410c,%al
f010f095:	83 e0 e0             	and    $0xffffffe0,%eax
f010f098:	a2 0c 41 92 f0       	mov    %al,0xf092410c
f010f09d:	a0 0c 41 92 f0       	mov    0xf092410c,%al
f010f0a2:	83 e0 1f             	and    $0x1f,%eax
f010f0a5:	a2 0c 41 92 f0       	mov    %al,0xf092410c
f010f0aa:	a0 0d 41 92 f0       	mov    0xf092410d,%al
f010f0af:	83 c8 0f             	or     $0xf,%eax
f010f0b2:	a2 0d 41 92 f0       	mov    %al,0xf092410d
f010f0b7:	a0 0d 41 92 f0       	mov    0xf092410d,%al
f010f0bc:	83 e0 ef             	and    $0xffffffef,%eax
f010f0bf:	a2 0d 41 92 f0       	mov    %al,0xf092410d
f010f0c4:	a0 0d 41 92 f0       	mov    0xf092410d,%al
f010f0c9:	83 c8 60             	or     $0x60,%eax
f010f0cc:	a2 0d 41 92 f0       	mov    %al,0xf092410d
f010f0d1:	a0 0d 41 92 f0       	mov    0xf092410d,%al
f010f0d6:	83 c8 80             	or     $0xffffff80,%eax
f010f0d9:	a2 0d 41 92 f0       	mov    %al,0xf092410d
f010f0de:	b8 66 03 11 f0       	mov    $0xf0110366,%eax
f010f0e3:	c1 e8 10             	shr    $0x10,%eax
f010f0e6:	66 a3 0e 41 92 f0    	mov    %ax,0xf092410e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010f0ec:	b8 70 03 11 f0       	mov    $0xf0110370,%eax
f010f0f1:	66 a3 10 41 92 f0    	mov    %ax,0xf0924110
f010f0f7:	66 c7 05 12 41 92 f0 	movw   $0x8,0xf0924112
f010f0fe:	08 00 
f010f100:	a0 14 41 92 f0       	mov    0xf0924114,%al
f010f105:	83 e0 e0             	and    $0xffffffe0,%eax
f010f108:	a2 14 41 92 f0       	mov    %al,0xf0924114
f010f10d:	a0 14 41 92 f0       	mov    0xf0924114,%al
f010f112:	83 e0 1f             	and    $0x1f,%eax
f010f115:	a2 14 41 92 f0       	mov    %al,0xf0924114
f010f11a:	a0 15 41 92 f0       	mov    0xf0924115,%al
f010f11f:	83 e0 f0             	and    $0xfffffff0,%eax
f010f122:	83 c8 0e             	or     $0xe,%eax
f010f125:	a2 15 41 92 f0       	mov    %al,0xf0924115
f010f12a:	a0 15 41 92 f0       	mov    0xf0924115,%al
f010f12f:	83 e0 ef             	and    $0xffffffef,%eax
f010f132:	a2 15 41 92 f0       	mov    %al,0xf0924115
f010f137:	a0 15 41 92 f0       	mov    0xf0924115,%al
f010f13c:	83 c8 60             	or     $0x60,%eax
f010f13f:	a2 15 41 92 f0       	mov    %al,0xf0924115
f010f144:	a0 15 41 92 f0       	mov    0xf0924115,%al
f010f149:	83 c8 80             	or     $0xffffff80,%eax
f010f14c:	a2 15 41 92 f0       	mov    %al,0xf0924115
f010f151:	b8 70 03 11 f0       	mov    $0xf0110370,%eax
f010f156:	c1 e8 10             	shr    $0x10,%eax
f010f159:	66 a3 16 41 92 f0    	mov    %ax,0xf0924116
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010f15f:	b8 7a 03 11 f0       	mov    $0xf011037a,%eax
f010f164:	66 a3 18 41 92 f0    	mov    %ax,0xf0924118
f010f16a:	66 c7 05 1a 41 92 f0 	movw   $0x8,0xf092411a
f010f171:	08 00 
f010f173:	a0 1c 41 92 f0       	mov    0xf092411c,%al
f010f178:	83 e0 e0             	and    $0xffffffe0,%eax
f010f17b:	a2 1c 41 92 f0       	mov    %al,0xf092411c
f010f180:	a0 1c 41 92 f0       	mov    0xf092411c,%al
f010f185:	83 e0 1f             	and    $0x1f,%eax
f010f188:	a2 1c 41 92 f0       	mov    %al,0xf092411c
f010f18d:	a0 1d 41 92 f0       	mov    0xf092411d,%al
f010f192:	83 c8 0f             	or     $0xf,%eax
f010f195:	a2 1d 41 92 f0       	mov    %al,0xf092411d
f010f19a:	a0 1d 41 92 f0       	mov    0xf092411d,%al
f010f19f:	83 e0 ef             	and    $0xffffffef,%eax
f010f1a2:	a2 1d 41 92 f0       	mov    %al,0xf092411d
f010f1a7:	a0 1d 41 92 f0       	mov    0xf092411d,%al
f010f1ac:	83 c8 60             	or     $0x60,%eax
f010f1af:	a2 1d 41 92 f0       	mov    %al,0xf092411d
f010f1b4:	a0 1d 41 92 f0       	mov    0xf092411d,%al
f010f1b9:	83 c8 80             	or     $0xffffff80,%eax
f010f1bc:	a2 1d 41 92 f0       	mov    %al,0xf092411d
f010f1c1:	b8 7a 03 11 f0       	mov    $0xf011037a,%eax
f010f1c6:	c1 e8 10             	shr    $0x10,%eax
f010f1c9:	66 a3 1e 41 92 f0    	mov    %ax,0xf092411e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010f1cf:	b8 84 03 11 f0       	mov    $0xf0110384,%eax
f010f1d4:	66 a3 20 41 92 f0    	mov    %ax,0xf0924120
f010f1da:	66 c7 05 22 41 92 f0 	movw   $0x8,0xf0924122
f010f1e1:	08 00 
f010f1e3:	a0 24 41 92 f0       	mov    0xf0924124,%al
f010f1e8:	83 e0 e0             	and    $0xffffffe0,%eax
f010f1eb:	a2 24 41 92 f0       	mov    %al,0xf0924124
f010f1f0:	a0 24 41 92 f0       	mov    0xf0924124,%al
f010f1f5:	83 e0 1f             	and    $0x1f,%eax
f010f1f8:	a2 24 41 92 f0       	mov    %al,0xf0924124
f010f1fd:	a0 25 41 92 f0       	mov    0xf0924125,%al
f010f202:	83 c8 0f             	or     $0xf,%eax
f010f205:	a2 25 41 92 f0       	mov    %al,0xf0924125
f010f20a:	a0 25 41 92 f0       	mov    0xf0924125,%al
f010f20f:	83 e0 ef             	and    $0xffffffef,%eax
f010f212:	a2 25 41 92 f0       	mov    %al,0xf0924125
f010f217:	a0 25 41 92 f0       	mov    0xf0924125,%al
f010f21c:	83 c8 60             	or     $0x60,%eax
f010f21f:	a2 25 41 92 f0       	mov    %al,0xf0924125
f010f224:	a0 25 41 92 f0       	mov    0xf0924125,%al
f010f229:	83 c8 80             	or     $0xffffff80,%eax
f010f22c:	a2 25 41 92 f0       	mov    %al,0xf0924125
f010f231:	b8 84 03 11 f0       	mov    $0xf0110384,%eax
f010f236:	c1 e8 10             	shr    $0x10,%eax
f010f239:	66 a3 26 41 92 f0    	mov    %ax,0xf0924126
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010f23f:	b8 8e 03 11 f0       	mov    $0xf011038e,%eax
f010f244:	66 a3 28 41 92 f0    	mov    %ax,0xf0924128
f010f24a:	66 c7 05 2a 41 92 f0 	movw   $0x8,0xf092412a
f010f251:	08 00 
f010f253:	a0 2c 41 92 f0       	mov    0xf092412c,%al
f010f258:	83 e0 e0             	and    $0xffffffe0,%eax
f010f25b:	a2 2c 41 92 f0       	mov    %al,0xf092412c
f010f260:	a0 2c 41 92 f0       	mov    0xf092412c,%al
f010f265:	83 e0 1f             	and    $0x1f,%eax
f010f268:	a2 2c 41 92 f0       	mov    %al,0xf092412c
f010f26d:	a0 2d 41 92 f0       	mov    0xf092412d,%al
f010f272:	83 e0 f0             	and    $0xfffffff0,%eax
f010f275:	83 c8 0e             	or     $0xe,%eax
f010f278:	a2 2d 41 92 f0       	mov    %al,0xf092412d
f010f27d:	a0 2d 41 92 f0       	mov    0xf092412d,%al
f010f282:	83 e0 ef             	and    $0xffffffef,%eax
f010f285:	a2 2d 41 92 f0       	mov    %al,0xf092412d
f010f28a:	a0 2d 41 92 f0       	mov    0xf092412d,%al
f010f28f:	83 c8 60             	or     $0x60,%eax
f010f292:	a2 2d 41 92 f0       	mov    %al,0xf092412d
f010f297:	a0 2d 41 92 f0       	mov    0xf092412d,%al
f010f29c:	83 c8 80             	or     $0xffffff80,%eax
f010f29f:	a2 2d 41 92 f0       	mov    %al,0xf092412d
f010f2a4:	b8 8e 03 11 f0       	mov    $0xf011038e,%eax
f010f2a9:	c1 e8 10             	shr    $0x10,%eax
f010f2ac:	66 a3 2e 41 92 f0    	mov    %ax,0xf092412e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010f2b2:	b8 98 03 11 f0       	mov    $0xf0110398,%eax
f010f2b7:	66 a3 30 41 92 f0    	mov    %ax,0xf0924130
f010f2bd:	66 c7 05 32 41 92 f0 	movw   $0x8,0xf0924132
f010f2c4:	08 00 
f010f2c6:	a0 34 41 92 f0       	mov    0xf0924134,%al
f010f2cb:	83 e0 e0             	and    $0xffffffe0,%eax
f010f2ce:	a2 34 41 92 f0       	mov    %al,0xf0924134
f010f2d3:	a0 34 41 92 f0       	mov    0xf0924134,%al
f010f2d8:	83 e0 1f             	and    $0x1f,%eax
f010f2db:	a2 34 41 92 f0       	mov    %al,0xf0924134
f010f2e0:	a0 35 41 92 f0       	mov    0xf0924135,%al
f010f2e5:	83 e0 f0             	and    $0xfffffff0,%eax
f010f2e8:	83 c8 0e             	or     $0xe,%eax
f010f2eb:	a2 35 41 92 f0       	mov    %al,0xf0924135
f010f2f0:	a0 35 41 92 f0       	mov    0xf0924135,%al
f010f2f5:	83 e0 ef             	and    $0xffffffef,%eax
f010f2f8:	a2 35 41 92 f0       	mov    %al,0xf0924135
f010f2fd:	a0 35 41 92 f0       	mov    0xf0924135,%al
f010f302:	83 c8 60             	or     $0x60,%eax
f010f305:	a2 35 41 92 f0       	mov    %al,0xf0924135
f010f30a:	a0 35 41 92 f0       	mov    0xf0924135,%al
f010f30f:	83 c8 80             	or     $0xffffff80,%eax
f010f312:	a2 35 41 92 f0       	mov    %al,0xf0924135
f010f317:	b8 98 03 11 f0       	mov    $0xf0110398,%eax
f010f31c:	c1 e8 10             	shr    $0x10,%eax
f010f31f:	66 a3 36 41 92 f0    	mov    %ax,0xf0924136
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010f325:	b8 a2 03 11 f0       	mov    $0xf01103a2,%eax
f010f32a:	66 a3 38 41 92 f0    	mov    %ax,0xf0924138
f010f330:	66 c7 05 3a 41 92 f0 	movw   $0x8,0xf092413a
f010f337:	08 00 
f010f339:	a0 3c 41 92 f0       	mov    0xf092413c,%al
f010f33e:	83 e0 e0             	and    $0xffffffe0,%eax
f010f341:	a2 3c 41 92 f0       	mov    %al,0xf092413c
f010f346:	a0 3c 41 92 f0       	mov    0xf092413c,%al
f010f34b:	83 e0 1f             	and    $0x1f,%eax
f010f34e:	a2 3c 41 92 f0       	mov    %al,0xf092413c
f010f353:	a0 3d 41 92 f0       	mov    0xf092413d,%al
f010f358:	83 e0 f0             	and    $0xfffffff0,%eax
f010f35b:	83 c8 0e             	or     $0xe,%eax
f010f35e:	a2 3d 41 92 f0       	mov    %al,0xf092413d
f010f363:	a0 3d 41 92 f0       	mov    0xf092413d,%al
f010f368:	83 e0 ef             	and    $0xffffffef,%eax
f010f36b:	a2 3d 41 92 f0       	mov    %al,0xf092413d
f010f370:	a0 3d 41 92 f0       	mov    0xf092413d,%al
f010f375:	83 c8 60             	or     $0x60,%eax
f010f378:	a2 3d 41 92 f0       	mov    %al,0xf092413d
f010f37d:	a0 3d 41 92 f0       	mov    0xf092413d,%al
f010f382:	83 c8 80             	or     $0xffffff80,%eax
f010f385:	a2 3d 41 92 f0       	mov    %al,0xf092413d
f010f38a:	b8 a2 03 11 f0       	mov    $0xf01103a2,%eax
f010f38f:	c1 e8 10             	shr    $0x10,%eax
f010f392:	66 a3 3e 41 92 f0    	mov    %ax,0xf092413e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010f398:	b8 a8 03 11 f0       	mov    $0xf01103a8,%eax
f010f39d:	66 a3 50 41 92 f0    	mov    %ax,0xf0924150
f010f3a3:	66 c7 05 52 41 92 f0 	movw   $0x8,0xf0924152
f010f3aa:	08 00 
f010f3ac:	a0 54 41 92 f0       	mov    0xf0924154,%al
f010f3b1:	83 e0 e0             	and    $0xffffffe0,%eax
f010f3b4:	a2 54 41 92 f0       	mov    %al,0xf0924154
f010f3b9:	a0 54 41 92 f0       	mov    0xf0924154,%al
f010f3be:	83 e0 1f             	and    $0x1f,%eax
f010f3c1:	a2 54 41 92 f0       	mov    %al,0xf0924154
f010f3c6:	a0 55 41 92 f0       	mov    0xf0924155,%al
f010f3cb:	83 e0 f0             	and    $0xfffffff0,%eax
f010f3ce:	83 c8 0e             	or     $0xe,%eax
f010f3d1:	a2 55 41 92 f0       	mov    %al,0xf0924155
f010f3d6:	a0 55 41 92 f0       	mov    0xf0924155,%al
f010f3db:	83 e0 ef             	and    $0xffffffef,%eax
f010f3de:	a2 55 41 92 f0       	mov    %al,0xf0924155
f010f3e3:	a0 55 41 92 f0       	mov    0xf0924155,%al
f010f3e8:	83 c8 60             	or     $0x60,%eax
f010f3eb:	a2 55 41 92 f0       	mov    %al,0xf0924155
f010f3f0:	a0 55 41 92 f0       	mov    0xf0924155,%al
f010f3f5:	83 c8 80             	or     $0xffffff80,%eax
f010f3f8:	a2 55 41 92 f0       	mov    %al,0xf0924155
f010f3fd:	b8 a8 03 11 f0       	mov    $0xf01103a8,%eax
f010f402:	c1 e8 10             	shr    $0x10,%eax
f010f405:	66 a3 56 41 92 f0    	mov    %ax,0xf0924156
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010f40b:	b8 ac 03 11 f0       	mov    $0xf01103ac,%eax
f010f410:	66 a3 58 41 92 f0    	mov    %ax,0xf0924158
f010f416:	66 c7 05 5a 41 92 f0 	movw   $0x8,0xf092415a
f010f41d:	08 00 
f010f41f:	a0 5c 41 92 f0       	mov    0xf092415c,%al
f010f424:	83 e0 e0             	and    $0xffffffe0,%eax
f010f427:	a2 5c 41 92 f0       	mov    %al,0xf092415c
f010f42c:	a0 5c 41 92 f0       	mov    0xf092415c,%al
f010f431:	83 e0 1f             	and    $0x1f,%eax
f010f434:	a2 5c 41 92 f0       	mov    %al,0xf092415c
f010f439:	a0 5d 41 92 f0       	mov    0xf092415d,%al
f010f43e:	83 e0 f0             	and    $0xfffffff0,%eax
f010f441:	83 c8 0e             	or     $0xe,%eax
f010f444:	a2 5d 41 92 f0       	mov    %al,0xf092415d
f010f449:	a0 5d 41 92 f0       	mov    0xf092415d,%al
f010f44e:	83 e0 ef             	and    $0xffffffef,%eax
f010f451:	a2 5d 41 92 f0       	mov    %al,0xf092415d
f010f456:	a0 5d 41 92 f0       	mov    0xf092415d,%al
f010f45b:	83 c8 60             	or     $0x60,%eax
f010f45e:	a2 5d 41 92 f0       	mov    %al,0xf092415d
f010f463:	a0 5d 41 92 f0       	mov    0xf092415d,%al
f010f468:	83 c8 80             	or     $0xffffff80,%eax
f010f46b:	a2 5d 41 92 f0       	mov    %al,0xf092415d
f010f470:	b8 ac 03 11 f0       	mov    $0xf01103ac,%eax
f010f475:	c1 e8 10             	shr    $0x10,%eax
f010f478:	66 a3 5e 41 92 f0    	mov    %ax,0xf092415e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010f47e:	b8 b0 03 11 f0       	mov    $0xf01103b0,%eax
f010f483:	66 a3 60 41 92 f0    	mov    %ax,0xf0924160
f010f489:	66 c7 05 62 41 92 f0 	movw   $0x8,0xf0924162
f010f490:	08 00 
f010f492:	a0 64 41 92 f0       	mov    0xf0924164,%al
f010f497:	83 e0 e0             	and    $0xffffffe0,%eax
f010f49a:	a2 64 41 92 f0       	mov    %al,0xf0924164
f010f49f:	a0 64 41 92 f0       	mov    0xf0924164,%al
f010f4a4:	83 e0 1f             	and    $0x1f,%eax
f010f4a7:	a2 64 41 92 f0       	mov    %al,0xf0924164
f010f4ac:	a0 65 41 92 f0       	mov    0xf0924165,%al
f010f4b1:	83 e0 f0             	and    $0xfffffff0,%eax
f010f4b4:	83 c8 0e             	or     $0xe,%eax
f010f4b7:	a2 65 41 92 f0       	mov    %al,0xf0924165
f010f4bc:	a0 65 41 92 f0       	mov    0xf0924165,%al
f010f4c1:	83 e0 ef             	and    $0xffffffef,%eax
f010f4c4:	a2 65 41 92 f0       	mov    %al,0xf0924165
f010f4c9:	a0 65 41 92 f0       	mov    0xf0924165,%al
f010f4ce:	83 c8 60             	or     $0x60,%eax
f010f4d1:	a2 65 41 92 f0       	mov    %al,0xf0924165
f010f4d6:	a0 65 41 92 f0       	mov    0xf0924165,%al
f010f4db:	83 c8 80             	or     $0xffffff80,%eax
f010f4de:	a2 65 41 92 f0       	mov    %al,0xf0924165
f010f4e3:	b8 b0 03 11 f0       	mov    $0xf01103b0,%eax
f010f4e8:	c1 e8 10             	shr    $0x10,%eax
f010f4eb:	66 a3 66 41 92 f0    	mov    %ax,0xf0924166
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010f4f1:	b8 b4 03 11 f0       	mov    $0xf01103b4,%eax
f010f4f6:	66 a3 68 41 92 f0    	mov    %ax,0xf0924168
f010f4fc:	66 c7 05 6a 41 92 f0 	movw   $0x8,0xf092416a
f010f503:	08 00 
f010f505:	a0 6c 41 92 f0       	mov    0xf092416c,%al
f010f50a:	83 e0 e0             	and    $0xffffffe0,%eax
f010f50d:	a2 6c 41 92 f0       	mov    %al,0xf092416c
f010f512:	a0 6c 41 92 f0       	mov    0xf092416c,%al
f010f517:	83 e0 1f             	and    $0x1f,%eax
f010f51a:	a2 6c 41 92 f0       	mov    %al,0xf092416c
f010f51f:	a0 6d 41 92 f0       	mov    0xf092416d,%al
f010f524:	83 e0 f0             	and    $0xfffffff0,%eax
f010f527:	83 c8 0e             	or     $0xe,%eax
f010f52a:	a2 6d 41 92 f0       	mov    %al,0xf092416d
f010f52f:	a0 6d 41 92 f0       	mov    0xf092416d,%al
f010f534:	83 e0 ef             	and    $0xffffffef,%eax
f010f537:	a2 6d 41 92 f0       	mov    %al,0xf092416d
f010f53c:	a0 6d 41 92 f0       	mov    0xf092416d,%al
f010f541:	83 c8 60             	or     $0x60,%eax
f010f544:	a2 6d 41 92 f0       	mov    %al,0xf092416d
f010f549:	a0 6d 41 92 f0       	mov    0xf092416d,%al
f010f54e:	83 c8 80             	or     $0xffffff80,%eax
f010f551:	a2 6d 41 92 f0       	mov    %al,0xf092416d
f010f556:	b8 b4 03 11 f0       	mov    $0xf01103b4,%eax
f010f55b:	c1 e8 10             	shr    $0x10,%eax
f010f55e:	66 a3 6e 41 92 f0    	mov    %ax,0xf092416e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010f564:	b8 b8 03 11 f0       	mov    $0xf01103b8,%eax
f010f569:	66 a3 80 41 92 f0    	mov    %ax,0xf0924180
f010f56f:	66 c7 05 82 41 92 f0 	movw   $0x8,0xf0924182
f010f576:	08 00 
f010f578:	a0 84 41 92 f0       	mov    0xf0924184,%al
f010f57d:	83 e0 e0             	and    $0xffffffe0,%eax
f010f580:	a2 84 41 92 f0       	mov    %al,0xf0924184
f010f585:	a0 84 41 92 f0       	mov    0xf0924184,%al
f010f58a:	83 e0 1f             	and    $0x1f,%eax
f010f58d:	a2 84 41 92 f0       	mov    %al,0xf0924184
f010f592:	a0 85 41 92 f0       	mov    0xf0924185,%al
f010f597:	83 e0 f0             	and    $0xfffffff0,%eax
f010f59a:	83 c8 0e             	or     $0xe,%eax
f010f59d:	a2 85 41 92 f0       	mov    %al,0xf0924185
f010f5a2:	a0 85 41 92 f0       	mov    0xf0924185,%al
f010f5a7:	83 e0 ef             	and    $0xffffffef,%eax
f010f5aa:	a2 85 41 92 f0       	mov    %al,0xf0924185
f010f5af:	a0 85 41 92 f0       	mov    0xf0924185,%al
f010f5b4:	83 c8 60             	or     $0x60,%eax
f010f5b7:	a2 85 41 92 f0       	mov    %al,0xf0924185
f010f5bc:	a0 85 41 92 f0       	mov    0xf0924185,%al
f010f5c1:	83 c8 80             	or     $0xffffff80,%eax
f010f5c4:	a2 85 41 92 f0       	mov    %al,0xf0924185
f010f5c9:	b8 b8 03 11 f0       	mov    $0xf01103b8,%eax
f010f5ce:	c1 e8 10             	shr    $0x10,%eax
f010f5d1:	66 a3 86 41 92 f0    	mov    %ax,0xf0924186
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010f5d7:	b8 be 03 11 f0       	mov    $0xf01103be,%eax
f010f5dc:	66 a3 88 41 92 f0    	mov    %ax,0xf0924188
f010f5e2:	66 c7 05 8a 41 92 f0 	movw   $0x8,0xf092418a
f010f5e9:	08 00 
f010f5eb:	a0 8c 41 92 f0       	mov    0xf092418c,%al
f010f5f0:	83 e0 e0             	and    $0xffffffe0,%eax
f010f5f3:	a2 8c 41 92 f0       	mov    %al,0xf092418c
f010f5f8:	a0 8c 41 92 f0       	mov    0xf092418c,%al
f010f5fd:	83 e0 1f             	and    $0x1f,%eax
f010f600:	a2 8c 41 92 f0       	mov    %al,0xf092418c
f010f605:	a0 8d 41 92 f0       	mov    0xf092418d,%al
f010f60a:	83 e0 f0             	and    $0xfffffff0,%eax
f010f60d:	83 c8 0e             	or     $0xe,%eax
f010f610:	a2 8d 41 92 f0       	mov    %al,0xf092418d
f010f615:	a0 8d 41 92 f0       	mov    0xf092418d,%al
f010f61a:	83 e0 ef             	and    $0xffffffef,%eax
f010f61d:	a2 8d 41 92 f0       	mov    %al,0xf092418d
f010f622:	a0 8d 41 92 f0       	mov    0xf092418d,%al
f010f627:	83 c8 60             	or     $0x60,%eax
f010f62a:	a2 8d 41 92 f0       	mov    %al,0xf092418d
f010f62f:	a0 8d 41 92 f0       	mov    0xf092418d,%al
f010f634:	83 c8 80             	or     $0xffffff80,%eax
f010f637:	a2 8d 41 92 f0       	mov    %al,0xf092418d
f010f63c:	b8 be 03 11 f0       	mov    $0xf01103be,%eax
f010f641:	c1 e8 10             	shr    $0x10,%eax
f010f644:	66 a3 8e 41 92 f0    	mov    %ax,0xf092418e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010f64a:	b8 c2 03 11 f0       	mov    $0xf01103c2,%eax
f010f64f:	66 a3 90 41 92 f0    	mov    %ax,0xf0924190
f010f655:	66 c7 05 92 41 92 f0 	movw   $0x8,0xf0924192
f010f65c:	08 00 
f010f65e:	a0 94 41 92 f0       	mov    0xf0924194,%al
f010f663:	83 e0 e0             	and    $0xffffffe0,%eax
f010f666:	a2 94 41 92 f0       	mov    %al,0xf0924194
f010f66b:	a0 94 41 92 f0       	mov    0xf0924194,%al
f010f670:	83 e0 1f             	and    $0x1f,%eax
f010f673:	a2 94 41 92 f0       	mov    %al,0xf0924194
f010f678:	a0 95 41 92 f0       	mov    0xf0924195,%al
f010f67d:	83 e0 f0             	and    $0xfffffff0,%eax
f010f680:	83 c8 0e             	or     $0xe,%eax
f010f683:	a2 95 41 92 f0       	mov    %al,0xf0924195
f010f688:	a0 95 41 92 f0       	mov    0xf0924195,%al
f010f68d:	83 e0 ef             	and    $0xffffffef,%eax
f010f690:	a2 95 41 92 f0       	mov    %al,0xf0924195
f010f695:	a0 95 41 92 f0       	mov    0xf0924195,%al
f010f69a:	83 c8 60             	or     $0x60,%eax
f010f69d:	a2 95 41 92 f0       	mov    %al,0xf0924195
f010f6a2:	a0 95 41 92 f0       	mov    0xf0924195,%al
f010f6a7:	83 c8 80             	or     $0xffffff80,%eax
f010f6aa:	a2 95 41 92 f0       	mov    %al,0xf0924195
f010f6af:	b8 c2 03 11 f0       	mov    $0xf01103c2,%eax
f010f6b4:	c1 e8 10             	shr    $0x10,%eax
f010f6b7:	66 a3 96 41 92 f0    	mov    %ax,0xf0924196
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010f6bd:	b8 c8 03 11 f0       	mov    $0xf01103c8,%eax
f010f6c2:	66 a3 98 41 92 f0    	mov    %ax,0xf0924198
f010f6c8:	66 c7 05 9a 41 92 f0 	movw   $0x8,0xf092419a
f010f6cf:	08 00 
f010f6d1:	a0 9c 41 92 f0       	mov    0xf092419c,%al
f010f6d6:	83 e0 e0             	and    $0xffffffe0,%eax
f010f6d9:	a2 9c 41 92 f0       	mov    %al,0xf092419c
f010f6de:	a0 9c 41 92 f0       	mov    0xf092419c,%al
f010f6e3:	83 e0 1f             	and    $0x1f,%eax
f010f6e6:	a2 9c 41 92 f0       	mov    %al,0xf092419c
f010f6eb:	a0 9d 41 92 f0       	mov    0xf092419d,%al
f010f6f0:	83 e0 f0             	and    $0xfffffff0,%eax
f010f6f3:	83 c8 0e             	or     $0xe,%eax
f010f6f6:	a2 9d 41 92 f0       	mov    %al,0xf092419d
f010f6fb:	a0 9d 41 92 f0       	mov    0xf092419d,%al
f010f700:	83 e0 ef             	and    $0xffffffef,%eax
f010f703:	a2 9d 41 92 f0       	mov    %al,0xf092419d
f010f708:	a0 9d 41 92 f0       	mov    0xf092419d,%al
f010f70d:	83 c8 60             	or     $0x60,%eax
f010f710:	a2 9d 41 92 f0       	mov    %al,0xf092419d
f010f715:	a0 9d 41 92 f0       	mov    0xf092419d,%al
f010f71a:	83 c8 80             	or     $0xffffff80,%eax
f010f71d:	a2 9d 41 92 f0       	mov    %al,0xf092419d
f010f722:	b8 c8 03 11 f0       	mov    $0xf01103c8,%eax
f010f727:	c1 e8 10             	shr    $0x10,%eax
f010f72a:	66 a3 9e 41 92 f0    	mov    %ax,0xf092419e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010f730:	b8 ce 03 11 f0       	mov    $0xf01103ce,%eax
f010f735:	66 a3 10 42 92 f0    	mov    %ax,0xf0924210
f010f73b:	66 c7 05 12 42 92 f0 	movw   $0x8,0xf0924212
f010f742:	08 00 
f010f744:	a0 14 42 92 f0       	mov    0xf0924214,%al
f010f749:	83 e0 e0             	and    $0xffffffe0,%eax
f010f74c:	a2 14 42 92 f0       	mov    %al,0xf0924214
f010f751:	a0 14 42 92 f0       	mov    0xf0924214,%al
f010f756:	83 e0 1f             	and    $0x1f,%eax
f010f759:	a2 14 42 92 f0       	mov    %al,0xf0924214
f010f75e:	a0 15 42 92 f0       	mov    0xf0924215,%al
f010f763:	83 e0 f0             	and    $0xfffffff0,%eax
f010f766:	83 c8 0e             	or     $0xe,%eax
f010f769:	a2 15 42 92 f0       	mov    %al,0xf0924215
f010f76e:	a0 15 42 92 f0       	mov    0xf0924215,%al
f010f773:	83 e0 ef             	and    $0xffffffef,%eax
f010f776:	a2 15 42 92 f0       	mov    %al,0xf0924215
f010f77b:	a0 15 42 92 f0       	mov    0xf0924215,%al
f010f780:	83 c8 60             	or     $0x60,%eax
f010f783:	a2 15 42 92 f0       	mov    %al,0xf0924215
f010f788:	a0 15 42 92 f0       	mov    0xf0924215,%al
f010f78d:	83 c8 80             	or     $0xffffff80,%eax
f010f790:	a2 15 42 92 f0       	mov    %al,0xf0924215
f010f795:	b8 ce 03 11 f0       	mov    $0xf01103ce,%eax
f010f79a:	c1 e8 10             	shr    $0x10,%eax
f010f79d:	66 a3 16 42 92 f0    	mov    %ax,0xf0924216
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010f7a3:	b8 d4 03 11 f0       	mov    $0xf01103d4,%eax
f010f7a8:	66 a3 18 42 92 f0    	mov    %ax,0xf0924218
f010f7ae:	66 c7 05 1a 42 92 f0 	movw   $0x8,0xf092421a
f010f7b5:	08 00 
f010f7b7:	a0 1c 42 92 f0       	mov    0xf092421c,%al
f010f7bc:	83 e0 e0             	and    $0xffffffe0,%eax
f010f7bf:	a2 1c 42 92 f0       	mov    %al,0xf092421c
f010f7c4:	a0 1c 42 92 f0       	mov    0xf092421c,%al
f010f7c9:	83 e0 1f             	and    $0x1f,%eax
f010f7cc:	a2 1c 42 92 f0       	mov    %al,0xf092421c
f010f7d1:	a0 1d 42 92 f0       	mov    0xf092421d,%al
f010f7d6:	83 e0 f0             	and    $0xfffffff0,%eax
f010f7d9:	83 c8 0e             	or     $0xe,%eax
f010f7dc:	a2 1d 42 92 f0       	mov    %al,0xf092421d
f010f7e1:	a0 1d 42 92 f0       	mov    0xf092421d,%al
f010f7e6:	83 e0 ef             	and    $0xffffffef,%eax
f010f7e9:	a2 1d 42 92 f0       	mov    %al,0xf092421d
f010f7ee:	a0 1d 42 92 f0       	mov    0xf092421d,%al
f010f7f3:	83 c8 60             	or     $0x60,%eax
f010f7f6:	a2 1d 42 92 f0       	mov    %al,0xf092421d
f010f7fb:	a0 1d 42 92 f0       	mov    0xf092421d,%al
f010f800:	83 c8 80             	or     $0xffffff80,%eax
f010f803:	a2 1d 42 92 f0       	mov    %al,0xf092421d
f010f808:	b8 d4 03 11 f0       	mov    $0xf01103d4,%eax
f010f80d:	c1 e8 10             	shr    $0x10,%eax
f010f810:	66 a3 1e 42 92 f0    	mov    %ax,0xf092421e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010f816:	b8 da 03 11 f0       	mov    $0xf01103da,%eax
f010f81b:	66 a3 20 42 92 f0    	mov    %ax,0xf0924220
f010f821:	66 c7 05 22 42 92 f0 	movw   $0x8,0xf0924222
f010f828:	08 00 
f010f82a:	a0 24 42 92 f0       	mov    0xf0924224,%al
f010f82f:	83 e0 e0             	and    $0xffffffe0,%eax
f010f832:	a2 24 42 92 f0       	mov    %al,0xf0924224
f010f837:	a0 24 42 92 f0       	mov    0xf0924224,%al
f010f83c:	83 e0 1f             	and    $0x1f,%eax
f010f83f:	a2 24 42 92 f0       	mov    %al,0xf0924224
f010f844:	a0 25 42 92 f0       	mov    0xf0924225,%al
f010f849:	83 e0 f0             	and    $0xfffffff0,%eax
f010f84c:	83 c8 0e             	or     $0xe,%eax
f010f84f:	a2 25 42 92 f0       	mov    %al,0xf0924225
f010f854:	a0 25 42 92 f0       	mov    0xf0924225,%al
f010f859:	83 e0 ef             	and    $0xffffffef,%eax
f010f85c:	a2 25 42 92 f0       	mov    %al,0xf0924225
f010f861:	a0 25 42 92 f0       	mov    0xf0924225,%al
f010f866:	83 c8 60             	or     $0x60,%eax
f010f869:	a2 25 42 92 f0       	mov    %al,0xf0924225
f010f86e:	a0 25 42 92 f0       	mov    0xf0924225,%al
f010f873:	83 c8 80             	or     $0xffffff80,%eax
f010f876:	a2 25 42 92 f0       	mov    %al,0xf0924225
f010f87b:	b8 da 03 11 f0       	mov    $0xf01103da,%eax
f010f880:	c1 e8 10             	shr    $0x10,%eax
f010f883:	66 a3 26 42 92 f0    	mov    %ax,0xf0924226
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010f889:	b8 e0 03 11 f0       	mov    $0xf01103e0,%eax
f010f88e:	66 a3 28 42 92 f0    	mov    %ax,0xf0924228
f010f894:	66 c7 05 2a 42 92 f0 	movw   $0x8,0xf092422a
f010f89b:	08 00 
f010f89d:	a0 2c 42 92 f0       	mov    0xf092422c,%al
f010f8a2:	83 e0 e0             	and    $0xffffffe0,%eax
f010f8a5:	a2 2c 42 92 f0       	mov    %al,0xf092422c
f010f8aa:	a0 2c 42 92 f0       	mov    0xf092422c,%al
f010f8af:	83 e0 1f             	and    $0x1f,%eax
f010f8b2:	a2 2c 42 92 f0       	mov    %al,0xf092422c
f010f8b7:	a0 2d 42 92 f0       	mov    0xf092422d,%al
f010f8bc:	83 e0 f0             	and    $0xfffffff0,%eax
f010f8bf:	83 c8 0e             	or     $0xe,%eax
f010f8c2:	a2 2d 42 92 f0       	mov    %al,0xf092422d
f010f8c7:	a0 2d 42 92 f0       	mov    0xf092422d,%al
f010f8cc:	83 e0 ef             	and    $0xffffffef,%eax
f010f8cf:	a2 2d 42 92 f0       	mov    %al,0xf092422d
f010f8d4:	a0 2d 42 92 f0       	mov    0xf092422d,%al
f010f8d9:	83 c8 60             	or     $0x60,%eax
f010f8dc:	a2 2d 42 92 f0       	mov    %al,0xf092422d
f010f8e1:	a0 2d 42 92 f0       	mov    0xf092422d,%al
f010f8e6:	83 c8 80             	or     $0xffffff80,%eax
f010f8e9:	a2 2d 42 92 f0       	mov    %al,0xf092422d
f010f8ee:	b8 e0 03 11 f0       	mov    $0xf01103e0,%eax
f010f8f3:	c1 e8 10             	shr    $0x10,%eax
f010f8f6:	66 a3 2e 42 92 f0    	mov    %ax,0xf092422e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010f8fc:	b8 e6 03 11 f0       	mov    $0xf01103e6,%eax
f010f901:	66 a3 30 42 92 f0    	mov    %ax,0xf0924230
f010f907:	66 c7 05 32 42 92 f0 	movw   $0x8,0xf0924232
f010f90e:	08 00 
f010f910:	a0 34 42 92 f0       	mov    0xf0924234,%al
f010f915:	83 e0 e0             	and    $0xffffffe0,%eax
f010f918:	a2 34 42 92 f0       	mov    %al,0xf0924234
f010f91d:	a0 34 42 92 f0       	mov    0xf0924234,%al
f010f922:	83 e0 1f             	and    $0x1f,%eax
f010f925:	a2 34 42 92 f0       	mov    %al,0xf0924234
f010f92a:	a0 35 42 92 f0       	mov    0xf0924235,%al
f010f92f:	83 e0 f0             	and    $0xfffffff0,%eax
f010f932:	83 c8 0e             	or     $0xe,%eax
f010f935:	a2 35 42 92 f0       	mov    %al,0xf0924235
f010f93a:	a0 35 42 92 f0       	mov    0xf0924235,%al
f010f93f:	83 e0 ef             	and    $0xffffffef,%eax
f010f942:	a2 35 42 92 f0       	mov    %al,0xf0924235
f010f947:	a0 35 42 92 f0       	mov    0xf0924235,%al
f010f94c:	83 c8 60             	or     $0x60,%eax
f010f94f:	a2 35 42 92 f0       	mov    %al,0xf0924235
f010f954:	a0 35 42 92 f0       	mov    0xf0924235,%al
f010f959:	83 c8 80             	or     $0xffffff80,%eax
f010f95c:	a2 35 42 92 f0       	mov    %al,0xf0924235
f010f961:	b8 e6 03 11 f0       	mov    $0xf01103e6,%eax
f010f966:	c1 e8 10             	shr    $0x10,%eax
f010f969:	66 a3 36 42 92 f0    	mov    %ax,0xf0924236
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010f96f:	b8 ec 03 11 f0       	mov    $0xf01103ec,%eax
f010f974:	66 a3 38 42 92 f0    	mov    %ax,0xf0924238
f010f97a:	66 c7 05 3a 42 92 f0 	movw   $0x8,0xf092423a
f010f981:	08 00 
f010f983:	a0 3c 42 92 f0       	mov    0xf092423c,%al
f010f988:	83 e0 e0             	and    $0xffffffe0,%eax
f010f98b:	a2 3c 42 92 f0       	mov    %al,0xf092423c
f010f990:	a0 3c 42 92 f0       	mov    0xf092423c,%al
f010f995:	83 e0 1f             	and    $0x1f,%eax
f010f998:	a2 3c 42 92 f0       	mov    %al,0xf092423c
f010f99d:	a0 3d 42 92 f0       	mov    0xf092423d,%al
f010f9a2:	83 e0 f0             	and    $0xfffffff0,%eax
f010f9a5:	83 c8 0e             	or     $0xe,%eax
f010f9a8:	a2 3d 42 92 f0       	mov    %al,0xf092423d
f010f9ad:	a0 3d 42 92 f0       	mov    0xf092423d,%al
f010f9b2:	83 e0 ef             	and    $0xffffffef,%eax
f010f9b5:	a2 3d 42 92 f0       	mov    %al,0xf092423d
f010f9ba:	a0 3d 42 92 f0       	mov    0xf092423d,%al
f010f9bf:	83 c8 60             	or     $0x60,%eax
f010f9c2:	a2 3d 42 92 f0       	mov    %al,0xf092423d
f010f9c7:	a0 3d 42 92 f0       	mov    0xf092423d,%al
f010f9cc:	83 c8 80             	or     $0xffffff80,%eax
f010f9cf:	a2 3d 42 92 f0       	mov    %al,0xf092423d
f010f9d4:	b8 ec 03 11 f0       	mov    $0xf01103ec,%eax
f010f9d9:	c1 e8 10             	shr    $0x10,%eax
f010f9dc:	66 a3 3e 42 92 f0    	mov    %ax,0xf092423e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010f9e2:	b8 f2 03 11 f0       	mov    $0xf01103f2,%eax
f010f9e7:	66 a3 40 42 92 f0    	mov    %ax,0xf0924240
f010f9ed:	66 c7 05 42 42 92 f0 	movw   $0x8,0xf0924242
f010f9f4:	08 00 
f010f9f6:	a0 44 42 92 f0       	mov    0xf0924244,%al
f010f9fb:	83 e0 e0             	and    $0xffffffe0,%eax
f010f9fe:	a2 44 42 92 f0       	mov    %al,0xf0924244
f010fa03:	a0 44 42 92 f0       	mov    0xf0924244,%al
f010fa08:	83 e0 1f             	and    $0x1f,%eax
f010fa0b:	a2 44 42 92 f0       	mov    %al,0xf0924244
f010fa10:	a0 45 42 92 f0       	mov    0xf0924245,%al
f010fa15:	83 e0 f0             	and    $0xfffffff0,%eax
f010fa18:	83 c8 0e             	or     $0xe,%eax
f010fa1b:	a2 45 42 92 f0       	mov    %al,0xf0924245
f010fa20:	a0 45 42 92 f0       	mov    0xf0924245,%al
f010fa25:	83 e0 ef             	and    $0xffffffef,%eax
f010fa28:	a2 45 42 92 f0       	mov    %al,0xf0924245
f010fa2d:	a0 45 42 92 f0       	mov    0xf0924245,%al
f010fa32:	83 c8 60             	or     $0x60,%eax
f010fa35:	a2 45 42 92 f0       	mov    %al,0xf0924245
f010fa3a:	a0 45 42 92 f0       	mov    0xf0924245,%al
f010fa3f:	83 c8 80             	or     $0xffffff80,%eax
f010fa42:	a2 45 42 92 f0       	mov    %al,0xf0924245
f010fa47:	b8 f2 03 11 f0       	mov    $0xf01103f2,%eax
f010fa4c:	c1 e8 10             	shr    $0x10,%eax
f010fa4f:	66 a3 46 42 92 f0    	mov    %ax,0xf0924246
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010fa55:	b8 f8 03 11 f0       	mov    $0xf01103f8,%eax
f010fa5a:	66 a3 48 42 92 f0    	mov    %ax,0xf0924248
f010fa60:	66 c7 05 4a 42 92 f0 	movw   $0x8,0xf092424a
f010fa67:	08 00 
f010fa69:	a0 4c 42 92 f0       	mov    0xf092424c,%al
f010fa6e:	83 e0 e0             	and    $0xffffffe0,%eax
f010fa71:	a2 4c 42 92 f0       	mov    %al,0xf092424c
f010fa76:	a0 4c 42 92 f0       	mov    0xf092424c,%al
f010fa7b:	83 e0 1f             	and    $0x1f,%eax
f010fa7e:	a2 4c 42 92 f0       	mov    %al,0xf092424c
f010fa83:	a0 4d 42 92 f0       	mov    0xf092424d,%al
f010fa88:	83 e0 f0             	and    $0xfffffff0,%eax
f010fa8b:	83 c8 0e             	or     $0xe,%eax
f010fa8e:	a2 4d 42 92 f0       	mov    %al,0xf092424d
f010fa93:	a0 4d 42 92 f0       	mov    0xf092424d,%al
f010fa98:	83 e0 ef             	and    $0xffffffef,%eax
f010fa9b:	a2 4d 42 92 f0       	mov    %al,0xf092424d
f010faa0:	a0 4d 42 92 f0       	mov    0xf092424d,%al
f010faa5:	83 c8 60             	or     $0x60,%eax
f010faa8:	a2 4d 42 92 f0       	mov    %al,0xf092424d
f010faad:	a0 4d 42 92 f0       	mov    0xf092424d,%al
f010fab2:	83 c8 80             	or     $0xffffff80,%eax
f010fab5:	a2 4d 42 92 f0       	mov    %al,0xf092424d
f010faba:	b8 f8 03 11 f0       	mov    $0xf01103f8,%eax
f010fabf:	c1 e8 10             	shr    $0x10,%eax
f010fac2:	66 a3 4e 42 92 f0    	mov    %ax,0xf092424e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010fac8:	b8 fe 03 11 f0       	mov    $0xf01103fe,%eax
f010facd:	66 a3 50 42 92 f0    	mov    %ax,0xf0924250
f010fad3:	66 c7 05 52 42 92 f0 	movw   $0x8,0xf0924252
f010fada:	08 00 
f010fadc:	a0 54 42 92 f0       	mov    0xf0924254,%al
f010fae1:	83 e0 e0             	and    $0xffffffe0,%eax
f010fae4:	a2 54 42 92 f0       	mov    %al,0xf0924254
f010fae9:	a0 54 42 92 f0       	mov    0xf0924254,%al
f010faee:	83 e0 1f             	and    $0x1f,%eax
f010faf1:	a2 54 42 92 f0       	mov    %al,0xf0924254
f010faf6:	a0 55 42 92 f0       	mov    0xf0924255,%al
f010fafb:	83 e0 f0             	and    $0xfffffff0,%eax
f010fafe:	83 c8 0e             	or     $0xe,%eax
f010fb01:	a2 55 42 92 f0       	mov    %al,0xf0924255
f010fb06:	a0 55 42 92 f0       	mov    0xf0924255,%al
f010fb0b:	83 e0 ef             	and    $0xffffffef,%eax
f010fb0e:	a2 55 42 92 f0       	mov    %al,0xf0924255
f010fb13:	a0 55 42 92 f0       	mov    0xf0924255,%al
f010fb18:	83 c8 60             	or     $0x60,%eax
f010fb1b:	a2 55 42 92 f0       	mov    %al,0xf0924255
f010fb20:	a0 55 42 92 f0       	mov    0xf0924255,%al
f010fb25:	83 c8 80             	or     $0xffffff80,%eax
f010fb28:	a2 55 42 92 f0       	mov    %al,0xf0924255
f010fb2d:	b8 fe 03 11 f0       	mov    $0xf01103fe,%eax
f010fb32:	c1 e8 10             	shr    $0x10,%eax
f010fb35:	66 a3 56 42 92 f0    	mov    %ax,0xf0924256
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010fb3b:	b8 04 04 11 f0       	mov    $0xf0110404,%eax
f010fb40:	66 a3 58 42 92 f0    	mov    %ax,0xf0924258
f010fb46:	66 c7 05 5a 42 92 f0 	movw   $0x8,0xf092425a
f010fb4d:	08 00 
f010fb4f:	a0 5c 42 92 f0       	mov    0xf092425c,%al
f010fb54:	83 e0 e0             	and    $0xffffffe0,%eax
f010fb57:	a2 5c 42 92 f0       	mov    %al,0xf092425c
f010fb5c:	a0 5c 42 92 f0       	mov    0xf092425c,%al
f010fb61:	83 e0 1f             	and    $0x1f,%eax
f010fb64:	a2 5c 42 92 f0       	mov    %al,0xf092425c
f010fb69:	a0 5d 42 92 f0       	mov    0xf092425d,%al
f010fb6e:	83 e0 f0             	and    $0xfffffff0,%eax
f010fb71:	83 c8 0e             	or     $0xe,%eax
f010fb74:	a2 5d 42 92 f0       	mov    %al,0xf092425d
f010fb79:	a0 5d 42 92 f0       	mov    0xf092425d,%al
f010fb7e:	83 e0 ef             	and    $0xffffffef,%eax
f010fb81:	a2 5d 42 92 f0       	mov    %al,0xf092425d
f010fb86:	a0 5d 42 92 f0       	mov    0xf092425d,%al
f010fb8b:	83 c8 60             	or     $0x60,%eax
f010fb8e:	a2 5d 42 92 f0       	mov    %al,0xf092425d
f010fb93:	a0 5d 42 92 f0       	mov    0xf092425d,%al
f010fb98:	83 c8 80             	or     $0xffffff80,%eax
f010fb9b:	a2 5d 42 92 f0       	mov    %al,0xf092425d
f010fba0:	b8 04 04 11 f0       	mov    $0xf0110404,%eax
f010fba5:	c1 e8 10             	shr    $0x10,%eax
f010fba8:	66 a3 5e 42 92 f0    	mov    %ax,0xf092425e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010fbae:	b8 0a 04 11 f0       	mov    $0xf011040a,%eax
f010fbb3:	66 a3 60 42 92 f0    	mov    %ax,0xf0924260
f010fbb9:	66 c7 05 62 42 92 f0 	movw   $0x8,0xf0924262
f010fbc0:	08 00 
f010fbc2:	a0 64 42 92 f0       	mov    0xf0924264,%al
f010fbc7:	83 e0 e0             	and    $0xffffffe0,%eax
f010fbca:	a2 64 42 92 f0       	mov    %al,0xf0924264
f010fbcf:	a0 64 42 92 f0       	mov    0xf0924264,%al
f010fbd4:	83 e0 1f             	and    $0x1f,%eax
f010fbd7:	a2 64 42 92 f0       	mov    %al,0xf0924264
f010fbdc:	a0 65 42 92 f0       	mov    0xf0924265,%al
f010fbe1:	83 e0 f0             	and    $0xfffffff0,%eax
f010fbe4:	83 c8 0e             	or     $0xe,%eax
f010fbe7:	a2 65 42 92 f0       	mov    %al,0xf0924265
f010fbec:	a0 65 42 92 f0       	mov    0xf0924265,%al
f010fbf1:	83 e0 ef             	and    $0xffffffef,%eax
f010fbf4:	a2 65 42 92 f0       	mov    %al,0xf0924265
f010fbf9:	a0 65 42 92 f0       	mov    0xf0924265,%al
f010fbfe:	83 c8 60             	or     $0x60,%eax
f010fc01:	a2 65 42 92 f0       	mov    %al,0xf0924265
f010fc06:	a0 65 42 92 f0       	mov    0xf0924265,%al
f010fc0b:	83 c8 80             	or     $0xffffff80,%eax
f010fc0e:	a2 65 42 92 f0       	mov    %al,0xf0924265
f010fc13:	b8 0a 04 11 f0       	mov    $0xf011040a,%eax
f010fc18:	c1 e8 10             	shr    $0x10,%eax
f010fc1b:	66 a3 66 42 92 f0    	mov    %ax,0xf0924266
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010fc21:	b8 10 04 11 f0       	mov    $0xf0110410,%eax
f010fc26:	66 a3 68 42 92 f0    	mov    %ax,0xf0924268
f010fc2c:	66 c7 05 6a 42 92 f0 	movw   $0x8,0xf092426a
f010fc33:	08 00 
f010fc35:	a0 6c 42 92 f0       	mov    0xf092426c,%al
f010fc3a:	83 e0 e0             	and    $0xffffffe0,%eax
f010fc3d:	a2 6c 42 92 f0       	mov    %al,0xf092426c
f010fc42:	a0 6c 42 92 f0       	mov    0xf092426c,%al
f010fc47:	83 e0 1f             	and    $0x1f,%eax
f010fc4a:	a2 6c 42 92 f0       	mov    %al,0xf092426c
f010fc4f:	a0 6d 42 92 f0       	mov    0xf092426d,%al
f010fc54:	83 e0 f0             	and    $0xfffffff0,%eax
f010fc57:	83 c8 0e             	or     $0xe,%eax
f010fc5a:	a2 6d 42 92 f0       	mov    %al,0xf092426d
f010fc5f:	a0 6d 42 92 f0       	mov    0xf092426d,%al
f010fc64:	83 e0 ef             	and    $0xffffffef,%eax
f010fc67:	a2 6d 42 92 f0       	mov    %al,0xf092426d
f010fc6c:	a0 6d 42 92 f0       	mov    0xf092426d,%al
f010fc71:	83 c8 60             	or     $0x60,%eax
f010fc74:	a2 6d 42 92 f0       	mov    %al,0xf092426d
f010fc79:	a0 6d 42 92 f0       	mov    0xf092426d,%al
f010fc7e:	83 c8 80             	or     $0xffffff80,%eax
f010fc81:	a2 6d 42 92 f0       	mov    %al,0xf092426d
f010fc86:	b8 10 04 11 f0       	mov    $0xf0110410,%eax
f010fc8b:	c1 e8 10             	shr    $0x10,%eax
f010fc8e:	66 a3 6e 42 92 f0    	mov    %ax,0xf092426e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010fc94:	b8 16 04 11 f0       	mov    $0xf0110416,%eax
f010fc99:	66 a3 70 42 92 f0    	mov    %ax,0xf0924270
f010fc9f:	66 c7 05 72 42 92 f0 	movw   $0x8,0xf0924272
f010fca6:	08 00 
f010fca8:	a0 74 42 92 f0       	mov    0xf0924274,%al
f010fcad:	83 e0 e0             	and    $0xffffffe0,%eax
f010fcb0:	a2 74 42 92 f0       	mov    %al,0xf0924274
f010fcb5:	a0 74 42 92 f0       	mov    0xf0924274,%al
f010fcba:	83 e0 1f             	and    $0x1f,%eax
f010fcbd:	a2 74 42 92 f0       	mov    %al,0xf0924274
f010fcc2:	a0 75 42 92 f0       	mov    0xf0924275,%al
f010fcc7:	83 e0 f0             	and    $0xfffffff0,%eax
f010fcca:	83 c8 0e             	or     $0xe,%eax
f010fccd:	a2 75 42 92 f0       	mov    %al,0xf0924275
f010fcd2:	a0 75 42 92 f0       	mov    0xf0924275,%al
f010fcd7:	83 e0 ef             	and    $0xffffffef,%eax
f010fcda:	a2 75 42 92 f0       	mov    %al,0xf0924275
f010fcdf:	a0 75 42 92 f0       	mov    0xf0924275,%al
f010fce4:	83 c8 60             	or     $0x60,%eax
f010fce7:	a2 75 42 92 f0       	mov    %al,0xf0924275
f010fcec:	a0 75 42 92 f0       	mov    0xf0924275,%al
f010fcf1:	83 c8 80             	or     $0xffffff80,%eax
f010fcf4:	a2 75 42 92 f0       	mov    %al,0xf0924275
f010fcf9:	b8 16 04 11 f0       	mov    $0xf0110416,%eax
f010fcfe:	c1 e8 10             	shr    $0x10,%eax
f010fd01:	66 a3 76 42 92 f0    	mov    %ax,0xf0924276
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010fd07:	b8 1c 04 11 f0       	mov    $0xf011041c,%eax
f010fd0c:	66 a3 78 42 92 f0    	mov    %ax,0xf0924278
f010fd12:	66 c7 05 7a 42 92 f0 	movw   $0x8,0xf092427a
f010fd19:	08 00 
f010fd1b:	a0 7c 42 92 f0       	mov    0xf092427c,%al
f010fd20:	83 e0 e0             	and    $0xffffffe0,%eax
f010fd23:	a2 7c 42 92 f0       	mov    %al,0xf092427c
f010fd28:	a0 7c 42 92 f0       	mov    0xf092427c,%al
f010fd2d:	83 e0 1f             	and    $0x1f,%eax
f010fd30:	a2 7c 42 92 f0       	mov    %al,0xf092427c
f010fd35:	a0 7d 42 92 f0       	mov    0xf092427d,%al
f010fd3a:	83 e0 f0             	and    $0xfffffff0,%eax
f010fd3d:	83 c8 0e             	or     $0xe,%eax
f010fd40:	a2 7d 42 92 f0       	mov    %al,0xf092427d
f010fd45:	a0 7d 42 92 f0       	mov    0xf092427d,%al
f010fd4a:	83 e0 ef             	and    $0xffffffef,%eax
f010fd4d:	a2 7d 42 92 f0       	mov    %al,0xf092427d
f010fd52:	a0 7d 42 92 f0       	mov    0xf092427d,%al
f010fd57:	83 c8 60             	or     $0x60,%eax
f010fd5a:	a2 7d 42 92 f0       	mov    %al,0xf092427d
f010fd5f:	a0 7d 42 92 f0       	mov    0xf092427d,%al
f010fd64:	83 c8 80             	or     $0xffffff80,%eax
f010fd67:	a2 7d 42 92 f0       	mov    %al,0xf092427d
f010fd6c:	b8 1c 04 11 f0       	mov    $0xf011041c,%eax
f010fd71:	c1 e8 10             	shr    $0x10,%eax
f010fd74:	66 a3 7e 42 92 f0    	mov    %ax,0xf092427e
f010fd7a:	c7 45 fc 00 41 92 f0 	movl   $0xf0924100,-0x4(%ebp)
f010fd81:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010fd88:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010fd8b:	48                   	dec    %eax
f010fd8c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010fd90:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010fd93:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010fd97:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010fd9a:	c1 e8 10             	shr    $0x10,%eax
f010fd9d:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010fda1:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010fda4:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010fda7:	90                   	nop
f010fda8:	c9                   	leave  
f010fda9:	c3                   	ret    

f010fdaa <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010fdaa:	55                   	push   %ebp
f010fdab:	89 e5                	mov    %esp,%ebp
f010fdad:	53                   	push   %ebx
f010fdae:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010fdb1:	83 ec 08             	sub    $0x8,%esp
f010fdb4:	ff 75 08             	pushl  0x8(%ebp)
f010fdb7:	68 5e 96 13 f0       	push   $0xf013965e
f010fdbc:	e8 8c 1d ff ff       	call   f0101b4d <cprintf>
f010fdc1:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010fdc4:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdc7:	83 ec 0c             	sub    $0xc,%esp
f010fdca:	50                   	push   %eax
f010fdcb:	e8 fd 00 00 00       	call   f010fecd <print_regs>
f010fdd0:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010fdd3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdd6:	8b 40 20             	mov    0x20(%eax),%eax
f010fdd9:	0f b7 c0             	movzwl %ax,%eax
f010fddc:	83 ec 08             	sub    $0x8,%esp
f010fddf:	50                   	push   %eax
f010fde0:	68 70 96 13 f0       	push   $0xf0139670
f010fde5:	e8 63 1d ff ff       	call   f0101b4d <cprintf>
f010fdea:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010fded:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdf0:	8b 40 24             	mov    0x24(%eax),%eax
f010fdf3:	0f b7 c0             	movzwl %ax,%eax
f010fdf6:	83 ec 08             	sub    $0x8,%esp
f010fdf9:	50                   	push   %eax
f010fdfa:	68 83 96 13 f0       	push   $0xf0139683
f010fdff:	e8 49 1d ff ff       	call   f0101b4d <cprintf>
f010fe04:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010fe07:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe0a:	8b 58 28             	mov    0x28(%eax),%ebx
f010fe0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe10:	8b 40 28             	mov    0x28(%eax),%eax
f010fe13:	83 ec 0c             	sub    $0xc,%esp
f010fe16:	50                   	push   %eax
f010fe17:	e8 28 ee ff ff       	call   f010ec44 <trapname>
f010fe1c:	83 c4 10             	add    $0x10,%esp
f010fe1f:	89 c2                	mov    %eax,%edx
f010fe21:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe24:	8b 40 28             	mov    0x28(%eax),%eax
f010fe27:	53                   	push   %ebx
f010fe28:	52                   	push   %edx
f010fe29:	50                   	push   %eax
f010fe2a:	68 96 96 13 f0       	push   $0xf0139696
f010fe2f:	e8 19 1d ff ff       	call   f0101b4d <cprintf>
f010fe34:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010fe37:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe3a:	8b 40 2c             	mov    0x2c(%eax),%eax
f010fe3d:	83 ec 08             	sub    $0x8,%esp
f010fe40:	50                   	push   %eax
f010fe41:	68 ad 96 13 f0       	push   $0xf01396ad
f010fe46:	e8 02 1d ff ff       	call   f0101b4d <cprintf>
f010fe4b:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010fe4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe51:	8b 40 30             	mov    0x30(%eax),%eax
f010fe54:	83 ec 08             	sub    $0x8,%esp
f010fe57:	50                   	push   %eax
f010fe58:	68 bc 96 13 f0       	push   $0xf01396bc
f010fe5d:	e8 eb 1c ff ff       	call   f0101b4d <cprintf>
f010fe62:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010fe65:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe68:	8b 40 34             	mov    0x34(%eax),%eax
f010fe6b:	0f b7 c0             	movzwl %ax,%eax
f010fe6e:	83 ec 08             	sub    $0x8,%esp
f010fe71:	50                   	push   %eax
f010fe72:	68 cb 96 13 f0       	push   $0xf01396cb
f010fe77:	e8 d1 1c ff ff       	call   f0101b4d <cprintf>
f010fe7c:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010fe7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe82:	8b 40 38             	mov    0x38(%eax),%eax
f010fe85:	83 ec 08             	sub    $0x8,%esp
f010fe88:	50                   	push   %eax
f010fe89:	68 de 96 13 f0       	push   $0xf01396de
f010fe8e:	e8 ba 1c ff ff       	call   f0101b4d <cprintf>
f010fe93:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010fe96:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe99:	8b 40 3c             	mov    0x3c(%eax),%eax
f010fe9c:	83 ec 08             	sub    $0x8,%esp
f010fe9f:	50                   	push   %eax
f010fea0:	68 ed 96 13 f0       	push   $0xf01396ed
f010fea5:	e8 a3 1c ff ff       	call   f0101b4d <cprintf>
f010feaa:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010fead:	8b 45 08             	mov    0x8(%ebp),%eax
f010feb0:	8b 40 40             	mov    0x40(%eax),%eax
f010feb3:	0f b7 c0             	movzwl %ax,%eax
f010feb6:	83 ec 08             	sub    $0x8,%esp
f010feb9:	50                   	push   %eax
f010feba:	68 fc 96 13 f0       	push   $0xf01396fc
f010febf:	e8 89 1c ff ff       	call   f0101b4d <cprintf>
f010fec4:	83 c4 10             	add    $0x10,%esp
}
f010fec7:	90                   	nop
f010fec8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fecb:	c9                   	leave  
f010fecc:	c3                   	ret    

f010fecd <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010fecd:	55                   	push   %ebp
f010fece:	89 e5                	mov    %esp,%ebp
f010fed0:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010fed3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fed6:	8b 00                	mov    (%eax),%eax
f010fed8:	83 ec 08             	sub    $0x8,%esp
f010fedb:	50                   	push   %eax
f010fedc:	68 0f 97 13 f0       	push   $0xf013970f
f010fee1:	e8 67 1c ff ff       	call   f0101b4d <cprintf>
f010fee6:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010fee9:	8b 45 08             	mov    0x8(%ebp),%eax
f010feec:	8b 40 04             	mov    0x4(%eax),%eax
f010feef:	83 ec 08             	sub    $0x8,%esp
f010fef2:	50                   	push   %eax
f010fef3:	68 1e 97 13 f0       	push   $0xf013971e
f010fef8:	e8 50 1c ff ff       	call   f0101b4d <cprintf>
f010fefd:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010ff00:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff03:	8b 40 08             	mov    0x8(%eax),%eax
f010ff06:	83 ec 08             	sub    $0x8,%esp
f010ff09:	50                   	push   %eax
f010ff0a:	68 2d 97 13 f0       	push   $0xf013972d
f010ff0f:	e8 39 1c ff ff       	call   f0101b4d <cprintf>
f010ff14:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010ff17:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff1a:	8b 40 0c             	mov    0xc(%eax),%eax
f010ff1d:	83 ec 08             	sub    $0x8,%esp
f010ff20:	50                   	push   %eax
f010ff21:	68 3c 97 13 f0       	push   $0xf013973c
f010ff26:	e8 22 1c ff ff       	call   f0101b4d <cprintf>
f010ff2b:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010ff2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff31:	8b 40 10             	mov    0x10(%eax),%eax
f010ff34:	83 ec 08             	sub    $0x8,%esp
f010ff37:	50                   	push   %eax
f010ff38:	68 4b 97 13 f0       	push   $0xf013974b
f010ff3d:	e8 0b 1c ff ff       	call   f0101b4d <cprintf>
f010ff42:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010ff45:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff48:	8b 40 14             	mov    0x14(%eax),%eax
f010ff4b:	83 ec 08             	sub    $0x8,%esp
f010ff4e:	50                   	push   %eax
f010ff4f:	68 5a 97 13 f0       	push   $0xf013975a
f010ff54:	e8 f4 1b ff ff       	call   f0101b4d <cprintf>
f010ff59:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010ff5c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff5f:	8b 40 18             	mov    0x18(%eax),%eax
f010ff62:	83 ec 08             	sub    $0x8,%esp
f010ff65:	50                   	push   %eax
f010ff66:	68 69 97 13 f0       	push   $0xf0139769
f010ff6b:	e8 dd 1b ff ff       	call   f0101b4d <cprintf>
f010ff70:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010ff73:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff76:	8b 40 1c             	mov    0x1c(%eax),%eax
f010ff79:	83 ec 08             	sub    $0x8,%esp
f010ff7c:	50                   	push   %eax
f010ff7d:	68 78 97 13 f0       	push   $0xf0139778
f010ff82:	e8 c6 1b ff ff       	call   f0101b4d <cprintf>
f010ff87:	83 c4 10             	add    $0x10,%esp
}
f010ff8a:	90                   	nop
f010ff8b:	c9                   	leave  
f010ff8c:	c3                   	ret    

f010ff8d <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010ff8d:	55                   	push   %ebp
f010ff8e:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010ff90:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff93:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ff96:	89 14 85 00 49 92 f0 	mov    %edx,-0xf6db700(,%eax,4)
}
f010ff9d:	90                   	nop
f010ff9e:	5d                   	pop    %ebp
f010ff9f:	c3                   	ret    

f010ffa0 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010ffa0:	55                   	push   %ebp
f010ffa1:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010ffa3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa6:	c7 04 85 00 49 92 f0 	movl   $0x0,-0xf6db700(,%eax,4)
f010ffad:	00 00 00 00 
}
f010ffb1:	90                   	nop
f010ffb2:	5d                   	pop    %ebp
f010ffb3:	c3                   	ret    

f010ffb4 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010ffb4:	55                   	push   %ebp
f010ffb5:	89 e5                	mov    %esp,%ebp
f010ffb7:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010ffba:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffbd:	8b 40 28             	mov    0x28(%eax),%eax
f010ffc0:	83 e8 20             	sub    $0x20,%eax
f010ffc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010ffc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ffc9:	8b 04 85 00 49 92 f0 	mov    -0xf6db700(,%eax,4),%eax
f010ffd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010ffd3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ffd7:	74 0e                	je     f010ffe7 <irq_dispatch+0x33>
	{
		handler(tf);
f010ffd9:	83 ec 0c             	sub    $0xc,%esp
f010ffdc:	ff 75 08             	pushl  0x8(%ebp)
f010ffdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ffe2:	ff d0                	call   *%eax
f010ffe4:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010ffe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ffea:	0f b6 c0             	movzbl %al,%eax
f010ffed:	83 ec 0c             	sub    $0xc,%esp
f010fff0:	50                   	push   %eax
f010fff1:	e8 d0 84 ff ff       	call   f01084c6 <pic_sendEOI>
f010fff6:	83 c4 10             	add    $0x10,%esp
}
f010fff9:	90                   	nop
f010fffa:	c9                   	leave  
f010fffb:	c3                   	ret    

f010fffc <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010fffc:	55                   	push   %ebp
f010fffd:	89 e5                	mov    %esp,%ebp
f010ffff:	57                   	push   %edi
f0110000:	56                   	push   %esi
f0110001:	53                   	push   %ebx
f0110002:	83 ec 1c             	sub    $0x1c,%esp
	// Handle processor exceptions.
	// LAB 3: Your code here.

	if(tf->tf_trapno == T_PGFLT)
f0110005:	8b 45 08             	mov    0x8(%ebp),%eax
f0110008:	8b 40 28             	mov    0x28(%eax),%eax
f011000b:	83 f8 0e             	cmp    $0xe,%eax
f011000e:	75 51                	jne    f0110061 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f0110010:	a0 40 49 92 f0       	mov    0xf0924940,%al
f0110015:	84 c0                	test   %al,%al
f0110017:	74 1f                	je     f0110038 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f0110019:	8b 45 08             	mov    0x8(%ebp),%eax
f011001c:	8b 40 30             	mov    0x30(%eax),%eax
f011001f:	89 c2                	mov    %eax,%edx
f0110021:	a0 40 49 92 f0       	mov    0xf0924940,%al
f0110026:	0f b6 c0             	movzbl %al,%eax
f0110029:	01 d0                	add    %edx,%eax
f011002b:	89 c2                	mov    %eax,%edx
f011002d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110030:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f0110033:	e9 0c 01 00 00       	jmp    f0110144 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0110038:	83 ec 0c             	sub    $0xc,%esp
f011003b:	6a 01                	push   $0x1
f011003d:	e8 3c 16 00 00       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0110042:	83 c4 10             	add    $0x10,%esp
f0110045:	85 c0                	test   %eax,%eax
f0110047:	74 05                	je     f011004e <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f0110049:	e8 1d 80 ff ff       	call   f010806b <update_WS_time_stamps>
		}
		fault_handler(tf);
f011004e:	83 ec 0c             	sub    $0xc,%esp
f0110051:	ff 75 08             	pushl  0x8(%ebp)
f0110054:	e8 51 17 00 00       	call   f01117aa <fault_handler>
f0110059:	83 c4 10             	add    $0x10,%esp
f011005c:	e9 e3 00 00 00       	jmp    f0110144 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f0110061:	8b 45 08             	mov    0x8(%ebp),%eax
f0110064:	8b 40 28             	mov    0x28(%eax),%eax
f0110067:	83 f8 30             	cmp    $0x30,%eax
f011006a:	75 6e                	jne    f01100da <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f011006c:	8b 45 08             	mov    0x8(%ebp),%eax
f011006f:	8b 40 38             	mov    0x38(%eax),%eax
f0110072:	25 00 02 00 00       	and    $0x200,%eax
f0110077:	85 c0                	test   %eax,%eax
f0110079:	74 06                	je     f0110081 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f011007b:	fb                   	sti    
		{
			sti();
			kclock_resume();
f011007c:	e8 cc 5c ff ff       	call   f0105d4d <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f0110081:	8b 45 08             	mov    0x8(%ebp),%eax
f0110084:	8b 78 04             	mov    0x4(%eax),%edi
f0110087:	8b 45 08             	mov    0x8(%ebp),%eax
f011008a:	8b 30                	mov    (%eax),%esi
f011008c:	8b 45 08             	mov    0x8(%ebp),%eax
f011008f:	8b 58 10             	mov    0x10(%eax),%ebx
f0110092:	8b 45 08             	mov    0x8(%ebp),%eax
f0110095:	8b 48 18             	mov    0x18(%eax),%ecx
f0110098:	8b 45 08             	mov    0x8(%ebp),%eax
f011009b:	8b 50 14             	mov    0x14(%eax),%edx
f011009e:	8b 45 08             	mov    0x8(%ebp),%eax
f01100a1:	8b 40 1c             	mov    0x1c(%eax),%eax
f01100a4:	83 ec 08             	sub    $0x8,%esp
f01100a7:	57                   	push   %edi
f01100a8:	56                   	push   %esi
f01100a9:	53                   	push   %ebx
f01100aa:	51                   	push   %ecx
f01100ab:	52                   	push   %edx
f01100ac:	50                   	push   %eax
f01100ad:	e8 d8 0c 00 00       	call   f0110d8a <syscall>
f01100b2:	83 c4 20             	add    $0x20,%esp
f01100b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f01100b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01100bb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01100be:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01100c1:	9c                   	pushf  
f01100c2:	58                   	pop    %eax
f01100c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f01100c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f01100c9:	25 00 02 00 00       	and    $0x200,%eax
f01100ce:	85 c0                	test   %eax,%eax
f01100d0:	74 72                	je     f0110144 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01100d2:	fa                   	cli    
		{
			cli();
			kclock_stop();
f01100d3:	e8 4d 5c ff ff       	call   f0105d25 <kclock_stop>
f01100d8:	eb 6a                	jmp    f0110144 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f01100da:	8b 45 08             	mov    0x8(%ebp),%eax
f01100dd:	8b 40 28             	mov    0x28(%eax),%eax
f01100e0:	83 f8 08             	cmp    $0x8,%eax
f01100e3:	75 17                	jne    f01100fc <trap_dispatch+0x100>
	{
		panic("double fault!!");
f01100e5:	83 ec 04             	sub    $0x4,%esp
f01100e8:	68 87 97 13 f0       	push   $0xf0139787
f01100ed:	68 29 01 00 00       	push   $0x129
f01100f2:	68 96 97 13 f0       	push   $0xf0139796
f01100f7:	e8 b3 0d ff ff       	call   f0100eaf <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f01100fc:	83 ec 0c             	sub    $0xc,%esp
f01100ff:	ff 75 08             	pushl  0x8(%ebp)
f0110102:	e8 a3 fc ff ff       	call   f010fdaa <print_trapframe>
f0110107:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f011010a:	8b 45 08             	mov    0x8(%ebp),%eax
f011010d:	8b 40 34             	mov    0x34(%eax),%eax
f0110110:	66 83 f8 08          	cmp    $0x8,%ax
f0110114:	75 17                	jne    f011012d <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f0110116:	83 ec 04             	sub    $0x4,%esp
f0110119:	68 a7 97 13 f0       	push   $0xf01397a7
f011011e:	68 31 01 00 00       	push   $0x131
f0110123:	68 96 97 13 f0       	push   $0xf0139796
f0110128:	e8 82 0d ff ff       	call   f0100eaf <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f011012d:	83 ec 04             	sub    $0x4,%esp
f0110130:	68 c0 97 13 f0       	push   $0xf01397c0
f0110135:	68 36 01 00 00       	push   $0x136
f011013a:	68 96 97 13 f0       	push   $0xf0139796
f011013f:	e8 6b 0d ff ff       	call   f0100eaf <_panic>
		}
	}
}
f0110144:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0110147:	5b                   	pop    %ebx
f0110148:	5e                   	pop    %esi
f0110149:	5f                   	pop    %edi
f011014a:	5d                   	pop    %ebp
f011014b:	c3                   	ret    

f011014c <trap>:

void trap(struct Trapframe *tf)
{
f011014c:	55                   	push   %ebp
f011014d:	89 e5                	mov    %esp,%ebp
f011014f:	57                   	push   %edi
f0110150:	56                   	push   %esi
f0110151:	53                   	push   %ebx
f0110152:	83 ec 3c             	sub    $0x3c,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f0110155:	e8 cb 5b ff ff       	call   f0105d25 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f011015a:	9c                   	pushf  
f011015b:	58                   	pop    %eax
f011015c:	89 45 c8             	mov    %eax,-0x38(%ebp)
        return eflags;
f011015f:	8b 45 c8             	mov    -0x38(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f0110162:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (flags & FL_IF)
f0110165:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110168:	25 00 02 00 00       	and    $0x200,%eax
f011016d:	85 c0                	test   %eax,%eax
f011016f:	74 25                	je     f0110196 <trap+0x4a>
	{
		print_trapframe(tf);
f0110171:	83 ec 0c             	sub    $0xc,%esp
f0110174:	ff 75 08             	pushl  0x8(%ebp)
f0110177:	e8 2e fc ff ff       	call   f010fdaa <print_trapframe>
f011017c:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f011017f:	83 ec 04             	sub    $0x4,%esp
f0110182:	68 e0 97 13 f0       	push   $0xf01397e0
f0110187:	68 4c 01 00 00       	push   $0x14c
f011018c:	68 96 97 13 f0       	push   $0xf0139796
f0110191:	e8 19 0d ff ff       	call   f0100eaf <_panic>
	}

	int userTrap = 0;
f0110196:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f011019d:	e8 a6 d4 ff ff       	call   f010d648 <get_cpu_proc>
f01101a2:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if ((tf->tf_cs & 3) == 3)
f01101a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01101a8:	8b 40 34             	mov    0x34(%eax),%eax
f01101ab:	0f b7 c0             	movzwl %ax,%eax
f01101ae:	83 e0 03             	and    $0x3,%eax
f01101b1:	83 f8 03             	cmp    $0x3,%eax
f01101b4:	0f 85 03 01 00 00    	jne    f01102bd <trap+0x171>
	{
		userTrap = 1;
f01101ba:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f01101c1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01101c5:	74 0b                	je     f01101d2 <trap+0x86>
f01101c7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01101ca:	8b 40 18             	mov    0x18(%eax),%eax
f01101cd:	83 f8 02             	cmp    $0x2,%eax
f01101d0:	74 19                	je     f01101eb <trap+0x9f>
f01101d2:	68 24 98 13 f0       	push   $0xf0139824
f01101d7:	68 52 98 13 f0       	push   $0xf0139852
f01101dc:	68 55 01 00 00       	push   $0x155
f01101e1:	68 96 97 13 f0       	push   $0xf0139796
f01101e6:	e8 c4 0c ff ff       	call   f0100eaf <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		//assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
		if (cur_env->env_tf != tf)
f01101eb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01101ee:	8b 00                	mov    (%eax),%eax
f01101f0:	3b 45 08             	cmp    0x8(%ebp),%eax
f01101f3:	0f 84 c4 00 00 00    	je     f01102bd <trap+0x171>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01101f9:	9c                   	pushf  
f01101fa:	58                   	pop    %eax
f01101fb:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return eflags;
f01101fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
		{
			cprintf("\n[%s - %d] trap #%d - %s (cr2 = %x) tf va = %x - eip = %x - IEN = %d\n", userTrap == 1? "USER" : "KERNEL", userTrap == 1? cur_env->env_id : 0, tf->tf_trapno, trapname(tf->tf_trapno), rcr2(), tf, tf->tf_eip, (read_eflags() & FL_IF) == 0? 0 : 1);
f0110201:	25 00 02 00 00       	and    $0x200,%eax
f0110206:	85 c0                	test   %eax,%eax
f0110208:	0f 95 c0             	setne  %al
f011020b:	0f b6 c0             	movzbl %al,%eax
f011020e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0110211:	8b 45 08             	mov    0x8(%ebp),%eax
f0110214:	8b 78 30             	mov    0x30(%eax),%edi

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f0110217:	0f 20 d0             	mov    %cr2,%eax
f011021a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return val;
f011021d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0110220:	8b 45 08             	mov    0x8(%ebp),%eax
f0110223:	8b 40 28             	mov    0x28(%eax),%eax
f0110226:	83 ec 0c             	sub    $0xc,%esp
f0110229:	50                   	push   %eax
f011022a:	e8 15 ea ff ff       	call   f010ec44 <trapname>
f011022f:	83 c4 10             	add    $0x10,%esp
f0110232:	89 c3                	mov    %eax,%ebx
f0110234:	8b 45 08             	mov    0x8(%ebp),%eax
f0110237:	8b 48 28             	mov    0x28(%eax),%ecx
f011023a:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f011023e:	75 08                	jne    f0110248 <trap+0xfc>
f0110240:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110243:	8b 40 10             	mov    0x10(%eax),%eax
f0110246:	eb 05                	jmp    f011024d <trap+0x101>
f0110248:	b8 00 00 00 00       	mov    $0x0,%eax
f011024d:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0110251:	75 07                	jne    f011025a <trap+0x10e>
f0110253:	ba 67 98 13 f0       	mov    $0xf0139867,%edx
f0110258:	eb 05                	jmp    f011025f <trap+0x113>
f011025a:	ba 6c 98 13 f0       	mov    $0xf013986c,%edx
f011025f:	83 ec 0c             	sub    $0xc,%esp
f0110262:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110265:	57                   	push   %edi
f0110266:	ff 75 08             	pushl  0x8(%ebp)
f0110269:	56                   	push   %esi
f011026a:	53                   	push   %ebx
f011026b:	51                   	push   %ecx
f011026c:	50                   	push   %eax
f011026d:	52                   	push   %edx
f011026e:	68 74 98 13 f0       	push   $0xf0139874
f0110273:	e8 d5 18 ff ff       	call   f0101b4d <cprintf>
f0110278:	83 c4 30             	add    $0x30,%esp
			panic("USER TRAP [%d:%s]: unexpected trapframe! cur_env->env_tf (%x) != tf (%x). Kernel stack [%x, %x)",
f011027b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011027e:	8b 40 70             	mov    0x70(%eax),%eax
f0110281:	8d b0 00 80 00 00    	lea    0x8000(%eax),%esi
f0110287:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011028a:	8b 48 70             	mov    0x70(%eax),%ecx
f011028d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110290:	8b 10                	mov    (%eax),%edx
f0110292:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110295:	8d 58 20             	lea    0x20(%eax),%ebx
f0110298:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011029b:	8b 40 10             	mov    0x10(%eax),%eax
f011029e:	83 ec 0c             	sub    $0xc,%esp
f01102a1:	56                   	push   %esi
f01102a2:	51                   	push   %ecx
f01102a3:	ff 75 08             	pushl  0x8(%ebp)
f01102a6:	52                   	push   %edx
f01102a7:	53                   	push   %ebx
f01102a8:	50                   	push   %eax
f01102a9:	68 bc 98 13 f0       	push   $0xf01398bc
f01102ae:	68 5c 01 00 00       	push   $0x15c
f01102b3:	68 96 97 13 f0       	push   $0xf0139796
f01102b8:	e8 f2 0b ff ff       	call   f0100eaf <_panic>
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f01102bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01102c0:	8b 40 28             	mov    0x28(%eax),%eax
f01102c3:	83 f8 1f             	cmp    $0x1f,%eax
f01102c6:	76 1b                	jbe    f01102e3 <trap+0x197>
f01102c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01102cb:	8b 40 28             	mov    0x28(%eax),%eax
f01102ce:	83 f8 2f             	cmp    $0x2f,%eax
f01102d1:	77 10                	ja     f01102e3 <trap+0x197>
	{
		irq_dispatch(tf);
f01102d3:	83 ec 0c             	sub    $0xc,%esp
f01102d6:	ff 75 08             	pushl  0x8(%ebp)
f01102d9:	e8 d6 fc ff ff       	call   f010ffb4 <irq_dispatch>
f01102de:	83 c4 10             	add    $0x10,%esp
f01102e1:	eb 0e                	jmp    f01102f1 <trap+0x1a5>
	}
	else
	{
		trap_dispatch(tf);
f01102e3:	83 ec 0c             	sub    $0xc,%esp
f01102e6:	ff 75 08             	pushl  0x8(%ebp)
f01102e9:	e8 0e fd ff ff       	call   f010fffc <trap_dispatch>
f01102ee:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01102f1:	9c                   	pushf  
f01102f2:	58                   	pop    %eax
f01102f3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        return eflags;
f01102f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f01102f9:	25 00 02 00 00       	and    $0x200,%eax
f01102fe:	89 45 cc             	mov    %eax,-0x34(%ebp)
	assert(IEN == 0);
f0110301:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0110305:	74 19                	je     f0110320 <trap+0x1d4>
f0110307:	68 1c 99 13 f0       	push   $0xf013991c
f011030c:	68 52 98 13 f0       	push   $0xf0139852
f0110311:	68 73 01 00 00       	push   $0x173
f0110316:	68 96 97 13 f0       	push   $0xf0139796
f011031b:	e8 8f 0b ff ff       	call   f0100eaf <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f0110320:	e8 28 5a ff ff       	call   f0105d4d <kclock_resume>
	//cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f0110325:	90                   	nop
f0110326:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0110329:	5b                   	pop    %ebx
f011032a:	5e                   	pop    %esi
f011032b:	5f                   	pop    %edi
f011032c:	5d                   	pop    %ebp
f011032d:	c3                   	ret    

f011032e <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f011032e:	6a 08                	push   $0x8
f0110330:	e9 ed 00 00 00       	jmp    f0110422 <_alltraps>
f0110335:	90                   	nop

f0110336 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f0110336:	6a 0e                	push   $0xe
f0110338:	e9 e5 00 00 00       	jmp    f0110422 <_alltraps>
f011033d:	90                   	nop

f011033e <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f011033e:	6a 00                	push   $0x0
f0110340:	6a 20                	push   $0x20
f0110342:	e9 db 00 00 00       	jmp    f0110422 <_alltraps>
f0110347:	90                   	nop

f0110348 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f0110348:	6a 00                	push   $0x0
f011034a:	6a 21                	push   $0x21
f011034c:	e9 d1 00 00 00       	jmp    f0110422 <_alltraps>
f0110351:	90                   	nop

f0110352 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f0110352:	6a 00                	push   $0x0
f0110354:	6a 30                	push   $0x30
f0110356:	e9 c7 00 00 00       	jmp    f0110422 <_alltraps>
f011035b:	90                   	nop

f011035c <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f011035c:	6a 00                	push   $0x0
f011035e:	6a 00                	push   $0x0
f0110360:	e9 bd 00 00 00       	jmp    f0110422 <_alltraps>
f0110365:	90                   	nop

f0110366 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f0110366:	6a 00                	push   $0x0
f0110368:	6a 01                	push   $0x1
f011036a:	e9 b3 00 00 00       	jmp    f0110422 <_alltraps>
f011036f:	90                   	nop

f0110370 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f0110370:	6a 00                	push   $0x0
f0110372:	6a 02                	push   $0x2
f0110374:	e9 a9 00 00 00       	jmp    f0110422 <_alltraps>
f0110379:	90                   	nop

f011037a <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f011037a:	6a 00                	push   $0x0
f011037c:	6a 03                	push   $0x3
f011037e:	e9 9f 00 00 00       	jmp    f0110422 <_alltraps>
f0110383:	90                   	nop

f0110384 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f0110384:	6a 00                	push   $0x0
f0110386:	6a 04                	push   $0x4
f0110388:	e9 95 00 00 00       	jmp    f0110422 <_alltraps>
f011038d:	90                   	nop

f011038e <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f011038e:	6a 00                	push   $0x0
f0110390:	6a 05                	push   $0x5
f0110392:	e9 8b 00 00 00       	jmp    f0110422 <_alltraps>
f0110397:	90                   	nop

f0110398 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f0110398:	6a 00                	push   $0x0
f011039a:	6a 06                	push   $0x6
f011039c:	e9 81 00 00 00       	jmp    f0110422 <_alltraps>
f01103a1:	90                   	nop

f01103a2 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f01103a2:	6a 00                	push   $0x0
f01103a4:	6a 07                	push   $0x7
f01103a6:	eb 7a                	jmp    f0110422 <_alltraps>

f01103a8 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f01103a8:	6a 0a                	push   $0xa
f01103aa:	eb 76                	jmp    f0110422 <_alltraps>

f01103ac <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f01103ac:	6a 0b                	push   $0xb
f01103ae:	eb 72                	jmp    f0110422 <_alltraps>

f01103b0 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f01103b0:	6a 0c                	push   $0xc
f01103b2:	eb 6e                	jmp    f0110422 <_alltraps>

f01103b4 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f01103b4:	6a 0d                	push   $0xd
f01103b6:	eb 6a                	jmp    f0110422 <_alltraps>

f01103b8 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f01103b8:	6a 00                	push   $0x0
f01103ba:	6a 10                	push   $0x10
f01103bc:	eb 64                	jmp    f0110422 <_alltraps>

f01103be <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f01103be:	6a 11                	push   $0x11
f01103c0:	eb 60                	jmp    f0110422 <_alltraps>

f01103c2 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f01103c2:	6a 00                	push   $0x0
f01103c4:	6a 12                	push   $0x12
f01103c6:	eb 5a                	jmp    f0110422 <_alltraps>

f01103c8 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f01103c8:	6a 00                	push   $0x0
f01103ca:	6a 13                	push   $0x13
f01103cc:	eb 54                	jmp    f0110422 <_alltraps>

f01103ce <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f01103ce:	6a 00                	push   $0x0
f01103d0:	6a 22                	push   $0x22
f01103d2:	eb 4e                	jmp    f0110422 <_alltraps>

f01103d4 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f01103d4:	6a 00                	push   $0x0
f01103d6:	6a 23                	push   $0x23
f01103d8:	eb 48                	jmp    f0110422 <_alltraps>

f01103da <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f01103da:	6a 00                	push   $0x0
f01103dc:	6a 24                	push   $0x24
f01103de:	eb 42                	jmp    f0110422 <_alltraps>

f01103e0 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f01103e0:	6a 00                	push   $0x0
f01103e2:	6a 25                	push   $0x25
f01103e4:	eb 3c                	jmp    f0110422 <_alltraps>

f01103e6 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f01103e6:	6a 00                	push   $0x0
f01103e8:	6a 26                	push   $0x26
f01103ea:	eb 36                	jmp    f0110422 <_alltraps>

f01103ec <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f01103ec:	6a 00                	push   $0x0
f01103ee:	6a 27                	push   $0x27
f01103f0:	eb 30                	jmp    f0110422 <_alltraps>

f01103f2 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f01103f2:	6a 00                	push   $0x0
f01103f4:	6a 28                	push   $0x28
f01103f6:	eb 2a                	jmp    f0110422 <_alltraps>

f01103f8 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f01103f8:	6a 00                	push   $0x0
f01103fa:	6a 29                	push   $0x29
f01103fc:	eb 24                	jmp    f0110422 <_alltraps>

f01103fe <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f01103fe:	6a 00                	push   $0x0
f0110400:	6a 2a                	push   $0x2a
f0110402:	eb 1e                	jmp    f0110422 <_alltraps>

f0110404 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f0110404:	6a 00                	push   $0x0
f0110406:	6a 2b                	push   $0x2b
f0110408:	eb 18                	jmp    f0110422 <_alltraps>

f011040a <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f011040a:	6a 00                	push   $0x0
f011040c:	6a 2c                	push   $0x2c
f011040e:	eb 12                	jmp    f0110422 <_alltraps>

f0110410 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f0110410:	6a 00                	push   $0x0
f0110412:	6a 2d                	push   $0x2d
f0110414:	eb 0c                	jmp    f0110422 <_alltraps>

f0110416 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f0110416:	6a 00                	push   $0x0
f0110418:	6a 2e                	push   $0x2e
f011041a:	eb 06                	jmp    f0110422 <_alltraps>

f011041c <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f011041c:	6a 00                	push   $0x0
f011041e:	6a 2f                	push   $0x2f
f0110420:	eb 00                	jmp    f0110422 <_alltraps>

f0110422 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f0110422:	1e                   	push   %ds
push 	%es
f0110423:	06                   	push   %es
pushal
f0110424:	60                   	pusha  

mov 	$(GD_KD), %ax
f0110425:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f0110429:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f011042b:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f011042d:	54                   	push   %esp
call 	trap
f011042e:	e8 19 fd ff ff       	call   f011014c <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f0110433:	59                   	pop    %ecx

f0110434 <trapret>:
.globl trapret
trapret:
popal
f0110434:	61                   	popa   
pop 	%es
f0110435:	07                   	pop    %es
pop 	%ds
f0110436:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f0110437:	83 c4 08             	add    $0x8,%esp
iret
f011043a:	cf                   	iret   

f011043b <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName, int color)
{
f011043b:	55                   	push   %ebp
f011043c:	89 e5                	mov    %esp,%ebp
f011043e:	83 ec 28             	sub    $0x28,%esp
f0110441:	8b 45 10             	mov    0x10(%ebp),%eax
f0110444:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0110447:	e8 fc d1 ff ff       	call   f010d648 <get_cpu_proc>
f011044c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f011044f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110453:	75 16                	jne    f011046b <sys_cputs+0x30>
f0110455:	68 d0 9a 13 f0       	push   $0xf0139ad0
f011045a:	68 e0 9a 13 f0       	push   $0xf0139ae0
f011045f:	6a 22                	push   $0x22
f0110461:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110466:	e8 44 0a ff ff       	call   f0100eaf <_panic>

	pushcli();	//disable interrupts
f011046b:	e8 52 81 ff ff       	call   f01085c2 <pushcli>
	{
		// Check that the user has permission to read memory [s, s+len).
		// Destroy the environment if not.
		current_text_color = color; // setting text color to be used in cga_putc()
f0110470:	8b 45 14             	mov    0x14(%ebp),%eax
f0110473:	a3 90 51 96 f1       	mov    %eax,0xf1965190
		{
			// Print the string supplied by the user.
			if (printProgName)
f0110478:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f011047c:	74 1e                	je     f011049c <sys_cputs+0x61>
				cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f011047e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110481:	8b 40 10             	mov    0x10(%eax),%eax
f0110484:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110487:	83 c2 20             	add    $0x20,%edx
f011048a:	83 ec 04             	sub    $0x4,%esp
f011048d:	50                   	push   %eax
f011048e:	52                   	push   %edx
f011048f:	68 09 9b 13 f0       	push   $0xf0139b09
f0110494:	e8 b4 16 ff ff       	call   f0101b4d <cprintf>
f0110499:	83 c4 10             	add    $0x10,%esp
			cprintf("%.*s",len, s);
f011049c:	83 ec 04             	sub    $0x4,%esp
f011049f:	ff 75 08             	pushl  0x8(%ebp)
f01104a2:	ff 75 0c             	pushl  0xc(%ebp)
f01104a5:	68 12 9b 13 f0       	push   $0xf0139b12
f01104aa:	e8 9e 16 ff ff       	call   f0101b4d <cprintf>
f01104af:	83 c4 10             	add    $0x10,%esp
		}
		current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f01104b2:	c7 05 90 51 96 f1 00 	movl   $0x700,0xf1965190
f01104b9:	07 00 00 
	}
	popcli();	//enable interrupts
f01104bc:	e8 53 81 ff ff       	call   f0108614 <popcli>
}
f01104c1:	90                   	nop
f01104c2:	c9                   	leave  
f01104c3:	c3                   	ret    

f01104c4 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f01104c4:	55                   	push   %ebp
f01104c5:	89 e5                	mov    %esp,%ebp
f01104c7:	83 ec 18             	sub    $0x18,%esp
f01104ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01104cd:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f01104d0:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f01104d4:	83 ec 08             	sub    $0x8,%esp
f01104d7:	50                   	push   %eax
f01104d8:	68 17 9b 13 f0       	push   $0xf0139b17
f01104dd:	e8 6b 16 ff ff       	call   f0101b4d <cprintf>
f01104e2:	83 c4 10             	add    $0x10,%esp
}
f01104e5:	90                   	nop
f01104e6:	c9                   	leave  
f01104e7:	c3                   	ret    

f01104e8 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f01104e8:	55                   	push   %ebp
f01104e9:	89 e5                	mov    %esp,%ebp
f01104eb:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01104ee:	9c                   	pushf  
f01104ef:	58                   	pop    %eax
f01104f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f01104f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f01104f6:	25 00 02 00 00       	and    $0x200,%eax
f01104fb:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f01104fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110502:	74 22                	je     f0110526 <sys_cgetc+0x3e>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f0110504:	eb 10                	jmp    f0110516 <sys_cgetc+0x2e>
				}
				release_kspinlock(&KBDlock);
			}
			else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
			{
				wait_ksemaphore(&KBDsem);
f0110506:	83 ec 0c             	sub    $0xc,%esp
f0110509:	68 c0 51 96 f1       	push   $0xf19651c0
f011050e:	e8 65 36 00 00       	call   f0113b78 <wait_ksemaphore>
f0110513:	83 c4 10             	add    $0x10,%esp
	int IEN = read_eflags() & FL_IF;

	if (IEN) /*Interrupt-Enabled I/O*/
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f0110516:	e8 4e 14 ff ff       	call   f0101969 <cons_getc2>
f011051b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011051e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110522:	74 e2                	je     f0110506 <sys_cgetc+0x1e>
f0110524:	eb 0e                	jmp    f0110534 <sys_cgetc+0x4c>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f0110526:	e8 e3 13 ff ff       	call   f010190e <cons_getc>
f011052b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011052e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110532:	74 f2                	je     f0110526 <sys_cgetc+0x3e>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f0110534:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110537:	c9                   	leave  
f0110538:	c3                   	ret    

f0110539 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f0110539:	55                   	push   %ebp
f011053a:	89 e5                	mov    %esp,%ebp
f011053c:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f011053f:	e8 8a 15 ff ff       	call   f0101ace <cons_lock>
}
f0110544:	90                   	nop
f0110545:	c9                   	leave  
f0110546:	c3                   	ret    

f0110547 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f0110547:	55                   	push   %ebp
f0110548:	89 e5                	mov    %esp,%ebp
f011054a:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f011054d:	e8 95 15 ff ff       	call   f0101ae7 <cons_unlock>
}
f0110552:	90                   	nop
f0110553:	c9                   	leave  
f0110554:	c3                   	ret    

f0110555 <__sys_allocate_page>:
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f0110555:	55                   	push   %ebp
f0110556:	89 e5                	mov    %esp,%ebp
f0110558:	83 ec 18             	sub    $0x18,%esp
	//   map_frame() from kern/mem/memory_manager.c.
	//   Most of the new code you write should be to check the
	//   parameters for correctness.
	//   If map_frame() fails, remember to free the page you allocated!

	struct Env* cur_env = get_cpu_proc();
f011055b:	e8 e8 d0 ff ff       	call   f010d648 <get_cpu_proc>
f0110560:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f0110563:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110567:	75 07                	jne    f0110570 <__sys_allocate_page+0x1b>
		return E_BAD_ENV;
f0110569:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f011056e:	eb 5d                	jmp    f01105cd <__sys_allocate_page+0x78>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f0110570:	8b 45 08             	mov    0x8(%ebp),%eax
f0110573:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0110578:	77 0c                	ja     f0110586 <__sys_allocate_page+0x31>
f011057a:	8b 45 08             	mov    0x8(%ebp),%eax
f011057d:	25 ff 0f 00 00       	and    $0xfff,%eax
f0110582:	85 c0                	test   %eax,%eax
f0110584:	74 07                	je     f011058d <__sys_allocate_page+0x38>
		return E_INVAL;
f0110586:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f011058b:	eb 40                	jmp    f01105cd <__sys_allocate_page+0x78>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f011058d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110590:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f0110595:	83 f8 04             	cmp    $0x4,%eax
f0110598:	74 07                	je     f01105a1 <__sys_allocate_page+0x4c>
		return E_INVAL;
f011059a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f011059f:	eb 2c                	jmp    f01105cd <__sys_allocate_page+0x78>

	int ret = alloc_page(cur_env->env_page_directory, (uint32)va, perm, 1);
f01105a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01105a4:	8b 55 08             	mov    0x8(%ebp),%edx
f01105a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105aa:	8b 40 64             	mov    0x64(%eax),%eax
f01105ad:	6a 01                	push   $0x1
f01105af:	51                   	push   %ecx
f01105b0:	52                   	push   %edx
f01105b1:	50                   	push   %eax
f01105b2:	e8 23 b1 ff ff       	call   f010b6da <alloc_page>
f01105b7:	83 c4 10             	add    $0x10,%esp
f01105ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret == E_NO_MEM)
f01105bd:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f01105c1:	75 05                	jne    f01105c8 <__sys_allocate_page+0x73>
		return ret ;
f01105c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01105c6:	eb 05                	jmp    f01105cd <__sys_allocate_page+0x78>

	return 0 ;
f01105c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105cd:	c9                   	leave  
f01105ce:	c3                   	ret    

f01105cf <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f01105cf:	55                   	push   %ebp
f01105d0:	89 e5                	mov    %esp,%ebp
f01105d2:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f01105d5:	83 ec 04             	sub    $0x4,%esp
f01105d8:	68 1a 9b 13 f0       	push   $0xf0139b1a
f01105dd:	68 bb 00 00 00       	push   $0xbb
f01105e2:	68 f5 9a 13 f0       	push   $0xf0139af5
f01105e7:	e8 c3 08 ff ff       	call   f0100eaf <_panic>

f01105ec <__sys_unmap_frame>:
//
// Return 0 on success, < 0 on error.  Errors are:
//	E_BAD_ENV if environment doesn't currently exist,
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
static int __sys_unmap_frame(uint32 va)
{
f01105ec:	55                   	push   %ebp
f01105ed:	89 e5                	mov    %esp,%ebp
f01105ef:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f01105f2:	e8 51 d0 ff ff       	call   f010d648 <get_cpu_proc>
f01105f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f01105fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01105fe:	75 07                	jne    f0110607 <__sys_unmap_frame+0x1b>
		return E_BAD_ENV;
f0110600:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0110605:	eb 36                	jmp    f011063d <__sys_unmap_frame+0x51>

	if (va >= USER_TOP || va % PAGE_SIZE != 0)
f0110607:	81 7d 08 ff ff bf ee 	cmpl   $0xeebfffff,0x8(%ebp)
f011060e:	77 0c                	ja     f011061c <__sys_unmap_frame+0x30>
f0110610:	8b 45 08             	mov    0x8(%ebp),%eax
f0110613:	25 ff 0f 00 00       	and    $0xfff,%eax
f0110618:	85 c0                	test   %eax,%eax
f011061a:	74 07                	je     f0110623 <__sys_unmap_frame+0x37>
		return E_INVAL;
f011061c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f0110621:	eb 1a                	jmp    f011063d <__sys_unmap_frame+0x51>

	unmap_frame(cur_env->env_page_directory, va);
f0110623:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110626:	8b 40 64             	mov    0x64(%eax),%eax
f0110629:	83 ec 08             	sub    $0x8,%esp
f011062c:	ff 75 08             	pushl  0x8(%ebp)
f011062f:	50                   	push   %eax
f0110630:	e8 37 96 ff ff       	call   f0109c6c <unmap_frame>
f0110635:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110638:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011063d:	c9                   	leave  
f011063e:	c3                   	ret    

f011063f <sys_calculate_required_frames>:

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f011063f:	55                   	push   %ebp
f0110640:	89 e5                	mov    %esp,%ebp
f0110642:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110645:	e8 fe cf ff ff       	call   f010d648 <get_cpu_proc>
f011064a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f011064d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110651:	75 19                	jne    f011066c <sys_calculate_required_frames+0x2d>
f0110653:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110658:	68 e0 9a 13 f0       	push   $0xf0139ae0
f011065d:	68 d6 00 00 00       	push   $0xd6
f0110662:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110667:	e8 43 08 ff ff       	call   f0100eaf <_panic>

	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f011066c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011066f:	8b 40 64             	mov    0x64(%eax),%eax
f0110672:	83 ec 04             	sub    $0x4,%esp
f0110675:	ff 75 0c             	pushl  0xc(%ebp)
f0110678:	ff 75 08             	pushl  0x8(%ebp)
f011067b:	50                   	push   %eax
f011067c:	e8 d6 bf ff ff       	call   f010c657 <calculate_required_frames>
f0110681:	83 c4 10             	add    $0x10,%esp
}
f0110684:	c9                   	leave  
f0110685:	c3                   	ret    

f0110686 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f0110686:	55                   	push   %ebp
f0110687:	89 e5                	mov    %esp,%ebp
f0110689:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f011068c:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011068f:	83 ec 0c             	sub    $0xc,%esp
f0110692:	50                   	push   %eax
f0110693:	e8 56 97 ff ff       	call   f0109dee <calculate_available_frames>
f0110698:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f011069b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011069e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01106a1:	01 d0                	add    %edx,%eax
}
f01106a3:	c9                   	leave  
f01106a4:	c3                   	ret    

f01106a5 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f01106a5:	55                   	push   %ebp
f01106a6:	89 e5                	mov    %esp,%ebp
f01106a8:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f01106ab:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01106ae:	83 ec 0c             	sub    $0xc,%esp
f01106b1:	50                   	push   %eax
f01106b2:	e8 37 97 ff ff       	call   f0109dee <calculate_available_frames>
f01106b7:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f01106ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01106bd:	c9                   	leave  
f01106be:	c3                   	ret    

f01106bf <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f01106bf:	55                   	push   %ebp
f01106c0:	89 e5                	mov    %esp,%ebp
f01106c2:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f01106c5:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01106c8:	83 ec 0c             	sub    $0xc,%esp
f01106cb:	50                   	push   %eax
f01106cc:	e8 1d 97 ff ff       	call   f0109dee <calculate_available_frames>
f01106d1:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f01106d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01106d7:	c9                   	leave  
f01106d8:	c3                   	ret    

f01106d9 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f01106d9:	55                   	push   %ebp
f01106da:	89 e5                	mov    %esp,%ebp
f01106dc:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f01106df:	83 ec 0c             	sub    $0xc,%esp
f01106e2:	ff 75 08             	pushl  0x8(%ebp)
f01106e5:	e8 34 14 01 00       	call   f0121b1e <calc_no_pages_tobe_removed_from_ready_exit_queues>
f01106ea:	83 c4 10             	add    $0x10,%esp
}
f01106ed:	c9                   	leave  
f01106ee:	c3                   	ret    

f01106ef <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f01106ef:	55                   	push   %ebp
f01106f0:	89 e5                	mov    %esp,%ebp
f01106f2:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f01106f5:	e8 4f 13 01 00       	call   f0121a49 <scarce_memory>
}
f01106fa:	90                   	nop
f01106fb:	c9                   	leave  
f01106fc:	c3                   	ret    

f01106fd <sys_clearFFL>:

void sys_clearFFL()
{
f01106fd:	55                   	push   %ebp
f01106fe:	89 e5                	mov    %esp,%ebp
f0110700:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
f0110703:	83 ec 0c             	sub    $0xc,%esp
f0110706:	68 80 ce 94 f1       	push   $0xf194ce80
f011070b:	e8 35 2e 00 00       	call   f0113545 <acquire_kspinlock>
f0110710:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f0110713:	a1 6c ce 94 f1       	mov    0xf194ce6c,%eax
f0110718:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f011071b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110722:	eb 12                	jmp    f0110736 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f0110724:	83 ec 0c             	sub    $0xc,%esp
f0110727:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011072a:	50                   	push   %eax
f011072b:	e8 26 8f ff ff       	call   f0109656 <allocate_frame>
f0110730:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f0110733:	ff 45 f4             	incl   -0xc(%ebp)
f0110736:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110739:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011073c:	7c e6                	jl     f0110724 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f011073e:	83 ec 0c             	sub    $0xc,%esp
f0110741:	68 80 ce 94 f1       	push   $0xf194ce80
f0110746:	e8 9f 2e 00 00       	call   f01135ea <release_kspinlock>
f011074b:	83 c4 10             	add    $0x10,%esp
}
f011074e:	90                   	nop
f011074f:	c9                   	leave  
f0110750:	c3                   	ret    

f0110751 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f0110751:	55                   	push   %ebp
f0110752:	89 e5                	mov    %esp,%ebp
f0110754:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110757:	e8 ec ce ff ff       	call   f010d648 <get_cpu_proc>
f011075c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f011075f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110763:	75 19                	jne    f011077e <sys_pf_calculate_allocated_pages+0x2d>
f0110765:	68 d0 9a 13 f0       	push   $0xf0139ad0
f011076a:	68 e0 9a 13 f0       	push   $0xf0139ae0
f011076f:	68 0e 01 00 00       	push   $0x10e
f0110774:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110779:	e8 31 07 ff ff       	call   f0100eaf <_panic>

	return pf_calculate_allocated_pages(cur_env);
f011077e:	83 ec 0c             	sub    $0xc,%esp
f0110781:	ff 75 f4             	pushl  -0xc(%ebp)
f0110784:	e8 0a 51 ff ff       	call   f0105893 <pf_calculate_allocated_pages>
f0110789:	83 c4 10             	add    $0x10,%esp
}
f011078c:	c9                   	leave  
f011078d:	c3                   	ret    

f011078e <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f011078e:	55                   	push   %ebp
f011078f:	89 e5                	mov    %esp,%ebp
f0110791:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110794:	e8 af ce ff ff       	call   f010d648 <get_cpu_proc>
f0110799:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f011079c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01107a0:	75 19                	jne    f01107bb <sys_free_user_mem+0x2d>
f01107a2:	68 d0 9a 13 f0       	push   $0xf0139ad0
f01107a7:	68 e0 9a 13 f0       	push   $0xf0139ae0
f01107ac:	68 19 01 00 00       	push   $0x119
f01107b1:	68 f5 9a 13 f0       	push   $0xf0139af5
f01107b6:	e8 f4 06 ff ff       	call   f0100eaf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f01107bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01107bf:	74 2b                	je     f01107ec <sys_free_user_mem+0x5e>
f01107c1:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f01107c8:	77 22                	ja     f01107ec <sys_free_user_mem+0x5e>
f01107ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01107cd:	85 c0                	test   %eax,%eax
f01107cf:	79 1b                	jns    f01107ec <sys_free_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f01107d1:	8b 55 08             	mov    0x8(%ebp),%edx
f01107d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107d7:	01 d0                	add    %edx,%eax
f01107d9:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f01107de:	77 0c                	ja     f01107ec <sys_free_user_mem+0x5e>
f01107e0:	8b 55 08             	mov    0x8(%ebp),%edx
f01107e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107e6:	01 d0                	add    %edx,%eax
f01107e8:	85 c0                	test   %eax,%eax
f01107ea:	78 15                	js     f0110801 <sys_free_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f01107ec:	83 ec 0c             	sub    $0xc,%esp
f01107ef:	68 38 9b 13 f0       	push   $0xf0139b38
f01107f4:	e8 54 13 ff ff       	call   f0101b4d <cprintf>
f01107f9:	83 c4 10             	add    $0x10,%esp
		env_exit();
f01107fc:	e8 05 ce ff ff       	call   f010d606 <env_exit>
	}

	if(isBufferingEnabled())
f0110801:	e8 56 0f 00 00       	call   f011175c <isBufferingEnabled>
f0110806:	84 c0                	test   %al,%al
f0110808:	74 16                	je     f0110820 <sys_free_user_mem+0x92>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f011080a:	83 ec 04             	sub    $0x4,%esp
f011080d:	ff 75 0c             	pushl  0xc(%ebp)
f0110810:	ff 75 08             	pushl  0x8(%ebp)
f0110813:	ff 75 f4             	pushl  -0xc(%ebp)
f0110816:	e8 a1 c0 ff ff       	call   f010c8bc <__free_user_mem_with_buffering>
f011081b:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f011081e:	eb 15                	jmp    f0110835 <sys_free_user_mem+0xa7>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f0110820:	83 ec 04             	sub    $0x4,%esp
f0110823:	ff 75 0c             	pushl  0xc(%ebp)
f0110826:	ff 75 08             	pushl  0x8(%ebp)
f0110829:	ff 75 f4             	pushl  -0xc(%ebp)
f011082c:	e8 b3 bf ff ff       	call   f010c7e4 <free_user_mem>
f0110831:	83 c4 10             	add    $0x10,%esp
	}
	return;
f0110834:	90                   	nop
}
f0110835:	c9                   	leave  
f0110836:	c3                   	ret    

f0110837 <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f0110837:	55                   	push   %ebp
f0110838:	89 e5                	mov    %esp,%ebp
f011083a:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f011083d:	e8 06 ce ff ff       	call   f010d648 <get_cpu_proc>
f0110842:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110845:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110849:	75 19                	jne    f0110864 <sys_allocate_user_mem+0x2d>
f011084b:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110850:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110855:	68 30 01 00 00       	push   $0x130
f011085a:	68 f5 9a 13 f0       	push   $0xf0139af5
f011085f:	e8 4b 06 ff ff       	call   f0100eaf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f0110864:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110868:	74 2b                	je     f0110895 <sys_allocate_user_mem+0x5e>
f011086a:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f0110871:	77 22                	ja     f0110895 <sys_allocate_user_mem+0x5e>
f0110873:	8b 45 08             	mov    0x8(%ebp),%eax
f0110876:	85 c0                	test   %eax,%eax
f0110878:	79 1b                	jns    f0110895 <sys_allocate_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f011087a:	8b 55 08             	mov    0x8(%ebp),%edx
f011087d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110880:	01 d0                	add    %edx,%eax
f0110882:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f0110887:	77 0c                	ja     f0110895 <sys_allocate_user_mem+0x5e>
f0110889:	8b 55 08             	mov    0x8(%ebp),%edx
f011088c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011088f:	01 d0                	add    %edx,%eax
f0110891:	85 c0                	test   %eax,%eax
f0110893:	78 15                	js     f01108aa <sys_allocate_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f0110895:	83 ec 0c             	sub    $0xc,%esp
f0110898:	68 38 9b 13 f0       	push   $0xf0139b38
f011089d:	e8 ab 12 ff ff       	call   f0101b4d <cprintf>
f01108a2:	83 c4 10             	add    $0x10,%esp
		env_exit();
f01108a5:	e8 5c cd ff ff       	call   f010d606 <env_exit>
	}
	allocate_user_mem(cur_env, virtual_address, size);
f01108aa:	83 ec 04             	sub    $0x4,%esp
f01108ad:	ff 75 0c             	pushl  0xc(%ebp)
f01108b0:	ff 75 08             	pushl  0x8(%ebp)
f01108b3:	ff 75 f4             	pushl  -0xc(%ebp)
f01108b6:	e8 d3 bd ff ff       	call   f010c68e <allocate_user_mem>
f01108bb:	83 c4 10             	add    $0x10,%esp
	return;
f01108be:	90                   	nop
}
f01108bf:	c9                   	leave  
f01108c0:	c3                   	ret    

f01108c1 <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f01108c1:	55                   	push   %ebp
f01108c2:	89 e5                	mov    %esp,%ebp
f01108c4:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f01108c7:	e8 7c cd ff ff       	call   f010d648 <get_cpu_proc>
f01108cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f01108cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01108d3:	75 19                	jne    f01108ee <sys_allocate_chunk+0x2d>
f01108d5:	68 d0 9a 13 f0       	push   $0xf0139ad0
f01108da:	68 e0 9a 13 f0       	push   $0xf0139ae0
f01108df:	68 3f 01 00 00       	push   $0x13f
f01108e4:	68 f5 9a 13 f0       	push   $0xf0139af5
f01108e9:	e8 c1 05 ff ff       	call   f0100eaf <_panic>

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f01108ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01108f1:	8b 40 64             	mov    0x64(%eax),%eax
f01108f4:	ff 75 10             	pushl  0x10(%ebp)
f01108f7:	ff 75 0c             	pushl  0xc(%ebp)
f01108fa:	ff 75 08             	pushl  0x8(%ebp)
f01108fd:	50                   	push   %eax
f01108fe:	e8 06 bd ff ff       	call   f010c609 <allocate_chunk>
f0110903:	83 c4 10             	add    $0x10,%esp
	return;
f0110906:	90                   	nop
}
f0110907:	c9                   	leave  
f0110908:	c3                   	ret    

f0110909 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f0110909:	55                   	push   %ebp
f011090a:	89 e5                	mov    %esp,%ebp
f011090c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f011090f:	e8 34 cd ff ff       	call   f010d648 <get_cpu_proc>
f0110914:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110917:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011091b:	75 19                	jne    f0110936 <sys_move_user_mem+0x2d>
f011091d:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110922:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110927:	68 49 01 00 00       	push   $0x149
f011092c:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110931:	e8 79 05 ff ff       	call   f0100eaf <_panic>

	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f0110936:	ff 75 10             	pushl  0x10(%ebp)
f0110939:	ff 75 0c             	pushl  0xc(%ebp)
f011093c:	ff 75 08             	pushl  0x8(%ebp)
f011093f:	ff 75 f4             	pushl  -0xc(%ebp)
f0110942:	e8 92 bf ff ff       	call   f010c8d9 <move_user_mem>
f0110947:	83 c4 10             	add    $0x10,%esp
	return;
f011094a:	90                   	nop
}
f011094b:	c9                   	leave  
f011094c:	c3                   	ret    

f011094d <sys_env_set_priority>:

void sys_env_set_priority(int32 envID, int priority)
{
f011094d:	55                   	push   %ebp
f011094e:	89 e5                	mov    %esp,%ebp
f0110950:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 System Calls - Add suitable code here
#if USE_KHEAP
	if(priority<0 || priority>=num_of_ready_queues)return;
f0110953:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0110957:	78 21                	js     f011097a <sys_env_set_priority+0x2d>
f0110959:	a0 00 54 96 f1       	mov    0xf1965400,%al
f011095e:	0f b6 c0             	movzbl %al,%eax
f0110961:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110964:	7e 14                	jle    f011097a <sys_env_set_priority+0x2d>
	env_set_priority(envID, priority);
f0110966:	83 ec 08             	sub    $0x8,%esp
f0110969:	ff 75 0c             	pushl  0xc(%ebp)
f011096c:	ff 75 08             	pushl  0x8(%ebp)
f011096f:	e8 f4 6d ff ff       	call   f0107768 <env_set_priority>
f0110974:	83 c4 10             	add    $0x10,%esp
	return;
f0110977:	90                   	nop
f0110978:	eb 01                	jmp    f011097b <sys_env_set_priority+0x2e>

void sys_env_set_priority(int32 envID, int priority)
{
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 System Calls - Add suitable code here
#if USE_KHEAP
	if(priority<0 || priority>=num_of_ready_queues)return;
f011097a:	90                   	nop
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

	//Comment the following line
	//panic("sys_env_set_priority() is not implemented yet...!!");
}
f011097b:	c9                   	leave  
f011097c:	c3                   	ret    

f011097d <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f011097d:	55                   	push   %ebp
f011097e:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f0110980:	a1 88 51 96 f1       	mov    0xf1965188,%eax
}
f0110985:	5d                   	pop    %ebp
f0110986:	c3                   	ret    

f0110987 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f0110987:	55                   	push   %ebp
f0110988:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f011098a:	8b 45 08             	mov    0x8(%ebp),%eax
f011098d:	a3 88 51 96 f1       	mov    %eax,0xf1965188
}
f0110992:	90                   	nop
f0110993:	5d                   	pop    %ebp
f0110994:	c3                   	ret    

f0110995 <sys_create_shared_object>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_create_shared_object(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0110995:	55                   	push   %ebp
f0110996:	89 e5                	mov    %esp,%ebp
f0110998:	83 ec 28             	sub    $0x28,%esp
f011099b:	8b 45 10             	mov    0x10(%ebp),%eax
f011099e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f01109a1:	e8 a2 cc ff ff       	call   f010d648 <get_cpu_proc>
f01109a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f01109a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01109ad:	75 19                	jne    f01109c8 <sys_create_shared_object+0x33>
f01109af:	68 d0 9a 13 f0       	push   $0xf0139ad0
f01109b4:	68 e0 9a 13 f0       	push   $0xf0139ae0
f01109b9:	68 73 01 00 00       	push   $0x173
f01109be:	68 f5 9a 13 f0       	push   $0xf0139af5
f01109c3:	e8 e7 04 ff ff       	call   f0100eaf <_panic>

	return create_shared_object(cur_env->env_id, shareName, size, isWritable, virtual_address);
f01109c8:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
f01109cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01109cf:	8b 40 10             	mov    0x10(%eax),%eax
f01109d2:	83 ec 0c             	sub    $0xc,%esp
f01109d5:	ff 75 14             	pushl  0x14(%ebp)
f01109d8:	52                   	push   %edx
f01109d9:	ff 75 0c             	pushl  0xc(%ebp)
f01109dc:	ff 75 08             	pushl  0x8(%ebp)
f01109df:	50                   	push   %eax
f01109e0:	e8 69 97 ff ff       	call   f010a14e <create_shared_object>
f01109e5:	83 c4 20             	add    $0x20,%esp
}
f01109e8:	c9                   	leave  
f01109e9:	c3                   	ret    

f01109ea <sys_size_of_shared_object>:

int sys_size_of_shared_object(int32 ownerID, char* shareName)
{
f01109ea:	55                   	push   %ebp
f01109eb:	89 e5                	mov    %esp,%ebp
f01109ed:	83 ec 08             	sub    $0x8,%esp
	return size_of_shared_object(ownerID, shareName);
f01109f0:	83 ec 08             	sub    $0x8,%esp
f01109f3:	ff 75 0c             	pushl  0xc(%ebp)
f01109f6:	ff 75 08             	pushl  0x8(%ebp)
f01109f9:	e8 c5 95 ff ff       	call   f0109fc3 <size_of_shared_object>
f01109fe:	83 c4 10             	add    $0x10,%esp
}
f0110a01:	c9                   	leave  
f0110a02:	c3                   	ret    

f0110a03 <sys_get_shared_object>:

int sys_get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f0110a03:	55                   	push   %ebp
f0110a04:	89 e5                	mov    %esp,%ebp
f0110a06:	83 ec 08             	sub    $0x8,%esp
	return get_shared_object(ownerID, shareName, virtual_address);
f0110a09:	83 ec 04             	sub    $0x4,%esp
f0110a0c:	ff 75 10             	pushl  0x10(%ebp)
f0110a0f:	ff 75 0c             	pushl  0xc(%ebp)
f0110a12:	ff 75 08             	pushl  0x8(%ebp)
f0110a15:	e8 5d 9a ff ff       	call   f010a477 <get_shared_object>
f0110a1a:	83 c4 10             	add    $0x10,%esp
}
f0110a1d:	c9                   	leave  
f0110a1e:	c3                   	ret    

f0110a1f <sys_delete_shared_object>:

int sys_delete_shared_object(int32 sharedObjectID, void *startVA)
{
f0110a1f:	55                   	push   %ebp
f0110a20:	89 e5                	mov    %esp,%ebp
f0110a22:	83 ec 08             	sub    $0x8,%esp
	return delete_shared_object(sharedObjectID, startVA);
f0110a25:	83 ec 08             	sub    $0x8,%esp
f0110a28:	ff 75 0c             	pushl  0xc(%ebp)
f0110a2b:	ff 75 08             	pushl  0x8(%ebp)
f0110a2e:	e8 21 9c ff ff       	call   f010a654 <delete_shared_object>
f0110a33:	83 c4 10             	add    $0x10,%esp
}
f0110a36:	c9                   	leave  
f0110a37:	c3                   	ret    

f0110a38 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f0110a38:	55                   	push   %ebp
f0110a39:	89 e5                	mov    %esp,%ebp
f0110a3b:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110a3e:	e8 05 cc ff ff       	call   f010d648 <get_cpu_proc>
f0110a43:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110a46:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110a4a:	75 19                	jne    f0110a65 <sys_getenvid+0x2d>
f0110a4c:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110a51:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110a56:	68 8f 01 00 00       	push   $0x18f
f0110a5b:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110a60:	e8 4a 04 ff ff       	call   f0100eaf <_panic>

	return cur_env->env_id;
f0110a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110a68:	8b 40 10             	mov    0x10(%eax),%eax
}
f0110a6b:	c9                   	leave  
f0110a6c:	c3                   	ret    

f0110a6d <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f0110a6d:	55                   	push   %ebp
f0110a6e:	89 e5                	mov    %esp,%ebp
f0110a70:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110a73:	e8 d0 cb ff ff       	call   f010d648 <get_cpu_proc>
f0110a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110a7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110a7f:	75 19                	jne    f0110a9a <sys_getenvindex+0x2d>
f0110a81:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110a86:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110a8b:	68 98 01 00 00       	push   $0x198
f0110a90:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110a95:	e8 15 04 ff ff       	call   f0100eaf <_panic>

	//return cur_env->env_id;
	return (cur_env - envs) ;
f0110a9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110a9d:	8b 15 d0 40 92 f0    	mov    0xf09240d0,%edx
f0110aa3:	29 d0                	sub    %edx,%eax
f0110aa5:	c1 f8 02             	sar    $0x2,%eax
f0110aa8:	89 c2                	mov    %eax,%edx
f0110aaa:	89 d0                	mov    %edx,%eax
f0110aac:	c1 e0 07             	shl    $0x7,%eax
f0110aaf:	01 d0                	add    %edx,%eax
f0110ab1:	c1 e0 03             	shl    $0x3,%eax
f0110ab4:	01 d0                	add    %edx,%eax
f0110ab6:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f0110abd:	01 c8                	add    %ecx,%eax
f0110abf:	01 c0                	add    %eax,%eax
f0110ac1:	01 d0                	add    %edx,%eax
f0110ac3:	89 c1                	mov    %eax,%ecx
f0110ac5:	c1 e1 04             	shl    $0x4,%ecx
f0110ac8:	01 c8                	add    %ecx,%eax
f0110aca:	c1 e0 03             	shl    $0x3,%eax
f0110acd:	01 d0                	add    %edx,%eax
f0110acf:	89 c2                	mov    %eax,%edx
f0110ad1:	c1 e2 0a             	shl    $0xa,%edx
f0110ad4:	29 c2                	sub    %eax,%edx
f0110ad6:	89 d0                	mov    %edx,%eax
f0110ad8:	f7 d8                	neg    %eax
}
f0110ada:	c9                   	leave  
f0110adb:	c3                   	ret    

f0110adc <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f0110adc:	55                   	push   %ebp
f0110add:	89 e5                	mov    %esp,%ebp
f0110adf:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110ae2:	e8 61 cb ff ff       	call   f010d648 <get_cpu_proc>
f0110ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110aea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110aee:	75 19                	jne    f0110b09 <sys_getparentenvid+0x2d>
f0110af0:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110af5:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110afa:	68 a2 01 00 00       	push   $0x1a2
f0110aff:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110b04:	e8 a6 03 ff ff       	call   f0100eaf <_panic>

	return cur_env->env_parent_id;
f0110b09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b0c:	8b 40 14             	mov    0x14(%eax),%eax
}
f0110b0f:	c9                   	leave  
f0110b10:	c3                   	ret    

f0110b11 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f0110b11:	55                   	push   %ebp
f0110b12:	89 e5                	mov    %esp,%ebp
f0110b14:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0110b17:	e8 2c cb ff ff       	call   f010d648 <get_cpu_proc>
f0110b1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110b1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b23:	75 19                	jne    f0110b3e <sys_destroy_env+0x2d>
f0110b25:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110b2a:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110b2f:	68 b0 01 00 00       	push   $0x1b0
f0110b34:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110b39:	e8 71 03 ff ff       	call   f0100eaf <_panic>

	int r;
	struct Env *e;
	if (envid == 0)
f0110b3e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110b42:	75 08                	jne    f0110b4c <sys_destroy_env+0x3b>
	{
		e = cur_env ;
f0110b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b47:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110b4a:	eb 22                	jmp    f0110b6e <sys_destroy_env+0x5d>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f0110b4c:	83 ec 04             	sub    $0x4,%esp
f0110b4f:	6a 00                	push   $0x0
f0110b51:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0110b54:	50                   	push   %eax
f0110b55:	ff 75 08             	pushl  0x8(%ebp)
f0110b58:	e8 3b cb ff ff       	call   f010d698 <envid2env>
f0110b5d:	83 c4 10             	add    $0x10,%esp
f0110b60:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110b63:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110b67:	79 05                	jns    f0110b6e <sys_destroy_env+0x5d>
	{
		return r;
f0110b69:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110b6c:	eb 56                	jmp    f0110bc4 <sys_destroy_env+0xb3>
	}

	if (e == cur_env)
f0110b6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110b71:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110b74:	75 19                	jne    f0110b8f <sys_destroy_env+0x7e>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f0110b76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b79:	8b 40 10             	mov    0x10(%eax),%eax
f0110b7c:	83 ec 08             	sub    $0x8,%esp
f0110b7f:	50                   	push   %eax
f0110b80:	68 7e 9b 13 f0       	push   $0xf0139b7e
f0110b85:	e8 c3 0f ff ff       	call   f0101b4d <cprintf>
f0110b8a:	83 c4 10             	add    $0x10,%esp
f0110b8d:	eb 1e                	jmp    f0110bad <sys_destroy_env+0x9c>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f0110b8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110b92:	8b 50 10             	mov    0x10(%eax),%edx
f0110b95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b98:	8b 40 10             	mov    0x10(%eax),%eax
f0110b9b:	83 ec 04             	sub    $0x4,%esp
f0110b9e:	52                   	push   %edx
f0110b9f:	50                   	push   %eax
f0110ba0:	68 99 9b 13 f0       	push   $0xf0139b99
f0110ba5:	e8 a3 0f ff ff       	call   f0101b4d <cprintf>
f0110baa:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f0110bad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110bb0:	8b 40 10             	mov    0x10(%eax),%eax
f0110bb3:	83 ec 0c             	sub    $0xc,%esp
f0110bb6:	50                   	push   %eax
f0110bb7:	e8 73 5f ff ff       	call   f0106b2f <sched_kill_env>
f0110bbc:	83 c4 10             	add    $0x10,%esp

	return 0;
f0110bbf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110bc4:	c9                   	leave  
f0110bc5:	c3                   	ret    

f0110bc6 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f0110bc6:	55                   	push   %ebp
f0110bc7:	89 e5                	mov    %esp,%ebp
f0110bc9:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f0110bcc:	e8 35 ca ff ff       	call   f010d606 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f0110bd1:	90                   	nop
f0110bd2:	c9                   	leave  
f0110bd3:	c3                   	ret    

f0110bd4 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f0110bd4:	55                   	push   %ebp
f0110bd5:	89 e5                	mov    %esp,%ebp
f0110bd7:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f0110bda:	ff 75 14             	pushl  0x14(%ebp)
f0110bdd:	ff 75 10             	pushl  0x10(%ebp)
f0110be0:	ff 75 0c             	pushl  0xc(%ebp)
f0110be3:	ff 75 08             	pushl  0x8(%ebp)
f0110be6:	e8 a6 be ff ff       	call   f010ca91 <env_create>
f0110beb:	83 c4 10             	add    $0x10,%esp
f0110bee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f0110bf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110bf5:	75 07                	jne    f0110bfe <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f0110bf7:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f0110bfc:	eb 14                	jmp    f0110c12 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f0110bfe:	83 ec 0c             	sub    $0xc,%esp
f0110c01:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c04:	e8 8a 5b ff ff       	call   f0106793 <sched_new_env>
f0110c09:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f0110c0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c0f:	8b 40 10             	mov    0x10(%eax),%eax
}
f0110c12:	c9                   	leave  
f0110c13:	c3                   	ret    

f0110c14 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f0110c14:	55                   	push   %ebp
f0110c15:	89 e5                	mov    %esp,%ebp
f0110c17:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f0110c1a:	8b 45 08             	mov    0x8(%ebp),%eax
f0110c1d:	83 ec 0c             	sub    $0xc,%esp
f0110c20:	50                   	push   %eax
f0110c21:	e8 c3 5b ff ff       	call   f01067e9 <sched_run_env>
f0110c26:	83 c4 10             	add    $0x10,%esp
}
f0110c29:	90                   	nop
f0110c2a:	c9                   	leave  
f0110c2b:	c3                   	ret    

f0110c2c <sys_get_optimal_num_faults>:

//Calculate the number of page faults for the OPTIMAL replacement
int sys_get_optimal_num_faults()
{
f0110c2c:	55                   	push   %ebp
f0110c2d:	89 e5                	mov    %esp,%ebp
f0110c2f:	53                   	push   %ebx
f0110c30:	83 ec 24             	sub    $0x24,%esp
#if USE_KHEAP
	struct Env* cur_env = get_cpu_proc();
f0110c33:	e8 10 ca ff ff       	call   f010d648 <get_cpu_proc>
f0110c38:	89 45 ec             	mov    %eax,-0x14(%ebp)
	assert(cur_env != NULL);
f0110c3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110c3f:	75 19                	jne    f0110c5a <sys_get_optimal_num_faults+0x2e>
f0110c41:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110c46:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110c4b:	68 f7 01 00 00       	push   $0x1f7
f0110c50:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110c55:	e8 55 02 ff ff       	call   f0100eaf <_panic>

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
f0110c5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f0110c61:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110c64:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0110c6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110c6d:	eb 5d                	jmp    f0110ccc <sys_get_optimal_num_faults+0xa0>
	{
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
f0110c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c72:	8b 00                	mov    (%eax),%eax
f0110c74:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0110c77:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110c7a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c7f:	89 c3                	mov    %eax,%ebx
f0110c81:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110c84:	8b 88 c0 00 00 00    	mov    0xc0(%eax),%ecx
f0110c8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110c8d:	8d 50 01             	lea    0x1(%eax),%edx
f0110c90:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0110c93:	c1 e0 02             	shl    $0x2,%eax
f0110c96:	01 c8                	add    %ecx,%eax
f0110c98:	8b 00                	mov    (%eax),%eax
f0110c9a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0110c9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110ca0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110ca5:	39 c3                	cmp    %eax,%ebx
f0110ca7:	74 17                	je     f0110cc0 <sys_get_optimal_num_faults+0x94>
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
f0110ca9:	83 ec 04             	sub    $0x4,%esp
f0110cac:	68 b4 9b 13 f0       	push   $0xf0139bb4
f0110cb1:	68 ff 01 00 00       	push   $0x1ff
f0110cb6:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110cbb:	e8 ef 01 ff ff       	call   f0100eaf <_panic>
	struct Env* cur_env = get_cpu_proc();
	assert(cur_env != NULL);

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f0110cc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110cc3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0110cc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110ccc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110cd0:	74 08                	je     f0110cda <sys_get_optimal_num_faults+0xae>
f0110cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110cd5:	8b 40 10             	mov    0x10(%eax),%eax
f0110cd8:	eb 05                	jmp    f0110cdf <sys_get_optimal_num_faults+0xb3>
f0110cda:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cdf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110ce2:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0110ce8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110ceb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0110cf1:	85 c0                	test   %eax,%eax
f0110cf3:	0f 85 76 ff ff ff    	jne    f0110c6f <sys_get_optimal_num_faults+0x43>
f0110cf9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110cfd:	0f 85 6c ff ff ff    	jne    f0110c6f <sys_get_optimal_num_faults+0x43>
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
		}
	}
	return get_optimal_num_faults(&(cur_env->page_WS_list), cur_env->page_WS_max_size, &(cur_env->referenceStreamList));
f0110d03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110d06:	8d 88 b0 00 00 00    	lea    0xb0(%eax),%ecx
f0110d0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110d0f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0110d15:	89 c2                	mov    %eax,%edx
f0110d17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110d1a:	05 88 00 00 00       	add    $0x88,%eax
f0110d1f:	83 ec 04             	sub    $0x4,%esp
f0110d22:	51                   	push   %ecx
f0110d23:	52                   	push   %edx
f0110d24:	50                   	push   %eax
f0110d25:	e8 22 0e 00 00       	call   f0111b4c <get_optimal_num_faults>
f0110d2a:	83 c4 10             	add    $0x10,%esp
#else
	panic("MUST ENABLE KHEAP");
#endif
	return 0;
}
f0110d2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110d30:	c9                   	leave  
f0110d31:	c3                   	ret    

f0110d32 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f0110d32:	55                   	push   %ebp
f0110d33:	89 e5                	mov    %esp,%ebp
f0110d35:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f0110d38:	0f 31                	rdtsc  
f0110d3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110d3d:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f0110d40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d43:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110d46:	89 45 f8             	mov    %eax,-0x8(%ebp)
f0110d49:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f0110d4c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0110d4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0110d52:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0110d55:	89 01                	mov    %eax,(%ecx)
f0110d57:	89 51 04             	mov    %edx,0x4(%ecx)
}
f0110d5a:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d5d:	c9                   	leave  
f0110d5e:	c2 04 00             	ret    $0x4

f0110d61 <sys_rcr2>:

uint32 sys_rcr2()
{
f0110d61:	55                   	push   %ebp
f0110d62:	89 e5                	mov    %esp,%ebp
f0110d64:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f0110d67:	0f 20 d0             	mov    %cr2,%eax
f0110d6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f0110d6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f0110d70:	90                   	nop
}
f0110d71:	c9                   	leave  
f0110d72:	c3                   	ret    

f0110d73 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f0110d73:	55                   	push   %ebp
f0110d74:	89 e5                	mov    %esp,%ebp
f0110d76:	83 ec 04             	sub    $0x4,%esp
f0110d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d7c:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f0110d7f:	8a 45 fc             	mov    -0x4(%ebp),%al
f0110d82:	a2 40 49 92 f0       	mov    %al,0xf0924940
}
f0110d87:	90                   	nop
f0110d88:	c9                   	leave  
f0110d89:	c3                   	ret    

f0110d8a <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f0110d8a:	55                   	push   %ebp
f0110d8b:	89 e5                	mov    %esp,%ebp
f0110d8d:	56                   	push   %esi
f0110d8e:	53                   	push   %ebx
f0110d8f:	83 ec 20             	sub    $0x20,%esp
	struct Env* cur_env = get_cpu_proc();
f0110d92:	e8 b1 c8 ff ff       	call   f010d648 <get_cpu_proc>
f0110d97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f0110d9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110d9e:	75 19                	jne    f0110db9 <syscall+0x2f>
f0110da0:	68 d0 9a 13 f0       	push   $0xf0139ad0
f0110da5:	68 e0 9a 13 f0       	push   $0xf0139ae0
f0110daa:	68 25 02 00 00       	push   $0x225
f0110daf:	68 f5 9a 13 f0       	push   $0xf0139af5
f0110db4:	e8 f6 00 ff ff       	call   f0100eaf <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f0110db9:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
f0110dbd:	0f 87 08 04 00 00    	ja     f01111cb <syscall+0x441>
f0110dc3:	8b 45 08             	mov    0x8(%ebp),%eax
f0110dc6:	c1 e0 02             	shl    $0x2,%eax
f0110dc9:	05 28 9c 13 f0       	add    $0xf0139c28,%eax
f0110dce:	8b 00                	mov    (%eax),%eax
f0110dd0:	ff e0                	jmp    *%eax
	/*2023*/
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 System Calls - Add suitable code here
	//Your code is here
#if USE_KHEAP
	case SYS_env_set_priority:
		sys_env_set_priority((int32)a1, (int) a2);
f0110dd2:	8b 55 10             	mov    0x10(%ebp),%edx
f0110dd5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110dd8:	83 ec 08             	sub    $0x8,%esp
f0110ddb:	52                   	push   %edx
f0110ddc:	50                   	push   %eax
f0110ddd:	e8 6b fb ff ff       	call   f011094d <sys_env_set_priority>
f0110de2:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110de5:	b8 00 00 00 00       	mov    $0x0,%eax
f0110dea:	e9 e1 03 00 00       	jmp    f01111d0 <syscall+0x446>
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

	//=============================================
	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1, a2);
f0110def:	83 ec 08             	sub    $0x8,%esp
f0110df2:	ff 75 10             	pushl  0x10(%ebp)
f0110df5:	ff 75 0c             	pushl  0xc(%ebp)
f0110df8:	e8 3a fa ff ff       	call   f0110837 <sys_allocate_user_mem>
f0110dfd:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e00:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e05:	e9 c6 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1, a2);
f0110e0a:	83 ec 08             	sub    $0x8,%esp
f0110e0d:	ff 75 10             	pushl  0x10(%ebp)
f0110e10:	ff 75 0c             	pushl  0xc(%ebp)
f0110e13:	e8 76 f9 ff ff       	call   f011078e <sys_free_user_mem>
f0110e18:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e1b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e20:	e9 ab 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3, a4);
f0110e25:	8b 4d 18             	mov    0x18(%ebp),%ecx
f0110e28:	8b 45 14             	mov    0x14(%ebp),%eax
f0110e2b:	0f b6 d0             	movzbl %al,%edx
f0110e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e31:	51                   	push   %ecx
f0110e32:	52                   	push   %edx
f0110e33:	ff 75 10             	pushl  0x10(%ebp)
f0110e36:	50                   	push   %eax
f0110e37:	e8 ff f5 ff ff       	call   f011043b <sys_cputs>
f0110e3c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e3f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e44:	e9 87 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f0110e49:	e8 9a f6 ff ff       	call   f01104e8 <sys_cgetc>
f0110e4e:	e9 7d 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_cputc:
		sys_cputc((const char)a1);
f0110e53:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e56:	0f be c0             	movsbl %al,%eax
f0110e59:	83 ec 0c             	sub    $0xc,%esp
f0110e5c:	50                   	push   %eax
f0110e5d:	e8 62 f6 ff ff       	call   f01104c4 <sys_cputc>
f0110e62:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e65:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e6a:	e9 61 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f0110e6f:	e8 c5 f6 ff ff       	call   f0110539 <sys_lock_cons>
		return 0;
f0110e74:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e79:	e9 52 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f0110e7e:	e8 c4 f6 ff ff       	call   f0110547 <sys_unlock_cons>
		return 0;
f0110e83:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e88:	e9 43 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f0110e8d:	83 ec 08             	sub    $0x8,%esp
f0110e90:	ff 75 10             	pushl  0x10(%ebp)
f0110e93:	ff 75 0c             	pushl  0xc(%ebp)
f0110e96:	e8 a4 f7 ff ff       	call   f011063f <sys_calculate_required_frames>
f0110e9b:	83 c4 10             	add    $0x10,%esp
f0110e9e:	e9 2d 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f0110ea3:	e8 de f7 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0110ea8:	e9 23 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f0110ead:	e8 f3 f7 ff ff       	call   f01106a5 <sys_calculate_modified_frames>
f0110eb2:	e9 19 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f0110eb7:	e8 03 f8 ff ff       	call   f01106bf <sys_calculate_notmod_frames>
f0110ebc:	e9 0f 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f0110ec1:	e8 8b f8 ff ff       	call   f0110751 <sys_pf_calculate_allocated_pages>
f0110ec6:	e9 05 03 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f0110ecb:	83 ec 0c             	sub    $0xc,%esp
f0110ece:	ff 75 0c             	pushl  0xc(%ebp)
f0110ed1:	e8 03 f8 ff ff       	call   f01106d9 <sys_calculate_pages_tobe_removed_ready_exit>
f0110ed6:	83 c4 10             	add    $0x10,%esp
f0110ed9:	e9 f2 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f0110ede:	e8 0c f8 ff ff       	call   f01106ef <sys_scarce_memory>
		return 0;
f0110ee3:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ee8:	e9 e3 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f0110eed:	83 ec 04             	sub    $0x4,%esp
f0110ef0:	ff 75 14             	pushl  0x14(%ebp)
f0110ef3:	ff 75 10             	pushl  0x10(%ebp)
f0110ef6:	ff 75 0c             	pushl  0xc(%ebp)
f0110ef9:	e8 c3 f9 ff ff       	call   f01108c1 <sys_allocate_chunk>
f0110efe:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110f01:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f06:	e9 c5 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

		//======================
	case SYS_allocate_page:
		return __sys_allocate_page((void*)a1, a2);
f0110f0b:	8b 55 10             	mov    0x10(%ebp),%edx
f0110f0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f11:	83 ec 08             	sub    $0x8,%esp
f0110f14:	52                   	push   %edx
f0110f15:	50                   	push   %eax
f0110f16:	e8 3a f6 ff ff       	call   f0110555 <__sys_allocate_page>
f0110f1b:	83 c4 10             	add    $0x10,%esp
f0110f1e:	e9 ad 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f0110f23:	8b 75 1c             	mov    0x1c(%ebp),%esi
f0110f26:	8b 5d 18             	mov    0x18(%ebp),%ebx
f0110f29:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0110f2c:	8b 55 10             	mov    0x10(%ebp),%edx
f0110f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f32:	83 ec 0c             	sub    $0xc,%esp
f0110f35:	56                   	push   %esi
f0110f36:	53                   	push   %ebx
f0110f37:	51                   	push   %ecx
f0110f38:	52                   	push   %edx
f0110f39:	50                   	push   %eax
f0110f3a:	e8 90 f6 ff ff       	call   f01105cf <__sys_map_frame>
f0110f3f:	83 c4 20             	add    $0x20,%esp
		return 0;
f0110f42:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f47:	e9 84 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_unmap_frame:
		return __sys_unmap_frame(a1);
f0110f4c:	83 ec 0c             	sub    $0xc,%esp
f0110f4f:	ff 75 0c             	pushl  0xc(%ebp)
f0110f52:	e8 95 f6 ff ff       	call   f01105ec <__sys_unmap_frame>
f0110f57:	83 c4 10             	add    $0x10,%esp
f0110f5a:	e9 71 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f0110f5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f62:	0f be c0             	movsbl %al,%eax
f0110f65:	83 ec 0c             	sub    $0xc,%esp
f0110f68:	50                   	push   %eax
f0110f69:	e8 8f f7 ff ff       	call   f01106fd <sys_clearFFL>
f0110f6e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110f71:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f76:	e9 55 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_create_shared_object:
		return sys_create_shared_object((char*)a1, a2, a3, (void*)a4);
f0110f7b:	8b 4d 18             	mov    0x18(%ebp),%ecx
f0110f7e:	8b 45 14             	mov    0x14(%ebp),%eax
f0110f81:	0f b6 d0             	movzbl %al,%edx
f0110f84:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f87:	51                   	push   %ecx
f0110f88:	52                   	push   %edx
f0110f89:	ff 75 10             	pushl  0x10(%ebp)
f0110f8c:	50                   	push   %eax
f0110f8d:	e8 03 fa ff ff       	call   f0110995 <sys_create_shared_object>
f0110f92:	83 c4 10             	add    $0x10,%esp
f0110f95:	e9 36 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_get_shared_object:
		return sys_get_shared_object((int32)a1, (char*)a2, (void*)a3);
f0110f9a:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0110f9d:	8b 55 10             	mov    0x10(%ebp),%edx
f0110fa0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fa3:	83 ec 04             	sub    $0x4,%esp
f0110fa6:	51                   	push   %ecx
f0110fa7:	52                   	push   %edx
f0110fa8:	50                   	push   %eax
f0110fa9:	e8 55 fa ff ff       	call   f0110a03 <sys_get_shared_object>
f0110fae:	83 c4 10             	add    $0x10,%esp
f0110fb1:	e9 1a 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_free_shared_object:
		return sys_delete_shared_object((int32)a1, (void *)a2);
f0110fb6:	8b 55 10             	mov    0x10(%ebp),%edx
f0110fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fbc:	83 ec 08             	sub    $0x8,%esp
f0110fbf:	52                   	push   %edx
f0110fc0:	50                   	push   %eax
f0110fc1:	e8 59 fa ff ff       	call   f0110a1f <sys_delete_shared_object>
f0110fc6:	83 c4 10             	add    $0x10,%esp
f0110fc9:	e9 02 02 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_get_size_of_shared_object:
		return sys_size_of_shared_object((int32)a1, (char*)a2);
f0110fce:	8b 55 10             	mov    0x10(%ebp),%edx
f0110fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fd4:	83 ec 08             	sub    $0x8,%esp
f0110fd7:	52                   	push   %edx
f0110fd8:	50                   	push   %eax
f0110fd9:	e8 0c fa ff ff       	call   f01109ea <sys_size_of_shared_object>
f0110fde:	83 c4 10             	add    $0x10,%esp
f0110fe1:	e9 ea 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f0110fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fe9:	ff 75 18             	pushl  0x18(%ebp)
f0110fec:	ff 75 14             	pushl  0x14(%ebp)
f0110fef:	ff 75 10             	pushl  0x10(%ebp)
f0110ff2:	50                   	push   %eax
f0110ff3:	e8 dc fb ff ff       	call   f0110bd4 <sys_create_env>
f0110ff8:	83 c4 10             	add    $0x10,%esp
f0110ffb:	e9 d0 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f0111000:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111003:	83 ec 0c             	sub    $0xc,%esp
f0111006:	50                   	push   %eax
f0111007:	e8 08 fc ff ff       	call   f0110c14 <sys_run_env>
f011100c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011100f:	b8 00 00 00 00       	mov    $0x0,%eax
f0111014:	e9 b7 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f0111019:	e8 4f fa ff ff       	call   f0110a6d <sys_getenvindex>
f011101e:	e9 ad 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f0111023:	e8 10 fa ff ff       	call   f0110a38 <sys_getenvid>
f0111028:	e9 a3 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f011102d:	e8 aa fa ff ff       	call   f0110adc <sys_getparentenvid>
f0111032:	e9 99 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f0111037:	8b 45 0c             	mov    0xc(%ebp),%eax
f011103a:	83 ec 0c             	sub    $0xc,%esp
f011103d:	50                   	push   %eax
f011103e:	e8 ce fa ff ff       	call   f0110b11 <sys_destroy_env>
f0111043:	83 c4 10             	add    $0x10,%esp
f0111046:	e9 85 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_exit_env:
		sys_exit_env();
f011104b:	e8 76 fb ff ff       	call   f0110bc6 <sys_exit_env>
		return 0;
f0111050:	b8 00 00 00 00       	mov    $0x0,%eax
f0111055:	e9 76 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f011105a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f011105d:	83 ec 0c             	sub    $0xc,%esp
f0111060:	50                   	push   %eax
f0111061:	e8 cc fc ff ff       	call   f0110d32 <sys_get_virtual_time>
f0111066:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f0111069:	8b 45 0c             	mov    0xc(%ebp),%eax
f011106c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f011106f:	8b 45 10             	mov    0x10(%ebp),%eax
f0111072:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*ptrlow = res.low;
f0111075:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0111078:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011107b:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f011107d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0111080:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111083:	89 10                	mov    %edx,(%eax)
		return 0;
f0111085:	b8 00 00 00 00       	mov    $0x0,%eax
f011108a:	e9 41 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f011108f:	83 ec 04             	sub    $0x4,%esp
f0111092:	ff 75 14             	pushl  0x14(%ebp)
f0111095:	ff 75 10             	pushl  0x10(%ebp)
f0111098:	ff 75 0c             	pushl  0xc(%ebp)
f011109b:	e8 69 f8 ff ff       	call   f0110909 <sys_move_user_mem>
f01110a0:	83 c4 10             	add    $0x10,%esp
		return 0;
f01110a3:	b8 00 00 00 00       	mov    $0x0,%eax
f01110a8:	e9 23 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f01110ad:	e8 af fc ff ff       	call   f0110d61 <sys_rcr2>
f01110b2:	e9 19 01 00 00       	jmp    f01111d0 <syscall+0x446>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f01110b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01110ba:	0f b6 c0             	movzbl %al,%eax
f01110bd:	83 ec 0c             	sub    $0xc,%esp
f01110c0:	50                   	push   %eax
f01110c1:	e8 ad fc ff ff       	call   f0110d73 <sys_bypassPageFault>
f01110c6:	83 c4 10             	add    $0x10,%esp
		return 0;
f01110c9:	b8 00 00 00 00       	mov    $0x0,%eax
f01110ce:	e9 fd 00 00 00       	jmp    f01111d0 <syscall+0x446>

	case SYS_rsttst:
		rsttst();
f01110d3:	e8 eb f5 00 00       	call   f01206c3 <rsttst>
		return 0;
f01110d8:	b8 00 00 00 00       	mov    $0x0,%eax
f01110dd:	e9 ee 00 00 00       	jmp    f01111d0 <syscall+0x446>
	case SYS_inctst:
		inctst();
f01110e2:	e8 24 f6 00 00       	call   f012070b <inctst>
		return 0;
f01110e7:	b8 00 00 00 00       	mov    $0x0,%eax
f01110ec:	e9 df 00 00 00       	jmp    f01111d0 <syscall+0x446>
	case SYS_chktst:
		chktst(a1);
f01110f1:	83 ec 0c             	sub    $0xc,%esp
f01110f4:	ff 75 0c             	pushl  0xc(%ebp)
f01110f7:	e8 51 f7 00 00       	call   f012084d <chktst>
f01110fc:	83 c4 10             	add    $0x10,%esp
		return 0;
f01110ff:	b8 00 00 00 00       	mov    $0x0,%eax
f0111104:	e9 c7 00 00 00       	jmp    f01111d0 <syscall+0x446>
	case SYS_gettst:
		return gettst();
f0111109:	e8 31 f6 00 00       	call   f012073f <gettst>
f011110e:	e9 bd 00 00 00       	jmp    f01111d0 <syscall+0x446>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f0111113:	8b 55 1c             	mov    0x1c(%ebp),%edx
f0111116:	8b 45 18             	mov    0x18(%ebp),%eax
f0111119:	0f be c0             	movsbl %al,%eax
f011111c:	83 ec 0c             	sub    $0xc,%esp
f011111f:	52                   	push   %edx
f0111120:	50                   	push   %eax
f0111121:	ff 75 14             	pushl  0x14(%ebp)
f0111124:	ff 75 10             	pushl  0x10(%ebp)
f0111127:	ff 75 0c             	pushl  0xc(%ebp)
f011112a:	e8 1a f6 00 00       	call   f0120749 <tst>
f011112f:	83 c4 20             	add    $0x20,%esp
		return 0;
f0111132:	b8 00 00 00 00       	mov    $0x0,%eax
f0111137:	e9 94 00 00 00       	jmp    f01111d0 <syscall+0x446>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f011113c:	e8 3c f8 ff ff       	call   f011097d <sys_get_heap_strategy>
f0111141:	e9 8a 00 00 00       	jmp    f01111d0 <syscall+0x446>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f0111146:	83 ec 0c             	sub    $0xc,%esp
f0111149:	ff 75 0c             	pushl  0xc(%ebp)
f011114c:	e8 36 f8 ff ff       	call   f0110987 <sys_set_uheap_strategy>
f0111151:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111154:	b8 00 00 00 00       	mov    $0x0,%eax
f0111159:	eb 75                	jmp    f01111d0 <syscall+0x446>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f011115b:	8b 5d 18             	mov    0x18(%ebp),%ebx
f011115e:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0111161:	8b 55 10             	mov    0x10(%ebp),%edx
f0111164:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111167:	53                   	push   %ebx
f0111168:	51                   	push   %ecx
f0111169:	52                   	push   %edx
f011116a:	50                   	push   %eax
f011116b:	e8 be 38 00 00       	call   f0114a2e <sys_check_LRU_lists>
f0111170:	83 c4 10             	add    $0x10,%esp
f0111173:	eb 5b                	jmp    f01111d0 <syscall+0x446>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f0111175:	8b 55 10             	mov    0x10(%ebp),%edx
f0111178:	8b 45 0c             	mov    0xc(%ebp),%eax
f011117b:	83 ec 08             	sub    $0x8,%esp
f011117e:	52                   	push   %edx
f011117f:	50                   	push   %eax
f0111180:	e8 7f 3a 00 00       	call   f0114c04 <sys_check_LRU_lists_free>
f0111185:	83 c4 10             	add    $0x10,%esp
f0111188:	eb 46                	jmp    f01111d0 <syscall+0x446>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f011118a:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011118d:	8b 55 10             	mov    0x10(%ebp),%edx
f0111190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111193:	51                   	push   %ecx
f0111194:	ff 75 14             	pushl  0x14(%ebp)
f0111197:	52                   	push   %edx
f0111198:	50                   	push   %eax
f0111199:	e8 00 3c 00 00       	call   f0114d9e <sys_check_WS_list>
f011119e:	83 c4 10             	add    $0x10,%esp
f01111a1:	eb 2d                	jmp    f01111d0 <syscall+0x446>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f01111a3:	8b 55 10             	mov    0x10(%ebp),%edx
f01111a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111a9:	83 ec 08             	sub    $0x8,%esp
f01111ac:	52                   	push   %edx
f01111ad:	50                   	push   %eax
f01111ae:	e8 9b f8 00 00       	call   f0120a4e <sys_utilities>
f01111b3:	83 c4 10             	add    $0x10,%esp
		return 0;
f01111b6:	b8 00 00 00 00       	mov    $0x0,%eax
f01111bb:	eb 13                	jmp    f01111d0 <syscall+0x446>

	case SYS_get_optimal_num_faults:
		return sys_get_optimal_num_faults();
f01111bd:	e8 6a fa ff ff       	call   f0110c2c <sys_get_optimal_num_faults>
f01111c2:	eb 0c                	jmp    f01111d0 <syscall+0x446>

	case NSYSCALLS:
		return 	-E_INVAL;
f01111c4:	b8 03 00 00 00       	mov    $0x3,%eax
f01111c9:	eb 05                	jmp    f01111d0 <syscall+0x446>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f01111cb:	b8 03 00 00 00       	mov    $0x3,%eax
}
f01111d0:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01111d3:	5b                   	pop    %ebx
f01111d4:	5e                   	pop    %esi
f01111d5:	5d                   	pop    %ebp
f01111d6:	c3                   	ret    

f01111d7 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f01111d7:	55                   	push   %ebp
f01111d8:	89 e5                	mov    %esp,%ebp
f01111da:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f01111dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111e0:	8b 00                	mov    (%eax),%eax
f01111e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01111e5:	8b 45 10             	mov    0x10(%ebp),%eax
f01111e8:	8b 00                	mov    (%eax),%eax
f01111ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
f01111ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f01111f4:	e9 ca 00 00 00       	jmp    f01112c3 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f01111f9:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01111fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01111ff:	01 d0                	add    %edx,%eax
f0111201:	89 c2                	mov    %eax,%edx
f0111203:	c1 ea 1f             	shr    $0x1f,%edx
f0111206:	01 d0                	add    %edx,%eax
f0111208:	d1 f8                	sar    %eax
f011120a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011120d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111210:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f0111213:	eb 03                	jmp    f0111218 <stab_binsearch+0x41>
			m--;
f0111215:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f0111218:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011121b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011121e:	7c 1e                	jl     f011123e <stab_binsearch+0x67>
f0111220:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0111223:	89 d0                	mov    %edx,%eax
f0111225:	01 c0                	add    %eax,%eax
f0111227:	01 d0                	add    %edx,%eax
f0111229:	c1 e0 02             	shl    $0x2,%eax
f011122c:	89 c2                	mov    %eax,%edx
f011122e:	8b 45 08             	mov    0x8(%ebp),%eax
f0111231:	01 d0                	add    %edx,%eax
f0111233:	8a 40 04             	mov    0x4(%eax),%al
f0111236:	0f b6 c0             	movzbl %al,%eax
f0111239:	3b 45 14             	cmp    0x14(%ebp),%eax
f011123c:	75 d7                	jne    f0111215 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f011123e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111241:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0111244:	7d 09                	jge    f011124f <stab_binsearch+0x78>
			l = true_m + 1;
f0111246:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111249:	40                   	inc    %eax
f011124a:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f011124d:	eb 74                	jmp    f01112c3 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f011124f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f0111256:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0111259:	89 d0                	mov    %edx,%eax
f011125b:	01 c0                	add    %eax,%eax
f011125d:	01 d0                	add    %edx,%eax
f011125f:	c1 e0 02             	shl    $0x2,%eax
f0111262:	89 c2                	mov    %eax,%edx
f0111264:	8b 45 08             	mov    0x8(%ebp),%eax
f0111267:	01 d0                	add    %edx,%eax
f0111269:	8b 40 08             	mov    0x8(%eax),%eax
f011126c:	3b 45 18             	cmp    0x18(%ebp),%eax
f011126f:	73 11                	jae    f0111282 <stab_binsearch+0xab>
			*region_left = m;
f0111271:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111274:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0111277:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f0111279:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011127c:	40                   	inc    %eax
f011127d:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0111280:	eb 41                	jmp    f01112c3 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f0111282:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0111285:	89 d0                	mov    %edx,%eax
f0111287:	01 c0                	add    %eax,%eax
f0111289:	01 d0                	add    %edx,%eax
f011128b:	c1 e0 02             	shl    $0x2,%eax
f011128e:	89 c2                	mov    %eax,%edx
f0111290:	8b 45 08             	mov    0x8(%ebp),%eax
f0111293:	01 d0                	add    %edx,%eax
f0111295:	8b 40 08             	mov    0x8(%eax),%eax
f0111298:	3b 45 18             	cmp    0x18(%ebp),%eax
f011129b:	76 14                	jbe    f01112b1 <stab_binsearch+0xda>
			*region_right = m - 1;
f011129d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01112a3:	8b 45 10             	mov    0x10(%ebp),%eax
f01112a6:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f01112a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112ab:	48                   	dec    %eax
f01112ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
f01112af:	eb 12                	jmp    f01112c3 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f01112b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01112b7:	89 10                	mov    %edx,(%eax)
			l = m;
f01112b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f01112bf:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f01112c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01112c6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01112c9:	0f 8e 2a ff ff ff    	jle    f01111f9 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f01112cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01112d3:	75 0f                	jne    f01112e4 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f01112d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112d8:	8b 00                	mov    (%eax),%eax
f01112da:	8d 50 ff             	lea    -0x1(%eax),%edx
f01112dd:	8b 45 10             	mov    0x10(%ebp),%eax
f01112e0:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f01112e2:	eb 3d                	jmp    f0111321 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f01112e4:	8b 45 10             	mov    0x10(%ebp),%eax
f01112e7:	8b 00                	mov    (%eax),%eax
f01112e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01112ec:	eb 03                	jmp    f01112f1 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f01112ee:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f01112f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112f4:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f01112f6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f01112f9:	7d 1e                	jge    f0111319 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f01112fb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01112fe:	89 d0                	mov    %edx,%eax
f0111300:	01 c0                	add    %eax,%eax
f0111302:	01 d0                	add    %edx,%eax
f0111304:	c1 e0 02             	shl    $0x2,%eax
f0111307:	89 c2                	mov    %eax,%edx
f0111309:	8b 45 08             	mov    0x8(%ebp),%eax
f011130c:	01 d0                	add    %edx,%eax
f011130e:	8a 40 04             	mov    0x4(%eax),%al
f0111311:	0f b6 c0             	movzbl %al,%eax
f0111314:	3b 45 14             	cmp    0x14(%ebp),%eax
f0111317:	75 d5                	jne    f01112ee <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f0111319:	8b 45 0c             	mov    0xc(%ebp),%eax
f011131c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011131f:	89 10                	mov    %edx,(%eax)
	}
}
f0111321:	90                   	nop
f0111322:	c9                   	leave  
f0111323:	c3                   	ret    

f0111324 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f0111324:	55                   	push   %ebp
f0111325:	89 e5                	mov    %esp,%ebp
f0111327:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f011132a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011132d:	c7 00 e8 9c 13 f0    	movl   $0xf0139ce8,(%eax)
	info->eip_line = 0;
f0111333:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111336:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f011133d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111340:	c7 40 08 e8 9c 13 f0 	movl   $0xf0139ce8,0x8(%eax)
	info->eip_fn_namelen = 9;
f0111347:	8b 45 0c             	mov    0xc(%ebp),%eax
f011134a:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f0111351:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111354:	8b 55 08             	mov    0x8(%ebp),%edx
f0111357:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f011135a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011135d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f0111364:	8b 45 08             	mov    0x8(%ebp),%eax
f0111367:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f011136c:	76 1e                	jbe    f011138c <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f011136e:	c7 45 f4 40 0e 14 f0 	movl   $0xf0140e40,-0xc(%ebp)
		stab_end = __STAB_END__;
f0111375:	c7 45 f0 c4 a1 17 f0 	movl   $0xf017a1c4,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f011137c:	c7 45 ec c5 a1 17 f0 	movl   $0xf017a1c5,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f0111383:	c7 45 e8 e0 e9 18 f0 	movl   $0xf018e9e0,-0x18(%ebp)
f011138a:	eb 2a                	jmp    f01113b6 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f011138c:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f0111393:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111396:	8b 00                	mov    (%eax),%eax
f0111398:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f011139b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011139e:	8b 40 04             	mov    0x4(%eax),%eax
f01113a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f01113a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01113a7:	8b 40 08             	mov    0x8(%eax),%eax
f01113aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f01113ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01113b0:	8b 40 0c             	mov    0xc(%eax),%eax
f01113b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f01113b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01113b9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01113bc:	76 0a                	jbe    f01113c8 <debuginfo_eip+0xa4>
f01113be:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01113c1:	48                   	dec    %eax
f01113c2:	8a 00                	mov    (%eax),%al
f01113c4:	84 c0                	test   %al,%al
f01113c6:	74 0a                	je     f01113d2 <debuginfo_eip+0xae>
		return -1;
f01113c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01113cd:	e9 01 02 00 00       	jmp    f01115d3 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f01113d2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f01113d9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01113dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113df:	29 c2                	sub    %eax,%edx
f01113e1:	89 d0                	mov    %edx,%eax
f01113e3:	c1 f8 02             	sar    $0x2,%eax
f01113e6:	89 c2                	mov    %eax,%edx
f01113e8:	89 d0                	mov    %edx,%eax
f01113ea:	c1 e0 02             	shl    $0x2,%eax
f01113ed:	01 d0                	add    %edx,%eax
f01113ef:	c1 e0 02             	shl    $0x2,%eax
f01113f2:	01 d0                	add    %edx,%eax
f01113f4:	c1 e0 02             	shl    $0x2,%eax
f01113f7:	01 d0                	add    %edx,%eax
f01113f9:	89 c1                	mov    %eax,%ecx
f01113fb:	c1 e1 08             	shl    $0x8,%ecx
f01113fe:	01 c8                	add    %ecx,%eax
f0111400:	89 c1                	mov    %eax,%ecx
f0111402:	c1 e1 10             	shl    $0x10,%ecx
f0111405:	01 c8                	add    %ecx,%eax
f0111407:	01 c0                	add    %eax,%eax
f0111409:	01 d0                	add    %edx,%eax
f011140b:	48                   	dec    %eax
f011140c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f011140f:	ff 75 08             	pushl  0x8(%ebp)
f0111412:	6a 64                	push   $0x64
f0111414:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0111417:	50                   	push   %eax
f0111418:	8d 45 d8             	lea    -0x28(%ebp),%eax
f011141b:	50                   	push   %eax
f011141c:	ff 75 f4             	pushl  -0xc(%ebp)
f011141f:	e8 b3 fd ff ff       	call   f01111d7 <stab_binsearch>
f0111424:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f0111427:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011142a:	85 c0                	test   %eax,%eax
f011142c:	75 0a                	jne    f0111438 <debuginfo_eip+0x114>
		return -1;
f011142e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0111433:	e9 9b 01 00 00       	jmp    f01115d3 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f0111438:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011143b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f011143e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111441:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f0111444:	ff 75 08             	pushl  0x8(%ebp)
f0111447:	6a 24                	push   $0x24
f0111449:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011144c:	50                   	push   %eax
f011144d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0111450:	50                   	push   %eax
f0111451:	ff 75 f4             	pushl  -0xc(%ebp)
f0111454:	e8 7e fd ff ff       	call   f01111d7 <stab_binsearch>
f0111459:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f011145c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011145f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111462:	39 c2                	cmp    %eax,%edx
f0111464:	0f 8f 86 00 00 00    	jg     f01114f0 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f011146a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011146d:	89 c2                	mov    %eax,%edx
f011146f:	89 d0                	mov    %edx,%eax
f0111471:	01 c0                	add    %eax,%eax
f0111473:	01 d0                	add    %edx,%eax
f0111475:	c1 e0 02             	shl    $0x2,%eax
f0111478:	89 c2                	mov    %eax,%edx
f011147a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011147d:	01 d0                	add    %edx,%eax
f011147f:	8b 00                	mov    (%eax),%eax
f0111481:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0111484:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0111487:	29 d1                	sub    %edx,%ecx
f0111489:	89 ca                	mov    %ecx,%edx
f011148b:	39 d0                	cmp    %edx,%eax
f011148d:	73 22                	jae    f01114b1 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f011148f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111492:	89 c2                	mov    %eax,%edx
f0111494:	89 d0                	mov    %edx,%eax
f0111496:	01 c0                	add    %eax,%eax
f0111498:	01 d0                	add    %edx,%eax
f011149a:	c1 e0 02             	shl    $0x2,%eax
f011149d:	89 c2                	mov    %eax,%edx
f011149f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01114a2:	01 d0                	add    %edx,%eax
f01114a4:	8b 10                	mov    (%eax),%edx
f01114a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01114a9:	01 c2                	add    %eax,%edx
f01114ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01114ae:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f01114b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01114b4:	89 c2                	mov    %eax,%edx
f01114b6:	89 d0                	mov    %edx,%eax
f01114b8:	01 c0                	add    %eax,%eax
f01114ba:	01 d0                	add    %edx,%eax
f01114bc:	c1 e0 02             	shl    $0x2,%eax
f01114bf:	89 c2                	mov    %eax,%edx
f01114c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01114c4:	01 d0                	add    %edx,%eax
f01114c6:	8b 50 08             	mov    0x8(%eax),%edx
f01114c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01114cc:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f01114cf:	8b 55 08             	mov    0x8(%ebp),%edx
f01114d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01114d5:	8b 40 10             	mov    0x10(%eax),%eax
f01114d8:	29 c2                	sub    %eax,%edx
f01114da:	89 d0                	mov    %edx,%eax
f01114dc:	c1 f8 02             	sar    $0x2,%eax
f01114df:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f01114e2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01114e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f01114e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114eb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01114ee:	eb 15                	jmp    f0111505 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f01114f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01114f3:	8b 55 08             	mov    0x8(%ebp),%edx
f01114f6:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f01114f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01114fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f01114ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111502:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f0111505:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111508:	8b 40 08             	mov    0x8(%eax),%eax
f011150b:	83 ec 08             	sub    $0x8,%esp
f011150e:	6a 3a                	push   $0x3a
f0111510:	50                   	push   %eax
f0111511:	e8 db 1a 01 00       	call   f0122ff1 <strfind>
f0111516:	83 c4 10             	add    $0x10,%esp
f0111519:	89 c2                	mov    %eax,%edx
f011151b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011151e:	8b 40 08             	mov    0x8(%eax),%eax
f0111521:	29 c2                	sub    %eax,%edx
f0111523:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111526:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f0111529:	eb 03                	jmp    f011152e <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f011152b:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f011152e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111531:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0111534:	7c 4e                	jl     f0111584 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f0111536:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0111539:	89 d0                	mov    %edx,%eax
f011153b:	01 c0                	add    %eax,%eax
f011153d:	01 d0                	add    %edx,%eax
f011153f:	c1 e0 02             	shl    $0x2,%eax
f0111542:	89 c2                	mov    %eax,%edx
f0111544:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111547:	01 d0                	add    %edx,%eax
f0111549:	8a 40 04             	mov    0x4(%eax),%al
f011154c:	3c 84                	cmp    $0x84,%al
f011154e:	74 34                	je     f0111584 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f0111550:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0111553:	89 d0                	mov    %edx,%eax
f0111555:	01 c0                	add    %eax,%eax
f0111557:	01 d0                	add    %edx,%eax
f0111559:	c1 e0 02             	shl    $0x2,%eax
f011155c:	89 c2                	mov    %eax,%edx
f011155e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111561:	01 d0                	add    %edx,%eax
f0111563:	8a 40 04             	mov    0x4(%eax),%al
f0111566:	3c 64                	cmp    $0x64,%al
f0111568:	75 c1                	jne    f011152b <debuginfo_eip+0x207>
f011156a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011156d:	89 d0                	mov    %edx,%eax
f011156f:	01 c0                	add    %eax,%eax
f0111571:	01 d0                	add    %edx,%eax
f0111573:	c1 e0 02             	shl    $0x2,%eax
f0111576:	89 c2                	mov    %eax,%edx
f0111578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011157b:	01 d0                	add    %edx,%eax
f011157d:	8b 40 08             	mov    0x8(%eax),%eax
f0111580:	85 c0                	test   %eax,%eax
f0111582:	74 a7                	je     f011152b <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f0111584:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111587:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f011158a:	7c 42                	jl     f01115ce <debuginfo_eip+0x2aa>
f011158c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011158f:	89 d0                	mov    %edx,%eax
f0111591:	01 c0                	add    %eax,%eax
f0111593:	01 d0                	add    %edx,%eax
f0111595:	c1 e0 02             	shl    $0x2,%eax
f0111598:	89 c2                	mov    %eax,%edx
f011159a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011159d:	01 d0                	add    %edx,%eax
f011159f:	8b 00                	mov    (%eax),%eax
f01115a1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f01115a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01115a7:	29 d1                	sub    %edx,%ecx
f01115a9:	89 ca                	mov    %ecx,%edx
f01115ab:	39 d0                	cmp    %edx,%eax
f01115ad:	73 1f                	jae    f01115ce <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f01115af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01115b2:	89 d0                	mov    %edx,%eax
f01115b4:	01 c0                	add    %eax,%eax
f01115b6:	01 d0                	add    %edx,%eax
f01115b8:	c1 e0 02             	shl    $0x2,%eax
f01115bb:	89 c2                	mov    %eax,%edx
f01115bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01115c0:	01 d0                	add    %edx,%eax
f01115c2:	8b 10                	mov    (%eax),%edx
f01115c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01115c7:	01 c2                	add    %eax,%edx
f01115c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01115cc:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f01115ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01115d3:	c9                   	leave  
f01115d4:	c3                   	ret    

f01115d5 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f01115d5:	55                   	push   %ebp
f01115d6:	89 e5                	mov    %esp,%ebp
f01115d8:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f01115db:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01115df:	74 1c                	je     f01115fd <setPageReplacmentAlgorithmLRU+0x28>
f01115e1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01115e5:	74 16                	je     f01115fd <setPageReplacmentAlgorithmLRU+0x28>
f01115e7:	68 f4 9c 13 f0       	push   $0xf0139cf4
f01115ec:	68 3e 9d 13 f0       	push   $0xf0139d3e
f01115f1:	6a 19                	push   $0x19
f01115f3:	68 53 9d 13 f0       	push   $0xf0139d53
f01115f8:	e8 b2 f8 fe ff       	call   f0100eaf <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f01115fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0111600:	a3 08 54 96 f1       	mov    %eax,0xf1965408
}
f0111605:	90                   	nop
f0111606:	c9                   	leave  
f0111607:	c3                   	ret    

f0111608 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f0111608:	55                   	push   %ebp
f0111609:	89 e5                	mov    %esp,%ebp
f011160b:	c7 05 08 54 96 f1 03 	movl   $0x3,0xf1965408
f0111612:	00 00 00 
f0111615:	90                   	nop
f0111616:	5d                   	pop    %ebp
f0111617:	c3                   	ret    

f0111618 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f0111618:	55                   	push   %ebp
f0111619:	89 e5                	mov    %esp,%ebp
f011161b:	c7 05 08 54 96 f1 04 	movl   $0x4,0xf1965408
f0111622:	00 00 00 
f0111625:	90                   	nop
f0111626:	5d                   	pop    %ebp
f0111627:	c3                   	ret    

f0111628 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f0111628:	55                   	push   %ebp
f0111629:	89 e5                	mov    %esp,%ebp
f011162b:	c7 05 08 54 96 f1 05 	movl   $0x5,0xf1965408
f0111632:	00 00 00 
f0111635:	90                   	nop
f0111636:	5d                   	pop    %ebp
f0111637:	c3                   	ret    

f0111638 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f0111638:	55                   	push   %ebp
f0111639:	89 e5                	mov    %esp,%ebp
f011163b:	c7 05 08 54 96 f1 07 	movl   $0x7,0xf1965408
f0111642:	00 00 00 
f0111645:	90                   	nop
f0111646:	5d                   	pop    %ebp
f0111647:	c3                   	ret    

f0111648 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f0111648:	55                   	push   %ebp
f0111649:	89 e5                	mov    %esp,%ebp
f011164b:	c7 05 08 54 96 f1 06 	movl   $0x6,0xf1965408
f0111652:	00 00 00 
f0111655:	8b 45 08             	mov    0x8(%ebp),%eax
f0111658:	a3 54 ce 94 f1       	mov    %eax,0xf194ce54
f011165d:	90                   	nop
f011165e:	5d                   	pop    %ebp
f011165f:	c3                   	ret    

f0111660 <setFASTNchanceCLOCK>:
/*2024*/ void setFASTNchanceCLOCK(bool fast){ FASTNchanceCLOCK = fast; };
f0111660:	55                   	push   %ebp
f0111661:	89 e5                	mov    %esp,%ebp
f0111663:	8b 45 08             	mov    0x8(%ebp),%eax
f0111666:	a3 b4 51 96 f1       	mov    %eax,0xf19651b4
f011166b:	90                   	nop
f011166c:	5d                   	pop    %ebp
f011166d:	c3                   	ret    

f011166e <setPageReplacmentAlgorithmOPTIMAL>:
/*2025*/ void setPageReplacmentAlgorithmOPTIMAL(){ _PageRepAlgoType = PG_REP_OPTIMAL; };
f011166e:	55                   	push   %ebp
f011166f:	89 e5                	mov    %esp,%ebp
f0111671:	c7 05 08 54 96 f1 08 	movl   $0x8,0xf1965408
f0111678:	00 00 00 
f011167b:	90                   	nop
f011167c:	5d                   	pop    %ebp
f011167d:	c3                   	ret    

f011167e <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f011167e:	55                   	push   %ebp
f011167f:	89 e5                	mov    %esp,%ebp
f0111681:	8b 15 08 54 96 f1    	mov    0xf1965408,%edx
f0111687:	8b 45 08             	mov    0x8(%ebp),%eax
f011168a:	39 c2                	cmp    %eax,%edx
f011168c:	0f 94 c0             	sete   %al
f011168f:	0f b6 c0             	movzbl %al,%eax
f0111692:	5d                   	pop    %ebp
f0111693:	c3                   	ret    

f0111694 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f0111694:	55                   	push   %ebp
f0111695:	89 e5                	mov    %esp,%ebp
f0111697:	a1 08 54 96 f1       	mov    0xf1965408,%eax
f011169c:	83 f8 03             	cmp    $0x3,%eax
f011169f:	75 07                	jne    f01116a8 <isPageReplacmentAlgorithmCLOCK+0x14>
f01116a1:	b8 01 00 00 00       	mov    $0x1,%eax
f01116a6:	eb 05                	jmp    f01116ad <isPageReplacmentAlgorithmCLOCK+0x19>
f01116a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01116ad:	5d                   	pop    %ebp
f01116ae:	c3                   	ret    

f01116af <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f01116af:	55                   	push   %ebp
f01116b0:	89 e5                	mov    %esp,%ebp
f01116b2:	a1 08 54 96 f1       	mov    0xf1965408,%eax
f01116b7:	83 f8 04             	cmp    $0x4,%eax
f01116ba:	75 07                	jne    f01116c3 <isPageReplacmentAlgorithmFIFO+0x14>
f01116bc:	b8 01 00 00 00       	mov    $0x1,%eax
f01116c1:	eb 05                	jmp    f01116c8 <isPageReplacmentAlgorithmFIFO+0x19>
f01116c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01116c8:	5d                   	pop    %ebp
f01116c9:	c3                   	ret    

f01116ca <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f01116ca:	55                   	push   %ebp
f01116cb:	89 e5                	mov    %esp,%ebp
f01116cd:	a1 08 54 96 f1       	mov    0xf1965408,%eax
f01116d2:	83 f8 05             	cmp    $0x5,%eax
f01116d5:	75 07                	jne    f01116de <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f01116d7:	b8 01 00 00 00       	mov    $0x1,%eax
f01116dc:	eb 05                	jmp    f01116e3 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f01116de:	b8 00 00 00 00       	mov    $0x0,%eax
f01116e3:	5d                   	pop    %ebp
f01116e4:	c3                   	ret    

f01116e5 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f01116e5:	55                   	push   %ebp
f01116e6:	89 e5                	mov    %esp,%ebp
f01116e8:	a1 08 54 96 f1       	mov    0xf1965408,%eax
f01116ed:	83 f8 07             	cmp    $0x7,%eax
f01116f0:	75 07                	jne    f01116f9 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f01116f2:	b8 01 00 00 00       	mov    $0x1,%eax
f01116f7:	eb 05                	jmp    f01116fe <isPageReplacmentAlgorithmDynamicLocal+0x19>
f01116f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01116fe:	5d                   	pop    %ebp
f01116ff:	c3                   	ret    

f0111700 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f0111700:	55                   	push   %ebp
f0111701:	89 e5                	mov    %esp,%ebp
f0111703:	a1 08 54 96 f1       	mov    0xf1965408,%eax
f0111708:	83 f8 06             	cmp    $0x6,%eax
f011170b:	75 07                	jne    f0111714 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f011170d:	b8 01 00 00 00       	mov    $0x1,%eax
f0111712:	eb 05                	jmp    f0111719 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f0111714:	b8 00 00 00 00       	mov    $0x0,%eax
f0111719:	5d                   	pop    %ebp
f011171a:	c3                   	ret    

f011171b <isPageReplacmentAlgorithmOPTIMAL>:
/*2021*/ uint32 isPageReplacmentAlgorithmOPTIMAL(){if(_PageRepAlgoType == PG_REP_OPTIMAL) return 1; return 0;}
f011171b:	55                   	push   %ebp
f011171c:	89 e5                	mov    %esp,%ebp
f011171e:	a1 08 54 96 f1       	mov    0xf1965408,%eax
f0111723:	83 f8 08             	cmp    $0x8,%eax
f0111726:	75 07                	jne    f011172f <isPageReplacmentAlgorithmOPTIMAL+0x14>
f0111728:	b8 01 00 00 00       	mov    $0x1,%eax
f011172d:	eb 05                	jmp    f0111734 <isPageReplacmentAlgorithmOPTIMAL+0x19>
f011172f:	b8 00 00 00 00       	mov    $0x0,%eax
f0111734:	5d                   	pop    %ebp
f0111735:	c3                   	ret    

f0111736 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f0111736:	55                   	push   %ebp
f0111737:	89 e5                	mov    %esp,%ebp
f0111739:	8b 45 08             	mov    0x8(%ebp),%eax
f011173c:	a3 a0 51 96 f1       	mov    %eax,0xf19651a0
f0111741:	90                   	nop
f0111742:	5d                   	pop    %ebp
f0111743:	c3                   	ret    

f0111744 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f0111744:	55                   	push   %ebp
f0111745:	89 e5                	mov    %esp,%ebp
f0111747:	a1 a0 51 96 f1       	mov    0xf19651a0,%eax
f011174c:	5d                   	pop    %ebp
f011174d:	c3                   	ret    

f011174e <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f011174e:	55                   	push   %ebp
f011174f:	89 e5                	mov    %esp,%ebp
f0111751:	8b 45 08             	mov    0x8(%ebp),%eax
f0111754:	a3 74 54 96 f1       	mov    %eax,0xf1965474
f0111759:	90                   	nop
f011175a:	5d                   	pop    %ebp
f011175b:	c3                   	ret    

f011175c <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f011175c:	55                   	push   %ebp
f011175d:	89 e5                	mov    %esp,%ebp
f011175f:	a1 74 54 96 f1       	mov    0xf1965474,%eax
f0111764:	5d                   	pop    %ebp
f0111765:	c3                   	ret    

f0111766 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f0111766:	55                   	push   %ebp
f0111767:	89 e5                	mov    %esp,%ebp
f0111769:	8b 45 08             	mov    0x8(%ebp),%eax
f011176c:	a3 10 55 96 f1       	mov    %eax,0xf1965510
f0111771:	90                   	nop
f0111772:	5d                   	pop    %ebp
f0111773:	c3                   	ret    

f0111774 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f0111774:	55                   	push   %ebp
f0111775:	89 e5                	mov    %esp,%ebp
f0111777:	a1 10 55 96 f1       	mov    0xf1965510,%eax
f011177c:	5d                   	pop    %ebp
f011177d:	c3                   	ret    

f011177e <fault_handler_init>:

//==================
// [0] INIT HANDLER:
//==================
void fault_handler_init()
{
f011177e:	55                   	push   %ebp
f011177f:	89 e5                	mov    %esp,%ebp
	//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
	//setPageReplacmentAlgorithmOPTIMAL();
	setPageReplacmentAlgorithmCLOCK();
f0111781:	e8 82 fe ff ff       	call   f0111608 <setPageReplacmentAlgorithmCLOCK>
	//setPageReplacmentAlgorithmModifiedCLOCK();
	enableBuffering(0);
f0111786:	6a 00                	push   $0x0
f0111788:	e8 c1 ff ff ff       	call   f011174e <enableBuffering>
f011178d:	83 c4 04             	add    $0x4,%esp
	enableModifiedBuffer(0) ;
f0111790:	6a 00                	push   $0x0
f0111792:	e8 9f ff ff ff       	call   f0111736 <enableModifiedBuffer>
f0111797:	83 c4 04             	add    $0x4,%esp
	setModifiedBufferLength(1000);
f011179a:	68 e8 03 00 00       	push   $0x3e8
f011179f:	e8 c2 ff ff ff       	call   f0111766 <setModifiedBufferLength>
f01117a4:	83 c4 04             	add    $0x4,%esp
}
f01117a7:	90                   	nop
f01117a8:	c9                   	leave  
f01117a9:	c3                   	ret    

f01117aa <fault_handler>:
int8 num_repeated_fault  = 0;
extern uint32 sys_calculate_free_frames() ;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f01117aa:	55                   	push   %ebp
f01117ab:	89 e5                	mov    %esp,%ebp
f01117ad:	83 ec 48             	sub    $0x48,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f01117b0:	0f 20 d0             	mov    %cr2,%eax
f01117b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	return val;
f01117b6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f01117b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f01117bc:	e8 87 be ff ff       	call   f010d648 <get_cpu_proc>
f01117c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f01117c4:	a1 4c 49 92 f0       	mov    0xf092494c,%eax
f01117c9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01117cc:	75 50                	jne    f011181e <fault_handler+0x74>
f01117ce:	a1 58 49 92 f0       	mov    0xf0924958,%eax
f01117d3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01117d6:	75 46                	jne    f011181e <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f01117d8:	a0 54 49 92 f0       	mov    0xf0924954,%al
f01117dd:	40                   	inc    %eax
f01117de:	a2 54 49 92 f0       	mov    %al,0xf0924954
		if (num_repeated_fault == 3)
f01117e3:	a0 54 49 92 f0       	mov    0xf0924954,%al
f01117e8:	3c 03                	cmp    $0x3,%al
f01117ea:	75 4d                	jne    f0111839 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f01117ec:	83 ec 0c             	sub    $0xc,%esp
f01117ef:	ff 75 08             	pushl  0x8(%ebp)
f01117f2:	e8 b3 e5 ff ff       	call   f010fdaa <print_trapframe>
f01117f7:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f01117fa:	8b 15 48 49 92 f0    	mov    0xf0924948,%edx
f0111800:	a1 50 49 92 f0       	mov    0xf0924950,%eax
f0111805:	83 ec 08             	sub    $0x8,%esp
f0111808:	ff 75 ec             	pushl  -0x14(%ebp)
f011180b:	52                   	push   %edx
f011180c:	50                   	push   %eax
f011180d:	68 70 9d 13 f0       	push   $0xf0139d70
f0111812:	6a 68                	push   $0x68
f0111814:	68 53 9d 13 f0       	push   $0xf0139d53
f0111819:	e8 91 f6 fe ff       	call   f0100eaf <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f011181e:	a1 4c 49 92 f0       	mov    0xf092494c,%eax
f0111823:	a3 50 49 92 f0       	mov    %eax,0xf0924950
		before_last_eip = last_eip;
f0111828:	a1 44 49 92 f0       	mov    0xf0924944,%eax
f011182d:	a3 48 49 92 f0       	mov    %eax,0xf0924948
		num_repeated_fault = 0;
f0111832:	c6 05 54 49 92 f0 00 	movb   $0x0,0xf0924954
	}
	last_eip = (uint32)tf->tf_eip;
f0111839:	8b 45 08             	mov    0x8(%ebp),%eax
f011183c:	8b 40 30             	mov    0x30(%eax),%eax
f011183f:	a3 44 49 92 f0       	mov    %eax,0xf0924944
	last_fault_va = fault_va ;
f0111844:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111847:	a3 4c 49 92 f0       	mov    %eax,0xf092494c
	last_faulted_env = cur_env;
f011184c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011184f:	a3 58 49 92 f0       	mov    %eax,0xf0924958
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f0111854:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f011185b:	8b 45 08             	mov    0x8(%ebp),%eax
f011185e:	8b 40 34             	mov    0x34(%eax),%eax
f0111861:	0f b7 c0             	movzwl %ax,%eax
f0111864:	83 e0 03             	and    $0x3,%eax
f0111867:	83 f8 03             	cmp    $0x3,%eax
f011186a:	75 07                	jne    f0111873 <fault_handler+0xc9>
		userTrap = 1;
f011186c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f0111873:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111877:	0f 85 c8 00 00 00    	jne    f0111945 <fault_handler+0x19b>
	{
		struct cpu* c = mycpu();
f011187d:	e8 7d 6c ff ff       	call   f01084ff <mycpu>
f0111882:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f0111885:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0111889:	74 2f                	je     f01118ba <fault_handler+0x110>
f011188b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011188e:	8b 40 70             	mov    0x70(%eax),%eax
f0111891:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111894:	77 24                	ja     f01118ba <fault_handler+0x110>
f0111896:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111899:	8b 40 70             	mov    0x70(%eax),%eax
f011189c:	05 00 10 00 00       	add    $0x1000,%eax
f01118a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01118a4:	76 14                	jbe    f01118ba <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f01118a6:	83 ec 04             	sub    $0x4,%esp
f01118a9:	68 e0 9d 13 f0       	push   $0xf0139de0
f01118ae:	6a 7f                	push   $0x7f
f01118b0:	68 53 9d 13 f0       	push   $0xf0139d53
f01118b5:	e8 f5 f5 fe ff       	call   f0100eaf <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f01118ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01118bd:	8b 40 08             	mov    0x8(%eax),%eax
f01118c0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01118c3:	77 60                	ja     f0111925 <fault_handler+0x17b>
f01118c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01118c8:	8b 40 08             	mov    0x8(%eax),%eax
f01118cb:	05 00 10 00 00       	add    $0x1000,%eax
f01118d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01118d3:	76 50                	jbe    f0111925 <fault_handler+0x17b>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f01118d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01118d8:	ba a0 cf 94 f1       	mov    $0xf194cfa0,%edx
f01118dd:	29 d0                	sub    %edx,%eax
f01118df:	c1 f8 03             	sar    $0x3,%eax
f01118e2:	89 c2                	mov    %eax,%edx
f01118e4:	89 d0                	mov    %edx,%eax
f01118e6:	c1 e0 02             	shl    $0x2,%eax
f01118e9:	01 d0                	add    %edx,%eax
f01118eb:	01 c0                	add    %eax,%eax
f01118ed:	01 d0                	add    %edx,%eax
f01118ef:	c1 e0 03             	shl    $0x3,%eax
f01118f2:	01 d0                	add    %edx,%eax
f01118f4:	89 c1                	mov    %eax,%ecx
f01118f6:	c1 e1 0b             	shl    $0xb,%ecx
f01118f9:	01 c8                	add    %ecx,%eax
f01118fb:	c1 e0 05             	shl    $0x5,%eax
f01118fe:	01 d0                	add    %edx,%eax
f0111900:	c1 e0 02             	shl    $0x2,%eax
f0111903:	01 d0                	add    %edx,%eax
f0111905:	01 c0                	add    %eax,%eax
f0111907:	01 d0                	add    %edx,%eax
f0111909:	c1 e0 03             	shl    $0x3,%eax
f011190c:	01 d0                	add    %edx,%eax
f011190e:	f7 d8                	neg    %eax
f0111910:	50                   	push   %eax
f0111911:	68 08 9e 13 f0       	push   $0xf0139e08
f0111916:	68 81 00 00 00       	push   $0x81
f011191b:	68 53 9d 13 f0       	push   $0xf0139d53
f0111920:	e8 8a f5 fe ff       	call   f0100eaf <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f0111925:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f011192c:	76 40                	jbe    f011196e <fault_handler+0x1c4>
			panic("Kernel: heap overflow exception!");
f011192e:	83 ec 04             	sub    $0x4,%esp
f0111931:	68 3c 9e 13 f0       	push   $0xf0139e3c
f0111936:	68 84 00 00 00       	push   $0x84
f011193b:	68 53 9d 13 f0       	push   $0xf0139d53
f0111940:	e8 6a f5 fe ff       	call   f0100eaf <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f0111945:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f011194c:	76 20                	jbe    f011196e <fault_handler+0x1c4>
f011194e:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f0111955:	77 17                	ja     f011196e <fault_handler+0x1c4>
			panic("User: stack underflow exception!");
f0111957:	83 ec 04             	sub    $0x4,%esp
f011195a:	68 60 9e 13 f0       	push   $0xf0139e60
f011195f:	68 8c 00 00 00       	push   $0x8c
f0111964:	68 53 9d 13 f0       	push   $0xf0139d53
f0111969:	e8 41 f5 fe ff       	call   f0100eaf <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f011196e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111971:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f0111974:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111978:	75 38                	jne    f01119b2 <fault_handler+0x208>
	{
		cprintf("\nFaulted VA = %x\n", fault_va);
f011197a:	83 ec 08             	sub    $0x8,%esp
f011197d:	ff 75 ec             	pushl  -0x14(%ebp)
f0111980:	68 81 9e 13 f0       	push   $0xf0139e81
f0111985:	e8 c3 01 ff ff       	call   f0101b4d <cprintf>
f011198a:	83 c4 10             	add    $0x10,%esp
		print_trapframe(tf);
f011198d:	83 ec 0c             	sub    $0xc,%esp
f0111990:	ff 75 08             	pushl  0x8(%ebp)
f0111993:	e8 12 e4 ff ff       	call   f010fdaa <print_trapframe>
f0111998:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f011199b:	83 ec 04             	sub    $0x4,%esp
f011199e:	68 93 9e 13 f0       	push   $0xf0139e93
f01119a3:	68 96 00 00 00       	push   $0x96
f01119a8:	68 53 9d 13 f0       	push   $0xf0139d53
f01119ad:	e8 fd f4 fe ff       	call   f0100eaf <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f01119b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01119b5:	8b 40 64             	mov    0x64(%eax),%eax
f01119b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01119bb:	c1 ea 16             	shr    $0x16,%edx
f01119be:	c1 e2 02             	shl    $0x2,%edx
f01119c1:	01 d0                	add    %edx,%eax
f01119c3:	8b 00                	mov    (%eax),%eax
f01119c5:	83 e0 01             	and    $0x1,%eax
f01119c8:	85 c0                	test   %eax,%eax
f01119ca:	75 2b                	jne    f01119f7 <fault_handler+0x24d>
	{
		faulted_env->tableFaultsCounter ++ ;
f01119cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01119cf:	8b 80 7c 06 00 00    	mov    0x67c(%eax),%eax
f01119d5:	8d 50 01             	lea    0x1(%eax),%edx
f01119d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01119db:	89 90 7c 06 00 00    	mov    %edx,0x67c(%eax)
		table_fault_handler(faulted_env, fault_va);
f01119e1:	83 ec 08             	sub    $0x8,%esp
f01119e4:	ff 75 ec             	pushl  -0x14(%ebp)
f01119e7:	ff 75 e0             	pushl  -0x20(%ebp)
f01119ea:	e8 3c 01 00 00       	call   f0111b2b <table_fault_handler>
f01119ef:	83 c4 10             	add    $0x10,%esp
f01119f2:	e9 25 01 00 00       	jmp    f0111b1c <fault_handler+0x372>
	}
	else
	{
		if (userTrap)
f01119f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01119fb:	0f 84 a0 00 00 00    	je     f0111aa1 <fault_handler+0x2f7>
			/*============================================================================================*/
			//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #2 Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
#if USE_KHEAP
			int page_access_perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f0111a01:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111a04:	8b 40 64             	mov    0x64(%eax),%eax
f0111a07:	83 ec 08             	sub    $0x8,%esp
f0111a0a:	ff 75 ec             	pushl  -0x14(%ebp)
f0111a0d:	50                   	push   %eax
f0111a0e:	e8 0e 9c ff ff       	call   f010b621 <pt_get_page_permissions>
f0111a13:	83 c4 10             	add    $0x10,%esp
f0111a16:	89 45 dc             	mov    %eax,-0x24(%ebp)

			int is_in_user_heap = (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX);
f0111a19:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111a1c:	85 c0                	test   %eax,%eax
f0111a1e:	79 10                	jns    f0111a30 <fault_handler+0x286>
f0111a20:	81 7d ec ff ff ff 9f 	cmpl   $0x9fffffff,-0x14(%ebp)
f0111a27:	77 07                	ja     f0111a30 <fault_handler+0x286>
f0111a29:	b8 01 00 00 00       	mov    $0x1,%eax
f0111a2e:	eb 05                	jmp    f0111a35 <fault_handler+0x28b>
f0111a30:	b8 00 00 00 00       	mov    $0x0,%eax
f0111a35:	89 45 d8             	mov    %eax,-0x28(%ebp)

			int exceeds_user_limit = (fault_va >= USER_LIMIT);
f0111a38:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f0111a3f:	0f 97 c0             	seta   %al
f0111a42:	0f b6 c0             	movzbl %al,%eax
f0111a45:	89 45 d4             	mov    %eax,-0x2c(%ebp)

			int is_present_readonly = ((page_access_perms & PERM_PRESENT) && !(page_access_perms & PERM_WRITEABLE));
f0111a48:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111a4b:	83 e0 01             	and    $0x1,%eax
f0111a4e:	85 c0                	test   %eax,%eax
f0111a50:	74 11                	je     f0111a63 <fault_handler+0x2b9>
f0111a52:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111a55:	83 e0 02             	and    $0x2,%eax
f0111a58:	85 c0                	test   %eax,%eax
f0111a5a:	75 07                	jne    f0111a63 <fault_handler+0x2b9>
f0111a5c:	b8 01 00 00 00       	mov    $0x1,%eax
f0111a61:	eb 05                	jmp    f0111a68 <fault_handler+0x2be>
f0111a63:	b8 00 00 00 00       	mov    $0x0,%eax
f0111a68:	89 45 d0             	mov    %eax,-0x30(%ebp)

			int has_heap_perms = (page_access_perms & PERM_UHPAGE);
f0111a6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111a6e:	25 00 04 00 00       	and    $0x400,%eax
f0111a73:	89 45 cc             	mov    %eax,-0x34(%ebp)

			if (exceeds_user_limit) {
f0111a76:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0111a7a:	74 07                	je     f0111a83 <fault_handler+0x2d9>
				env_exit();
f0111a7c:	e8 85 bb ff ff       	call   f010d606 <env_exit>
f0111a81:	eb 1e                	jmp    f0111aa1 <fault_handler+0x2f7>
			}
			else if (is_in_user_heap && !has_heap_perms) {
f0111a83:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0111a87:	74 0d                	je     f0111a96 <fault_handler+0x2ec>
f0111a89:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0111a8d:	75 07                	jne    f0111a96 <fault_handler+0x2ec>
				env_exit();
f0111a8f:	e8 72 bb ff ff       	call   f010d606 <env_exit>
f0111a94:	eb 0b                	jmp    f0111aa1 <fault_handler+0x2f7>
			}
			else if (is_present_readonly) {
f0111a96:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111a9a:	74 05                	je     f0111aa1 <fault_handler+0x2f7>
				env_exit();
f0111a9c:	e8 65 bb ff ff       	call   f010d606 <env_exit>
#endif
			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f0111aa1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111aa4:	8b 40 64             	mov    0x64(%eax),%eax
f0111aa7:	83 ec 08             	sub    $0x8,%esp
f0111aaa:	ff 75 ec             	pushl  -0x14(%ebp)
f0111aad:	50                   	push   %eax
f0111aae:	e8 6e 9b ff ff       	call   f010b621 <pt_get_page_permissions>
f0111ab3:	83 c4 10             	add    $0x10,%esp
f0111ab6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (perms & PERM_PRESENT)
f0111ab9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111abc:	83 e0 01             	and    $0x1,%eax
f0111abf:	85 c0                	test   %eax,%eax
f0111ac1:	74 17                	je     f0111ada <fault_handler+0x330>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f0111ac3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ac6:	68 a8 9e 13 f0       	push   $0xf0139ea8
f0111acb:	68 c4 00 00 00       	push   $0xc4
f0111ad0:	68 53 9d 13 f0       	push   $0xf0139d53
f0111ad5:	e8 d5 f3 fe ff       	call   f0100eaf <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f0111ada:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111add:	8b 80 78 06 00 00    	mov    0x678(%eax),%eax
f0111ae3:	8d 50 01             	lea    0x1(%eax),%edx
f0111ae6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111ae9:	89 90 78 06 00 00    	mov    %edx,0x678(%eax)
//				cprintf("[%08s] user PAGE fault va %08x\n", faulted_env->prog_name, fault_va);
//				cprintf("\nPage working set BEFORE fault handler...\n");
//				env_page_ws_print(faulted_env);
		//int ffb = sys_calculate_free_frames();

		if(isBufferingEnabled())
f0111aef:	e8 68 fc ff ff       	call   f011175c <isBufferingEnabled>
f0111af4:	84 c0                	test   %al,%al
f0111af6:	74 13                	je     f0111b0b <fault_handler+0x361>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f0111af8:	83 ec 08             	sub    $0x8,%esp
f0111afb:	ff 75 ec             	pushl  -0x14(%ebp)
f0111afe:	ff 75 e0             	pushl  -0x20(%ebp)
f0111b01:	e8 f1 19 00 00       	call   f01134f7 <__page_fault_handler_with_buffering>
f0111b06:	83 c4 10             	add    $0x10,%esp
f0111b09:	eb 11                	jmp    f0111b1c <fault_handler+0x372>
		}
		else
		{
			page_fault_handler(faulted_env, fault_va);
f0111b0b:	83 ec 08             	sub    $0x8,%esp
f0111b0e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111b11:	ff 75 e0             	pushl  -0x20(%ebp)
f0111b14:	e8 c8 07 00 00       	call   f01122e1 <page_fault_handler>
f0111b19:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0111b1c:	0f 20 d8             	mov    %cr3,%eax
f0111b1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0111b22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111b25:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f0111b28:	90                   	nop
f0111b29:	c9                   	leave  
f0111b2a:	c3                   	ret    

f0111b2b <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f0111b2b:	55                   	push   %ebp
f0111b2c:	89 e5                	mov    %esp,%ebp
f0111b2e:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f0111b31:	8b 45 08             	mov    0x8(%ebp),%eax
f0111b34:	8b 40 64             	mov    0x64(%eax),%eax
f0111b37:	83 ec 08             	sub    $0x8,%esp
f0111b3a:	ff 75 0c             	pushl  0xc(%ebp)
f0111b3d:	50                   	push   %eax
f0111b3e:	e8 7a 7e ff ff       	call   f01099bd <create_page_table>
f0111b43:	83 c4 10             	add    $0x10,%esp
f0111b46:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f0111b49:	90                   	nop
f0111b4a:	c9                   	leave  
f0111b4b:	c3                   	ret    

f0111b4c <get_optimal_num_faults>:
 * 	3. Page References List (contains the stream of referenced VAs till the process finished)
 *
 * 	IMPORTANT: This function SHOULD NOT change any of the given lists
 */
int get_optimal_num_faults(struct WS_List *initWS, int maxWSSize, struct PageRef_List *refStream)
{
f0111b4c:	55                   	push   %ebp
f0111b4d:	89 e5                	mov    %esp,%ebp
f0111b4f:	83 ec 58             	sub    $0x58,%esp
	//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #2 get_optimal_num_faults
	//Your code is here
#if USE_KHEAP
    int faultCount = 0;
f0111b52:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    struct WS_List WS;
    LIST_INIT(&WS);
f0111b59:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f0111b60:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0111b67:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

    struct WorkingSetElement *e;
    LIST_FOREACH(e, initWS)
f0111b6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0111b71:	8b 00                	mov    (%eax),%eax
f0111b73:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111b76:	e9 93 00 00 00       	jmp    f0111c0e <get_optimal_num_faults+0xc2>
    {
        struct WorkingSetElement *cp = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
f0111b7b:	83 ec 0c             	sub    $0xc,%esp
f0111b7e:	6a 1c                	push   $0x1c
f0111b80:	e8 4d 93 ff ff       	call   f010aed2 <kmalloc>
f0111b85:	83 c4 10             	add    $0x10,%esp
f0111b88:	89 45 cc             	mov    %eax,-0x34(%ebp)
        cp->virtual_address = e->virtual_address;
f0111b8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111b8e:	8b 10                	mov    (%eax),%edx
f0111b90:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111b93:	89 10                	mov    %edx,(%eax)
        cp->sweeps_counter = e->sweeps_counter;
f0111b95:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111b98:	8b 50 0c             	mov    0xc(%eax),%edx
f0111b9b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111b9e:	89 50 0c             	mov    %edx,0xc(%eax)
        cp->time_stamp = e->time_stamp;
f0111ba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111ba4:	8b 50 08             	mov    0x8(%eax),%edx
f0111ba7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111baa:	89 50 08             	mov    %edx,0x8(%eax)
        LIST_INSERT_TAIL(&WS, cp);
f0111bad:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0111bb1:	75 17                	jne    f0111bca <get_optimal_num_faults+0x7e>
f0111bb3:	83 ec 04             	sub    $0x4,%esp
f0111bb6:	68 ec 9e 13 f0       	push   $0xf0139eec
f0111bbb:	68 14 01 00 00       	push   $0x114
f0111bc0:	68 53 9d 13 f0       	push   $0xf0139d53
f0111bc5:	e8 e5 f2 fe ff       	call   f0100eaf <_panic>
f0111bca:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0111bcd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111bd0:	89 50 14             	mov    %edx,0x14(%eax)
f0111bd3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111bd6:	8b 40 14             	mov    0x14(%eax),%eax
f0111bd9:	85 c0                	test   %eax,%eax
f0111bdb:	74 0b                	je     f0111be8 <get_optimal_num_faults+0x9c>
f0111bdd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111be0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111be3:	89 50 10             	mov    %edx,0x10(%eax)
f0111be6:	eb 06                	jmp    f0111bee <get_optimal_num_faults+0xa2>
f0111be8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111beb:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111bee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111bf1:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111bf4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111bf7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0111bfe:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111c01:	40                   	inc    %eax
f0111c02:	89 45 b8             	mov    %eax,-0x48(%ebp)

    struct WS_List WS;
    LIST_INIT(&WS);

    struct WorkingSetElement *e;
    LIST_FOREACH(e, initWS)
f0111c05:	8b 45 08             	mov    0x8(%ebp),%eax
f0111c08:	8b 40 08             	mov    0x8(%eax),%eax
f0111c0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111c0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111c12:	74 08                	je     f0111c1c <get_optimal_num_faults+0xd0>
f0111c14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111c17:	8b 40 10             	mov    0x10(%eax),%eax
f0111c1a:	eb 05                	jmp    f0111c21 <get_optimal_num_faults+0xd5>
f0111c1c:	b8 00 00 00 00       	mov    $0x0,%eax
f0111c21:	8b 55 08             	mov    0x8(%ebp),%edx
f0111c24:	89 42 08             	mov    %eax,0x8(%edx)
f0111c27:	8b 45 08             	mov    0x8(%ebp),%eax
f0111c2a:	8b 40 08             	mov    0x8(%eax),%eax
f0111c2d:	85 c0                	test   %eax,%eax
f0111c2f:	0f 85 46 ff ff ff    	jne    f0111b7b <get_optimal_num_faults+0x2f>
f0111c35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111c39:	0f 85 3c ff ff ff    	jne    f0111b7b <get_optimal_num_faults+0x2f>
        cp->time_stamp = e->time_stamp;
        LIST_INSERT_TAIL(&WS, cp);
    }

    struct PageRefElement *curRef;
    LIST_FOREACH(curRef, refStream)
f0111c3f:	8b 45 10             	mov    0x10(%ebp),%eax
f0111c42:	8b 00                	mov    (%eax),%eax
f0111c44:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111c47:	e9 94 02 00 00       	jmp    f0111ee0 <get_optimal_num_faults+0x394>
    {
        uint32 va = curRef->virtual_address;
f0111c4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111c4f:	8b 00                	mov    (%eax),%eax
f0111c51:	89 45 c8             	mov    %eax,-0x38(%ebp)

        int hit = 0;
f0111c54:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        struct WorkingSetElement *wsElem;

        LIST_FOREACH(wsElem, &WS)
f0111c5b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111c5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0111c61:	eb 19                	jmp    f0111c7c <get_optimal_num_faults+0x130>
        {
            if (wsElem->virtual_address == va)
f0111c63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111c66:	8b 00                	mov    (%eax),%eax
f0111c68:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0111c6b:	75 09                	jne    f0111c76 <get_optimal_num_faults+0x12a>
            {
                hit = 1;
f0111c6d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
                break;
f0111c74:	eb 29                	jmp    f0111c9f <get_optimal_num_faults+0x153>
        uint32 va = curRef->virtual_address;

        int hit = 0;
        struct WorkingSetElement *wsElem;

        LIST_FOREACH(wsElem, &WS)
f0111c76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111c79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0111c7c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111c80:	74 08                	je     f0111c8a <get_optimal_num_faults+0x13e>
f0111c82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111c85:	8b 40 10             	mov    0x10(%eax),%eax
f0111c88:	eb 05                	jmp    f0111c8f <get_optimal_num_faults+0x143>
f0111c8a:	b8 00 00 00 00       	mov    $0x0,%eax
f0111c8f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111c92:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111c95:	85 c0                	test   %eax,%eax
f0111c97:	75 ca                	jne    f0111c63 <get_optimal_num_faults+0x117>
f0111c99:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111c9d:	75 c4                	jne    f0111c63 <get_optimal_num_faults+0x117>
                hit = 1;
                break;
            }
        }

        if (hit)
f0111c9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0111ca3:	0f 85 2d 02 00 00    	jne    f0111ed6 <get_optimal_num_faults+0x38a>
            continue;   // No fault

        faultCount++;
f0111ca9:	ff 45 f4             	incl   -0xc(%ebp)

        if (LIST_SIZE(&WS) < (uint32)maxWSSize)
f0111cac:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0111caf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111cb2:	39 c2                	cmp    %eax,%edx
f0111cb4:	73 75                	jae    f0111d2b <get_optimal_num_faults+0x1df>
        {
            struct WorkingSetElement *newElem = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
f0111cb6:	83 ec 0c             	sub    $0xc,%esp
f0111cb9:	6a 1c                	push   $0x1c
f0111cbb:	e8 12 92 ff ff       	call   f010aed2 <kmalloc>
f0111cc0:	83 c4 10             	add    $0x10,%esp
f0111cc3:	89 45 c4             	mov    %eax,-0x3c(%ebp)

            newElem->virtual_address = va;
f0111cc6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111cc9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0111ccc:	89 10                	mov    %edx,(%eax)
            LIST_INSERT_TAIL(&WS, newElem);
f0111cce:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0111cd2:	75 17                	jne    f0111ceb <get_optimal_num_faults+0x19f>
f0111cd4:	83 ec 04             	sub    $0x4,%esp
f0111cd7:	68 ec 9e 13 f0       	push   $0xf0139eec
f0111cdc:	68 32 01 00 00       	push   $0x132
f0111ce1:	68 53 9d 13 f0       	push   $0xf0139d53
f0111ce6:	e8 c4 f1 fe ff       	call   f0100eaf <_panic>
f0111ceb:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0111cee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111cf1:	89 50 14             	mov    %edx,0x14(%eax)
f0111cf4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111cf7:	8b 40 14             	mov    0x14(%eax),%eax
f0111cfa:	85 c0                	test   %eax,%eax
f0111cfc:	74 0b                	je     f0111d09 <get_optimal_num_faults+0x1bd>
f0111cfe:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111d01:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111d04:	89 50 10             	mov    %edx,0x10(%eax)
f0111d07:	eb 06                	jmp    f0111d0f <get_optimal_num_faults+0x1c3>
f0111d09:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111d0c:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111d0f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111d12:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111d15:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111d18:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0111d1f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111d22:	40                   	inc    %eax
f0111d23:	89 45 b8             	mov    %eax,-0x48(%ebp)
            continue;
f0111d26:	e9 ac 01 00 00       	jmp    f0111ed7 <get_optimal_num_faults+0x38b>
        }

        struct WorkingSetElement *victim = NULL;
f0111d2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        uint32 farthestDistance = 0;
f0111d32:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

        LIST_FOREACH(wsElem, &WS)
f0111d39:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111d3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0111d3f:	eb 6a                	jmp    f0111dab <get_optimal_num_faults+0x25f>
        {
            uint32 distance = 0;
f0111d41:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
            int willBeUsedAgain = 0;
f0111d48:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

            struct PageRefElement *scan = LIST_NEXT(curRef);
f0111d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111d52:	8b 40 04             	mov    0x4(%eax),%eax
f0111d55:	89 45 d0             	mov    %eax,-0x30(%ebp)

            while (scan != NULL)
f0111d58:	eb 23                	jmp    f0111d7d <get_optimal_num_faults+0x231>
            {
                distance++;
f0111d5a:	ff 45 d8             	incl   -0x28(%ebp)

                if (scan->virtual_address == wsElem->virtual_address)
f0111d5d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111d60:	8b 10                	mov    (%eax),%edx
f0111d62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111d65:	8b 00                	mov    (%eax),%eax
f0111d67:	39 c2                	cmp    %eax,%edx
f0111d69:	75 09                	jne    f0111d74 <get_optimal_num_faults+0x228>
                {
                    willBeUsedAgain = 1;
f0111d6b:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
                    break;
f0111d72:	eb 0f                	jmp    f0111d83 <get_optimal_num_faults+0x237>
                }

                scan = LIST_NEXT(scan);
f0111d74:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111d77:	8b 40 04             	mov    0x4(%eax),%eax
f0111d7a:	89 45 d0             	mov    %eax,-0x30(%ebp)
            uint32 distance = 0;
            int willBeUsedAgain = 0;

            struct PageRefElement *scan = LIST_NEXT(curRef);

            while (scan != NULL)
f0111d7d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111d81:	75 d7                	jne    f0111d5a <get_optimal_num_faults+0x20e>
                }

                scan = LIST_NEXT(scan);
            }

            if (!willBeUsedAgain)
f0111d83:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0111d87:	75 08                	jne    f0111d91 <get_optimal_num_faults+0x245>
            {
                victim = wsElem;
f0111d89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111d8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
                break;
f0111d8f:	eb 45                	jmp    f0111dd6 <get_optimal_num_faults+0x28a>
            }

            if (distance > farthestDistance)
f0111d91:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d94:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0111d97:	76 0c                	jbe    f0111da5 <get_optimal_num_faults+0x259>
            {
                farthestDistance = distance;
f0111d99:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d9c:	89 45 dc             	mov    %eax,-0x24(%ebp)
                victim = wsElem;
f0111d9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111da2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        }

        struct WorkingSetElement *victim = NULL;
        uint32 farthestDistance = 0;

        LIST_FOREACH(wsElem, &WS)
f0111da5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111da8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0111dab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111daf:	74 08                	je     f0111db9 <get_optimal_num_faults+0x26d>
f0111db1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111db4:	8b 40 10             	mov    0x10(%eax),%eax
f0111db7:	eb 05                	jmp    f0111dbe <get_optimal_num_faults+0x272>
f0111db9:	b8 00 00 00 00       	mov    $0x0,%eax
f0111dbe:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111dc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111dc4:	85 c0                	test   %eax,%eax
f0111dc6:	0f 85 75 ff ff ff    	jne    f0111d41 <get_optimal_num_faults+0x1f5>
f0111dcc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111dd0:	0f 85 6b ff ff ff    	jne    f0111d41 <get_optimal_num_faults+0x1f5>
                farthestDistance = distance;
                victim = wsElem;
            }
        }

        LIST_REMOVE(&WS, victim);
f0111dd6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111dda:	75 17                	jne    f0111df3 <get_optimal_num_faults+0x2a7>
f0111ddc:	83 ec 04             	sub    $0x4,%esp
f0111ddf:	68 0f 9f 13 f0       	push   $0xf0139f0f
f0111de4:	68 5a 01 00 00       	push   $0x15a
f0111de9:	68 53 9d 13 f0       	push   $0xf0139d53
f0111dee:	e8 bc f0 fe ff       	call   f0100eaf <_panic>
f0111df3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111df6:	8b 40 10             	mov    0x10(%eax),%eax
f0111df9:	85 c0                	test   %eax,%eax
f0111dfb:	74 11                	je     f0111e0e <get_optimal_num_faults+0x2c2>
f0111dfd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e00:	8b 40 10             	mov    0x10(%eax),%eax
f0111e03:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111e06:	8b 52 14             	mov    0x14(%edx),%edx
f0111e09:	89 50 14             	mov    %edx,0x14(%eax)
f0111e0c:	eb 09                	jmp    f0111e17 <get_optimal_num_faults+0x2cb>
f0111e0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e11:	8b 40 14             	mov    0x14(%eax),%eax
f0111e14:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111e17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e1a:	8b 40 14             	mov    0x14(%eax),%eax
f0111e1d:	85 c0                	test   %eax,%eax
f0111e1f:	74 11                	je     f0111e32 <get_optimal_num_faults+0x2e6>
f0111e21:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e24:	8b 40 14             	mov    0x14(%eax),%eax
f0111e27:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111e2a:	8b 52 10             	mov    0x10(%edx),%edx
f0111e2d:	89 50 10             	mov    %edx,0x10(%eax)
f0111e30:	eb 09                	jmp    f0111e3b <get_optimal_num_faults+0x2ef>
f0111e32:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e35:	8b 40 10             	mov    0x10(%eax),%eax
f0111e38:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111e3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e3e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0111e45:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111e48:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0111e4f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111e52:	48                   	dec    %eax
f0111e53:	89 45 b8             	mov    %eax,-0x48(%ebp)
        kfree(victim);
f0111e56:	83 ec 0c             	sub    $0xc,%esp
f0111e59:	ff 75 e0             	pushl  -0x20(%ebp)
f0111e5c:	e8 f2 93 ff ff       	call   f010b253 <kfree>
f0111e61:	83 c4 10             	add    $0x10,%esp

        struct WorkingSetElement *add = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
f0111e64:	83 ec 0c             	sub    $0xc,%esp
f0111e67:	6a 1c                	push   $0x1c
f0111e69:	e8 64 90 ff ff       	call   f010aed2 <kmalloc>
f0111e6e:	83 c4 10             	add    $0x10,%esp
f0111e71:	89 45 c0             	mov    %eax,-0x40(%ebp)
        add->virtual_address = va;
f0111e74:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111e77:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0111e7a:	89 10                	mov    %edx,(%eax)
        LIST_INSERT_TAIL(&WS, add);
f0111e7c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0111e80:	75 17                	jne    f0111e99 <get_optimal_num_faults+0x34d>
f0111e82:	83 ec 04             	sub    $0x4,%esp
f0111e85:	68 ec 9e 13 f0       	push   $0xf0139eec
f0111e8a:	68 5f 01 00 00       	push   $0x15f
f0111e8f:	68 53 9d 13 f0       	push   $0xf0139d53
f0111e94:	e8 16 f0 fe ff       	call   f0100eaf <_panic>
f0111e99:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0111e9c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111e9f:	89 50 14             	mov    %edx,0x14(%eax)
f0111ea2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ea5:	8b 40 14             	mov    0x14(%eax),%eax
f0111ea8:	85 c0                	test   %eax,%eax
f0111eaa:	74 0b                	je     f0111eb7 <get_optimal_num_faults+0x36b>
f0111eac:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111eaf:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0111eb2:	89 50 10             	mov    %edx,0x10(%eax)
f0111eb5:	eb 06                	jmp    f0111ebd <get_optimal_num_faults+0x371>
f0111eb7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111eba:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111ebd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ec0:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111ec3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ec6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0111ecd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111ed0:	40                   	inc    %eax
f0111ed1:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111ed4:	eb 01                	jmp    f0111ed7 <get_optimal_num_faults+0x38b>
                break;
            }
        }

        if (hit)
            continue;   // No fault
f0111ed6:	90                   	nop
        cp->time_stamp = e->time_stamp;
        LIST_INSERT_TAIL(&WS, cp);
    }

    struct PageRefElement *curRef;
    LIST_FOREACH(curRef, refStream)
f0111ed7:	8b 45 10             	mov    0x10(%ebp),%eax
f0111eda:	8b 40 08             	mov    0x8(%eax),%eax
f0111edd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111ee0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111ee4:	74 08                	je     f0111eee <get_optimal_num_faults+0x3a2>
f0111ee6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111ee9:	8b 40 04             	mov    0x4(%eax),%eax
f0111eec:	eb 05                	jmp    f0111ef3 <get_optimal_num_faults+0x3a7>
f0111eee:	b8 00 00 00 00       	mov    $0x0,%eax
f0111ef3:	8b 55 10             	mov    0x10(%ebp),%edx
f0111ef6:	89 42 08             	mov    %eax,0x8(%edx)
f0111ef9:	8b 45 10             	mov    0x10(%ebp),%eax
f0111efc:	8b 40 08             	mov    0x8(%eax),%eax
f0111eff:	85 c0                	test   %eax,%eax
f0111f01:	0f 85 45 fd ff ff    	jne    f0111c4c <get_optimal_num_faults+0x100>
f0111f07:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111f0b:	0f 85 3b fd ff ff    	jne    f0111c4c <get_optimal_num_faults+0x100>
        struct WorkingSetElement *add = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
        add->virtual_address = va;
        LIST_INSERT_TAIL(&WS, add);
    }

    while (!LIST_EMPTY(&WS))
f0111f11:	e9 94 00 00 00       	jmp    f0111faa <get_optimal_num_faults+0x45e>
    {
        struct WorkingSetElement *tmp = LIST_FIRST(&WS);
f0111f16:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111f19:	89 45 bc             	mov    %eax,-0x44(%ebp)
        LIST_REMOVE(&WS, tmp);
f0111f1c:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f0111f20:	75 17                	jne    f0111f39 <get_optimal_num_faults+0x3ed>
f0111f22:	83 ec 04             	sub    $0x4,%esp
f0111f25:	68 0f 9f 13 f0       	push   $0xf0139f0f
f0111f2a:	68 65 01 00 00       	push   $0x165
f0111f2f:	68 53 9d 13 f0       	push   $0xf0139d53
f0111f34:	e8 76 ef fe ff       	call   f0100eaf <_panic>
f0111f39:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f3c:	8b 40 10             	mov    0x10(%eax),%eax
f0111f3f:	85 c0                	test   %eax,%eax
f0111f41:	74 11                	je     f0111f54 <get_optimal_num_faults+0x408>
f0111f43:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f46:	8b 40 10             	mov    0x10(%eax),%eax
f0111f49:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0111f4c:	8b 52 14             	mov    0x14(%edx),%edx
f0111f4f:	89 50 14             	mov    %edx,0x14(%eax)
f0111f52:	eb 09                	jmp    f0111f5d <get_optimal_num_faults+0x411>
f0111f54:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f57:	8b 40 14             	mov    0x14(%eax),%eax
f0111f5a:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111f5d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f60:	8b 40 14             	mov    0x14(%eax),%eax
f0111f63:	85 c0                	test   %eax,%eax
f0111f65:	74 11                	je     f0111f78 <get_optimal_num_faults+0x42c>
f0111f67:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f6a:	8b 40 14             	mov    0x14(%eax),%eax
f0111f6d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0111f70:	8b 52 10             	mov    0x10(%edx),%edx
f0111f73:	89 50 10             	mov    %edx,0x10(%eax)
f0111f76:	eb 09                	jmp    f0111f81 <get_optimal_num_faults+0x435>
f0111f78:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f7b:	8b 40 10             	mov    0x10(%eax),%eax
f0111f7e:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111f81:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f84:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0111f8b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111f8e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0111f95:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111f98:	48                   	dec    %eax
f0111f99:	89 45 b8             	mov    %eax,-0x48(%ebp)
        kfree(tmp);
f0111f9c:	83 ec 0c             	sub    $0xc,%esp
f0111f9f:	ff 75 bc             	pushl  -0x44(%ebp)
f0111fa2:	e8 ac 92 ff ff       	call   f010b253 <kfree>
f0111fa7:	83 c4 10             	add    $0x10,%esp
        struct WorkingSetElement *add = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
        add->virtual_address = va;
        LIST_INSERT_TAIL(&WS, add);
    }

    while (!LIST_EMPTY(&WS))
f0111faa:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111fad:	85 c0                	test   %eax,%eax
f0111faf:	0f 85 61 ff ff ff    	jne    f0111f16 <get_optimal_num_faults+0x3ca>
        struct WorkingSetElement *tmp = LIST_FIRST(&WS);
        LIST_REMOVE(&WS, tmp);
        kfree(tmp);
    }

    return faultCount;
f0111fb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif
	//Comment the following line
	//panic("get_optimal_num_faults() is not implemented yet...!!");
}
f0111fb8:	c9                   	leave  
f0111fb9:	c3                   	ret    

f0111fba <reorder_ws_by_id>:

void reorder_ws_by_id(struct Env *e)
{
f0111fba:	55                   	push   %ebp
f0111fbb:	89 e5                	mov    %esp,%ebp
f0111fbd:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
    if (!e) return;
f0111fc0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0111fc4:	0f 84 fa 01 00 00    	je     f01121c4 <reorder_ws_by_id+0x20a>

    // Save the pointer's id BEFORE reordering
    uint32 saved_id = 0;
f0111fca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if (e->page_last_WS_element)
f0111fd1:	8b 45 08             	mov    0x8(%ebp),%eax
f0111fd4:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0111fda:	85 c0                	test   %eax,%eax
f0111fdc:	74 0f                	je     f0111fed <reorder_ws_by_id+0x33>
        saved_id = e->page_last_WS_element->id;
f0111fde:	8b 45 08             	mov    0x8(%ebp),%eax
f0111fe1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0111fe7:	8b 40 18             	mov    0x18(%eax),%eax
f0111fea:	89 45 f4             	mov    %eax,-0xc(%ebp)

    bool changed = 1;
f0111fed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

    while (changed)
f0111ff4:	e9 70 01 00 00       	jmp    f0112169 <reorder_ws_by_id+0x1af>
    {
        changed = 0;
f0111ff9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

        struct WorkingSetElement *a = LIST_FIRST(&(e->page_WS_list));
f0112000:	8b 45 08             	mov    0x8(%ebp),%eax
f0112003:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0112009:	89 45 ec             	mov    %eax,-0x14(%ebp)
        while (a)
f011200c:	e9 4e 01 00 00       	jmp    f011215f <reorder_ws_by_id+0x1a5>
        {
            struct WorkingSetElement *b = LIST_NEXT(a);
f0112011:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112014:	8b 40 10             	mov    0x10(%eax),%eax
f0112017:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            if (!b) break;
f011201a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011201e:	75 05                	jne    f0112025 <reorder_ws_by_id+0x6b>
f0112020:	e9 44 01 00 00       	jmp    f0112169 <reorder_ws_by_id+0x1af>

            if (a->id > b->id)
f0112025:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112028:	8b 50 18             	mov    0x18(%eax),%edx
f011202b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011202e:	8b 40 18             	mov    0x18(%eax),%eax
f0112031:	39 c2                	cmp    %eax,%edx
f0112033:	0f 86 1d 01 00 00    	jbe    f0112156 <reorder_ws_by_id+0x19c>
            {
                LIST_REMOVE(&(e->page_WS_list), b);
f0112039:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011203d:	75 17                	jne    f0112056 <reorder_ws_by_id+0x9c>
f011203f:	83 ec 04             	sub    $0x4,%esp
f0112042:	68 0f 9f 13 f0       	push   $0xf0139f0f
f0112047:	68 89 01 00 00       	push   $0x189
f011204c:	68 53 9d 13 f0       	push   $0xf0139d53
f0112051:	e8 59 ee fe ff       	call   f0100eaf <_panic>
f0112056:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112059:	8b 40 10             	mov    0x10(%eax),%eax
f011205c:	85 c0                	test   %eax,%eax
f011205e:	74 11                	je     f0112071 <reorder_ws_by_id+0xb7>
f0112060:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112063:	8b 40 10             	mov    0x10(%eax),%eax
f0112066:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0112069:	8b 52 14             	mov    0x14(%edx),%edx
f011206c:	89 50 14             	mov    %edx,0x14(%eax)
f011206f:	eb 0f                	jmp    f0112080 <reorder_ws_by_id+0xc6>
f0112071:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112074:	8b 50 14             	mov    0x14(%eax),%edx
f0112077:	8b 45 08             	mov    0x8(%ebp),%eax
f011207a:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f0112080:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112083:	8b 40 14             	mov    0x14(%eax),%eax
f0112086:	85 c0                	test   %eax,%eax
f0112088:	74 11                	je     f011209b <reorder_ws_by_id+0xe1>
f011208a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011208d:	8b 40 14             	mov    0x14(%eax),%eax
f0112090:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0112093:	8b 52 10             	mov    0x10(%edx),%edx
f0112096:	89 50 10             	mov    %edx,0x10(%eax)
f0112099:	eb 0f                	jmp    f01120aa <reorder_ws_by_id+0xf0>
f011209b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011209e:	8b 50 10             	mov    0x10(%eax),%edx
f01120a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01120a4:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f01120aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01120ad:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01120b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01120b7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01120be:	8b 45 08             	mov    0x8(%ebp),%eax
f01120c1:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01120c7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01120ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01120cd:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
                LIST_INSERT_BEFORE(&(e->page_WS_list), a, b);
f01120d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01120d7:	74 06                	je     f01120df <reorder_ws_by_id+0x125>
f01120d9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01120dd:	75 17                	jne    f01120f6 <reorder_ws_by_id+0x13c>
f01120df:	83 ec 04             	sub    $0x4,%esp
f01120e2:	68 30 9f 13 f0       	push   $0xf0139f30
f01120e7:	68 8a 01 00 00       	push   $0x18a
f01120ec:	68 53 9d 13 f0       	push   $0xf0139d53
f01120f1:	e8 b9 ed fe ff       	call   f0100eaf <_panic>
f01120f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01120f9:	8b 50 14             	mov    0x14(%eax),%edx
f01120fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01120ff:	89 50 14             	mov    %edx,0x14(%eax)
f0112102:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112105:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0112108:	89 50 10             	mov    %edx,0x10(%eax)
f011210b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011210e:	8b 40 14             	mov    0x14(%eax),%eax
f0112111:	85 c0                	test   %eax,%eax
f0112113:	74 0e                	je     f0112123 <reorder_ws_by_id+0x169>
f0112115:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112118:	8b 40 14             	mov    0x14(%eax),%eax
f011211b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011211e:	89 50 10             	mov    %edx,0x10(%eax)
f0112121:	eb 0c                	jmp    f011212f <reorder_ws_by_id+0x175>
f0112123:	8b 45 08             	mov    0x8(%ebp),%eax
f0112126:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0112129:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f011212f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112132:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0112135:	89 50 14             	mov    %edx,0x14(%eax)
f0112138:	8b 45 08             	mov    0x8(%ebp),%eax
f011213b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112141:	8d 50 01             	lea    0x1(%eax),%edx
f0112144:	8b 45 08             	mov    0x8(%ebp),%eax
f0112147:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
                changed = 1;
f011214d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
                continue;
f0112154:	eb 09                	jmp    f011215f <reorder_ws_by_id+0x1a5>
            }

            a = LIST_NEXT(a);
f0112156:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112159:	8b 40 10             	mov    0x10(%eax),%eax
f011215c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (changed)
    {
        changed = 0;

        struct WorkingSetElement *a = LIST_FIRST(&(e->page_WS_list));
        while (a)
f011215f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0112163:	0f 85 a8 fe ff ff    	jne    f0112011 <reorder_ws_by_id+0x57>
    if (e->page_last_WS_element)
        saved_id = e->page_last_WS_element->id;

    bool changed = 1;

    while (changed)
f0112169:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011216d:	0f 85 86 fe ff ff    	jne    f0111ff9 <reorder_ws_by_id+0x3f>
            a = LIST_NEXT(a);
        }
    }

	struct WorkingSetElement *it;
    LIST_FOREACH_SAFE(it, &(e->page_WS_list), WorkingSetElement){
f0112173:	8b 45 08             	mov    0x8(%ebp),%eax
f0112176:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011217c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011217f:	eb 1f                	jmp    f01121a0 <reorder_ws_by_id+0x1e6>
    	if(it->id == saved_id){
f0112181:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0112184:	8b 40 18             	mov    0x18(%eax),%eax
f0112187:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011218a:	75 0e                	jne    f011219a <reorder_ws_by_id+0x1e0>
    		e->page_last_WS_element = it;
f011218c:	8b 45 08             	mov    0x8(%ebp),%eax
f011218f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0112192:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
    		break;
f0112198:	eb 2b                	jmp    f01121c5 <reorder_ws_by_id+0x20b>
            a = LIST_NEXT(a);
        }
    }

	struct WorkingSetElement *it;
    LIST_FOREACH_SAFE(it, &(e->page_WS_list), WorkingSetElement){
f011219a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011219d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01121a0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01121a4:	74 08                	je     f01121ae <reorder_ws_by_id+0x1f4>
f01121a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01121a9:	8b 40 10             	mov    0x10(%eax),%eax
f01121ac:	eb 05                	jmp    f01121b3 <reorder_ws_by_id+0x1f9>
f01121ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01121b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01121b6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01121ba:	75 c5                	jne    f0112181 <reorder_ws_by_id+0x1c7>
f01121bc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01121c0:	75 bf                	jne    f0112181 <reorder_ws_by_id+0x1c7>
f01121c2:	eb 01                	jmp    f01121c5 <reorder_ws_by_id+0x20b>
}

void reorder_ws_by_id(struct Env *e)
{
#if USE_KHEAP
    if (!e) return;
f01121c4:	90                   	nop
    }
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

}
f01121c5:	c9                   	leave  
f01121c6:	c3                   	ret    

f01121c7 <THE_BEFORE_REPLACEMEEEEEEEEEENT>:

void THE_BEFORE_REPLACEMEEEEEEEEEENT(struct WorkingSetElement *victimWSElement,struct Env * faulted_env, uint32 victim_va,uint32 fault_va){
f01121c7:	55                   	push   %ebp
f01121c8:	89 e5                	mov    %esp,%ebp
f01121ca:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
	uint32 *ptr_page_table = NULL;
f01121cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	struct FrameInfo *victimFrame = get_frame_info(faulted_env->env_page_directory, victim_va, &ptr_page_table);
f01121d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01121d7:	8b 40 64             	mov    0x64(%eax),%eax
f01121da:	83 ec 04             	sub    $0x4,%esp
f01121dd:	8d 55 e0             	lea    -0x20(%ebp),%edx
f01121e0:	52                   	push   %edx
f01121e1:	ff 75 10             	pushl  0x10(%ebp)
f01121e4:	50                   	push   %eax
f01121e5:	e8 00 7a ff ff       	call   f0109bea <get_frame_info>
f01121ea:	83 c4 10             	add    $0x10,%esp
f01121ed:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Check the MODIFIED bit of the victim
	uint32 perms = pt_get_page_permissions(faulted_env->env_page_directory, victim_va);
f01121f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01121f3:	8b 40 64             	mov    0x64(%eax),%eax
f01121f6:	83 ec 08             	sub    $0x8,%esp
f01121f9:	ff 75 10             	pushl  0x10(%ebp)
f01121fc:	50                   	push   %eax
f01121fd:	e8 1f 94 ff ff       	call   f010b621 <pt_get_page_permissions>
f0112202:	83 c4 10             	add    $0x10,%esp
f0112205:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(perms & PERM_MODIFIED) {
f0112208:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011220b:	83 e0 40             	and    $0x40,%eax
f011220e:	85 c0                	test   %eax,%eax
f0112210:	74 14                	je     f0112226 <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x5f>
		pf_update_env_page(faulted_env, victim_va, victimFrame);
f0112212:	83 ec 04             	sub    $0x4,%esp
f0112215:	ff 75 f4             	pushl  -0xc(%ebp)
f0112218:	ff 75 10             	pushl  0x10(%ebp)
f011221b:	ff 75 0c             	pushl  0xc(%ebp)
f011221e:	e8 ee 30 ff ff       	call   f0105311 <pf_update_env_page>
f0112223:	83 c4 10             	add    $0x10,%esp
	}

	// Unmap the victim's frame and remove it from the working set list.
	// victimWSElement pointer is now INVALID.
	if(isPageReplacmentAlgorithmModifiedCLOCK())
f0112226:	e8 9f f4 ff ff       	call   f01116ca <isPageReplacmentAlgorithmModifiedCLOCK>
f011222b:	85 c0                	test   %eax,%eax
f011222d:	74 13                	je     f0112242 <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x7b>
	env_page_ws_invalidate(faulted_env, victim_va);
f011222f:	83 ec 08             	sub    $0x8,%esp
f0112232:	ff 75 10             	pushl  0x10(%ebp)
f0112235:	ff 75 0c             	pushl  0xc(%ebp)
f0112238:	e8 e5 96 ff ff       	call   f010b922 <env_page_ws_invalidate>
f011223d:	83 c4 10             	add    $0x10,%esp
f0112240:	eb 15                	jmp    f0112257 <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x90>
	else unmap_frame(faulted_env->env_page_directory, victim_va);
f0112242:	8b 45 0c             	mov    0xc(%ebp),%eax
f0112245:	8b 40 64             	mov    0x64(%eax),%eax
f0112248:	83 ec 08             	sub    $0x8,%esp
f011224b:	ff 75 10             	pushl  0x10(%ebp)
f011224e:	50                   	push   %eax
f011224f:	e8 18 7a ff ff       	call   f0109c6c <unmap_frame>
f0112254:	83 c4 10             	add    $0x10,%esp

	struct FrameInfo *newf;
	allocate_frame(&newf);
f0112257:	83 ec 0c             	sub    $0xc,%esp
f011225a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011225d:	50                   	push   %eax
f011225e:	e8 f3 73 ff ff       	call   f0109656 <allocate_frame>
f0112263:	83 c4 10             	add    $0x10,%esp
	map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0112266:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0112269:	8b 45 0c             	mov    0xc(%ebp),%eax
f011226c:	8b 40 64             	mov    0x64(%eax),%eax
f011226f:	6a 07                	push   $0x7
f0112271:	ff 75 14             	pushl  0x14(%ebp)
f0112274:	52                   	push   %edx
f0112275:	50                   	push   %eax
f0112276:	e8 7c 78 ff ff       	call   f0109af7 <map_frame>
f011227b:	83 c4 10             	add    $0x10,%esp

	int ret = pf_read_env_page(faulted_env, (void*)fault_va);
f011227e:	8b 45 14             	mov    0x14(%ebp),%eax
f0112281:	83 ec 08             	sub    $0x8,%esp
f0112284:	50                   	push   %eax
f0112285:	ff 75 0c             	pushl  0xc(%ebp)
f0112288:	e8 15 33 ff ff       	call   f01055a2 <pf_read_env_page>
f011228d:	83 c4 10             	add    $0x10,%esp
f0112290:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ret == E_PAGE_NOT_EXIST_IN_PF)
f0112293:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f0112297:	75 45                	jne    f01122de <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x117>
	{
		if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f0112299:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f01122a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01122a3:	2d 01 30 fe 5f       	sub    $0x5ffe3001,%eax
f01122a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01122ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01122ae:	ba 00 00 00 00       	mov    $0x0,%edx
f01122b3:	f7 75 e8             	divl   -0x18(%ebp)
f01122b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01122b9:	29 d0                	sub    %edx,%eax
f01122bb:	3b 45 14             	cmp    0x14(%ebp),%eax
f01122be:	77 09                	ja     f01122c9 <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x102>
f01122c0:	81 7d 14 ff df bf ee 	cmpl   $0xeebfdfff,0x14(%ebp)
f01122c7:	76 15                	jbe    f01122de <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x117>
			  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f01122c9:	8b 45 14             	mov    0x14(%ebp),%eax
	map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	int ret = pf_read_env_page(faulted_env, (void*)fault_va);
	if (ret == E_PAGE_NOT_EXIST_IN_PF)
	{
		if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f01122cc:	85 c0                	test   %eax,%eax
f01122ce:	79 09                	jns    f01122d9 <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x112>
			  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f01122d0:	81 7d 14 ff ff ff 9f 	cmpl   $0x9fffffff,0x14(%ebp)
f01122d7:	76 05                	jbe    f01122de <THE_BEFORE_REPLACEMEEEEEEEEEENT+0x117>
			env_exit();
f01122d9:	e8 28 b3 ff ff       	call   f010d606 <env_exit>
	}
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif
}
f01122de:	90                   	nop
f01122df:	c9                   	leave  
f01122e0:	c3                   	ret    

f01122e1 <page_fault_handler>:

void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f01122e1:	55                   	push   %ebp
f01122e2:	89 e5                	mov    %esp,%ebp
f01122e4:	81 ec 28 01 00 00    	sub    $0x128,%esp
#if USE_KHEAP
	if (isPageReplacmentAlgorithmOPTIMAL())
f01122ea:	e8 2c f4 ff ff       	call   f011171b <isPageReplacmentAlgorithmOPTIMAL>
f01122ef:	85 c0                	test   %eax,%eax
f01122f1:	0f 84 c7 04 00 00    	je     f01127be <page_fault_handler+0x4dd>
	{
		//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #1 Optimal Reference Stream
		//Your code is here

		fault_va = ROUNDDOWN(fault_va, PAGE_SIZE);
f01122f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01122fa:	89 45 b0             	mov    %eax,-0x50(%ebp)
f01122fd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112300:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112305:	89 45 0c             	mov    %eax,0xc(%ebp)
		uint32 *ptr_table = NULL;
f0112308:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%ebp)
f011230f:	00 00 00 
		struct FrameInfo *fi = get_frame_info(faulted_env->env_page_directory, fault_va, &ptr_table);
f0112312:	8b 45 08             	mov    0x8(%ebp),%eax
f0112315:	8b 40 64             	mov    0x64(%eax),%eax
f0112318:	83 ec 04             	sub    $0x4,%esp
f011231b:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f0112321:	52                   	push   %edx
f0112322:	ff 75 0c             	pushl  0xc(%ebp)
f0112325:	50                   	push   %eax
f0112326:	e8 bf 78 ff ff       	call   f0109bea <get_frame_info>
f011232b:	83 c4 10             	add    $0x10,%esp
f011232e:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (fi == NULL)
f0112331:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f0112335:	0f 85 8f 00 00 00    	jne    f01123ca <page_fault_handler+0xe9>
		{
			struct FrameInfo *newf;
			allocate_frame(&newf);
f011233b:	83 ec 0c             	sub    $0xc,%esp
f011233e:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
f0112344:	50                   	push   %eax
f0112345:	e8 0c 73 ff ff       	call   f0109656 <allocate_frame>
f011234a:	83 c4 10             	add    $0x10,%esp
			map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f011234d:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
f0112353:	8b 45 08             	mov    0x8(%ebp),%eax
f0112356:	8b 40 64             	mov    0x64(%eax),%eax
f0112359:	6a 07                	push   $0x7
f011235b:	ff 75 0c             	pushl  0xc(%ebp)
f011235e:	52                   	push   %edx
f011235f:	50                   	push   %eax
f0112360:	e8 92 77 ff ff       	call   f0109af7 <map_frame>
f0112365:	83 c4 10             	add    $0x10,%esp

			int ret = pf_read_env_page(faulted_env, (void*)fault_va);
f0112368:	8b 45 0c             	mov    0xc(%ebp),%eax
f011236b:	83 ec 08             	sub    $0x8,%esp
f011236e:	50                   	push   %eax
f011236f:	ff 75 08             	pushl  0x8(%ebp)
f0112372:	e8 2b 32 ff ff       	call   f01055a2 <pf_read_env_page>
f0112377:	83 c4 10             	add    $0x10,%esp
f011237a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if (ret == E_PAGE_NOT_EXIST_IN_PF)
f011237d:	83 7d a8 f7          	cmpl   $0xfffffff7,-0x58(%ebp)
f0112381:	75 5d                	jne    f01123e0 <page_fault_handler+0xff>
			{
				if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f0112383:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f011238a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011238d:	2d 01 30 fe 5f       	sub    $0x5ffe3001,%eax
f0112392:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0112395:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112398:	ba 00 00 00 00       	mov    $0x0,%edx
f011239d:	f7 75 a4             	divl   -0x5c(%ebp)
f01123a0:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01123a3:	29 d0                	sub    %edx,%eax
f01123a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01123a8:	77 09                	ja     f01123b3 <page_fault_handler+0xd2>
f01123aa:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f01123b1:	76 2d                	jbe    f01123e0 <page_fault_handler+0xff>
					  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f01123b3:	8b 45 0c             	mov    0xc(%ebp),%eax
			map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

			int ret = pf_read_env_page(faulted_env, (void*)fault_va);
			if (ret == E_PAGE_NOT_EXIST_IN_PF)
			{
				if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f01123b6:	85 c0                	test   %eax,%eax
f01123b8:	79 09                	jns    f01123c3 <page_fault_handler+0xe2>
					  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f01123ba:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f01123c1:	76 1d                	jbe    f01123e0 <page_fault_handler+0xff>
					env_exit();
f01123c3:	e8 3e b2 ff ff       	call   f010d606 <env_exit>
f01123c8:	eb 16                	jmp    f01123e0 <page_fault_handler+0xff>
			}
		}
		else
			pt_set_page_permissions(faulted_env->env_page_directory, fault_va, PERM_PRESENT, 0);
f01123ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01123cd:	8b 40 64             	mov    0x64(%eax),%eax
f01123d0:	6a 00                	push   $0x0
f01123d2:	6a 01                	push   $0x1
f01123d4:	ff 75 0c             	pushl  0xc(%ebp)
f01123d7:	50                   	push   %eax
f01123d8:	e8 7f 91 ff ff       	call   f010b55c <pt_set_page_permissions>
f01123dd:	83 c4 10             	add    $0x10,%esp

		struct PageRefElement *mref = (struct PageRefElement*) kmalloc(sizeof(struct PageRefElement));
f01123e0:	83 ec 0c             	sub    $0xc,%esp
f01123e3:	6a 0c                	push   $0xc
f01123e5:	e8 e8 8a ff ff       	call   f010aed2 <kmalloc>
f01123ea:	83 c4 10             	add    $0x10,%esp
f01123ed:	89 45 9c             	mov    %eax,-0x64(%ebp)
		mref->virtual_address = fault_va;
f01123f0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01123f3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01123f6:	89 10                	mov    %edx,(%eax)
		LIST_INSERT_TAIL(&(faulted_env->referenceStreamList), mref);
f01123f8:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f01123fc:	75 17                	jne    f0112415 <page_fault_handler+0x134>
f01123fe:	83 ec 04             	sub    $0x4,%esp
f0112401:	68 ec 9e 13 f0       	push   $0xf0139eec
f0112406:	68 e0 01 00 00       	push   $0x1e0
f011240b:	68 53 9d 13 f0       	push   $0xf0139d53
f0112410:	e8 9a ea fe ff       	call   f0100eaf <_panic>
f0112415:	8b 45 08             	mov    0x8(%ebp),%eax
f0112418:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
f011241e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112421:	89 50 08             	mov    %edx,0x8(%eax)
f0112424:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112427:	8b 40 08             	mov    0x8(%eax),%eax
f011242a:	85 c0                	test   %eax,%eax
f011242c:	74 11                	je     f011243f <page_fault_handler+0x15e>
f011242e:	8b 45 08             	mov    0x8(%ebp),%eax
f0112431:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0112437:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011243a:	89 50 04             	mov    %edx,0x4(%eax)
f011243d:	eb 0c                	jmp    f011244b <page_fault_handler+0x16a>
f011243f:	8b 45 08             	mov    0x8(%ebp),%eax
f0112442:	8b 55 9c             	mov    -0x64(%ebp),%edx
f0112445:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
f011244b:	8b 45 08             	mov    0x8(%ebp),%eax
f011244e:	8b 55 9c             	mov    -0x64(%ebp),%edx
f0112451:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
f0112457:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011245a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0112461:	8b 45 08             	mov    0x8(%ebp),%eax
f0112464:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
f011246a:	8d 50 01             	lea    0x1(%eax),%edx
f011246d:	8b 45 08             	mov    0x8(%ebp),%eax
f0112470:	89 90 bc 00 00 00    	mov    %edx,0xbc(%eax)

		if (!faulted_env->simWS_copy) {
f0112476:	8b 45 08             	mov    0x8(%ebp),%eax
f0112479:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f011247f:	85 c0                	test   %eax,%eax
f0112481:	0f 85 e6 00 00 00    	jne    f011256d <page_fault_handler+0x28c>
			struct WorkingSetElement *e;
			LIST_FOREACH_SAFE(e, &(faulted_env->page_WS_list), WorkingSetElement)
f0112487:	8b 45 08             	mov    0x8(%ebp),%eax
f011248a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0112490:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0112493:	e9 9e 00 00 00       	jmp    f0112536 <page_fault_handler+0x255>
			{
				struct WorkingSetElement *cp = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
f0112498:	83 ec 0c             	sub    $0xc,%esp
f011249b:	6a 1c                	push   $0x1c
f011249d:	e8 30 8a ff ff       	call   f010aed2 <kmalloc>
f01124a2:	83 c4 10             	add    $0x10,%esp
f01124a5:	89 45 94             	mov    %eax,-0x6c(%ebp)
				cp->virtual_address = e->virtual_address;
f01124a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01124ab:	8b 10                	mov    (%eax),%edx
f01124ad:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01124b0:	89 10                	mov    %edx,(%eax)
				LIST_INSERT_TAIL(&(faulted_env->simWS), cp);
f01124b2:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f01124b6:	75 17                	jne    f01124cf <page_fault_handler+0x1ee>
f01124b8:	83 ec 04             	sub    $0x4,%esp
f01124bb:	68 ec 9e 13 f0       	push   $0xf0139eec
f01124c0:	68 e8 01 00 00       	push   $0x1e8
f01124c5:	68 53 9d 13 f0       	push   $0xf0139d53
f01124ca:	e8 e0 e9 fe ff       	call   f0100eaf <_panic>
f01124cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01124d2:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
f01124d8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01124db:	89 50 14             	mov    %edx,0x14(%eax)
f01124de:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01124e1:	8b 40 14             	mov    0x14(%eax),%eax
f01124e4:	85 c0                	test   %eax,%eax
f01124e6:	74 11                	je     f01124f9 <page_fault_handler+0x218>
f01124e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01124eb:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01124f1:	8b 55 94             	mov    -0x6c(%ebp),%edx
f01124f4:	89 50 10             	mov    %edx,0x10(%eax)
f01124f7:	eb 0c                	jmp    f0112505 <page_fault_handler+0x224>
f01124f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01124fc:	8b 55 94             	mov    -0x6c(%ebp),%edx
f01124ff:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f0112505:	8b 45 08             	mov    0x8(%ebp),%eax
f0112508:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011250b:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f0112511:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112514:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f011251b:	8b 45 08             	mov    0x8(%ebp),%eax
f011251e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0112524:	8d 50 01             	lea    0x1(%eax),%edx
f0112527:	8b 45 08             	mov    0x8(%ebp),%eax
f011252a:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		mref->virtual_address = fault_va;
		LIST_INSERT_TAIL(&(faulted_env->referenceStreamList), mref);

		if (!faulted_env->simWS_copy) {
			struct WorkingSetElement *e;
			LIST_FOREACH_SAFE(e, &(faulted_env->page_WS_list), WorkingSetElement)
f0112530:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112533:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0112536:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011253a:	74 08                	je     f0112544 <page_fault_handler+0x263>
f011253c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011253f:	8b 40 10             	mov    0x10(%eax),%eax
f0112542:	eb 05                	jmp    f0112549 <page_fault_handler+0x268>
f0112544:	b8 00 00 00 00       	mov    $0x0,%eax
f0112549:	89 45 98             	mov    %eax,-0x68(%ebp)
f011254c:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0112550:	0f 85 42 ff ff ff    	jne    f0112498 <page_fault_handler+0x1b7>
f0112556:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011255a:	0f 85 38 ff ff ff    	jne    f0112498 <page_fault_handler+0x1b7>
			{
				struct WorkingSetElement *cp = (struct WorkingSetElement*) kmalloc(sizeof(struct WorkingSetElement));
				cp->virtual_address = e->virtual_address;
				LIST_INSERT_TAIL(&(faulted_env->simWS), cp);
			}
			faulted_env->simWS_copy = 1;
f0112560:	8b 45 08             	mov    0x8(%ebp),%eax
f0112563:	c7 80 a8 00 00 00 01 	movl   $0x1,0xa8(%eax)
f011256a:	00 00 00 
		}

		if(LIST_SIZE(&faulted_env->simWS) < (faulted_env->page_WS_max_size)) {
f011256d:	8b 45 08             	mov    0x8(%ebp),%eax
f0112570:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
f0112576:	8b 45 08             	mov    0x8(%ebp),%eax
f0112579:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011257f:	39 c2                	cmp    %eax,%edx
f0112581:	0f 83 97 00 00 00    	jae    f011261e <page_fault_handler+0x33d>
			struct WorkingSetElement* e = env_page_ws_list_create_element(faulted_env, fault_va);
f0112587:	83 ec 08             	sub    $0x8,%esp
f011258a:	ff 75 0c             	pushl  0xc(%ebp)
f011258d:	ff 75 08             	pushl  0x8(%ebp)
f0112590:	e8 fc 92 ff ff       	call   f010b891 <env_page_ws_list_create_element>
f0112595:	83 c4 10             	add    $0x10,%esp
f0112598:	89 45 90             	mov    %eax,-0x70(%ebp)
			LIST_INSERT_TAIL(&faulted_env->simWS, e);
f011259b:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f011259f:	75 17                	jne    f01125b8 <page_fault_handler+0x2d7>
f01125a1:	83 ec 04             	sub    $0x4,%esp
f01125a4:	68 ec 9e 13 f0       	push   $0xf0139eec
f01125a9:	68 ef 01 00 00       	push   $0x1ef
f01125ae:	68 53 9d 13 f0       	push   $0xf0139d53
f01125b3:	e8 f7 e8 fe ff       	call   f0100eaf <_panic>
f01125b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01125bb:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
f01125c1:	8b 45 90             	mov    -0x70(%ebp),%eax
f01125c4:	89 50 14             	mov    %edx,0x14(%eax)
f01125c7:	8b 45 90             	mov    -0x70(%ebp),%eax
f01125ca:	8b 40 14             	mov    0x14(%eax),%eax
f01125cd:	85 c0                	test   %eax,%eax
f01125cf:	74 11                	je     f01125e2 <page_fault_handler+0x301>
f01125d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01125d4:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01125da:	8b 55 90             	mov    -0x70(%ebp),%edx
f01125dd:	89 50 10             	mov    %edx,0x10(%eax)
f01125e0:	eb 0c                	jmp    f01125ee <page_fault_handler+0x30d>
f01125e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01125e5:	8b 55 90             	mov    -0x70(%ebp),%edx
f01125e8:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f01125ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01125f1:	8b 55 90             	mov    -0x70(%ebp),%edx
f01125f4:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f01125fa:	8b 45 90             	mov    -0x70(%ebp),%eax
f01125fd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0112604:	8b 45 08             	mov    0x8(%ebp),%eax
f0112607:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011260d:	8d 50 01             	lea    0x1(%eax),%edx
f0112610:	8b 45 08             	mov    0x8(%ebp),%eax
f0112613:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f0112619:	e9 d7 0e 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
		} else {

		struct WorkingSetElement *it = NULL;
f011261e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH_SAFE(it, &faulted_env->simWS, WorkingSetElement) {
f0112625:	8b 45 08             	mov    0x8(%ebp),%eax
f0112628:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f011262e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0112631:	e9 c7 00 00 00       	jmp    f01126fd <page_fault_handler+0x41c>
			pt_set_page_permissions(faulted_env->env_page_directory, it->virtual_address, 0, PERM_PRESENT);
f0112636:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112639:	8b 10                	mov    (%eax),%edx
f011263b:	8b 45 08             	mov    0x8(%ebp),%eax
f011263e:	8b 40 64             	mov    0x64(%eax),%eax
f0112641:	6a 01                	push   $0x1
f0112643:	6a 00                	push   $0x0
f0112645:	52                   	push   %edx
f0112646:	50                   	push   %eax
f0112647:	e8 10 8f ff ff       	call   f010b55c <pt_set_page_permissions>
f011264c:	83 c4 10             	add    $0x10,%esp
			LIST_REMOVE(&faulted_env->simWS, it);
f011264f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112653:	75 17                	jne    f011266c <page_fault_handler+0x38b>
f0112655:	83 ec 04             	sub    $0x4,%esp
f0112658:	68 0f 9f 13 f0       	push   $0xf0139f0f
f011265d:	68 f5 01 00 00       	push   $0x1f5
f0112662:	68 53 9d 13 f0       	push   $0xf0139d53
f0112667:	e8 43 e8 fe ff       	call   f0100eaf <_panic>
f011266c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011266f:	8b 40 10             	mov    0x10(%eax),%eax
f0112672:	85 c0                	test   %eax,%eax
f0112674:	74 11                	je     f0112687 <page_fault_handler+0x3a6>
f0112676:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112679:	8b 40 10             	mov    0x10(%eax),%eax
f011267c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011267f:	8b 52 14             	mov    0x14(%edx),%edx
f0112682:	89 50 14             	mov    %edx,0x14(%eax)
f0112685:	eb 0f                	jmp    f0112696 <page_fault_handler+0x3b5>
f0112687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011268a:	8b 50 14             	mov    0x14(%eax),%edx
f011268d:	8b 45 08             	mov    0x8(%ebp),%eax
f0112690:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f0112696:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112699:	8b 40 14             	mov    0x14(%eax),%eax
f011269c:	85 c0                	test   %eax,%eax
f011269e:	74 11                	je     f01126b1 <page_fault_handler+0x3d0>
f01126a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01126a3:	8b 40 14             	mov    0x14(%eax),%eax
f01126a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01126a9:	8b 52 10             	mov    0x10(%edx),%edx
f01126ac:	89 50 10             	mov    %edx,0x10(%eax)
f01126af:	eb 0f                	jmp    f01126c0 <page_fault_handler+0x3df>
f01126b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01126b4:	8b 50 10             	mov    0x10(%eax),%edx
f01126b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01126ba:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f01126c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01126c3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01126ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01126cd:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01126d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01126d7:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01126dd:	8d 50 ff             	lea    -0x1(%eax),%edx
f01126e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01126e3:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
			kfree((void *)it);
f01126e9:	83 ec 0c             	sub    $0xc,%esp
f01126ec:	ff 75 f0             	pushl  -0x10(%ebp)
f01126ef:	e8 5f 8b ff ff       	call   f010b253 <kfree>
f01126f4:	83 c4 10             	add    $0x10,%esp
			struct WorkingSetElement* e = env_page_ws_list_create_element(faulted_env, fault_va);
			LIST_INSERT_TAIL(&faulted_env->simWS, e);
		} else {

		struct WorkingSetElement *it = NULL;
		LIST_FOREACH_SAFE(it, &faulted_env->simWS, WorkingSetElement) {
f01126f7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01126fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01126fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112701:	74 08                	je     f011270b <page_fault_handler+0x42a>
f0112703:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112706:	8b 40 10             	mov    0x10(%eax),%eax
f0112709:	eb 05                	jmp    f0112710 <page_fault_handler+0x42f>
f011270b:	b8 00 00 00 00       	mov    $0x0,%eax
f0112710:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0112713:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0112717:	0f 85 19 ff ff ff    	jne    f0112636 <page_fault_handler+0x355>
f011271d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112721:	0f 85 0f ff ff ff    	jne    f0112636 <page_fault_handler+0x355>
			pt_set_page_permissions(faulted_env->env_page_directory, it->virtual_address, 0, PERM_PRESENT);
			LIST_REMOVE(&faulted_env->simWS, it);
			kfree((void *)it);
		}

		struct WorkingSetElement *newWSE = env_page_ws_list_create_element(faulted_env, fault_va);
f0112727:	83 ec 08             	sub    $0x8,%esp
f011272a:	ff 75 0c             	pushl  0xc(%ebp)
f011272d:	ff 75 08             	pushl  0x8(%ebp)
f0112730:	e8 5c 91 ff ff       	call   f010b891 <env_page_ws_list_create_element>
f0112735:	83 c4 10             	add    $0x10,%esp
f0112738:	89 45 88             	mov    %eax,-0x78(%ebp)
		LIST_INSERT_TAIL(&faulted_env->simWS, newWSE);
f011273b:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f011273f:	75 17                	jne    f0112758 <page_fault_handler+0x477>
f0112741:	83 ec 04             	sub    $0x4,%esp
f0112744:	68 ec 9e 13 f0       	push   $0xf0139eec
f0112749:	68 fa 01 00 00       	push   $0x1fa
f011274e:	68 53 9d 13 f0       	push   $0xf0139d53
f0112753:	e8 57 e7 fe ff       	call   f0100eaf <_panic>
f0112758:	8b 45 08             	mov    0x8(%ebp),%eax
f011275b:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
f0112761:	8b 45 88             	mov    -0x78(%ebp),%eax
f0112764:	89 50 14             	mov    %edx,0x14(%eax)
f0112767:	8b 45 88             	mov    -0x78(%ebp),%eax
f011276a:	8b 40 14             	mov    0x14(%eax),%eax
f011276d:	85 c0                	test   %eax,%eax
f011276f:	74 11                	je     f0112782 <page_fault_handler+0x4a1>
f0112771:	8b 45 08             	mov    0x8(%ebp),%eax
f0112774:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011277a:	8b 55 88             	mov    -0x78(%ebp),%edx
f011277d:	89 50 10             	mov    %edx,0x10(%eax)
f0112780:	eb 0c                	jmp    f011278e <page_fault_handler+0x4ad>
f0112782:	8b 45 08             	mov    0x8(%ebp),%eax
f0112785:	8b 55 88             	mov    -0x78(%ebp),%edx
f0112788:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f011278e:	8b 45 08             	mov    0x8(%ebp),%eax
f0112791:	8b 55 88             	mov    -0x78(%ebp),%edx
f0112794:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f011279a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011279d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01127a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01127a7:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01127ad:	8d 50 01             	lea    0x1(%eax),%edx
f01127b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01127b3:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f01127b9:	e9 37 0d 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
		//Comment the following line
		//panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
	}
	else
	{
		fault_va = ROUNDDOWN(fault_va, PAGE_SIZE);
f01127be:	8b 45 0c             	mov    0xc(%ebp),%eax
f01127c1:	89 45 84             	mov    %eax,-0x7c(%ebp)
f01127c4:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01127c7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01127cc:	89 45 0c             	mov    %eax,0xc(%ebp)
		struct WorkingSetElement *victimWSElement = NULL;
f01127cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f01127d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01127d9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01127df:	89 45 80             	mov    %eax,-0x80(%ebp)
		if(wsSize < (faulted_env->page_WS_max_size))
f01127e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01127e5:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01127eb:	3b 45 80             	cmp    -0x80(%ebp),%eax
f01127ee:	0f 86 eb 03 00 00    	jbe    f0112bdf <page_fault_handler+0x8fe>
			//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #3 placement
			//Your code is here

			// Check if fault_va is already in the working set
			struct WorkingSetElement *wse_check;
			for(int i=0;i<10;i++){
f01127f4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01127fb:	eb 03                	jmp    f0112800 <page_fault_handler+0x51f>
f01127fd:	ff 45 e4             	incl   -0x1c(%ebp)
f0112800:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f0112804:	7e f7                	jle    f01127fd <page_fault_handler+0x51c>

			}
			bool already_in_ws = 0;
f0112806:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f011280d:	00 00 00 
			LIST_FOREACH(wse_check, &(faulted_env->page_WS_list))
f0112810:	8b 45 08             	mov    0x8(%ebp),%eax
f0112813:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0112819:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011281c:	eb 4c                	jmp    f011286a <page_fault_handler+0x589>
			{
				if(ROUNDDOWN(wse_check->virtual_address, PAGE_SIZE) == fault_va)
f011281e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0112821:	8b 00                	mov    (%eax),%eax
f0112823:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
f0112829:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011282f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112834:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0112837:	75 25                	jne    f011285e <page_fault_handler+0x57d>
				{
					already_in_ws = 1;
f0112839:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0112840:	00 00 00 
					// Page is already in working set, just set it to present
					pt_set_page_permissions(faulted_env->env_page_directory, fault_va, PERM_PRESENT, 0);
f0112843:	8b 45 08             	mov    0x8(%ebp),%eax
f0112846:	8b 40 64             	mov    0x64(%eax),%eax
f0112849:	6a 00                	push   $0x0
f011284b:	6a 01                	push   $0x1
f011284d:	ff 75 0c             	pushl  0xc(%ebp)
f0112850:	50                   	push   %eax
f0112851:	e8 06 8d ff ff       	call   f010b55c <pt_set_page_permissions>
f0112856:	83 c4 10             	add    $0x10,%esp
f0112859:	e9 97 0c 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
			struct WorkingSetElement *wse_check;
			for(int i=0;i<10;i++){

			}
			bool already_in_ws = 0;
			LIST_FOREACH(wse_check, &(faulted_env->page_WS_list))
f011285e:	8b 45 08             	mov    0x8(%ebp),%eax
f0112861:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0112867:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011286a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011286e:	74 08                	je     f0112878 <page_fault_handler+0x597>
f0112870:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0112873:	8b 40 10             	mov    0x10(%eax),%eax
f0112876:	eb 05                	jmp    f011287d <page_fault_handler+0x59c>
f0112878:	b8 00 00 00 00       	mov    $0x0,%eax
f011287d:	8b 55 08             	mov    0x8(%ebp),%edx
f0112880:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0112886:	8b 45 08             	mov    0x8(%ebp),%eax
f0112889:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011288f:	85 c0                	test   %eax,%eax
f0112891:	75 8b                	jne    f011281e <page_fault_handler+0x53d>
f0112893:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0112897:	75 85                	jne    f011281e <page_fault_handler+0x53d>
					pt_set_page_permissions(faulted_env->env_page_directory, fault_va, PERM_PRESENT, 0);
					return;
				}
			}

			if (!isPageReplacmentAlgorithmModifiedCLOCK())
f0112899:	e8 2c ee ff ff       	call   f01116ca <isPageReplacmentAlgorithmModifiedCLOCK>
f011289e:	85 c0                	test   %eax,%eax
f01128a0:	75 0e                	jne    f01128b0 <page_fault_handler+0x5cf>
			{
				reorder_ws_by_id(faulted_env);
f01128a2:	83 ec 0c             	sub    $0xc,%esp
f01128a5:	ff 75 08             	pushl  0x8(%ebp)
f01128a8:	e8 0d f7 ff ff       	call   f0111fba <reorder_ws_by_id>
f01128ad:	83 c4 10             	add    $0x10,%esp
			}
			//reorder_ws_by_id(faulted_env);

			struct FrameInfo *newf;
			allocate_frame(&newf);
f01128b0:	83 ec 0c             	sub    $0xc,%esp
f01128b3:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f01128b9:	50                   	push   %eax
f01128ba:	e8 97 6d ff ff       	call   f0109656 <allocate_frame>
f01128bf:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<10;i++){
f01128c2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01128c9:	eb 03                	jmp    f01128ce <page_fault_handler+0x5ed>
f01128cb:	ff 45 e0             	incl   -0x20(%ebp)
f01128ce:	83 7d e0 09          	cmpl   $0x9,-0x20(%ebp)
f01128d2:	7e f7                	jle    f01128cb <page_fault_handler+0x5ea>

			}
			map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01128d4:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f01128da:	8b 45 08             	mov    0x8(%ebp),%eax
f01128dd:	8b 40 64             	mov    0x64(%eax),%eax
f01128e0:	6a 07                	push   $0x7
f01128e2:	ff 75 0c             	pushl  0xc(%ebp)
f01128e5:	52                   	push   %edx
f01128e6:	50                   	push   %eax
f01128e7:	e8 0b 72 ff ff       	call   f0109af7 <map_frame>
f01128ec:	83 c4 10             	add    $0x10,%esp

			int ret = pf_read_env_page(faulted_env, (void*)fault_va);
f01128ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01128f2:	83 ec 08             	sub    $0x8,%esp
f01128f5:	50                   	push   %eax
f01128f6:	ff 75 08             	pushl  0x8(%ebp)
f01128f9:	e8 a4 2c ff ff       	call   f01055a2 <pf_read_env_page>
f01128fe:	83 c4 10             	add    $0x10,%esp
f0112901:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
			if (ret == E_PAGE_NOT_EXIST_IN_PF)
f0112907:	83 bd 78 ff ff ff f7 	cmpl   $0xfffffff7,-0x88(%ebp)
f011290e:	75 57                	jne    f0112967 <page_fault_handler+0x686>
			{
				if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f0112910:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f0112917:	10 00 00 
f011291a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112920:	2d 01 30 fe 5f       	sub    $0x5ffe3001,%eax
f0112925:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f011292b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0112931:	ba 00 00 00 00       	mov    $0x0,%edx
f0112936:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f011293c:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0112942:	29 d0                	sub    %edx,%eax
f0112944:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0112947:	77 09                	ja     f0112952 <page_fault_handler+0x671>
f0112949:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f0112950:	76 15                	jbe    f0112967 <page_fault_handler+0x686>
					  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f0112952:	8b 45 0c             	mov    0xc(%ebp),%eax
			map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

			int ret = pf_read_env_page(faulted_env, (void*)fault_va);
			if (ret == E_PAGE_NOT_EXIST_IN_PF)
			{
				if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f0112955:	85 c0                	test   %eax,%eax
f0112957:	79 09                	jns    f0112962 <page_fault_handler+0x681>
					  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f0112959:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0112960:	76 05                	jbe    f0112967 <page_fault_handler+0x686>
					env_exit();
f0112962:	e8 9f ac ff ff       	call   f010d606 <env_exit>
			}

			struct WorkingSetElement* e = env_page_ws_list_create_element(faulted_env, fault_va);
f0112967:	83 ec 08             	sub    $0x8,%esp
f011296a:	ff 75 0c             	pushl  0xc(%ebp)
f011296d:	ff 75 08             	pushl  0x8(%ebp)
f0112970:	e8 1c 8f ff ff       	call   f010b891 <env_page_ws_list_create_element>
f0112975:	83 c4 10             	add    $0x10,%esp
f0112978:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			// For Modified Clock, preserve Clock Hand and insert before it
			  if (isPageReplacmentAlgorithmModifiedCLOCK()) {
f011297e:	e8 47 ed ff ff       	call   f01116ca <isPageReplacmentAlgorithmModifiedCLOCK>
f0112983:	85 c0                	test   %eax,%eax
f0112985:	0f 84 82 01 00 00    	je     f0112b0d <page_fault_handler+0x82c>
				if (faulted_env->page_last_WS_element != NULL) {
f011298b:	8b 45 08             	mov    0x8(%ebp),%eax
f011298e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0112994:	85 c0                	test   %eax,%eax
f0112996:	0f 84 b6 00 00 00    	je     f0112a52 <page_fault_handler+0x771>
				  LIST_INSERT_BEFORE(&(faulted_env->page_WS_list),
f011299c:	8b 45 08             	mov    0x8(%ebp),%eax
f011299f:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01129a5:	85 c0                	test   %eax,%eax
f01129a7:	74 09                	je     f01129b2 <page_fault_handler+0x6d1>
f01129a9:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f01129b0:	75 17                	jne    f01129c9 <page_fault_handler+0x6e8>
f01129b2:	83 ec 04             	sub    $0x4,%esp
f01129b5:	68 30 9f 13 f0       	push   $0xf0139f30
f01129ba:	68 35 02 00 00       	push   $0x235
f01129bf:	68 53 9d 13 f0       	push   $0xf0139d53
f01129c4:	e8 e6 e4 fe ff       	call   f0100eaf <_panic>
f01129c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01129cc:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01129d2:	8b 50 14             	mov    0x14(%eax),%edx
f01129d5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f01129db:	89 50 14             	mov    %edx,0x14(%eax)
f01129de:	8b 45 08             	mov    0x8(%ebp),%eax
f01129e1:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
f01129e7:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f01129ed:	89 50 10             	mov    %edx,0x10(%eax)
f01129f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01129f3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01129f9:	8b 40 14             	mov    0x14(%eax),%eax
f01129fc:	85 c0                	test   %eax,%eax
f01129fe:	74 17                	je     f0112a17 <page_fault_handler+0x736>
f0112a00:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a03:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0112a09:	8b 40 14             	mov    0x14(%eax),%eax
f0112a0c:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112a12:	89 50 10             	mov    %edx,0x10(%eax)
f0112a15:	eb 0f                	jmp    f0112a26 <page_fault_handler+0x745>
f0112a17:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a1a:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112a20:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f0112a26:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a29:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0112a2f:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112a35:	89 50 14             	mov    %edx,0x14(%eax)
f0112a38:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a3b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112a41:	8d 50 01             	lea    0x1(%eax),%edx
f0112a44:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a47:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0112a4d:	e9 93 00 00 00       	jmp    f0112ae5 <page_fault_handler+0x804>
									 faulted_env->page_last_WS_element, e);
				} else {
				  LIST_INSERT_TAIL(&(faulted_env->page_WS_list), e);
f0112a52:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f0112a59:	75 17                	jne    f0112a72 <page_fault_handler+0x791>
f0112a5b:	83 ec 04             	sub    $0x4,%esp
f0112a5e:	68 ec 9e 13 f0       	push   $0xf0139eec
f0112a63:	68 37 02 00 00       	push   $0x237
f0112a68:	68 53 9d 13 f0       	push   $0xf0139d53
f0112a6d:	e8 3d e4 fe ff       	call   f0100eaf <_panic>
f0112a72:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a75:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f0112a7b:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0112a81:	89 50 14             	mov    %edx,0x14(%eax)
f0112a84:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0112a8a:	8b 40 14             	mov    0x14(%eax),%eax
f0112a8d:	85 c0                	test   %eax,%eax
f0112a8f:	74 14                	je     f0112aa5 <page_fault_handler+0x7c4>
f0112a91:	8b 45 08             	mov    0x8(%ebp),%eax
f0112a94:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f0112a9a:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112aa0:	89 50 10             	mov    %edx,0x10(%eax)
f0112aa3:	eb 0f                	jmp    f0112ab4 <page_fault_handler+0x7d3>
f0112aa5:	8b 45 08             	mov    0x8(%ebp),%eax
f0112aa8:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112aae:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f0112ab4:	8b 45 08             	mov    0x8(%ebp),%eax
f0112ab7:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112abd:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f0112ac3:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0112ac9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0112ad0:	8b 45 08             	mov    0x8(%ebp),%eax
f0112ad3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112ad9:	8d 50 01             	lea    0x1(%eax),%edx
f0112adc:	8b 45 08             	mov    0x8(%ebp),%eax
f0112adf:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				}

				// Initialize Clock Hand if adding first element
				if (faulted_env->page_last_WS_element == NULL) {
f0112ae5:	8b 45 08             	mov    0x8(%ebp),%eax
f0112ae8:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0112aee:	85 c0                	test   %eax,%eax
f0112af0:	0f 85 ff 09 00 00    	jne    f01134f5 <page_fault_handler+0x1214>
				  faulted_env->page_last_WS_element =
					  LIST_FIRST(&(faulted_env->page_WS_list));
f0112af6:	8b 45 08             	mov    0x8(%ebp),%eax
f0112af9:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
				  LIST_INSERT_TAIL(&(faulted_env->page_WS_list), e);
				}

				// Initialize Clock Hand if adding first element
				if (faulted_env->page_last_WS_element == NULL) {
				  faulted_env->page_last_WS_element =
f0112aff:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b02:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f0112b08:	e9 e8 09 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
					  LIST_FIRST(&(faulted_env->page_WS_list));
				}
			  } else {
				LIST_INSERT_TAIL(&(faulted_env->page_WS_list), e);
f0112b0d:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f0112b14:	75 17                	jne    f0112b2d <page_fault_handler+0x84c>
f0112b16:	83 ec 04             	sub    $0x4,%esp
f0112b19:	68 ec 9e 13 f0       	push   $0xf0139eec
f0112b1e:	68 40 02 00 00       	push   $0x240
f0112b23:	68 53 9d 13 f0       	push   $0xf0139d53
f0112b28:	e8 82 e3 fe ff       	call   f0100eaf <_panic>
f0112b2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b30:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f0112b36:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0112b3c:	89 50 14             	mov    %edx,0x14(%eax)
f0112b3f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0112b45:	8b 40 14             	mov    0x14(%eax),%eax
f0112b48:	85 c0                	test   %eax,%eax
f0112b4a:	74 14                	je     f0112b60 <page_fault_handler+0x87f>
f0112b4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b4f:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f0112b55:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112b5b:	89 50 10             	mov    %edx,0x10(%eax)
f0112b5e:	eb 0f                	jmp    f0112b6f <page_fault_handler+0x88e>
f0112b60:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b63:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112b69:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f0112b6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b72:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f0112b78:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f0112b7e:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0112b84:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0112b8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b8e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112b94:	8d 50 01             	lea    0x1(%eax),%edx
f0112b97:	8b 45 08             	mov    0x8(%ebp),%eax
f0112b9a:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				if (LIST_SIZE(&(faulted_env->page_WS_list)) ==
f0112ba0:	8b 45 08             	mov    0x8(%ebp),%eax
f0112ba3:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
					faulted_env->page_WS_max_size) {
f0112ba9:	8b 45 08             	mov    0x8(%ebp),%eax
f0112bac:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
					  LIST_FIRST(&(faulted_env->page_WS_list));
				}
			  } else {
				LIST_INSERT_TAIL(&(faulted_env->page_WS_list), e);

				if (LIST_SIZE(&(faulted_env->page_WS_list)) ==
f0112bb2:	39 c2                	cmp    %eax,%edx
f0112bb4:	75 17                	jne    f0112bcd <page_fault_handler+0x8ec>
					faulted_env->page_WS_max_size) {
				  faulted_env->page_last_WS_element =
					  LIST_FIRST(&(faulted_env->page_WS_list));
f0112bb6:	8b 45 08             	mov    0x8(%ebp),%eax
f0112bb9:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
			  } else {
				LIST_INSERT_TAIL(&(faulted_env->page_WS_list), e);

				if (LIST_SIZE(&(faulted_env->page_WS_list)) ==
					faulted_env->page_WS_max_size) {
				  faulted_env->page_last_WS_element =
f0112bbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0112bc2:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f0112bc8:	e9 28 09 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
					  LIST_FIRST(&(faulted_env->page_WS_list));
				} else
				  faulted_env->page_last_WS_element = NULL;
f0112bcd:	8b 45 08             	mov    0x8(%ebp),%eax
f0112bd0:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0112bd7:	00 00 00 
f0112bda:	e9 16 09 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
			//Comment the following line
			//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		}
		else
		{
			if (isPageReplacmentAlgorithmCLOCK())
f0112bdf:	e8 b0 ea ff ff       	call   f0111694 <isPageReplacmentAlgorithmCLOCK>
f0112be4:	85 c0                	test   %eax,%eax
f0112be6:	0f 84 9a 03 00 00    	je     f0112f86 <page_fault_handler+0xca5>
			{
				//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #3 Clock Replacement
				//Your code is here

				struct WorkingSetElement* ptr = faulted_env->page_last_WS_element;
f0112bec:	8b 45 08             	mov    0x8(%ebp),%eax
f0112bef:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0112bf5:	89 45 dc             	mov    %eax,-0x24(%ebp)
				for(int i = 0; i < wsSize * 2; ++i){
f0112bf8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0112bff:	e9 86 00 00 00       	jmp    f0112c8a <page_fault_handler+0x9a9>
					uint32 va = ROUNDDOWN(ptr->virtual_address, PAGE_SIZE);
f0112c04:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112c07:	8b 00                	mov    (%eax),%eax
f0112c09:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f0112c0f:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0112c15:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112c1a:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
					int perms = pt_get_page_permissions(faulted_env->env_page_directory, va);
f0112c20:	8b 45 08             	mov    0x8(%ebp),%eax
f0112c23:	8b 40 64             	mov    0x64(%eax),%eax
f0112c26:	83 ec 08             	sub    $0x8,%esp
f0112c29:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f0112c2f:	50                   	push   %eax
f0112c30:	e8 ec 89 ff ff       	call   f010b621 <pt_get_page_permissions>
f0112c35:	83 c4 10             	add    $0x10,%esp
f0112c38:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)

					if (!(perms & PERM_USED)) {
f0112c3e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0112c44:	83 e0 20             	and    $0x20,%eax
f0112c47:	85 c0                	test   %eax,%eax
f0112c49:	75 08                	jne    f0112c53 <page_fault_handler+0x972>
						victimWSElement = ptr;
f0112c4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
						break;
f0112c51:	eb 49                	jmp    f0112c9c <page_fault_handler+0x9bb>
					}
					 pt_set_page_permissions(faulted_env->env_page_directory, va, 0, PERM_USED);
f0112c53:	8b 45 08             	mov    0x8(%ebp),%eax
f0112c56:	8b 40 64             	mov    0x64(%eax),%eax
f0112c59:	6a 20                	push   $0x20
f0112c5b:	6a 00                	push   $0x0
f0112c5d:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f0112c63:	50                   	push   %eax
f0112c64:	e8 f3 88 ff ff       	call   f010b55c <pt_set_page_permissions>
f0112c69:	83 c4 10             	add    $0x10,%esp

					 ptr = LIST_NEXT(ptr);
f0112c6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112c6f:	8b 40 10             	mov    0x10(%eax),%eax
f0112c72:	89 45 dc             	mov    %eax,-0x24(%ebp)
				     if (ptr == NULL) ptr = LIST_FIRST(&(faulted_env->page_WS_list));
f0112c75:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112c79:	75 0c                	jne    f0112c87 <page_fault_handler+0x9a6>
f0112c7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0112c7e:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0112c84:	89 45 dc             	mov    %eax,-0x24(%ebp)
			{
				//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #3 Clock Replacement
				//Your code is here

				struct WorkingSetElement* ptr = faulted_env->page_last_WS_element;
				for(int i = 0; i < wsSize * 2; ++i){
f0112c87:	ff 45 d8             	incl   -0x28(%ebp)
f0112c8a:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112c8d:	01 c0                	add    %eax,%eax
f0112c8f:	89 c2                	mov    %eax,%edx
f0112c91:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112c94:	39 c2                	cmp    %eax,%edx
f0112c96:	0f 87 68 ff ff ff    	ja     f0112c04 <page_fault_handler+0x923>

					 ptr = LIST_NEXT(ptr);
				     if (ptr == NULL) ptr = LIST_FIRST(&(faulted_env->page_WS_list));
				}

				uint32 victim_va = ROUNDDOWN(victimWSElement->virtual_address, PAGE_SIZE);
f0112c9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112c9f:	8b 00                	mov    (%eax),%eax
f0112ca1:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f0112ca7:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0112cad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112cb2:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)

				struct WorkingSetElement *next = LIST_NEXT(victimWSElement);
f0112cb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112cbb:	8b 40 10             	mov    0x10(%eax),%eax
f0112cbe:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)

				uint32 *ptr_page_table = NULL;
f0112cc4:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
f0112ccb:	00 00 00 
				struct FrameInfo *victimFrame = get_frame_info(faulted_env->env_page_directory, victim_va, &ptr_page_table);
f0112cce:	8b 45 08             	mov    0x8(%ebp),%eax
f0112cd1:	8b 40 64             	mov    0x64(%eax),%eax
f0112cd4:	83 ec 04             	sub    $0x4,%esp
f0112cd7:	8d 95 ec fe ff ff    	lea    -0x114(%ebp),%edx
f0112cdd:	52                   	push   %edx
f0112cde:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f0112ce4:	50                   	push   %eax
f0112ce5:	e8 00 6f ff ff       	call   f0109bea <get_frame_info>
f0112cea:	83 c4 10             	add    $0x10,%esp
f0112ced:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)

				int perms = pt_get_page_permissions(faulted_env->env_page_directory, victim_va);
f0112cf3:	8b 45 08             	mov    0x8(%ebp),%eax
f0112cf6:	8b 40 64             	mov    0x64(%eax),%eax
f0112cf9:	83 ec 08             	sub    $0x8,%esp
f0112cfc:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f0112d02:	50                   	push   %eax
f0112d03:	e8 19 89 ff ff       	call   f010b621 <pt_get_page_permissions>
f0112d08:	83 c4 10             	add    $0x10,%esp
f0112d0b:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
				//------------------->
				if(perms & PERM_MODIFIED)
f0112d11:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0112d17:	83 e0 40             	and    $0x40,%eax
f0112d1a:	85 c0                	test   %eax,%eax
f0112d1c:	74 1a                	je     f0112d38 <page_fault_handler+0xa57>
					pf_update_env_page(faulted_env, victim_va, victimFrame);
f0112d1e:	83 ec 04             	sub    $0x4,%esp
f0112d21:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
f0112d27:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f0112d2d:	ff 75 08             	pushl  0x8(%ebp)
f0112d30:	e8 dc 25 ff ff       	call   f0105311 <pf_update_env_page>
f0112d35:	83 c4 10             	add    $0x10,%esp
				//------------------->
				env_page_ws_invalidate(faulted_env, victim_va);
f0112d38:	83 ec 08             	sub    $0x8,%esp
f0112d3b:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f0112d41:	ff 75 08             	pushl  0x8(%ebp)
f0112d44:	e8 d9 8b ff ff       	call   f010b922 <env_page_ws_invalidate>
f0112d49:	83 c4 10             	add    $0x10,%esp

				struct FrameInfo *newf;
				allocate_frame(&newf);
f0112d4c:	83 ec 0c             	sub    $0xc,%esp
f0112d4f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112d55:	50                   	push   %eax
f0112d56:	e8 fb 68 ff ff       	call   f0109656 <allocate_frame>
f0112d5b:	83 c4 10             	add    $0x10,%esp
				map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0112d5e:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f0112d64:	8b 45 08             	mov    0x8(%ebp),%eax
f0112d67:	8b 40 64             	mov    0x64(%eax),%eax
f0112d6a:	6a 07                	push   $0x7
f0112d6c:	ff 75 0c             	pushl  0xc(%ebp)
f0112d6f:	52                   	push   %edx
f0112d70:	50                   	push   %eax
f0112d71:	e8 81 6d ff ff       	call   f0109af7 <map_frame>
f0112d76:	83 c4 10             	add    $0x10,%esp

				int ret = pf_read_env_page(faulted_env, (void*)fault_va);
f0112d79:	8b 45 0c             	mov    0xc(%ebp),%eax
f0112d7c:	83 ec 08             	sub    $0x8,%esp
f0112d7f:	50                   	push   %eax
f0112d80:	ff 75 08             	pushl  0x8(%ebp)
f0112d83:	e8 1a 28 ff ff       	call   f01055a2 <pf_read_env_page>
f0112d88:	83 c4 10             	add    $0x10,%esp
f0112d8b:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
				if (ret == E_PAGE_NOT_EXIST_IN_PF)
f0112d91:	83 bd 44 ff ff ff f7 	cmpl   $0xfffffff7,-0xbc(%ebp)
f0112d98:	75 57                	jne    f0112df1 <page_fault_handler+0xb10>
				{
					if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f0112d9a:	c7 85 40 ff ff ff 00 	movl   $0x1000,-0xc0(%ebp)
f0112da1:	10 00 00 
f0112da4:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0112daa:	2d 01 30 fe 5f       	sub    $0x5ffe3001,%eax
f0112daf:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
f0112db5:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0112dbb:	ba 00 00 00 00       	mov    $0x0,%edx
f0112dc0:	f7 b5 40 ff ff ff    	divl   -0xc0(%ebp)
f0112dc6:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0112dcc:	29 d0                	sub    %edx,%eax
f0112dce:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0112dd1:	77 09                	ja     f0112ddc <page_fault_handler+0xafb>
f0112dd3:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f0112dda:	76 15                	jbe    f0112df1 <page_fault_handler+0xb10>
						  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f0112ddc:	8b 45 0c             	mov    0xc(%ebp),%eax
				map_frame(faulted_env->env_page_directory, newf, fault_va, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

				int ret = pf_read_env_page(faulted_env, (void*)fault_va);
				if (ret == E_PAGE_NOT_EXIST_IN_PF)
				{
					if (!((fault_va >= USTACKBOTTOM && fault_va < USTACKTOP) ||
f0112ddf:	85 c0                	test   %eax,%eax
f0112de1:	79 09                	jns    f0112dec <page_fault_handler+0xb0b>
						  (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)))
f0112de3:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0112dea:	76 05                	jbe    f0112df1 <page_fault_handler+0xb10>
						env_exit();
f0112dec:	e8 15 a8 ff ff       	call   f010d606 <env_exit>
				}

				struct WorkingSetElement *newWSE = env_page_ws_list_create_element(faulted_env, fault_va);
f0112df1:	83 ec 08             	sub    $0x8,%esp
f0112df4:	ff 75 0c             	pushl  0xc(%ebp)
f0112df7:	ff 75 08             	pushl  0x8(%ebp)
f0112dfa:	e8 92 8a ff ff       	call   f010b891 <env_page_ws_list_create_element>
f0112dff:	83 c4 10             	add    $0x10,%esp
f0112e02:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)

				if (!next) LIST_INSERT_TAIL(&(faulted_env->page_WS_list), newWSE);
f0112e08:	83 bd 50 ff ff ff 00 	cmpl   $0x0,-0xb0(%ebp)
f0112e0f:	0f 85 98 00 00 00    	jne    f0112ead <page_fault_handler+0xbcc>
f0112e15:	83 bd 38 ff ff ff 00 	cmpl   $0x0,-0xc8(%ebp)
f0112e1c:	75 17                	jne    f0112e35 <page_fault_handler+0xb54>
f0112e1e:	83 ec 04             	sub    $0x4,%esp
f0112e21:	68 ec 9e 13 f0       	push   $0xf0139eec
f0112e26:	68 7e 02 00 00       	push   $0x27e
f0112e2b:	68 53 9d 13 f0       	push   $0xf0139d53
f0112e30:	e8 7a e0 fe ff       	call   f0100eaf <_panic>
f0112e35:	8b 45 08             	mov    0x8(%ebp),%eax
f0112e38:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f0112e3e:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112e44:	89 50 14             	mov    %edx,0x14(%eax)
f0112e47:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112e4d:	8b 40 14             	mov    0x14(%eax),%eax
f0112e50:	85 c0                	test   %eax,%eax
f0112e52:	74 14                	je     f0112e68 <page_fault_handler+0xb87>
f0112e54:	8b 45 08             	mov    0x8(%ebp),%eax
f0112e57:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f0112e5d:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f0112e63:	89 50 10             	mov    %edx,0x10(%eax)
f0112e66:	eb 0f                	jmp    f0112e77 <page_fault_handler+0xb96>
f0112e68:	8b 45 08             	mov    0x8(%ebp),%eax
f0112e6b:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f0112e71:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f0112e77:	8b 45 08             	mov    0x8(%ebp),%eax
f0112e7a:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f0112e80:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f0112e86:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112e8c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0112e93:	8b 45 08             	mov    0x8(%ebp),%eax
f0112e96:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112e9c:	8d 50 01             	lea    0x1(%eax),%edx
f0112e9f:	8b 45 08             	mov    0x8(%ebp),%eax
f0112ea2:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0112ea8:	e9 9e 00 00 00       	jmp    f0112f4b <page_fault_handler+0xc6a>
				else LIST_INSERT_BEFORE(&(faulted_env->page_WS_list), next, newWSE);
f0112ead:	83 bd 50 ff ff ff 00 	cmpl   $0x0,-0xb0(%ebp)
f0112eb4:	74 09                	je     f0112ebf <page_fault_handler+0xbde>
f0112eb6:	83 bd 38 ff ff ff 00 	cmpl   $0x0,-0xc8(%ebp)
f0112ebd:	75 17                	jne    f0112ed6 <page_fault_handler+0xbf5>
f0112ebf:	83 ec 04             	sub    $0x4,%esp
f0112ec2:	68 30 9f 13 f0       	push   $0xf0139f30
f0112ec7:	68 7f 02 00 00       	push   $0x27f
f0112ecc:	68 53 9d 13 f0       	push   $0xf0139d53
f0112ed1:	e8 d9 df fe ff       	call   f0100eaf <_panic>
f0112ed6:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0112edc:	8b 50 14             	mov    0x14(%eax),%edx
f0112edf:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112ee5:	89 50 14             	mov    %edx,0x14(%eax)
f0112ee8:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112eee:	8b 95 50 ff ff ff    	mov    -0xb0(%ebp),%edx
f0112ef4:	89 50 10             	mov    %edx,0x10(%eax)
f0112ef7:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0112efd:	8b 40 14             	mov    0x14(%eax),%eax
f0112f00:	85 c0                	test   %eax,%eax
f0112f02:	74 14                	je     f0112f18 <page_fault_handler+0xc37>
f0112f04:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0112f0a:	8b 40 14             	mov    0x14(%eax),%eax
f0112f0d:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f0112f13:	89 50 10             	mov    %edx,0x10(%eax)
f0112f16:	eb 0f                	jmp    f0112f27 <page_fault_handler+0xc46>
f0112f18:	8b 45 08             	mov    0x8(%ebp),%eax
f0112f1b:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f0112f21:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f0112f27:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0112f2d:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f0112f33:	89 50 14             	mov    %edx,0x14(%eax)
f0112f36:	8b 45 08             	mov    0x8(%ebp),%eax
f0112f39:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112f3f:	8d 50 01             	lea    0x1(%eax),%edx
f0112f42:	8b 45 08             	mov    0x8(%ebp),%eax
f0112f45:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				if(!LIST_NEXT(newWSE)) faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f0112f4b:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112f51:	8b 40 10             	mov    0x10(%eax),%eax
f0112f54:	85 c0                	test   %eax,%eax
f0112f56:	75 17                	jne    f0112f6f <page_fault_handler+0xc8e>
f0112f58:	8b 45 08             	mov    0x8(%ebp),%eax
f0112f5b:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f0112f61:	8b 45 08             	mov    0x8(%ebp),%eax
f0112f64:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f0112f6a:	e9 86 05 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
				else faulted_env->page_last_WS_element = LIST_NEXT(newWSE);
f0112f6f:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0112f75:	8b 50 10             	mov    0x10(%eax),%edx
f0112f78:	8b 45 08             	mov    0x8(%ebp),%eax
f0112f7b:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f0112f81:	e9 6f 05 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>

				//Comment the following line
				//panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
			}
			else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0112f86:	83 ec 0c             	sub    $0xc,%esp
f0112f89:	6a 01                	push   $0x1
f0112f8b:	e8 ee e6 ff ff       	call   f011167e <isPageReplacmentAlgorithmLRU>
f0112f90:	83 c4 10             	add    $0x10,%esp
f0112f93:	85 c0                	test   %eax,%eax
f0112f95:	0f 84 84 01 00 00    	je     f011311f <page_fault_handler+0xe3e>
			{
				//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #2 LRU Aging Replacement
				//Your code is here

				struct Env *cur_env = get_cpu_proc();
f0112f9b:	e8 a8 a6 ff ff       	call   f010d648 <get_cpu_proc>
f0112fa0:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
				if (cur_env == NULL)
f0112fa6:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%ebp)
f0112fad:	0f 84 3e 05 00 00    	je     f01134f1 <page_fault_handler+0x1210>
					return;

				// Round down fault_va to PAGE_SIZE boundary
				fault_va = ROUNDDOWN(fault_va, PAGE_SIZE);
f0112fb3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0112fb6:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
f0112fbc:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f0112fc2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112fc7:	89 45 0c             	mov    %eax,0xc(%ebp)

				// Check if the frame already exists (page might be mapped but not present)
				uint32 *ptr_table = NULL;
f0112fca:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
f0112fd1:	00 00 00 
				struct FrameInfo * frame_info = get_frame_info(cur_env->env_page_directory, fault_va, &ptr_table);
f0112fd4:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0112fda:	8b 40 64             	mov    0x64(%eax),%eax
f0112fdd:	83 ec 04             	sub    $0x4,%esp
f0112fe0:	8d 95 e4 fe ff ff    	lea    -0x11c(%ebp),%edx
f0112fe6:	52                   	push   %edx
f0112fe7:	ff 75 0c             	pushl  0xc(%ebp)
f0112fea:	50                   	push   %eax
f0112feb:	e8 fa 6b ff ff       	call   f0109bea <get_frame_info>
f0112ff0:	83 c4 10             	add    $0x10,%esp
f0112ff3:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)

				if (frame_info != NULL)
f0112ff9:	83 bd 2c ff ff ff 00 	cmpl   $0x0,-0xd4(%ebp)
f0113000:	74 1f                	je     f0113021 <page_fault_handler+0xd40>
				{
					// Frame already exists, just set PRESENT permission
					pt_set_page_permissions(cur_env->env_page_directory, fault_va, PERM_PRESENT, 0);
f0113002:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0113008:	8b 40 64             	mov    0x64(%eax),%eax
f011300b:	6a 00                	push   $0x0
f011300d:	6a 01                	push   $0x1
f011300f:	ff 75 0c             	pushl  0xc(%ebp)
f0113012:	50                   	push   %eax
f0113013:	e8 44 85 ff ff       	call   f010b55c <pt_set_page_permissions>
f0113018:	83 c4 10             	add    $0x10,%esp
					return;
f011301b:	90                   	nop
f011301c:	e9 d4 04 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
				}

				//=========== [1] intialize the required variables ============

				uint32 min_timestamp = 0xFFFFFFFF;
f0113021:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
				//uint32 max_timestamp = 0; //--------------------------------------->
				uint32 victim_va = 0;
f0113028:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
				struct FrameInfo *frame_to_evict = NULL;
f011302f:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
f0113036:	00 00 00 
	#if USE_KHEAP
				struct WorkingSetElement * the_victim = NULL;
f0113039:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	#else
				int victim_index = -1;
	#endif

				//============= [2] update aging time stamps ===========
				update_WS_time_stamps();
f0113040:	e8 26 50 ff ff       	call   f010806b <update_WS_time_stamps>

				//================== [3] Search through page_WS_list to find page with minimum time stamp ==================

	#if USE_KHEAP

				struct WorkingSetElement * working_set_ele = NULL;
f0113045:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
				LIST_FOREACH(working_set_ele, &(cur_env->page_WS_list))
f011304c:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0113052:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0113058:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011305b:	eb 31                	jmp    f011308e <page_fault_handler+0xdad>
				{
					/*if (wse->time_stamp > max_timestamp) {//----------------------------------------------->
						 max_timestamp = wse->time_stamp;
					}//----------------------------------------------->*/
					if (working_set_ele->time_stamp < min_timestamp)
f011305d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0113060:	8b 40 08             	mov    0x8(%eax),%eax
f0113063:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0113066:	73 17                	jae    f011307f <page_fault_handler+0xd9e>
					{
						min_timestamp = working_set_ele->time_stamp;
f0113068:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011306b:	8b 40 08             	mov    0x8(%eax),%eax
f011306e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
						victim_va = working_set_ele->virtual_address;
f0113071:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0113074:	8b 00                	mov    (%eax),%eax
f0113076:	89 45 d0             	mov    %eax,-0x30(%ebp)
						the_victim = working_set_ele;
f0113079:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011307c:	89 45 cc             	mov    %eax,-0x34(%ebp)
				//================== [3] Search through page_WS_list to find page with minimum time stamp ==================

	#if USE_KHEAP

				struct WorkingSetElement * working_set_ele = NULL;
				LIST_FOREACH(working_set_ele, &(cur_env->page_WS_list))
f011307f:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0113085:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011308b:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011308e:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0113092:	74 08                	je     f011309c <page_fault_handler+0xdbb>
f0113094:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0113097:	8b 40 10             	mov    0x10(%eax),%eax
f011309a:	eb 05                	jmp    f01130a1 <page_fault_handler+0xdc0>
f011309c:	b8 00 00 00 00       	mov    $0x0,%eax
f01130a1:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f01130a7:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01130ad:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f01130b3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01130b9:	85 c0                	test   %eax,%eax
f01130bb:	75 a0                	jne    f011305d <page_fault_handler+0xd7c>
f01130bd:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01130c1:	75 9a                	jne    f011305d <page_fault_handler+0xd7c>
					}
				}
	#endif

				//================= [4] the replacement =================
				if (victim_va != 0)
f01130c3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01130c7:	74 3f                	je     f0113108 <page_fault_handler+0xe27>
				{

					THE_BEFORE_REPLACEMEEEEEEEEEENT(the_victim,faulted_env,victim_va,fault_va);
f01130c9:	ff 75 0c             	pushl  0xc(%ebp)
f01130cc:	ff 75 d0             	pushl  -0x30(%ebp)
f01130cf:	ff 75 08             	pushl  0x8(%ebp)
f01130d2:	ff 75 cc             	pushl  -0x34(%ebp)
f01130d5:	e8 ed f0 ff ff       	call   f01121c7 <THE_BEFORE_REPLACEMEEEEEEEEEENT>
f01130da:	83 c4 10             	add    $0x10,%esp

	#if USE_KHEAP
					// Update the working set element with the new page info
					if (the_victim != NULL)
f01130dd:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01130e1:	0f 84 0e 04 00 00    	je     f01134f5 <page_fault_handler+0x1214>
					{
						the_victim->virtual_address = fault_va;
f01130e7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01130ea:	8b 55 0c             	mov    0xc(%ebp),%edx
f01130ed:	89 10                	mov    %edx,(%eax)
						the_victim->time_stamp = 0xFFFFFFFF; // New page gets highest priority//------------------------------------------->
f01130ef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01130f2:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
						//victim_wse->time_stamp = max_timestamp;//----------------------------------------------->
						the_victim->sweeps_counter = 0;
f01130f9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01130fc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0113103:	e9 ed 03 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
					//cur_env->pageFaultsCounter++;
					//cur_env->nNewPageAdded++;
				}
				else
				{
					panic("page_fault_handler(): No suitable page found for LRU replacement");
f0113108:	83 ec 04             	sub    $0x4,%esp
f011310b:	68 68 9f 13 f0       	push   $0xf0139f68
f0113110:	68 ee 02 00 00       	push   $0x2ee
f0113115:	68 53 9d 13 f0       	push   $0xf0139d53
f011311a:	e8 90 dd fe ff       	call   f0100eaf <_panic>
				}

				//Comment the following line
				//panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
			}
			else if (isPageReplacmentAlgorithmModifiedCLOCK())
f011311f:	e8 a6 e5 ff ff       	call   f01116ca <isPageReplacmentAlgorithmModifiedCLOCK>
f0113124:	85 c0                	test   %eax,%eax
f0113126:	0f 84 c9 03 00 00    	je     f01134f5 <page_fault_handler+0x1214>
			{
				//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #3 Modified Clock Replacement
				//Your code is here

				if (faulted_env == NULL)
f011312c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0113130:	0f 84 be 03 00 00    	je     f01134f4 <page_fault_handler+0x1213>
					return;

				fault_va = ROUNDDOWN(fault_va, PAGE_SIZE);
f0113136:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113139:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
f011313f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0113145:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011314a:	89 45 0c             	mov    %eax,0xc(%ebp)

				uint32 *ptr_table = NULL;
f011314d:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
f0113154:	00 00 00 
				struct FrameInfo * frame_info = get_frame_info(faulted_env->env_page_directory, fault_va, &ptr_table);
f0113157:	8b 45 08             	mov    0x8(%ebp),%eax
f011315a:	8b 40 64             	mov    0x64(%eax),%eax
f011315d:	83 ec 04             	sub    $0x4,%esp
f0113160:	8d 95 e0 fe ff ff    	lea    -0x120(%ebp),%edx
f0113166:	52                   	push   %edx
f0113167:	ff 75 0c             	pushl  0xc(%ebp)
f011316a:	50                   	push   %eax
f011316b:	e8 7a 6a ff ff       	call   f0109bea <get_frame_info>
f0113170:	83 c4 10             	add    $0x10,%esp
f0113173:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
				if (frame_info != NULL)
f0113179:	83 bd 20 ff ff ff 00 	cmpl   $0x0,-0xe0(%ebp)
f0113180:	74 1b                	je     f011319d <page_fault_handler+0xebc>
				{
					pt_set_page_permissions(faulted_env->env_page_directory, fault_va, PERM_PRESENT, 0);
f0113182:	8b 45 08             	mov    0x8(%ebp),%eax
f0113185:	8b 40 64             	mov    0x64(%eax),%eax
f0113188:	6a 00                	push   $0x0
f011318a:	6a 01                	push   $0x1
f011318c:	ff 75 0c             	pushl  0xc(%ebp)
f011318f:	50                   	push   %eax
f0113190:	e8 c7 83 ff ff       	call   f010b55c <pt_set_page_permissions>
f0113195:	83 c4 10             	add    $0x10,%esp
					return;
f0113198:	e9 58 03 00 00       	jmp    f01134f5 <page_fault_handler+0x1214>
				}

				// Variables for the replacement search
				struct WorkingSetElement *ptr = faulted_env->page_last_WS_element;
f011319d:	8b 45 08             	mov    0x8(%ebp),%eax
f01131a0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01131a6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				struct WorkingSetElement * the_victim = NULL;
f01131a9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
				uint32 victim_va = 0;
f01131b0:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%ebp)
f01131b7:	00 00 00 

				//(faulted_env, "BEFORE CLOCK SEARCH (Finding Victim)");

				// --- 1. Modified Clock Search Passes ---

				for (int pass = 0;pass<2;pass++)
f01131ba:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01131c1:	e9 49 01 00 00       	jmp    f011330f <page_fault_handler+0x102e>
				{
					// Start or resume the rotation from the clock hand
					ptr = (ptr == NULL) ? LIST_FIRST(&(faulted_env->page_WS_list)) : ptr;
f01131c6:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f01131ca:	75 0b                	jne    f01131d7 <page_fault_handler+0xef6>
f01131cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01131cf:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01131d5:	eb 03                	jmp    f01131da <page_fault_handler+0xef9>
f01131d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01131da:	89 45 c4             	mov    %eax,-0x3c(%ebp)

					// Loop through the list (size check added for safety)
					for (int i = 0; i < wsSize; ++i)
f01131dd:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01131e4:	eb 78                	jmp    f011325e <page_fault_handler+0xf7d>
					{
						uint32 va = ptr->virtual_address;
f01131e6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01131e9:	8b 00                	mov    (%eax),%eax
f01131eb:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
						uint32 perms = pt_get_page_permissions(faulted_env->env_page_directory, va);
f01131f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01131f4:	8b 40 64             	mov    0x64(%eax),%eax
f01131f7:	83 ec 08             	sub    $0x8,%esp
f01131fa:	ff b5 10 ff ff ff    	pushl  -0xf0(%ebp)
f0113200:	50                   	push   %eax
f0113201:	e8 1b 84 ff ff       	call   f010b621 <pt_get_page_permissions>
f0113206:	83 c4 10             	add    $0x10,%esp
f0113209:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)


						if (!(perms & PERM_USED) && !(perms & PERM_MODIFIED))
f011320f:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f0113215:	83 e0 20             	and    $0x20,%eax
f0113218:	85 c0                	test   %eax,%eax
f011321a:	75 24                	jne    f0113240 <page_fault_handler+0xf5f>
f011321c:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f0113222:	83 e0 40             	and    $0x40,%eax
f0113225:	85 c0                	test   %eax,%eax
f0113227:	75 17                	jne    f0113240 <page_fault_handler+0xf5f>
						{
							the_victim = ptr;
f0113229:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011322c:	89 45 c0             	mov    %eax,-0x40(%ebp)
							victim_va = va;
f011322f:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0113235:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
							goto victim_found;
f011323b:	e9 d9 00 00 00       	jmp    f0113319 <page_fault_handler+0x1038>
						}

						// Advance the clock hand (ptr)
						ptr = LIST_NEXT(ptr);
f0113240:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113243:	8b 40 10             	mov    0x10(%eax),%eax
f0113246:	89 45 c4             	mov    %eax,-0x3c(%ebp)
						if (ptr == NULL) ptr = LIST_FIRST(&(faulted_env->page_WS_list));
f0113249:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011324d:	75 0c                	jne    f011325b <page_fault_handler+0xf7a>
f011324f:	8b 45 08             	mov    0x8(%ebp),%eax
f0113252:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0113258:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				{
					// Start or resume the rotation from the clock hand
					ptr = (ptr == NULL) ? LIST_FIRST(&(faulted_env->page_WS_list)) : ptr;

					// Loop through the list (size check added for safety)
					for (int i = 0; i < wsSize; ++i)
f011325b:	ff 45 b8             	incl   -0x48(%ebp)
f011325e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113261:	3b 45 80             	cmp    -0x80(%ebp),%eax
f0113264:	72 80                	jb     f01131e6 <page_fault_handler+0xf05>
						// Advance the clock hand (ptr)
						ptr = LIST_NEXT(ptr);
						if (ptr == NULL) ptr = LIST_FIRST(&(faulted_env->page_WS_list));
					}

					for (int i = 0; i < wsSize; ++i)
f0113266:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f011326d:	e9 8e 00 00 00       	jmp    f0113300 <page_fault_handler+0x101f>
					{
						uint32 va = ptr->virtual_address;
f0113272:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113275:	8b 00                	mov    (%eax),%eax
f0113277:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
						uint32 perms = pt_get_page_permissions(faulted_env->env_page_directory, va);
f011327d:	8b 45 08             	mov    0x8(%ebp),%eax
f0113280:	8b 40 64             	mov    0x64(%eax),%eax
f0113283:	83 ec 08             	sub    $0x8,%esp
f0113286:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f011328c:	50                   	push   %eax
f011328d:	e8 8f 83 ff ff       	call   f010b621 <pt_get_page_permissions>
f0113292:	83 c4 10             	add    $0x10,%esp
f0113295:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)

						if (!(perms & PERM_USED))
f011329b:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f01132a1:	83 e0 20             	and    $0x20,%eax
f01132a4:	85 c0                	test   %eax,%eax
f01132a6:	75 14                	jne    f01132bc <page_fault_handler+0xfdb>
						{
							the_victim = ptr;
f01132a8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01132ab:	89 45 c0             	mov    %eax,-0x40(%ebp)
							victim_va = va;
f01132ae:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f01132b4:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
							goto victim_found;
f01132ba:	eb 5d                	jmp    f0113319 <page_fault_handler+0x1038>
						}

						if (perms & PERM_USED)
f01132bc:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f01132c2:	83 e0 20             	and    $0x20,%eax
f01132c5:	85 c0                	test   %eax,%eax
f01132c7:	74 19                	je     f01132e2 <page_fault_handler+0x1001>
						{
							pt_set_page_permissions(faulted_env->env_page_directory, va, 0, PERM_USED);
f01132c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01132cc:	8b 40 64             	mov    0x64(%eax),%eax
f01132cf:	6a 20                	push   $0x20
f01132d1:	6a 00                	push   $0x0
f01132d3:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f01132d9:	50                   	push   %eax
f01132da:	e8 7d 82 ff ff       	call   f010b55c <pt_set_page_permissions>
f01132df:	83 c4 10             	add    $0x10,%esp
						}


						// Advance the clock hand (ptr)
						ptr = LIST_NEXT(ptr);
f01132e2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01132e5:	8b 40 10             	mov    0x10(%eax),%eax
f01132e8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
						if (ptr == NULL) ptr = LIST_FIRST(&(faulted_env->page_WS_list));
f01132eb:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f01132ef:	75 0c                	jne    f01132fd <page_fault_handler+0x101c>
f01132f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01132f4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01132fa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
						// Advance the clock hand (ptr)
						ptr = LIST_NEXT(ptr);
						if (ptr == NULL) ptr = LIST_FIRST(&(faulted_env->page_WS_list));
					}

					for (int i = 0; i < wsSize; ++i)
f01132fd:	ff 45 b4             	incl   -0x4c(%ebp)
f0113300:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113303:	3b 45 80             	cmp    -0x80(%ebp),%eax
f0113306:	0f 82 66 ff ff ff    	jb     f0113272 <page_fault_handler+0xf91>

				//(faulted_env, "BEFORE CLOCK SEARCH (Finding Victim)");

				// --- 1. Modified Clock Search Passes ---

				for (int pass = 0;pass<2;pass++)
f011330c:	ff 45 bc             	incl   -0x44(%ebp)
f011330f:	83 7d bc 01          	cmpl   $0x1,-0x44(%ebp)
f0113313:	0f 8e ad fe ff ff    	jle    f01131c6 <page_fault_handler+0xee5>
				}

			// --- 2. Eviction and Loading ---
				victim_found:

				if (the_victim != NULL)
f0113319:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011331d:	0f 84 d2 01 00 00    	je     f01134f5 <page_fault_handler+0x1214>
				{
					uint32 victim_va = ROUNDDOWN(the_victim->virtual_address, PAGE_SIZE);
f0113323:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113326:	8b 00                	mov    (%eax),%eax
f0113328:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
f011332e:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f0113334:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0113339:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)

					// Save the pointer to the element *after* the victim BEFORE removal
					struct WorkingSetElement *next = LIST_NEXT(the_victim);
f011333f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113342:	8b 40 10             	mov    0x10(%eax),%eax
f0113345:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)

					THE_BEFORE_REPLACEMEEEEEEEEEENT(the_victim,faulted_env,victim_va,fault_va);
f011334b:	ff 75 0c             	pushl  0xc(%ebp)
f011334e:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0113354:	ff 75 08             	pushl  0x8(%ebp)
f0113357:	ff 75 c0             	pushl  -0x40(%ebp)
f011335a:	e8 68 ee ff ff       	call   f01121c7 <THE_BEFORE_REPLACEMEEEEEEEEEENT>
f011335f:	83 c4 10             	add    $0x10,%esp


					struct WorkingSetElement *new_WS_ele = env_page_ws_list_create_element(faulted_env, fault_va);
f0113362:	83 ec 08             	sub    $0x8,%esp
f0113365:	ff 75 0c             	pushl  0xc(%ebp)
f0113368:	ff 75 08             	pushl  0x8(%ebp)
f011336b:	e8 21 85 ff ff       	call   f010b891 <env_page_ws_list_create_element>
f0113370:	83 c4 10             	add    $0x10,%esp
f0113373:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)


					if (!next)
f0113379:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
f0113380:	0f 85 98 00 00 00    	jne    f011341e <page_fault_handler+0x113d>
						LIST_INSERT_TAIL(&(faulted_env->page_WS_list), new_WS_ele);
f0113386:	83 bd fc fe ff ff 00 	cmpl   $0x0,-0x104(%ebp)
f011338d:	75 17                	jne    f01133a6 <page_fault_handler+0x10c5>
f011338f:	83 ec 04             	sub    $0x4,%esp
f0113392:	68 ec 9e 13 f0       	push   $0xf0139eec
f0113397:	68 53 03 00 00       	push   $0x353
f011339c:	68 53 9d 13 f0       	push   $0xf0139d53
f01133a1:	e8 09 db fe ff       	call   f0100eaf <_panic>
f01133a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01133a9:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f01133af:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f01133b5:	89 50 14             	mov    %edx,0x14(%eax)
f01133b8:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f01133be:	8b 40 14             	mov    0x14(%eax),%eax
f01133c1:	85 c0                	test   %eax,%eax
f01133c3:	74 14                	je     f01133d9 <page_fault_handler+0x10f8>
f01133c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01133c8:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f01133ce:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f01133d4:	89 50 10             	mov    %edx,0x10(%eax)
f01133d7:	eb 0f                	jmp    f01133e8 <page_fault_handler+0x1107>
f01133d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01133dc:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f01133e2:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f01133e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01133eb:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f01133f1:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f01133f7:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f01133fd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0113404:	8b 45 08             	mov    0x8(%ebp),%eax
f0113407:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011340d:	8d 50 01             	lea    0x1(%eax),%edx
f0113410:	8b 45 08             	mov    0x8(%ebp),%eax
f0113413:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0113419:	e9 9e 00 00 00       	jmp    f01134bc <page_fault_handler+0x11db>
					else
						LIST_INSERT_BEFORE(&(faulted_env->page_WS_list), next, new_WS_ele);
f011341e:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
f0113425:	74 09                	je     f0113430 <page_fault_handler+0x114f>
f0113427:	83 bd fc fe ff ff 00 	cmpl   $0x0,-0x104(%ebp)
f011342e:	75 17                	jne    f0113447 <page_fault_handler+0x1166>
f0113430:	83 ec 04             	sub    $0x4,%esp
f0113433:	68 30 9f 13 f0       	push   $0xf0139f30
f0113438:	68 55 03 00 00       	push   $0x355
f011343d:	68 53 9d 13 f0       	push   $0xf0139d53
f0113442:	e8 68 da fe ff       	call   f0100eaf <_panic>
f0113447:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011344d:	8b 50 14             	mov    0x14(%eax),%edx
f0113450:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f0113456:	89 50 14             	mov    %edx,0x14(%eax)
f0113459:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011345f:	8b 95 00 ff ff ff    	mov    -0x100(%ebp),%edx
f0113465:	89 50 10             	mov    %edx,0x10(%eax)
f0113468:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011346e:	8b 40 14             	mov    0x14(%eax),%eax
f0113471:	85 c0                	test   %eax,%eax
f0113473:	74 14                	je     f0113489 <page_fault_handler+0x11a8>
f0113475:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011347b:	8b 40 14             	mov    0x14(%eax),%eax
f011347e:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f0113484:	89 50 10             	mov    %edx,0x10(%eax)
f0113487:	eb 0f                	jmp    f0113498 <page_fault_handler+0x11b7>
f0113489:	8b 45 08             	mov    0x8(%ebp),%eax
f011348c:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f0113492:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f0113498:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011349e:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f01134a4:	89 50 14             	mov    %edx,0x14(%eax)
f01134a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01134aa:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01134b0:	8d 50 01             	lea    0x1(%eax),%edx
f01134b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01134b6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

					if(!LIST_NEXT(new_WS_ele))
f01134bc:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f01134c2:	8b 40 10             	mov    0x10(%eax),%eax
f01134c5:	85 c0                	test   %eax,%eax
f01134c7:	75 14                	jne    f01134dd <page_fault_handler+0x11fc>
						faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f01134c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01134cc:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01134d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01134d5:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f01134db:	eb 18                	jmp    f01134f5 <page_fault_handler+0x1214>
					else
						faulted_env->page_last_WS_element = LIST_NEXT(new_WS_ele);
f01134dd:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f01134e3:	8b 50 10             	mov    0x10(%eax),%edx
f01134e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01134e9:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
f01134ef:	eb 04                	jmp    f01134f5 <page_fault_handler+0x1214>
				//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #2 LRU Aging Replacement
				//Your code is here

				struct Env *cur_env = get_cpu_proc();
				if (cur_env == NULL)
					return;
f01134f1:	90                   	nop
f01134f2:	eb 01                	jmp    f01134f5 <page_fault_handler+0x1214>
			{
				//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #3 Modified Clock Replacement
				//Your code is here

				if (faulted_env == NULL)
					return;
f01134f4:	90                   	nop
				//panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
			}
		}
	}
#endif
}
f01134f5:	c9                   	leave  
f01134f6:	c3                   	ret    

f01134f7 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f01134f7:	55                   	push   %ebp
f01134f8:	89 e5                	mov    %esp,%ebp
f01134fa:	83 ec 08             	sub    $0x8,%esp
	panic("this function is not required...!!");
f01134fd:	83 ec 04             	sub    $0x4,%esp
f0113500:	68 ac 9f 13 f0       	push   $0xf0139fac
f0113505:	68 67 03 00 00       	push   $0x367
f011350a:	68 53 9d 13 f0       	push   $0xf0139d53
f011350f:	e8 9b d9 fe ff       	call   f0100eaf <_panic>

f0113514 <init_kspinlock>:
#include "inc/assert.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_kspinlock(struct kspinlock *lk, char *name)
{
f0113514:	55                   	push   %ebp
f0113515:	89 e5                	mov    %esp,%ebp
f0113517:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f011351a:	8b 45 08             	mov    0x8(%ebp),%eax
f011351d:	83 c0 04             	add    $0x4,%eax
f0113520:	83 ec 08             	sub    $0x8,%esp
f0113523:	ff 75 0c             	pushl  0xc(%ebp)
f0113526:	50                   	push   %eax
f0113527:	e8 52 f9 00 00       	call   f0122e7e <strcpy>
f011352c:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f011352f:	8b 45 08             	mov    0x8(%ebp),%eax
f0113532:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f0113538:	8b 45 08             	mov    0x8(%ebp),%eax
f011353b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f0113542:	90                   	nop
f0113543:	c9                   	leave  
f0113544:	c3                   	ret    

f0113545 <acquire_kspinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_kspinlock(struct kspinlock *lk)
{
f0113545:	55                   	push   %ebp
f0113546:	89 e5                	mov    %esp,%ebp
f0113548:	53                   	push   %ebx
f0113549:	83 ec 24             	sub    $0x24,%esp
	if(holding_kspinlock(lk))
f011354c:	8b 45 08             	mov    0x8(%ebp),%eax
f011354f:	83 ec 0c             	sub    $0xc,%esp
f0113552:	50                   	push   %eax
f0113553:	e8 42 02 00 00       	call   f011379a <holding_kspinlock>
f0113558:	83 c4 10             	add    $0x10,%esp
f011355b:	85 c0                	test   %eax,%eax
f011355d:	74 18                	je     f0113577 <acquire_kspinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f011355f:	8b 45 08             	mov    0x8(%ebp),%eax
f0113562:	83 c0 04             	add    $0x4,%eax
f0113565:	50                   	push   %eax
f0113566:	68 d0 9f 13 f0       	push   $0xf0139fd0
f011356b:	6a 1f                	push   $0x1f
f011356d:	68 0d a0 13 f0       	push   $0xf013a00d
f0113572:	e8 38 d9 fe ff       	call   f0100eaf <_panic>

	/*disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler)
	 * just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
	 */
	pushcli();
f0113577:	e8 46 50 ff ff       	call   f01085c2 <pushcli>

	int envID = 0;
f011357c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f0113583:	e8 c0 a0 ff ff       	call   f010d648 <get_cpu_proc>
f0113588:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f011358b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011358f:	74 09                	je     f011359a <acquire_kspinlock+0x55>
f0113591:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113594:	8b 40 10             	mov    0x10(%eax),%eax
f0113597:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] try to acquire spinlock [%s]\n", envID, lk->name);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f011359a:	90                   	nop
f011359b:	8b 45 08             	mov    0x8(%ebp),%eax
f011359e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01135a1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01135a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01135ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01135ae:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01135b1:	f0 87 02             	lock xchg %eax,(%edx)
f01135b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f01135b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01135ba:	85 c0                	test   %eax,%eax
f01135bc:	75 dd                	jne    f011359b <acquire_kspinlock+0x56>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, envID);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f01135be:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f01135c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01135c6:	e8 34 4f ff ff       	call   f01084ff <mycpu>
f01135cb:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f01135ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01135d1:	83 c0 48             	add    $0x48,%eax
f01135d4:	83 ec 08             	sub    $0x8,%esp
f01135d7:	50                   	push   %eax
f01135d8:	8d 45 08             	lea    0x8(%ebp),%eax
f01135db:	50                   	push   %eax
f01135dc:	e8 92 00 00 00       	call   f0113673 <getcallerpcs>
f01135e1:	83 c4 10             	add    $0x10,%esp

}
f01135e4:	90                   	nop
f01135e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01135e8:	c9                   	leave  
f01135e9:	c3                   	ret    

f01135ea <release_kspinlock>:

// Release the lock.
void release_kspinlock(struct kspinlock *lk)
{
f01135ea:	55                   	push   %ebp
f01135eb:	89 e5                	mov    %esp,%ebp
f01135ed:	83 ec 18             	sub    $0x18,%esp
	if(!holding_kspinlock(lk))
f01135f0:	83 ec 0c             	sub    $0xc,%esp
f01135f3:	ff 75 08             	pushl  0x8(%ebp)
f01135f6:	e8 9f 01 00 00       	call   f011379a <holding_kspinlock>
f01135fb:	83 c4 10             	add    $0x10,%esp
f01135fe:	85 c0                	test   %eax,%eax
f0113600:	75 26                	jne    f0113628 <release_kspinlock+0x3e>
	{
		printcallstack(lk);
f0113602:	83 ec 0c             	sub    $0xc,%esp
f0113605:	ff 75 08             	pushl  0x8(%ebp)
f0113608:	e8 26 01 00 00       	call   f0113733 <printcallstack>
f011360d:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f0113610:	8b 45 08             	mov    0x8(%ebp),%eax
f0113613:	83 c0 04             	add    $0x4,%eax
f0113616:	50                   	push   %eax
f0113617:	68 24 a0 13 f0       	push   $0xf013a024
f011361c:	6a 41                	push   $0x41
f011361e:	68 0d a0 13 f0       	push   $0xf013a00d
f0113623:	e8 87 d8 fe ff       	call   f0100eaf <_panic>
	}
	lk->pcs[0] = 0;
f0113628:	8b 45 08             	mov    0x8(%ebp),%eax
f011362b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f0113632:	8b 45 08             	mov    0x8(%ebp),%eax
f0113635:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f011363c:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0113641:	8b 45 08             	mov    0x8(%ebp),%eax
f0113644:	8b 55 08             	mov    0x8(%ebp),%edx
f0113647:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	int envID = 0;
f011364d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f0113654:	e8 ef 9f ff ff       	call   f010d648 <get_cpu_proc>
f0113659:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f011365c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113660:	74 09                	je     f011366b <release_kspinlock+0x81>
f0113662:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113665:	8b 40 10             	mov    0x10(%eax),%eax
f0113668:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] release spinlock [%s]\n", envID, lk->name);

	popcli();
f011366b:	e8 a4 4f ff ff       	call   f0108614 <popcli>

}
f0113670:	90                   	nop
f0113671:	c9                   	leave  
f0113672:	c3                   	ret    

f0113673 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f0113673:	55                   	push   %ebp
f0113674:	89 e5                	mov    %esp,%ebp
f0113676:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f0113679:	e8 ca 9f ff ff       	call   f010d648 <get_cpu_proc>
f011367e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f0113681:	e8 79 4e ff ff       	call   f01084ff <mycpu>
f0113686:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f0113689:	8b 45 08             	mov    0x8(%ebp),%eax
f011368c:	83 e8 08             	sub    $0x8,%eax
f011368f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f0113692:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0113699:	eb 67                	jmp    f0113702 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f011369b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011369f:	74 67                	je     f0113708 <getcallerpcs+0x95>
f01136a1:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f01136a8:	76 5e                	jbe    f0113708 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f01136aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01136ad:	8b 40 08             	mov    0x8(%eax),%eax
f01136b0:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f01136b5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01136b8:	77 10                	ja     f01136ca <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f01136ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01136bd:	8b 40 08             	mov    0x8(%eax),%eax
f01136c0:	05 00 90 00 00       	add    $0x9000,%eax
f01136c5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01136c8:	77 3e                	ja     f0113708 <getcallerpcs+0x95>
f01136ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01136ce:	74 10                	je     f01136e0 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f01136d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01136d3:	8b 40 70             	mov    0x70(%eax),%eax
f01136d6:	05 00 80 00 00       	add    $0x8000,%eax
f01136db:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01136de:	76 28                	jbe    f0113708 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f01136e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01136e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01136ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01136ed:	01 c2                	add    %eax,%edx
f01136ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01136f2:	8b 40 04             	mov    0x4(%eax),%eax
f01136f5:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f01136f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01136fa:	8b 00                	mov    (%eax),%eax
f01136fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f01136ff:	ff 45 f0             	incl   -0x10(%ebp)
f0113702:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0113706:	7e 93                	jle    f011369b <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f0113708:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011370b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f011370e:	eb 18                	jmp    f0113728 <getcallerpcs+0xb5>
		pcs[i] = 0;
f0113710:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113713:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011371a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011371d:	01 d0                	add    %edx,%eax
f011371f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f0113725:	ff 45 f0             	incl   -0x10(%ebp)
f0113728:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011372c:	7e e2                	jle    f0113710 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f011372e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0113731:	c9                   	leave  
f0113732:	c3                   	ret    

f0113733 <printcallstack>:

void printcallstack(struct kspinlock *lk)
{
f0113733:	55                   	push   %ebp
f0113734:	89 e5                	mov    %esp,%ebp
f0113736:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f0113739:	83 ec 0c             	sub    $0xc,%esp
f011373c:	68 62 a0 13 f0       	push   $0xf013a062
f0113741:	e8 07 e4 fe ff       	call   f0101b4d <cprintf>
f0113746:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f0113749:	8b 45 08             	mov    0x8(%ebp),%eax
f011374c:	83 c0 48             	add    $0x48,%eax
f011374f:	83 ec 08             	sub    $0x8,%esp
f0113752:	50                   	push   %eax
f0113753:	8d 45 08             	lea    0x8(%ebp),%eax
f0113756:	50                   	push   %eax
f0113757:	e8 17 ff ff ff       	call   f0113673 <getcallerpcs>
f011375c:	83 c4 10             	add    $0x10,%esp
f011375f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f0113762:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0113769:	eb 24                	jmp    f011378f <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f011376b:	8b 45 08             	mov    0x8(%ebp),%eax
f011376e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0113771:	83 c2 10             	add    $0x10,%edx
f0113774:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f0113778:	83 ec 04             	sub    $0x4,%esp
f011377b:	50                   	push   %eax
f011377c:	ff 75 f4             	pushl  -0xc(%ebp)
f011377f:	68 72 a0 13 f0       	push   $0xf013a072
f0113784:	e8 c4 e3 fe ff       	call   f0101b4d <cprintf>
f0113789:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct kspinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f011378c:	ff 45 f4             	incl   -0xc(%ebp)
f011378f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113792:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0113795:	7c d4                	jl     f011376b <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f0113797:	90                   	nop
f0113798:	c9                   	leave  
f0113799:	c3                   	ret    

f011379a <holding_kspinlock>:
// Check whether this cpu is holding the lock.
int holding_kspinlock(struct kspinlock *lock)
{
f011379a:	55                   	push   %ebp
f011379b:	89 e5                	mov    %esp,%ebp
f011379d:	53                   	push   %ebx
f011379e:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f01137a1:	e8 1c 4e ff ff       	call   f01085c2 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f01137a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01137a9:	8b 00                	mov    (%eax),%eax
f01137ab:	85 c0                	test   %eax,%eax
f01137ad:	74 16                	je     f01137c5 <holding_kspinlock+0x2b>
f01137af:	8b 45 08             	mov    0x8(%ebp),%eax
f01137b2:	8b 58 44             	mov    0x44(%eax),%ebx
f01137b5:	e8 45 4d ff ff       	call   f01084ff <mycpu>
f01137ba:	39 c3                	cmp    %eax,%ebx
f01137bc:	75 07                	jne    f01137c5 <holding_kspinlock+0x2b>
f01137be:	b8 01 00 00 00       	mov    $0x1,%eax
f01137c3:	eb 05                	jmp    f01137ca <holding_kspinlock+0x30>
f01137c5:	b8 00 00 00 00       	mov    $0x0,%eax
f01137ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f01137cd:	e8 42 4e ff ff       	call   f0108614 <popcli>
	return r;
f01137d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01137d5:	83 c4 14             	add    $0x14,%esp
f01137d8:	5b                   	pop    %ebx
f01137d9:	5d                   	pop    %ebp
f01137da:	c3                   	ret    

f01137db <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f01137db:	55                   	push   %ebp
f01137dc:	89 e5                	mov    %esp,%ebp
f01137de:	57                   	push   %edi
f01137df:	56                   	push   %esi
f01137e0:	53                   	push   %ebx
f01137e1:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  init_channel(&(lk->chan), "sleep lock channel");
f01137e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01137ea:	83 c0 74             	add    $0x74,%eax
f01137ed:	83 ec 08             	sub    $0x8,%esp
f01137f0:	68 81 a0 13 f0       	push   $0xf013a081
f01137f5:	50                   	push   %eax
f01137f6:	e8 99 01 00 00       	call   f0113994 <init_channel>
f01137fb:	83 c4 10             	add    $0x10,%esp
  char prefix[30] = "lock of sleeplock - ";
f01137fe:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0113801:	bb 94 a0 13 f0       	mov    $0xf013a094,%ebx
f0113806:	ba 15 00 00 00       	mov    $0x15,%edx
f011380b:	89 c7                	mov    %eax,%edi
f011380d:	89 de                	mov    %ebx,%esi
f011380f:	89 d1                	mov    %edx,%ecx
f0113811:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113813:	8d 55 df             	lea    -0x21(%ebp),%edx
f0113816:	b9 09 00 00 00       	mov    $0x9,%ecx
f011381b:	b0 00                	mov    $0x0,%al
f011381d:	89 d7                	mov    %edx,%edi
f011381f:	f3 aa                	rep stos %al,%es:(%edi)
  char guardName[30+NAMELEN];
  strcconcat(prefix, name, guardName);
f0113821:	83 ec 04             	sub    $0x4,%esp
f0113824:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011382a:	50                   	push   %eax
f011382b:	ff 75 0c             	pushl  0xc(%ebp)
f011382e:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0113831:	50                   	push   %eax
f0113832:	e8 26 fc 00 00       	call   f012345d <strcconcat>
f0113837:	83 c4 10             	add    $0x10,%esp
  init_kspinlock(&(lk->lk), guardName);
f011383a:	8b 45 08             	mov    0x8(%ebp),%eax
f011383d:	8d 50 04             	lea    0x4(%eax),%edx
f0113840:	83 ec 08             	sub    $0x8,%esp
f0113843:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0113849:	50                   	push   %eax
f011384a:	52                   	push   %edx
f011384b:	e8 c4 fc ff ff       	call   f0113514 <init_kspinlock>
f0113850:	83 c4 10             	add    $0x10,%esp
  strcpy(lk->name, name);
f0113853:	8b 45 08             	mov    0x8(%ebp),%eax
f0113856:	05 c4 00 00 00       	add    $0xc4,%eax
f011385b:	83 ec 08             	sub    $0x8,%esp
f011385e:	ff 75 0c             	pushl  0xc(%ebp)
f0113861:	50                   	push   %eax
f0113862:	e8 17 f6 00 00       	call   f0122e7e <strcpy>
f0113867:	83 c4 10             	add    $0x10,%esp
  lk->locked = 0;
f011386a:	8b 45 08             	mov    0x8(%ebp),%eax
f011386d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  lk->pid = 0;
f0113873:	8b 45 08             	mov    0x8(%ebp),%eax
f0113876:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f011387d:	00 00 00 
}
f0113880:	90                   	nop
f0113881:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113884:	5b                   	pop    %ebx
f0113885:	5e                   	pop    %esi
f0113886:	5f                   	pop    %edi
f0113887:	5d                   	pop    %ebp
f0113888:	c3                   	ret    

f0113889 <acquire_sleeplock>:

void acquire_sleeplock(struct sleeplock *lk)
{
f0113889:	55                   	push   %ebp
f011388a:	89 e5                	mov    %esp,%ebp
f011388c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&lk->lk);
f011388f:	8b 45 08             	mov    0x8(%ebp),%eax
f0113892:	83 c0 04             	add    $0x4,%eax
f0113895:	83 ec 0c             	sub    $0xc,%esp
f0113898:	50                   	push   %eax
f0113899:	e8 a7 fc ff ff       	call   f0113545 <acquire_kspinlock>
f011389e:	83 c4 10             	add    $0x10,%esp

	while (lk->locked) {
f01138a1:	eb 19                	jmp    f01138bc <acquire_sleeplock+0x33>
		sleep(&lk->chan, &lk->lk);
f01138a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01138a6:	8d 50 04             	lea    0x4(%eax),%edx
f01138a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01138ac:	83 c0 74             	add    $0x74,%eax
f01138af:	83 ec 08             	sub    $0x8,%esp
f01138b2:	52                   	push   %edx
f01138b3:	50                   	push   %eax
f01138b4:	e8 08 01 00 00       	call   f01139c1 <sleep>
f01138b9:	83 c4 10             	add    $0x10,%esp
void acquire_sleeplock(struct sleeplock *lk)
{
#if USE_KHEAP
	acquire_kspinlock(&lk->lk);

	while (lk->locked) {
f01138bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01138bf:	8b 00                	mov    (%eax),%eax
f01138c1:	85 c0                	test   %eax,%eax
f01138c3:	75 de                	jne    f01138a3 <acquire_sleeplock+0x1a>
		sleep(&lk->chan, &lk->lk);
	}

	lk->locked = 1;
f01138c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01138c8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	release_kspinlock(&lk->lk);
f01138ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01138d1:	83 c0 04             	add    $0x4,%eax
f01138d4:	83 ec 0c             	sub    $0xc,%esp
f01138d7:	50                   	push   %eax
f01138d8:	e8 0d fd ff ff       	call   f01135ea <release_kspinlock>
f01138dd:	83 c4 10             	add    $0x10,%esp
#else
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

}
f01138e0:	90                   	nop
f01138e1:	c9                   	leave  
f01138e2:	c3                   	ret    

f01138e3 <release_sleeplock>:


void release_sleeplock(struct sleeplock *lk)
{
f01138e3:	55                   	push   %ebp
f01138e4:	89 e5                	mov    %esp,%ebp
f01138e6:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&lk->lk);
f01138e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01138ec:	83 c0 04             	add    $0x4,%eax
f01138ef:	83 ec 0c             	sub    $0xc,%esp
f01138f2:	50                   	push   %eax
f01138f3:	e8 4d fc ff ff       	call   f0113545 <acquire_kspinlock>
f01138f8:	83 c4 10             	add    $0x10,%esp
	if (lk->locked) {
f01138fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01138fe:	8b 00                	mov    (%eax),%eax
f0113900:	85 c0                	test   %eax,%eax
f0113902:	74 1b                	je     f011391f <release_sleeplock+0x3c>
		lk->locked = 0;
f0113904:	8b 45 08             	mov    0x8(%ebp),%eax
f0113907:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		wakeup_all(&lk->chan);
f011390d:	8b 45 08             	mov    0x8(%ebp),%eax
f0113910:	83 c0 74             	add    $0x74,%eax
f0113913:	83 ec 0c             	sub    $0xc,%esp
f0113916:	50                   	push   %eax
f0113917:	e8 8d 01 00 00       	call   f0113aa9 <wakeup_all>
f011391c:	83 c4 10             	add    $0x10,%esp
	 }


	release_kspinlock(&lk->lk);
f011391f:	8b 45 08             	mov    0x8(%ebp),%eax
f0113922:	83 c0 04             	add    $0x4,%eax
f0113925:	83 ec 0c             	sub    $0xc,%esp
f0113928:	50                   	push   %eax
f0113929:	e8 bc fc ff ff       	call   f01135ea <release_kspinlock>
f011392e:	83 c4 10             	add    $0x10,%esp

  //TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #5 SLEEP LOCK - release_sleeplock
  //Your code is here
  //Comment the following line
  //panic("release_sleeplock() is not implemented yet...!!");
}
f0113931:	90                   	nop
f0113932:	c9                   	leave  
f0113933:	c3                   	ret    

f0113934 <holding_sleeplock>:

int holding_sleeplock(struct sleeplock *lk)
{
f0113934:	55                   	push   %ebp
f0113935:	89 e5                	mov    %esp,%ebp
f0113937:	53                   	push   %ebx
f0113938:	83 ec 14             	sub    $0x14,%esp
  int r;
  acquire_kspinlock(&(lk->lk));
f011393b:	8b 45 08             	mov    0x8(%ebp),%eax
f011393e:	83 c0 04             	add    $0x4,%eax
f0113941:	83 ec 0c             	sub    $0xc,%esp
f0113944:	50                   	push   %eax
f0113945:	e8 fb fb ff ff       	call   f0113545 <acquire_kspinlock>
f011394a:	83 c4 10             	add    $0x10,%esp
  r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f011394d:	8b 45 08             	mov    0x8(%ebp),%eax
f0113950:	8b 00                	mov    (%eax),%eax
f0113952:	85 c0                	test   %eax,%eax
f0113954:	74 1c                	je     f0113972 <holding_sleeplock+0x3e>
f0113956:	8b 45 08             	mov    0x8(%ebp),%eax
f0113959:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f011395f:	e8 e4 9c ff ff       	call   f010d648 <get_cpu_proc>
f0113964:	8b 40 10             	mov    0x10(%eax),%eax
f0113967:	39 c3                	cmp    %eax,%ebx
f0113969:	75 07                	jne    f0113972 <holding_sleeplock+0x3e>
f011396b:	b8 01 00 00 00       	mov    $0x1,%eax
f0113970:	eb 05                	jmp    f0113977 <holding_sleeplock+0x43>
f0113972:	b8 00 00 00 00       	mov    $0x0,%eax
f0113977:	89 45 f4             	mov    %eax,-0xc(%ebp)
  release_kspinlock(&(lk->lk));
f011397a:	8b 45 08             	mov    0x8(%ebp),%eax
f011397d:	83 c0 04             	add    $0x4,%eax
f0113980:	83 ec 0c             	sub    $0xc,%esp
f0113983:	50                   	push   %eax
f0113984:	e8 61 fc ff ff       	call   f01135ea <release_kspinlock>
f0113989:	83 c4 10             	add    $0x10,%esp
  return r;
f011398c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011398f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0113992:	c9                   	leave  
f0113993:	c3                   	ret    

f0113994 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0113994:	55                   	push   %ebp
f0113995:	89 e5                	mov    %esp,%ebp
f0113997:	83 ec 08             	sub    $0x8,%esp
  strcpy(chan->name, name);
f011399a:	8b 45 08             	mov    0x8(%ebp),%eax
f011399d:	83 c0 10             	add    $0x10,%eax
f01139a0:	83 ec 08             	sub    $0x8,%esp
f01139a3:	ff 75 0c             	pushl  0xc(%ebp)
f01139a6:	50                   	push   %eax
f01139a7:	e8 d2 f4 00 00       	call   f0122e7e <strcpy>
f01139ac:	83 c4 10             	add    $0x10,%esp
  init_queue(&(chan->queue));
f01139af:	8b 45 08             	mov    0x8(%ebp),%eax
f01139b2:	83 ec 0c             	sub    $0xc,%esp
f01139b5:	50                   	push   %eax
f01139b6:	e8 19 26 ff ff       	call   f0105fd4 <init_queue>
f01139bb:	83 c4 10             	add    $0x10,%esp
}
f01139be:	90                   	nop
f01139bf:	c9                   	leave  
f01139c0:	c3                   	ret    

f01139c1 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct kspinlock *lk)
{
f01139c1:	55                   	push   %ebp
f01139c2:	89 e5                	mov    %esp,%ebp
f01139c4:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #1 CHANNEL - sleep
	//Your code is here

#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f01139c7:	83 ec 0c             	sub    $0xc,%esp
f01139ca:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01139cf:	e8 71 fb ff ff       	call   f0113545 <acquire_kspinlock>
f01139d4:	83 c4 10             	add    $0x10,%esp

	release_kspinlock(lk);
f01139d7:	83 ec 0c             	sub    $0xc,%esp
f01139da:	ff 75 0c             	pushl  0xc(%ebp)
f01139dd:	e8 08 fc ff ff       	call   f01135ea <release_kspinlock>
f01139e2:	83 c4 10             	add    $0x10,%esp

	struct Env *cur = get_cpu_proc();
f01139e5:	e8 5e 9c ff ff       	call   f010d648 <get_cpu_proc>
f01139ea:	89 45 f4             	mov    %eax,-0xc(%ebp)

	cur->channel = chan;
f01139ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01139f0:	8b 55 08             	mov    0x8(%ebp),%edx
f01139f3:	89 50 60             	mov    %edx,0x60(%eax)

	enqueue(&(chan->queue), cur);
f01139f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01139f9:	83 ec 08             	sub    $0x8,%esp
f01139fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01139ff:	50                   	push   %eax
f0113a00:	e8 10 26 ff ff       	call   f0106015 <enqueue>
f0113a05:	83 c4 10             	add    $0x10,%esp

	cur->env_status = ENV_BLOCKED;
f0113a08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113a0b:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)

	sched();
f0113a12:	e8 ab 9d ff ff       	call   f010d7c2 <sched>

	release_kspinlock(&ProcessQueues.qlock);
f0113a17:	83 ec 0c             	sub    $0xc,%esp
f0113a1a:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113a1f:	e8 c6 fb ff ff       	call   f01135ea <release_kspinlock>
f0113a24:	83 c4 10             	add    $0x10,%esp

	acquire_kspinlock(lk);
f0113a27:	83 ec 0c             	sub    $0xc,%esp
f0113a2a:	ff 75 0c             	pushl  0xc(%ebp)
f0113a2d:	e8 13 fb ff ff       	call   f0113545 <acquire_kspinlock>
f0113a32:	83 c4 10             	add    $0x10,%esp
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

  //Comment the following line
  //panic("sleep() is not implemented yet...!!");
}
f0113a35:	90                   	nop
f0113a36:	c9                   	leave  
f0113a37:	c3                   	ret    

f0113a38 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f0113a38:	55                   	push   %ebp
f0113a39:	89 e5                	mov    %esp,%ebp
f0113a3b:	83 ec 18             	sub    $0x18,%esp
  //TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #2 CHANNEL - wakeup_one
  //Your code is here

#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f0113a3e:	83 ec 0c             	sub    $0xc,%esp
f0113a41:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113a46:	e8 fa fa ff ff       	call   f0113545 <acquire_kspinlock>
f0113a4b:	83 c4 10             	add    $0x10,%esp

	if (queue_size(&(chan->queue)) == 0)
f0113a4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0113a51:	83 ec 0c             	sub    $0xc,%esp
f0113a54:	50                   	push   %eax
f0113a55:	e8 a3 25 ff ff       	call   f0105ffd <queue_size>
f0113a5a:	83 c4 10             	add    $0x10,%esp
f0113a5d:	85 c0                	test   %eax,%eax
f0113a5f:	74 42                	je     f0113aa3 <wakeup_one+0x6b>
		return;

	struct Env *e = dequeue(&(chan->queue));
f0113a61:	8b 45 08             	mov    0x8(%ebp),%eax
f0113a64:	83 ec 0c             	sub    $0xc,%esp
f0113a67:	50                   	push   %eax
f0113a68:	e8 39 26 ff ff       	call   f01060a6 <dequeue>
f0113a6d:	83 c4 10             	add    $0x10,%esp
f0113a70:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!e) return;
f0113a73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0113a77:	74 2d                	je     f0113aa6 <wakeup_one+0x6e>

	e->channel = NULL;
f0113a79:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113a7c:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)

	sched_insert_ready(e);
f0113a83:	83 ec 0c             	sub    $0xc,%esp
f0113a86:	ff 75 f4             	pushl  -0xc(%ebp)
f0113a89:	e8 53 28 ff ff       	call   f01062e1 <sched_insert_ready>
f0113a8e:	83 c4 10             	add    $0x10,%esp

	release_kspinlock(&ProcessQueues.qlock);
f0113a91:	83 ec 0c             	sub    $0xc,%esp
f0113a94:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113a99:	e8 4c fb ff ff       	call   f01135ea <release_kspinlock>
f0113a9e:	83 c4 10             	add    $0x10,%esp
f0113aa1:	eb 04                	jmp    f0113aa7 <wakeup_one+0x6f>

#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);

	if (queue_size(&(chan->queue)) == 0)
		return;
f0113aa3:	90                   	nop
f0113aa4:	eb 01                	jmp    f0113aa7 <wakeup_one+0x6f>

	struct Env *e = dequeue(&(chan->queue));
	if (!e) return;
f0113aa6:	90                   	nop
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

  //Comment the following line
  //panic("wakeup_one() is not implemented yet...!!");
}
f0113aa7:	c9                   	leave  
f0113aa8:	c3                   	ret    

f0113aa9 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f0113aa9:	55                   	push   %ebp
f0113aaa:	89 e5                	mov    %esp,%ebp
f0113aac:	83 ec 18             	sub    $0x18,%esp
  //TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #3 CHANNEL - wakeup_all
  //Your code is here

#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f0113aaf:	83 ec 0c             	sub    $0xc,%esp
f0113ab2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113ab7:	e8 89 fa ff ff       	call   f0113545 <acquire_kspinlock>
f0113abc:	83 c4 10             	add    $0x10,%esp

	int sizeq = queue_size(&(chan->queue));
f0113abf:	8b 45 08             	mov    0x8(%ebp),%eax
f0113ac2:	83 ec 0c             	sub    $0xc,%esp
f0113ac5:	50                   	push   %eax
f0113ac6:	e8 32 25 ff ff       	call   f0105ffd <queue_size>
f0113acb:	83 c4 10             	add    $0x10,%esp
f0113ace:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for(int i =0;i<sizeq;i++){
f0113ad1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0113ad8:	eb 2d                	jmp    f0113b07 <wakeup_all+0x5e>
	struct Env *e = dequeue(&(chan->queue));
f0113ada:	8b 45 08             	mov    0x8(%ebp),%eax
f0113add:	83 ec 0c             	sub    $0xc,%esp
f0113ae0:	50                   	push   %eax
f0113ae1:	e8 c0 25 ff ff       	call   f01060a6 <dequeue>
f0113ae6:	83 c4 10             	add    $0x10,%esp
f0113ae9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	e->env_status = ENV_READY;
f0113aec:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0113aef:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
	sched_insert_ready(e);
f0113af6:	83 ec 0c             	sub    $0xc,%esp
f0113af9:	ff 75 ec             	pushl  -0x14(%ebp)
f0113afc:	e8 e0 27 ff ff       	call   f01062e1 <sched_insert_ready>
f0113b01:	83 c4 10             	add    $0x10,%esp
#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);

	int sizeq = queue_size(&(chan->queue));

	for(int i =0;i<sizeq;i++){
f0113b04:	ff 45 f4             	incl   -0xc(%ebp)
f0113b07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113b0a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0113b0d:	7c cb                	jl     f0113ada <wakeup_all+0x31>
	struct Env *e = dequeue(&(chan->queue));
	e->env_status = ENV_READY;
	sched_insert_ready(e);
	}
	release_kspinlock(&ProcessQueues.qlock);
f0113b0f:	83 ec 0c             	sub    $0xc,%esp
f0113b12:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113b17:	e8 ce fa ff ff       	call   f01135ea <release_kspinlock>
f0113b1c:	83 c4 10             	add    $0x10,%esp
	panic("make sure to enable the kernel heap: USE_KHEAP=1");
#endif

  //Comment the following line
  //panic("wakeup_all() is not implemented yet...!!");
}
f0113b1f:	90                   	nop
f0113b20:	c9                   	leave  
f0113b21:	c3                   	ret    

f0113b22 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0113b22:	55                   	push   %ebp
f0113b23:	89 e5                	mov    %esp,%ebp
f0113b25:	83 ec 08             	sub    $0x8,%esp
  init_channel(&(ksem->chan), "ksemaphore channel");
f0113b28:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b2b:	83 c0 74             	add    $0x74,%eax
f0113b2e:	83 ec 08             	sub    $0x8,%esp
f0113b31:	68 b2 a0 13 f0       	push   $0xf013a0b2
f0113b36:	50                   	push   %eax
f0113b37:	e8 58 fe ff ff       	call   f0113994 <init_channel>
f0113b3c:	83 c4 10             	add    $0x10,%esp
  init_kspinlock(&(ksem->lk), "lock of ksemaphore");
f0113b3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b42:	83 c0 04             	add    $0x4,%eax
f0113b45:	83 ec 08             	sub    $0x8,%esp
f0113b48:	68 c5 a0 13 f0       	push   $0xf013a0c5
f0113b4d:	50                   	push   %eax
f0113b4e:	e8 c1 f9 ff ff       	call   f0113514 <init_kspinlock>
f0113b53:	83 c4 10             	add    $0x10,%esp
  strcpy(ksem->name, name);
f0113b56:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b59:	05 c4 00 00 00       	add    $0xc4,%eax
f0113b5e:	83 ec 08             	sub    $0x8,%esp
f0113b61:	ff 75 10             	pushl  0x10(%ebp)
f0113b64:	50                   	push   %eax
f0113b65:	e8 14 f3 00 00       	call   f0122e7e <strcpy>
f0113b6a:	83 c4 10             	add    $0x10,%esp
  ksem->count = value;
f0113b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b70:	8b 55 0c             	mov    0xc(%ebp),%edx
f0113b73:	89 10                	mov    %edx,(%eax)
}
f0113b75:	90                   	nop
f0113b76:	c9                   	leave  
f0113b77:	c3                   	ret    

f0113b78 <wait_ksemaphore>:

void wait_ksemaphore(struct ksemaphore *ksema)
{
f0113b78:	55                   	push   %ebp
f0113b79:	89 e5                	mov    %esp,%ebp
f0113b7b:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&(ksema->lk));
f0113b7e:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b81:	83 c0 04             	add    $0x4,%eax
f0113b84:	83 ec 0c             	sub    $0xc,%esp
f0113b87:	50                   	push   %eax
f0113b88:	e8 b8 f9 ff ff       	call   f0113545 <acquire_kspinlock>
f0113b8d:	83 c4 10             	add    $0x10,%esp

	ksema->count--;
f0113b90:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b93:	8b 00                	mov    (%eax),%eax
f0113b95:	8d 50 ff             	lea    -0x1(%eax),%edx
f0113b98:	8b 45 08             	mov    0x8(%ebp),%eax
f0113b9b:	89 10                	mov    %edx,(%eax)
	if (ksema->count < 0) {
f0113b9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0113ba0:	8b 00                	mov    (%eax),%eax
f0113ba2:	85 c0                	test   %eax,%eax
f0113ba4:	79 19                	jns    f0113bbf <wait_ksemaphore+0x47>
	  sleep(&(ksema->chan), &(ksema->lk));
f0113ba6:	8b 45 08             	mov    0x8(%ebp),%eax
f0113ba9:	8d 50 04             	lea    0x4(%eax),%edx
f0113bac:	8b 45 08             	mov    0x8(%ebp),%eax
f0113baf:	83 c0 74             	add    $0x74,%eax
f0113bb2:	83 ec 08             	sub    $0x8,%esp
f0113bb5:	52                   	push   %edx
f0113bb6:	50                   	push   %eax
f0113bb7:	e8 05 fe ff ff       	call   f01139c1 <sleep>
f0113bbc:	83 c4 10             	add    $0x10,%esp
	}

	release_kspinlock(&(ksema->lk));
f0113bbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0113bc2:	83 c0 04             	add    $0x4,%eax
f0113bc5:	83 ec 0c             	sub    $0xc,%esp
f0113bc8:	50                   	push   %eax
f0113bc9:	e8 1c fa ff ff       	call   f01135ea <release_kspinlock>
f0113bce:	83 c4 10             	add    $0x10,%esp
  //TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #6 SEMAPHORE - wait_ksemaphore
  //Your code is here
  //Comment the following line
  //panic("wait_ksemaphore() is not implemented yet...!!");

}
f0113bd1:	90                   	nop
f0113bd2:	c9                   	leave  
f0113bd3:	c3                   	ret    

f0113bd4 <signal_ksemaphore>:

void signal_ksemaphore(struct ksemaphore *ksema)
{
f0113bd4:	55                   	push   %ebp
f0113bd5:	89 e5                	mov    %esp,%ebp
f0113bd7:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&(ksema->lk));
f0113bda:	8b 45 08             	mov    0x8(%ebp),%eax
f0113bdd:	83 c0 04             	add    $0x4,%eax
f0113be0:	83 ec 0c             	sub    $0xc,%esp
f0113be3:	50                   	push   %eax
f0113be4:	e8 5c f9 ff ff       	call   f0113545 <acquire_kspinlock>
f0113be9:	83 c4 10             	add    $0x10,%esp
	ksema->count++;
f0113bec:	8b 45 08             	mov    0x8(%ebp),%eax
f0113bef:	8b 00                	mov    (%eax),%eax
f0113bf1:	8d 50 01             	lea    0x1(%eax),%edx
f0113bf4:	8b 45 08             	mov    0x8(%ebp),%eax
f0113bf7:	89 10                	mov    %edx,(%eax)
	if (ksema->count <= 0) {
f0113bf9:	8b 45 08             	mov    0x8(%ebp),%eax
f0113bfc:	8b 00                	mov    (%eax),%eax
f0113bfe:	85 c0                	test   %eax,%eax
f0113c00:	7f 12                	jg     f0113c14 <signal_ksemaphore+0x40>
	  wakeup_one(&(ksema->chan));
f0113c02:	8b 45 08             	mov    0x8(%ebp),%eax
f0113c05:	83 c0 74             	add    $0x74,%eax
f0113c08:	83 ec 0c             	sub    $0xc,%esp
f0113c0b:	50                   	push   %eax
f0113c0c:	e8 27 fe ff ff       	call   f0113a38 <wakeup_one>
f0113c11:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&(ksema->lk));
f0113c14:	8b 45 08             	mov    0x8(%ebp),%eax
f0113c17:	83 c0 04             	add    $0x4,%eax
f0113c1a:	83 ec 0c             	sub    $0xc,%esp
f0113c1d:	50                   	push   %eax
f0113c1e:	e8 c7 f9 ff ff       	call   f01135ea <release_kspinlock>
f0113c23:	83 c4 10             	add    $0x10,%esp
  //TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #7 SEMAPHORE - signal_ksemaphore
  //Your code is here
  //Comment the following line
  //panic("signal_ksemaphore() is not implemented yet...!!");

}
f0113c26:	90                   	nop
f0113c27:	c9                   	leave  
f0113c28:	c3                   	ret    

f0113c29 <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0113c29:	55                   	push   %ebp
f0113c2a:	89 e5                	mov    %esp,%ebp
f0113c2c:	8b 45 08             	mov    0x8(%ebp),%eax
f0113c2f:	a3 64 50 96 f1       	mov    %eax,0xf1965064
f0113c34:	90                   	nop
f0113c35:	5d                   	pop    %ebp
f0113c36:	c3                   	ret    

f0113c37 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0113c37:	55                   	push   %ebp
f0113c38:	89 e5                	mov    %esp,%ebp
f0113c3a:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0113c3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0113c44:	eb 26                	jmp    f0113c6c <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0113c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113c49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0113c50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113c53:	01 c2                	add    %eax,%edx
f0113c55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113c58:	40                   	inc    %eax
f0113c59:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0113c60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113c63:	01 c8                	add    %ecx,%eax
f0113c65:	8b 00                	mov    (%eax),%eax
f0113c67:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0113c69:	ff 45 f4             	incl   -0xc(%ebp)
f0113c6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0113c6f:	48                   	dec    %eax
f0113c70:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0113c73:	7f d1                	jg     f0113c46 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f0113c75:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0113c78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0113c7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0113c86:	eb 35                	jmp    f0113cbd <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f0113c88:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0113c8b:	89 d0                	mov    %edx,%eax
f0113c8d:	01 c0                	add    %eax,%eax
f0113c8f:	01 d0                	add    %edx,%eax
f0113c91:	c1 e0 02             	shl    $0x2,%eax
f0113c94:	05 c0 80 19 f0       	add    $0xf01980c0,%eax
f0113c99:	8b 10                	mov    (%eax),%edx
f0113c9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113c9e:	8b 00                	mov    (%eax),%eax
f0113ca0:	83 ec 08             	sub    $0x8,%esp
f0113ca3:	52                   	push   %edx
f0113ca4:	50                   	push   %eax
f0113ca5:	e8 91 f2 00 00       	call   f0122f3b <strcmp>
f0113caa:	83 c4 10             	add    $0x10,%esp
f0113cad:	85 c0                	test   %eax,%eax
f0113caf:	75 09                	jne    f0113cba <tst_handler+0x83>
		{
			test_found = 1;
f0113cb1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f0113cb8:	eb 0f                	jmp    f0113cc9 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0113cba:	ff 45 ec             	incl   -0x14(%ebp)
f0113cbd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0113cc0:	a1 80 81 19 f0       	mov    0xf0198180,%eax
f0113cc5:	39 c2                	cmp    %eax,%edx
f0113cc7:	72 bf                	jb     f0113c88 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f0113cc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113ccd:	74 29                	je     f0113cf8 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f0113ccf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0113cd2:	89 d0                	mov    %edx,%eax
f0113cd4:	01 c0                	add    %eax,%eax
f0113cd6:	01 d0                	add    %edx,%eax
f0113cd8:	c1 e0 02             	shl    $0x2,%eax
f0113cdb:	05 c8 80 19 f0       	add    $0xf01980c8,%eax
f0113ce0:	8b 00                	mov    (%eax),%eax
f0113ce2:	83 ec 08             	sub    $0x8,%esp
f0113ce5:	ff 75 0c             	pushl  0xc(%ebp)
f0113ce8:	ff 75 08             	pushl  0x8(%ebp)
f0113ceb:	ff d0                	call   *%eax
f0113ced:	83 c4 10             	add    $0x10,%esp
f0113cf0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0113cf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0113cf6:	eb 1b                	jmp    f0113d13 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0113cf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113cfb:	8b 00                	mov    (%eax),%eax
f0113cfd:	83 ec 08             	sub    $0x8,%esp
f0113d00:	50                   	push   %eax
f0113d01:	68 68 a4 13 f0       	push   $0xf013a468
f0113d06:	e8 42 de fe ff       	call   f0101b4d <cprintf>
f0113d0b:	83 c4 10             	add    $0x10,%esp
		return 0;
f0113d0e:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0113d13:	c9                   	leave  
f0113d14:	c3                   	ret    

f0113d15 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0113d15:	55                   	push   %ebp
f0113d16:	89 e5                	mov    %esp,%ebp
f0113d18:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f0113d1b:	e8 c9 ba 00 00       	call   f011f7e9 <test_three_creation_functions>
	return 0;
f0113d20:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d25:	c9                   	leave  
f0113d26:	c3                   	ret    

f0113d27 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0113d27:	55                   	push   %ebp
f0113d28:	89 e5                	mov    %esp,%ebp
f0113d2a:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f0113d2d:	e8 34 6f 00 00       	call   f011ac66 <test_priority_normal_and_higher>
	return 0;
f0113d32:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d37:	c9                   	leave  
f0113d38:	c3                   	ret    

f0113d39 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0113d39:	55                   	push   %ebp
f0113d3a:	89 e5                	mov    %esp,%ebp
f0113d3c:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f0113d3f:	e8 3c 6f 00 00       	call   f011ac80 <test_priority_normal_and_lower>
	return 0;
f0113d44:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d49:	c9                   	leave  
f0113d4a:	c3                   	ret    

f0113d4b <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f0113d4b:	55                   	push   %ebp
f0113d4c:	89 e5                	mov    %esp,%ebp
f0113d4e:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f0113d51:	e8 48 bc 00 00       	call   f011f99e <test_kfreeall>
	return 0;
f0113d56:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d5b:	c9                   	leave  
f0113d5c:	c3                   	ret    

f0113d5d <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f0113d5d:	55                   	push   %ebp
f0113d5e:	89 e5                	mov    %esp,%ebp
f0113d60:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0113d63:	e8 53 bc 00 00       	call   f011f9bb <test_kexpand>
	return 0;
f0113d68:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d6d:	c9                   	leave  
f0113d6e:	c3                   	ret    

f0113d6f <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f0113d6f:	55                   	push   %ebp
f0113d70:	89 e5                	mov    %esp,%ebp
f0113d72:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f0113d75:	e8 5e bc 00 00       	call   f011f9d8 <test_kshrink>
	return 0;
f0113d7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d7f:	c9                   	leave  
f0113d80:	c3                   	ret    

f0113d81 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f0113d81:	55                   	push   %ebp
f0113d82:	89 e5                	mov    %esp,%ebp
f0113d84:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f0113d87:	e8 69 bc 00 00       	call   f011f9f5 <test_kfreelast>
	return 0;
f0113d8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d91:	c9                   	leave  
f0113d92:	c3                   	ret    

f0113d93 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f0113d93:	55                   	push   %ebp
f0113d94:	89 e5                	mov    %esp,%ebp
f0113d96:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f0113d99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113d9c:	83 c0 04             	add    $0x4,%eax
f0113d9f:	8b 00                	mov    (%eax),%eax
f0113da1:	83 ec 04             	sub    $0x4,%esp
f0113da4:	6a 0a                	push   $0xa
f0113da6:	6a 00                	push   $0x0
f0113da8:	50                   	push   %eax
f0113da9:	e8 90 f4 00 00       	call   f012323e <strtol>
f0113dae:	83 c4 10             	add    $0x10,%esp
f0113db1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f0113db4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f0113dbb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
f0113dc2:	83 ec 0c             	sub    $0xc,%esp
f0113dc5:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113dca:	e8 76 f7 ff ff       	call   f0113545 <acquire_kspinlock>
f0113dcf:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0113dd2:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0113dd7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0113dda:	eb 3b                	jmp    f0113e17 <tst_sc_MLFQ+0x84>
									{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f0113ddc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0113ddf:	83 c0 20             	add    $0x20,%eax
f0113de2:	83 ec 08             	sub    $0x8,%esp
f0113de5:	68 7b a4 13 f0       	push   $0xf013a47b
f0113dea:	50                   	push   %eax
f0113deb:	e8 4b f1 00 00       	call   f0122f3b <strcmp>
f0113df0:	83 c4 10             	add    $0x10,%esp
f0113df3:	85 c0                	test   %eax,%eax
f0113df5:	75 12                	jne    f0113e09 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0113df7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113dfb:	74 07                	je     f0113e04 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f0113dfd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0113e04:	ff 45 f4             	incl   -0xc(%ebp)
f0113e07:	eb 06                	jmp    f0113e0f <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f0113e09:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113e0d:	74 31                	je     f0113e40 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0113e0f:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0113e14:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0113e17:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0113e1b:	74 08                	je     f0113e25 <tst_sc_MLFQ+0x92>
f0113e1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0113e20:	8b 40 08             	mov    0x8(%eax),%eax
f0113e23:	eb 05                	jmp    f0113e2a <tst_sc_MLFQ+0x97>
f0113e25:	b8 00 00 00 00       	mov    $0x0,%eax
f0113e2a:	a3 48 ce 94 f1       	mov    %eax,0xf194ce48
f0113e2f:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0113e34:	85 c0                	test   %eax,%eax
f0113e36:	75 a4                	jne    f0113ddc <tst_sc_MLFQ+0x49>
f0113e38:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0113e3c:	75 9e                	jne    f0113ddc <tst_sc_MLFQ+0x49>
f0113e3e:	eb 01                	jmp    f0113e41 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f0113e40:	90                   	nop
									}
		if(cnt == numOfSlave2)
f0113e41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113e44:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0113e47:	75 12                	jne    f0113e5b <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0113e49:	83 ec 0c             	sub    $0xc,%esp
f0113e4c:	68 84 a4 13 f0       	push   $0xf013a484
f0113e51:	e8 f7 dc fe ff       	call   f0101b4d <cprintf>
f0113e56:	83 c4 10             	add    $0x10,%esp
f0113e59:	eb 17                	jmp    f0113e72 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0113e5b:	83 ec 04             	sub    $0x4,%esp
f0113e5e:	68 bd a4 13 f0       	push   $0xf013a4bd
f0113e63:	68 9c 00 00 00       	push   $0x9c
f0113e68:	68 d3 a4 13 f0       	push   $0xf013a4d3
f0113e6d:	e8 3d d0 fe ff       	call   f0100eaf <_panic>
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0113e72:	83 ec 0c             	sub    $0xc,%esp
f0113e75:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0113e7a:	e8 6b f7 ff ff       	call   f01135ea <release_kspinlock>
f0113e7f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113e82:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113e87:	c9                   	leave  
f0113e88:	c3                   	ret    

f0113e89 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f0113e89:	55                   	push   %ebp
f0113e8a:	89 e5                	mov    %esp,%ebp
f0113e8c:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0113e8f:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0113e93:	74 17                	je     f0113eac <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f0113e95:	83 ec 0c             	sub    $0xc,%esp
f0113e98:	68 ec a4 13 f0       	push   $0xf013a4ec
f0113e9d:	e8 ab dc fe ff       	call   f0101b4d <cprintf>
f0113ea2:	83 c4 10             	add    $0x10,%esp
		return 0;
f0113ea5:	b8 00 00 00 00       	mov    $0x0,%eax
f0113eaa:	eb 45                	jmp    f0113ef1 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0113eac:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113eaf:	83 c0 04             	add    $0x4,%eax
f0113eb2:	8b 00                	mov    (%eax),%eax
f0113eb4:	83 ec 04             	sub    $0x4,%esp
f0113eb7:	6a 0a                	push   $0xa
f0113eb9:	6a 00                	push   $0x0
f0113ebb:	50                   	push   %eax
f0113ebc:	e8 7d f3 00 00       	call   f012323e <strtol>
f0113ec1:	83 c4 10             	add    $0x10,%esp
f0113ec4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0113ec7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113eca:	83 f8 01             	cmp    $0x1,%eax
f0113ecd:	74 10                	je     f0113edf <tst_bsd_nice+0x56>
f0113ecf:	83 f8 02             	cmp    $0x2,%eax
f0113ed2:	74 12                	je     f0113ee6 <tst_bsd_nice+0x5d>
f0113ed4:	85 c0                	test   %eax,%eax
f0113ed6:	75 14                	jne    f0113eec <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f0113ed8:	e8 8a bc 00 00       	call   f011fb67 <test_bsd_nice_0>
		break;
f0113edd:	eb 0d                	jmp    f0113eec <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f0113edf:	e8 9d bc 00 00       	call   f011fb81 <test_bsd_nice_1>
		break;
f0113ee4:	eb 06                	jmp    f0113eec <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0113ee6:	e8 b0 bc 00 00       	call   f011fb9b <test_bsd_nice_2>
		break;
f0113eeb:	90                   	nop
	}
	return 0;
f0113eec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113ef1:	c9                   	leave  
f0113ef2:	c3                   	ret    

f0113ef3 <tst_priorityRR>:

/*2024*/
int tst_priorityRR(int number_of_arguments, char **arguments)
{
f0113ef3:	55                   	push   %ebp
f0113ef4:	89 e5                	mov    %esp,%ebp
f0113ef6:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0113ef9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0113efd:	74 17                	je     f0113f16 <tst_priorityRR+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst priorityRR <testnumber>\n");
f0113eff:	83 ec 0c             	sub    $0xc,%esp
f0113f02:	68 2c a5 13 f0       	push   $0xf013a52c
f0113f07:	e8 41 dc fe ff       	call   f0101b4d <cprintf>
f0113f0c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0113f0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0113f14:	eb 45                	jmp    f0113f5b <tst_priorityRR+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0113f16:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113f19:	83 c0 04             	add    $0x4,%eax
f0113f1c:	8b 00                	mov    (%eax),%eax
f0113f1e:	83 ec 04             	sub    $0x4,%esp
f0113f21:	6a 0a                	push   $0xa
f0113f23:	6a 00                	push   $0x0
f0113f25:	50                   	push   %eax
f0113f26:	e8 13 f3 00 00       	call   f012323e <strtol>
f0113f2b:	83 c4 10             	add    $0x10,%esp
f0113f2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0113f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113f34:	83 f8 01             	cmp    $0x1,%eax
f0113f37:	74 10                	je     f0113f49 <tst_priorityRR+0x56>
f0113f39:	83 f8 02             	cmp    $0x2,%eax
f0113f3c:	74 12                	je     f0113f50 <tst_priorityRR+0x5d>
f0113f3e:	85 c0                	test   %eax,%eax
f0113f40:	75 14                	jne    f0113f56 <tst_priorityRR+0x63>
	{
	case 0:
		test_priorityRR_0();
f0113f42:	e8 6e bc 00 00       	call   f011fbb5 <test_priorityRR_0>
		break;
f0113f47:	eb 0d                	jmp    f0113f56 <tst_priorityRR+0x63>
	case 1:
		test_priorityRR_1();
f0113f49:	e8 77 bf 00 00       	call   f011fec5 <test_priorityRR_1>
		break;
f0113f4e:	eb 06                	jmp    f0113f56 <tst_priorityRR+0x63>
	case 2:
		test_priorityRR_2();
f0113f50:	e8 2c c2 00 00       	call   f0120181 <test_priorityRR_2>
		break;
f0113f55:	90                   	nop
	}
	return 0;
f0113f56:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113f5b:	c9                   	leave  
f0113f5c:	c3                   	ret    

f0113f5d <tst_str2lower>:
int tst_str2lower(int number_of_arguments, char **arguments)
{
f0113f5d:	55                   	push   %ebp
f0113f5e:	89 e5                	mov    %esp,%ebp
f0113f60:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f0113f63:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0113f67:	74 17                	je     f0113f80 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f0113f69:	83 ec 0c             	sub    $0xc,%esp
f0113f6c:	68 70 a5 13 f0       	push   $0xf013a570
f0113f71:	e8 d7 db fe ff       	call   f0101b4d <cprintf>
f0113f76:	83 c4 10             	add    $0x10,%esp
		return 0;
f0113f79:	b8 00 00 00 00       	mov    $0x0,%eax
f0113f7e:	eb 0a                	jmp    f0113f8a <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f0113f80:	e8 78 17 00 00       	call   f01156fd <test_str2lower_function>
	return 0;
f0113f85:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113f8a:	c9                   	leave  
f0113f8b:	c3                   	ret    

f0113f8c <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f0113f8c:	55                   	push   %ebp
f0113f8d:	89 e5                	mov    %esp,%ebp
f0113f8f:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f0113f92:	e8 4b 13 00 00       	call   f01152e2 <TestAutoCompleteCommand>
f0113f97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f0113f9a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113f9f:	c9                   	leave  
f0113fa0:	c3                   	ret    

f0113fa1 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f0113fa1:	55                   	push   %ebp
f0113fa2:	89 e5                	mov    %esp,%ebp
f0113fa4:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0113fa7:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0113fab:	74 1a                	je     f0113fc7 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f0113fad:	83 ec 0c             	sub    $0xc,%esp
f0113fb0:	68 a4 a5 13 f0       	push   $0xf013a5a4
f0113fb5:	e8 93 db fe ff       	call   f0101b4d <cprintf>
f0113fba:	83 c4 10             	add    $0x10,%esp
		return 0;
f0113fbd:	b8 00 00 00 00       	mov    $0x0,%eax
f0113fc2:	e9 93 00 00 00       	jmp    f011405a <tst_dyn_alloc+0xb9>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f0113fc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113fca:	83 c0 04             	add    $0x4,%eax
f0113fcd:	8b 00                	mov    (%eax),%eax
f0113fcf:	83 ec 08             	sub    $0x8,%esp
f0113fd2:	68 e1 a5 13 f0       	push   $0xf013a5e1
f0113fd7:	50                   	push   %eax
f0113fd8:	e8 5e ef 00 00       	call   f0122f3b <strcmp>
f0113fdd:	83 c4 10             	add    $0x10,%esp
f0113fe0:	85 c0                	test   %eax,%eax
f0113fe2:	75 07                	jne    f0113feb <tst_dyn_alloc+0x4a>
	{
		test_initialize_dynamic_allocator();
f0113fe4:	e8 b7 09 00 00       	call   f01149a0 <test_initialize_dynamic_allocator>
f0113fe9:	eb 6a                	jmp    f0114055 <tst_dyn_alloc+0xb4>
	}
	// Test 2 Example for alloc_block: tst dynalloc alloc
	else if(strcmp(arguments[1], "alloc") == 0)
f0113feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113fee:	83 c0 04             	add    $0x4,%eax
f0113ff1:	8b 00                	mov    (%eax),%eax
f0113ff3:	83 ec 08             	sub    $0x8,%esp
f0113ff6:	68 e6 a5 13 f0       	push   $0xf013a5e6
f0113ffb:	50                   	push   %eax
f0113ffc:	e8 3a ef 00 00       	call   f0122f3b <strcmp>
f0114001:	83 c4 10             	add    $0x10,%esp
f0114004:	85 c0                	test   %eax,%eax
f0114006:	75 07                	jne    f011400f <tst_dyn_alloc+0x6e>
	{
		test_alloc_block();
f0114008:	e8 ca 09 00 00       	call   f01149d7 <test_alloc_block>
f011400d:	eb 46                	jmp    f0114055 <tst_dyn_alloc+0xb4>
	{
		test_alloc_block_NF();
	}
	 */
	// Test 5 Example for free_block: tst dynalloc free
	else if(strcmp(arguments[1], "free") == 0)
f011400f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114012:	83 c0 04             	add    $0x4,%eax
f0114015:	8b 00                	mov    (%eax),%eax
f0114017:	83 ec 08             	sub    $0x8,%esp
f011401a:	68 ec a5 13 f0       	push   $0xf013a5ec
f011401f:	50                   	push   %eax
f0114020:	e8 16 ef 00 00       	call   f0122f3b <strcmp>
f0114025:	83 c4 10             	add    $0x10,%esp
f0114028:	85 c0                	test   %eax,%eax
f011402a:	75 07                	jne    f0114033 <tst_dyn_alloc+0x92>
	{
		test_free_block();
f011402c:	e8 c3 09 00 00       	call   f01149f4 <test_free_block>
f0114031:	eb 22                	jmp    f0114055 <tst_dyn_alloc+0xb4>
	else if(strcmp(arguments[1], "freenf") == 0)
	{
		test_free_block_NF();
	}*/
	// Test 8 Example for realloc_block: tst dynalloc realloc
	else if(strcmp(arguments[1], "realloc") == 0)
f0114033:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114036:	83 c0 04             	add    $0x4,%eax
f0114039:	8b 00                	mov    (%eax),%eax
f011403b:	83 ec 08             	sub    $0x8,%esp
f011403e:	68 f1 a5 13 f0       	push   $0xf013a5f1
f0114043:	50                   	push   %eax
f0114044:	e8 f2 ee 00 00       	call   f0122f3b <strcmp>
f0114049:	83 c4 10             	add    $0x10,%esp
f011404c:	85 c0                	test   %eax,%eax
f011404e:	75 05                	jne    f0114055 <tst_dyn_alloc+0xb4>
	{
		test_realloc_block();
f0114050:	e8 bc 09 00 00       	call   f0114a11 <test_realloc_block>
	}
	return 0;
f0114055:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011405a:	c9                   	leave  
f011405b:	c3                   	ret    

f011405c <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f011405c:	55                   	push   %ebp
f011405d:	89 e5                	mov    %esp,%ebp
f011405f:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0114062:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0114066:	74 1a                	je     f0114082 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst chunks <testname>\n") ;
f0114068:	83 ec 0c             	sub    $0xc,%esp
f011406b:	68 fc a5 13 f0       	push   $0xf013a5fc
f0114070:	e8 d8 da fe ff       	call   f0101b4d <cprintf>
f0114075:	83 c4 10             	add    $0x10,%esp
		return 0;
f0114078:	b8 00 00 00 00       	mov    $0x0,%eax
f011407d:	e9 e1 00 00 00       	jmp    f0114163 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f0114082:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114085:	83 c0 04             	add    $0x4,%eax
f0114088:	8b 00                	mov    (%eax),%eax
f011408a:	83 ec 08             	sub    $0x8,%esp
f011408d:	68 37 a6 13 f0       	push   $0xf013a637
f0114092:	50                   	push   %eax
f0114093:	e8 a3 ee 00 00       	call   f0122f3b <strcmp>
f0114098:	83 c4 10             	add    $0x10,%esp
f011409b:	85 c0                	test   %eax,%eax
f011409d:	75 0a                	jne    f01140a9 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f011409f:	e8 fa 22 00 00       	call   f011639e <test_cut_paste_pages>
f01140a4:	e9 b5 00 00 00       	jmp    f011415e <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01140a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01140ac:	83 c0 04             	add    $0x4,%eax
f01140af:	8b 00                	mov    (%eax),%eax
f01140b1:	83 ec 08             	sub    $0x8,%esp
f01140b4:	68 40 a6 13 f0       	push   $0xf013a640
f01140b9:	50                   	push   %eax
f01140ba:	e8 7c ee 00 00       	call   f0122f3b <strcmp>
f01140bf:	83 c4 10             	add    $0x10,%esp
f01140c2:	85 c0                	test   %eax,%eax
f01140c4:	75 0a                	jne    f01140d0 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01140c6:	e8 1e 2d 00 00       	call   f0116de9 <test_copy_paste_chunk>
f01140cb:	e9 8e 00 00 00       	jmp    f011415e <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01140d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01140d3:	83 c0 04             	add    $0x4,%eax
f01140d6:	8b 00                	mov    (%eax),%eax
f01140d8:	83 ec 08             	sub    $0x8,%esp
f01140db:	68 4a a6 13 f0       	push   $0xf013a64a
f01140e0:	50                   	push   %eax
f01140e1:	e8 55 ee 00 00       	call   f0122f3b <strcmp>
f01140e6:	83 c4 10             	add    $0x10,%esp
f01140e9:	85 c0                	test   %eax,%eax
f01140eb:	75 07                	jne    f01140f4 <tst_chunks+0x98>
	{
		test_share_chunk();
f01140ed:	e8 f5 3d 00 00       	call   f0117ee7 <test_share_chunk>
f01140f2:	eb 6a                	jmp    f011415e <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01140f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01140f7:	83 c0 04             	add    $0x4,%eax
f01140fa:	8b 00                	mov    (%eax),%eax
f01140fc:	83 ec 08             	sub    $0x8,%esp
f01140ff:	68 50 a6 13 f0       	push   $0xf013a650
f0114104:	50                   	push   %eax
f0114105:	e8 31 ee 00 00       	call   f0122f3b <strcmp>
f011410a:	83 c4 10             	add    $0x10,%esp
f011410d:	85 c0                	test   %eax,%eax
f011410f:	75 07                	jne    f0114118 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0114111:	e8 f9 47 00 00       	call   f011890f <test_allocate_chunk>
f0114116:	eb 46                	jmp    f011415e <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0114118:	8b 45 0c             	mov    0xc(%ebp),%eax
f011411b:	83 c0 04             	add    $0x4,%eax
f011411e:	8b 00                	mov    (%eax),%eax
f0114120:	83 ec 08             	sub    $0x8,%esp
f0114123:	68 59 a6 13 f0       	push   $0xf013a659
f0114128:	50                   	push   %eax
f0114129:	e8 0d ee 00 00       	call   f0122f3b <strcmp>
f011412e:	83 c4 10             	add    $0x10,%esp
f0114131:	85 c0                	test   %eax,%eax
f0114133:	75 07                	jne    f011413c <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0114135:	e8 dc 50 00 00       	call   f0119216 <test_calculate_required_frames>
f011413a:	eb 22                	jmp    f011415e <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f011413c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011413f:	83 c0 04             	add    $0x4,%eax
f0114142:	8b 00                	mov    (%eax),%eax
f0114144:	83 ec 08             	sub    $0x8,%esp
f0114147:	68 68 a6 13 f0       	push   $0xf013a668
f011414c:	50                   	push   %eax
f011414d:	e8 e9 ed 00 00       	call   f0122f3b <strcmp>
f0114152:	83 c4 10             	add    $0x10,%esp
f0114155:	85 c0                	test   %eax,%eax
f0114157:	75 05                	jne    f011415e <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0114159:	e8 2c 59 00 00       	call   f0119a8a <test_calculate_allocated_space>
	}
	return 0;
f011415e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114163:	c9                   	leave  
f0114164:	c3                   	ret    

f0114165 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0114165:	55                   	push   %ebp
f0114166:	89 e5                	mov    %esp,%ebp
f0114168:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011416b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011416f:	74 1a                	je     f011418b <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst pg <testname>\n") ;
f0114171:	83 ec 0c             	sub    $0xc,%esp
f0114174:	68 78 a6 13 f0       	push   $0xf013a678
f0114179:	e8 cf d9 fe ff       	call   f0101b4d <cprintf>
f011417e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0114181:	b8 00 00 00 00       	mov    $0x0,%eax
f0114186:	e9 e1 00 00 00       	jmp    f011426c <tst_paging_manipulation+0x107>
	}
	// Test 1.1-Set/Clear permissions: tst pg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f011418b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011418e:	83 c0 04             	add    $0x4,%eax
f0114191:	8b 00                	mov    (%eax),%eax
f0114193:	83 ec 08             	sub    $0x8,%esp
f0114196:	68 af a6 13 f0       	push   $0xf013a6af
f011419b:	50                   	push   %eax
f011419c:	e8 9a ed 00 00       	call   f0122f3b <strcmp>
f01141a1:	83 c4 10             	add    $0x10,%esp
f01141a4:	85 c0                	test   %eax,%eax
f01141a6:	75 0a                	jne    f01141b2 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01141a8:	e8 d6 18 00 00       	call   f0115a83 <test_pt_set_page_permissions>
f01141ad:	e9 b5 00 00 00       	jmp    f0114267 <tst_paging_manipulation+0x102>
	}
	// Test 1.2-Set/Clear permissions: tst pg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01141b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01141b5:	83 c0 04             	add    $0x4,%eax
f01141b8:	8b 00                	mov    (%eax),%eax
f01141ba:	83 ec 08             	sub    $0x8,%esp
f01141bd:	68 b7 a6 13 f0       	push   $0xf013a6b7
f01141c2:	50                   	push   %eax
f01141c3:	e8 73 ed 00 00       	call   f0122f3b <strcmp>
f01141c8:	83 c4 10             	add    $0x10,%esp
f01141cb:	85 c0                	test   %eax,%eax
f01141cd:	75 0a                	jne    f01141d9 <tst_paging_manipulation+0x74>
	{
		test_pt_set_page_permissions_invalid_va();
f01141cf:	e8 1e 1b 00 00       	call   f0115cf2 <test_pt_set_page_permissions_invalid_va>
f01141d4:	e9 8e 00 00 00       	jmp    f0114267 <tst_paging_manipulation+0x102>
	}
	// Test 2-Get permissions: tst pg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01141d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01141dc:	83 c0 04             	add    $0x4,%eax
f01141df:	8b 00                	mov    (%eax),%eax
f01141e1:	83 ec 08             	sub    $0x8,%esp
f01141e4:	68 bf a6 13 f0       	push   $0xf013a6bf
f01141e9:	50                   	push   %eax
f01141ea:	e8 4c ed 00 00       	call   f0122f3b <strcmp>
f01141ef:	83 c4 10             	add    $0x10,%esp
f01141f2:	85 c0                	test   %eax,%eax
f01141f4:	75 07                	jne    f01141fd <tst_paging_manipulation+0x98>
	{
		test_pt_get_page_permissions();
f01141f6:	e8 40 1b 00 00       	call   f0115d3b <test_pt_get_page_permissions>
f01141fb:	eb 6a                	jmp    f0114267 <tst_paging_manipulation+0x102>
	}
	// Test 3.1-Clear entry: tst pg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f01141fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114200:	83 c0 04             	add    $0x4,%eax
f0114203:	8b 00                	mov    (%eax),%eax
f0114205:	83 ec 08             	sub    $0x8,%esp
f0114208:	68 c7 a6 13 f0       	push   $0xf013a6c7
f011420d:	50                   	push   %eax
f011420e:	e8 28 ed 00 00       	call   f0122f3b <strcmp>
f0114213:	83 c4 10             	add    $0x10,%esp
f0114216:	85 c0                	test   %eax,%eax
f0114218:	75 07                	jne    f0114221 <tst_paging_manipulation+0xbc>
	{
		test_pt_clear_page_table_entry();
f011421a:	e8 60 1c 00 00       	call   f0115e7f <test_pt_clear_page_table_entry>
f011421f:	eb 46                	jmp    f0114267 <tst_paging_manipulation+0x102>
	}
	// Test 3.2-Clear entry: tst pg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0114221:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114224:	83 c0 04             	add    $0x4,%eax
f0114227:	8b 00                	mov    (%eax),%eax
f0114229:	83 ec 08             	sub    $0x8,%esp
f011422c:	68 ce a6 13 f0       	push   $0xf013a6ce
f0114231:	50                   	push   %eax
f0114232:	e8 04 ed 00 00       	call   f0122f3b <strcmp>
f0114237:	83 c4 10             	add    $0x10,%esp
f011423a:	85 c0                	test   %eax,%eax
f011423c:	75 07                	jne    f0114245 <tst_paging_manipulation+0xe0>
	{
		test_pt_clear_page_table_entry_invalid_va();
f011423e:	e8 95 1d 00 00       	call   f0115fd8 <test_pt_clear_page_table_entry_invalid_va>
f0114243:	eb 22                	jmp    f0114267 <tst_paging_manipulation+0x102>
	}
	// Test 4-Convert virtual to physical: tst pg v2p
	else if(strcmp(arguments[1], "v2p") == 0)
f0114245:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114248:	83 c0 04             	add    $0x4,%eax
f011424b:	8b 00                	mov    (%eax),%eax
f011424d:	83 ec 08             	sub    $0x8,%esp
f0114250:	68 d5 a6 13 f0       	push   $0xf013a6d5
f0114255:	50                   	push   %eax
f0114256:	e8 e0 ec 00 00       	call   f0122f3b <strcmp>
f011425b:	83 c4 10             	add    $0x10,%esp
f011425e:	85 c0                	test   %eax,%eax
f0114260:	75 05                	jne    f0114267 <tst_paging_manipulation+0x102>
	{
		test_virtual_to_physical();
f0114262:	e8 a9 1d 00 00       	call   f0116010 <test_virtual_to_physical>
	}
	return 0;
f0114267:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011426c:	c9                   	leave  
f011426d:	c3                   	ret    

f011426e <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011426e:	55                   	push   %ebp
f011426f:	89 e5                	mov    %esp,%ebp
f0114271:	83 ec 18             	sub    $0x18,%esp
#if !USE_KHEAP
	panic("MUST ENABLE KHEAP");
	return 0;
#endif
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0114274:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114277:	83 c0 08             	add    $0x8,%eax
f011427a:	8b 00                	mov    (%eax),%eax
f011427c:	83 ec 08             	sub    $0x8,%esp
f011427f:	68 d9 a6 13 f0       	push   $0xf013a6d9
f0114284:	50                   	push   %eax
f0114285:	e8 b1 ec 00 00       	call   f0122f3b <strcmp>
f011428a:	83 c4 10             	add    $0x10,%esp
f011428d:	85 c0                	test   %eax,%eax
f011428f:	75 20                	jne    f01142b1 <tst_kheap+0x43>
f0114291:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0114295:	74 1a                	je     f01142b1 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <both or blk or page>\n") ;
f0114297:	83 ec 0c             	sub    $0xc,%esp
f011429a:	68 e4 a6 13 f0       	push   $0xf013a6e4
f011429f:	e8 a9 d8 fe ff       	call   f0101b4d <cprintf>
f01142a4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01142a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01142ac:	e9 b1 04 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "fast") == 0 && number_of_arguments != 3)
f01142b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01142b4:	83 c0 08             	add    $0x8,%eax
f01142b7:	8b 00                	mov    (%eax),%eax
f01142b9:	83 ec 08             	sub    $0x8,%esp
f01142bc:	68 3c a7 13 f0       	push   $0xf013a73c
f01142c1:	50                   	push   %eax
f01142c2:	e8 74 ec 00 00       	call   f0122f3b <strcmp>
f01142c7:	83 c4 10             	add    $0x10,%esp
f01142ca:	85 c0                	test   %eax,%eax
f01142cc:	75 20                	jne    f01142ee <tst_kheap+0x80>
f01142ce:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01142d2:	74 1a                	je     f01142ee <tst_kheap+0x80>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> fast\n") ;
f01142d4:	83 ec 0c             	sub    $0xc,%esp
f01142d7:	68 44 a7 13 f0       	push   $0xf013a744
f01142dc:	e8 6c d8 fe ff       	call   f0101b4d <cprintf>
f01142e1:	83 c4 10             	add    $0x10,%esp
		return 0;
f01142e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01142e9:	e9 74 04 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kfree") == 0 && number_of_arguments != 4)
f01142ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01142f1:	83 c0 08             	add    $0x8,%eax
f01142f4:	8b 00                	mov    (%eax),%eax
f01142f6:	83 ec 08             	sub    $0x8,%esp
f01142f9:	68 83 a7 13 f0       	push   $0xf013a783
f01142fe:	50                   	push   %eax
f01142ff:	e8 37 ec 00 00       	call   f0122f3b <strcmp>
f0114304:	83 c4 10             	add    $0x10,%esp
f0114307:	85 c0                	test   %eax,%eax
f0114309:	75 20                	jne    f011432b <tst_kheap+0xbd>
f011430b:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f011430f:	74 1a                	je     f011432b <tst_kheap+0xbd>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kfree <both or blk or page>\n") ;
f0114311:	83 ec 0c             	sub    $0xc,%esp
f0114314:	68 8c a7 13 f0       	push   $0xf013a78c
f0114319:	e8 2f d8 fe ff       	call   f0101b4d <cprintf>
f011431e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0114321:	b8 00 00 00 00       	mov    $0x0,%eax
f0114326:	e9 37 04 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kvirtaddr") == 0 && number_of_arguments != 3)
f011432b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011432e:	83 c0 08             	add    $0x8,%eax
f0114331:	8b 00                	mov    (%eax),%eax
f0114333:	83 ec 08             	sub    $0x8,%esp
f0114336:	68 e2 a7 13 f0       	push   $0xf013a7e2
f011433b:	50                   	push   %eax
f011433c:	e8 fa eb 00 00       	call   f0122f3b <strcmp>
f0114341:	83 c4 10             	add    $0x10,%esp
f0114344:	85 c0                	test   %eax,%eax
f0114346:	75 20                	jne    f0114368 <tst_kheap+0xfa>
f0114348:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011434c:	74 1a                	je     f0114368 <tst_kheap+0xfa>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kvirtaddr\n") ;
f011434e:	83 ec 0c             	sub    $0xc,%esp
f0114351:	68 ec a7 13 f0       	push   $0xf013a7ec
f0114356:	e8 f2 d7 fe ff       	call   f0101b4d <cprintf>
f011435b:	83 c4 10             	add    $0x10,%esp
		return 0;
f011435e:	b8 00 00 00 00       	mov    $0x0,%eax
f0114363:	e9 fa 03 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kphysaddr") == 0 && number_of_arguments != 3)
f0114368:	8b 45 0c             	mov    0xc(%ebp),%eax
f011436b:	83 c0 08             	add    $0x8,%eax
f011436e:	8b 00                	mov    (%eax),%eax
f0114370:	83 ec 08             	sub    $0x8,%esp
f0114373:	68 30 a8 13 f0       	push   $0xf013a830
f0114378:	50                   	push   %eax
f0114379:	e8 bd eb 00 00       	call   f0122f3b <strcmp>
f011437e:	83 c4 10             	add    $0x10,%esp
f0114381:	85 c0                	test   %eax,%eax
f0114383:	75 20                	jne    f01143a5 <tst_kheap+0x137>
f0114385:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0114389:	74 1a                	je     f01143a5 <tst_kheap+0x137>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kphysaddr\n") ;
f011438b:	83 ec 0c             	sub    $0xc,%esp
f011438e:	68 3c a8 13 f0       	push   $0xf013a83c
f0114393:	e8 b5 d7 fe ff       	call   f0101b4d <cprintf>
f0114398:	83 c4 10             	add    $0x10,%esp
		return 0;
f011439b:	b8 00 00 00 00       	mov    $0x0,%eax
f01143a0:	e9 bd 03 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "krealloc") == 0 && number_of_arguments != 4)
f01143a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01143a8:	83 c0 08             	add    $0x8,%eax
f01143ab:	8b 00                	mov    (%eax),%eax
f01143ad:	83 ec 08             	sub    $0x8,%esp
f01143b0:	68 80 a8 13 f0       	push   $0xf013a880
f01143b5:	50                   	push   %eax
f01143b6:	e8 80 eb 00 00       	call   f0122f3b <strcmp>
f01143bb:	83 c4 10             	add    $0x10,%esp
f01143be:	85 c0                	test   %eax,%eax
f01143c0:	75 20                	jne    f01143e2 <tst_kheap+0x174>
f01143c2:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01143c6:	74 1a                	je     f01143e2 <tst_kheap+0x174>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> krealloc <both or blk or page>\n") ;
f01143c8:	83 ec 0c             	sub    $0xc,%esp
f01143cb:	68 8c a8 13 f0       	push   $0xf013a88c
f01143d0:	e8 78 d7 fe ff       	call   f0101b4d <cprintf>
f01143d5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01143d8:	b8 00 00 00 00       	mov    $0x0,%eax
f01143dd:	e9 80 03 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}

	// Specify Test Type [if any]
	uint32 testType = 0;
f01143e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 4)
f01143e9:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01143ed:	0f 85 8c 00 00 00    	jne    f011447f <tst_kheap+0x211>
	{
		if (strcmp(arguments[3], "page") == 0)
f01143f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01143f6:	83 c0 0c             	add    $0xc,%eax
f01143f9:	8b 00                	mov    (%eax),%eax
f01143fb:	83 ec 08             	sub    $0x8,%esp
f01143fe:	68 e5 a8 13 f0       	push   $0xf013a8e5
f0114403:	50                   	push   %eax
f0114404:	e8 32 eb 00 00       	call   f0122f3b <strcmp>
f0114409:	83 c4 10             	add    $0x10,%esp
f011440c:	85 c0                	test   %eax,%eax
f011440e:	75 09                	jne    f0114419 <tst_kheap+0x1ab>
		{
			testType = TST_PAGE_ALLOC;
f0114410:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0114417:	eb 66                	jmp    f011447f <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "blk") == 0)
f0114419:	8b 45 0c             	mov    0xc(%ebp),%eax
f011441c:	83 c0 0c             	add    $0xc,%eax
f011441f:	8b 00                	mov    (%eax),%eax
f0114421:	83 ec 08             	sub    $0x8,%esp
f0114424:	68 ea a8 13 f0       	push   $0xf013a8ea
f0114429:	50                   	push   %eax
f011442a:	e8 0c eb 00 00       	call   f0122f3b <strcmp>
f011442f:	83 c4 10             	add    $0x10,%esp
f0114432:	85 c0                	test   %eax,%eax
f0114434:	75 09                	jne    f011443f <tst_kheap+0x1d1>
		{
			testType = TST_BLOCK_ALLOC;
f0114436:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f011443d:	eb 40                	jmp    f011447f <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "both") == 0)
f011443f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114442:	83 c0 0c             	add    $0xc,%eax
f0114445:	8b 00                	mov    (%eax),%eax
f0114447:	83 ec 08             	sub    $0x8,%esp
f011444a:	68 ee a8 13 f0       	push   $0xf013a8ee
f011444f:	50                   	push   %eax
f0114450:	e8 e6 ea 00 00       	call   f0122f3b <strcmp>
f0114455:	83 c4 10             	add    $0x10,%esp
f0114458:	85 c0                	test   %eax,%eax
f011445a:	75 09                	jne    f0114465 <tst_kheap+0x1f7>
		{
			testType = TST_BOTH_ALLOC;
f011445c:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0114463:	eb 1a                	jmp    f011447f <tst_kheap+0x211>
		}
		else
		{
			cprintf("Invalid Allocator Type! <both or blk or page>\n") ;
f0114465:	83 ec 0c             	sub    $0xc,%esp
f0114468:	68 f4 a8 13 f0       	push   $0xf013a8f4
f011446d:	e8 db d6 fe ff       	call   f0101b4d <cprintf>
f0114472:	83 c4 10             	add    $0x10,%esp
			return 0;
f0114475:	b8 00 00 00 00       	mov    $0x0,%eax
f011447a:	e9 e3 02 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
		}
	}
	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f011447f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114482:	83 c0 04             	add    $0x4,%eax
f0114485:	8b 00                	mov    (%eax),%eax
f0114487:	83 ec 08             	sub    $0x8,%esp
f011448a:	68 23 a9 13 f0       	push   $0xf013a923
f011448f:	50                   	push   %eax
f0114490:	e8 a6 ea 00 00       	call   f0122f3b <strcmp>
f0114495:	83 c4 10             	add    $0x10,%esp
f0114498:	85 c0                	test   %eax,%eax
f011449a:	74 1d                	je     f01144b9 <tst_kheap+0x24b>
f011449c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011449f:	83 c0 04             	add    $0x4,%eax
f01144a2:	8b 00                	mov    (%eax),%eax
f01144a4:	83 ec 08             	sub    $0x8,%esp
f01144a7:	68 26 a9 13 f0       	push   $0xf013a926
f01144ac:	50                   	push   %eax
f01144ad:	e8 89 ea 00 00       	call   f0122f3b <strcmp>
f01144b2:	83 c4 10             	add    $0x10,%esp
f01144b5:	85 c0                	test   %eax,%eax
f01144b7:	75 22                	jne    f01144db <tst_kheap+0x26d>
	{
		set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f01144b9:	83 ec 0c             	sub    $0xc,%esp
f01144bc:	6a 01                	push   $0x1
f01144be:	e8 66 f7 ff ff       	call   f0113c29 <set_kheap_strategy>
f01144c3:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01144c6:	83 ec 0c             	sub    $0xc,%esp
f01144c9:	68 2c a9 13 f0       	push   $0xf013a92c
f01144ce:	e8 7a d6 fe ff       	call   f0101b4d <cprintf>
f01144d3:	83 c4 10             	add    $0x10,%esp
f01144d6:	e9 68 01 00 00       	jmp    f0114643 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f01144db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01144de:	83 c0 04             	add    $0x4,%eax
f01144e1:	8b 00                	mov    (%eax),%eax
f01144e3:	83 ec 08             	sub    $0x8,%esp
f01144e6:	68 59 a9 13 f0       	push   $0xf013a959
f01144eb:	50                   	push   %eax
f01144ec:	e8 4a ea 00 00       	call   f0122f3b <strcmp>
f01144f1:	83 c4 10             	add    $0x10,%esp
f01144f4:	85 c0                	test   %eax,%eax
f01144f6:	74 1d                	je     f0114515 <tst_kheap+0x2a7>
f01144f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01144fb:	83 c0 04             	add    $0x4,%eax
f01144fe:	8b 00                	mov    (%eax),%eax
f0114500:	83 ec 08             	sub    $0x8,%esp
f0114503:	68 5c a9 13 f0       	push   $0xf013a95c
f0114508:	50                   	push   %eax
f0114509:	e8 2d ea 00 00       	call   f0122f3b <strcmp>
f011450e:	83 c4 10             	add    $0x10,%esp
f0114511:	85 c0                	test   %eax,%eax
f0114513:	75 22                	jne    f0114537 <tst_kheap+0x2c9>
	{
		set_kheap_strategy(KHP_PLACE_BESTFIT);
f0114515:	83 ec 0c             	sub    $0xc,%esp
f0114518:	6a 02                	push   $0x2
f011451a:	e8 0a f7 ff ff       	call   f0113c29 <set_kheap_strategy>
f011451f:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0114522:	83 ec 0c             	sub    $0xc,%esp
f0114525:	68 60 a9 13 f0       	push   $0xf013a960
f011452a:	e8 1e d6 fe ff       	call   f0101b4d <cprintf>
f011452f:	83 c4 10             	add    $0x10,%esp
f0114532:	e9 0c 01 00 00       	jmp    f0114643 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0114537:	8b 45 0c             	mov    0xc(%ebp),%eax
f011453a:	83 c0 04             	add    $0x4,%eax
f011453d:	8b 00                	mov    (%eax),%eax
f011453f:	83 ec 08             	sub    $0x8,%esp
f0114542:	68 8c a9 13 f0       	push   $0xf013a98c
f0114547:	50                   	push   %eax
f0114548:	e8 ee e9 00 00       	call   f0122f3b <strcmp>
f011454d:	83 c4 10             	add    $0x10,%esp
f0114550:	85 c0                	test   %eax,%eax
f0114552:	74 1d                	je     f0114571 <tst_kheap+0x303>
f0114554:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114557:	83 c0 04             	add    $0x4,%eax
f011455a:	8b 00                	mov    (%eax),%eax
f011455c:	83 ec 08             	sub    $0x8,%esp
f011455f:	68 8f a9 13 f0       	push   $0xf013a98f
f0114564:	50                   	push   %eax
f0114565:	e8 d1 e9 00 00       	call   f0122f3b <strcmp>
f011456a:	83 c4 10             	add    $0x10,%esp
f011456d:	85 c0                	test   %eax,%eax
f011456f:	75 22                	jne    f0114593 <tst_kheap+0x325>
	{
		set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0114571:	83 ec 0c             	sub    $0xc,%esp
f0114574:	6a 03                	push   $0x3
f0114576:	e8 ae f6 ff ff       	call   f0113c29 <set_kheap_strategy>
f011457b:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f011457e:	83 ec 0c             	sub    $0xc,%esp
f0114581:	68 94 a9 13 f0       	push   $0xf013a994
f0114586:	e8 c2 d5 fe ff       	call   f0101b4d <cprintf>
f011458b:	83 c4 10             	add    $0x10,%esp
f011458e:	e9 b0 00 00 00       	jmp    f0114643 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "WF") == 0 || strcmp(arguments[1], "wf") == 0)
f0114593:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114596:	83 c0 04             	add    $0x4,%eax
f0114599:	8b 00                	mov    (%eax),%eax
f011459b:	83 ec 08             	sub    $0x8,%esp
f011459e:	68 c0 a9 13 f0       	push   $0xf013a9c0
f01145a3:	50                   	push   %eax
f01145a4:	e8 92 e9 00 00       	call   f0122f3b <strcmp>
f01145a9:	83 c4 10             	add    $0x10,%esp
f01145ac:	85 c0                	test   %eax,%eax
f01145ae:	74 1d                	je     f01145cd <tst_kheap+0x35f>
f01145b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01145b3:	83 c0 04             	add    $0x4,%eax
f01145b6:	8b 00                	mov    (%eax),%eax
f01145b8:	83 ec 08             	sub    $0x8,%esp
f01145bb:	68 c3 a9 13 f0       	push   $0xf013a9c3
f01145c0:	50                   	push   %eax
f01145c1:	e8 75 e9 00 00       	call   f0122f3b <strcmp>
f01145c6:	83 c4 10             	add    $0x10,%esp
f01145c9:	85 c0                	test   %eax,%eax
f01145cb:	75 1f                	jne    f01145ec <tst_kheap+0x37e>
	{
		set_kheap_strategy(KHP_PLACE_WORSTFIT);
f01145cd:	83 ec 0c             	sub    $0xc,%esp
f01145d0:	6a 04                	push   $0x4
f01145d2:	e8 52 f6 ff ff       	call   f0113c29 <set_kheap_strategy>
f01145d7:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01145da:	83 ec 0c             	sub    $0xc,%esp
f01145dd:	68 c8 a9 13 f0       	push   $0xf013a9c8
f01145e2:	e8 66 d5 fe ff       	call   f0101b4d <cprintf>
f01145e7:	83 c4 10             	add    $0x10,%esp
f01145ea:	eb 57                	jmp    f0114643 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "CF") == 0 || strcmp(arguments[1], "cf") == 0)
f01145ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01145ef:	83 c0 04             	add    $0x4,%eax
f01145f2:	8b 00                	mov    (%eax),%eax
f01145f4:	83 ec 08             	sub    $0x8,%esp
f01145f7:	68 f5 a9 13 f0       	push   $0xf013a9f5
f01145fc:	50                   	push   %eax
f01145fd:	e8 39 e9 00 00       	call   f0122f3b <strcmp>
f0114602:	83 c4 10             	add    $0x10,%esp
f0114605:	85 c0                	test   %eax,%eax
f0114607:	74 1d                	je     f0114626 <tst_kheap+0x3b8>
f0114609:	8b 45 0c             	mov    0xc(%ebp),%eax
f011460c:	83 c0 04             	add    $0x4,%eax
f011460f:	8b 00                	mov    (%eax),%eax
f0114611:	83 ec 08             	sub    $0x8,%esp
f0114614:	68 f8 a9 13 f0       	push   $0xf013a9f8
f0114619:	50                   	push   %eax
f011461a:	e8 1c e9 00 00       	call   f0122f3b <strcmp>
f011461f:	83 c4 10             	add    $0x10,%esp
f0114622:	85 c0                	test   %eax,%eax
f0114624:	75 1d                	jne    f0114643 <tst_kheap+0x3d5>
	{
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0114626:	83 ec 0c             	sub    $0xc,%esp
f0114629:	6a 05                	push   $0x5
f011462b:	e8 f9 f5 ff ff       	call   f0113c29 <set_kheap_strategy>
f0114630:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f0114633:	83 ec 0c             	sub    $0xc,%esp
f0114636:	68 fc a9 13 f0       	push   $0xf013a9fc
f011463b:	e8 0d d5 fe ff       	call   f0101b4d <cprintf>
f0114640:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap <Strategy> kmalloc <allocator>
	if(strcmp(arguments[2], "kmalloc") == 0)
f0114643:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114646:	83 c0 08             	add    $0x8,%eax
f0114649:	8b 00                	mov    (%eax),%eax
f011464b:	83 ec 08             	sub    $0x8,%esp
f011464e:	68 d9 a6 13 f0       	push   $0xf013a6d9
f0114653:	50                   	push   %eax
f0114654:	e8 e2 e8 00 00       	call   f0122f3b <strcmp>
f0114659:	83 c4 10             	add    $0x10,%esp
f011465c:	85 c0                	test   %eax,%eax
f011465e:	75 18                	jne    f0114678 <tst_kheap+0x40a>
	{
		test_kmalloc(testType);
f0114660:	83 ec 0c             	sub    $0xc,%esp
f0114663:	ff 75 f4             	pushl  -0xc(%ebp)
f0114666:	e8 3c 66 00 00       	call   f011aca7 <test_kmalloc>
f011466b:	83 c4 10             	add    $0x10,%esp
		return 0;
f011466e:	b8 00 00 00 00       	mov    $0x0,%eax
f0114673:	e9 ea 00 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	// Test Fast Implementation of kmalloc/kfree: tst kheap <Startegy> fast
	else if(strcmp(arguments[2], "fast") == 0)
f0114678:	8b 45 0c             	mov    0xc(%ebp),%eax
f011467b:	83 c0 08             	add    $0x8,%eax
f011467e:	8b 00                	mov    (%eax),%eax
f0114680:	83 ec 08             	sub    $0x8,%esp
f0114683:	68 3c a7 13 f0       	push   $0xf013a73c
f0114688:	50                   	push   %eax
f0114689:	e8 ad e8 00 00       	call   f0122f3b <strcmp>
f011468e:	83 c4 10             	add    $0x10,%esp
f0114691:	85 c0                	test   %eax,%eax
f0114693:	75 0f                	jne    f01146a4 <tst_kheap+0x436>
	{
		test_fast_page_alloc();
f0114695:	e8 5b 69 00 00       	call   f011aff5 <test_fast_page_alloc>
		return 0;
f011469a:	b8 00 00 00 00       	mov    $0x0,%eax
f011469f:	e9 be 00 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	// Test 2-kfree: tst kheap <Strategy> kfree <allocator>
	else if(strcmp(arguments[2], "kfree") == 0)
f01146a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01146a7:	83 c0 08             	add    $0x8,%eax
f01146aa:	8b 00                	mov    (%eax),%eax
f01146ac:	83 ec 08             	sub    $0x8,%esp
f01146af:	68 83 a7 13 f0       	push   $0xf013a783
f01146b4:	50                   	push   %eax
f01146b5:	e8 81 e8 00 00       	call   f0122f3b <strcmp>
f01146ba:	83 c4 10             	add    $0x10,%esp
f01146bd:	85 c0                	test   %eax,%eax
f01146bf:	75 18                	jne    f01146d9 <tst_kheap+0x46b>
	{
		test_kfree(testType);
f01146c1:	83 ec 0c             	sub    $0xc,%esp
f01146c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01146c7:	e8 f5 66 00 00       	call   f011adc1 <test_kfree>
f01146cc:	83 c4 10             	add    $0x10,%esp
		return 0;
f01146cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01146d4:	e9 89 00 00 00       	jmp    f0114762 <tst_kheap+0x4f4>
	}
	// Test 3-kphysaddr: tst kheap <Strategy> kphysaddr
	// <Strategy> IS NEGLECTED
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f01146d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01146dc:	83 c0 08             	add    $0x8,%eax
f01146df:	8b 00                	mov    (%eax),%eax
f01146e1:	83 ec 08             	sub    $0x8,%esp
f01146e4:	68 30 a8 13 f0       	push   $0xf013a830
f01146e9:	50                   	push   %eax
f01146ea:	e8 4c e8 00 00       	call   f0122f3b <strcmp>
f01146ef:	83 c4 10             	add    $0x10,%esp
f01146f2:	85 c0                	test   %eax,%eax
f01146f4:	75 0c                	jne    f0114702 <tst_kheap+0x494>
	{
		test_kheap_phys_addr();
f01146f6:	e8 4a 95 00 00       	call   f011dc45 <test_kheap_phys_addr>
		return 0;
f01146fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0114700:	eb 60                	jmp    f0114762 <tst_kheap+0x4f4>
	}
	// Test 4-kvirtaddr: tst kheap <Strategy> kvirtaddr
	// <Strategy> IS NEGLECTED
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0114702:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114705:	83 c0 08             	add    $0x8,%eax
f0114708:	8b 00                	mov    (%eax),%eax
f011470a:	83 ec 08             	sub    $0x8,%esp
f011470d:	68 e2 a7 13 f0       	push   $0xf013a7e2
f0114712:	50                   	push   %eax
f0114713:	e8 23 e8 00 00       	call   f0122f3b <strcmp>
f0114718:	83 c4 10             	add    $0x10,%esp
f011471b:	85 c0                	test   %eax,%eax
f011471d:	75 0c                	jne    f011472b <tst_kheap+0x4bd>
	{
		test_kheap_virt_addr();
f011471f:	e8 78 a2 00 00       	call   f011e99c <test_kheap_virt_addr>
		return 0;
f0114724:	b8 00 00 00 00       	mov    $0x0,%eax
f0114729:	eb 37                	jmp    f0114762 <tst_kheap+0x4f4>
	}
	// Test 5-krealloc: tst kheap <Strategy> krealloc <allocator>
	else if(strcmp(arguments[2], "krealloc") == 0)
f011472b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011472e:	83 c0 08             	add    $0x8,%eax
f0114731:	8b 00                	mov    (%eax),%eax
f0114733:	83 ec 08             	sub    $0x8,%esp
f0114736:	68 80 a8 13 f0       	push   $0xf013a880
f011473b:	50                   	push   %eax
f011473c:	e8 fa e7 00 00       	call   f0122f3b <strcmp>
f0114741:	83 c4 10             	add    $0x10,%esp
f0114744:	85 c0                	test   %eax,%eax
f0114746:	75 15                	jne    f011475d <tst_kheap+0x4ef>
	{
		test_krealloc(testType);
f0114748:	83 ec 0c             	sub    $0xc,%esp
f011474b:	ff 75 f4             	pushl  -0xc(%ebp)
f011474e:	e8 88 67 00 00       	call   f011aedb <test_krealloc>
f0114753:	83 c4 10             	add    $0x10,%esp
		return 0;
f0114756:	b8 00 00 00 00       	mov    $0x0,%eax
f011475b:	eb 05                	jmp    f0114762 <tst_kheap+0x4f4>
	/*	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
	{
		test_ksbrk();
	}*/
	return 0;
f011475d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114762:	c9                   	leave  
f0114763:	c3                   	ret    

f0114764 <IDX>:

short* startVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;
short* endVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;

__inline__ uint8 IDX(uint32 size)
{
f0114764:	55                   	push   %ebp
f0114765:	89 e5                	mov    %esp,%ebp
f0114767:	83 ec 10             	sub    $0x10,%esp
	size>>= LOG2_MIN_SIZE;
f011476a:	c1 6d 08 03          	shrl   $0x3,0x8(%ebp)
	int index = 0;
f011476e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while ((size>>=1) != 0)
f0114775:	eb 03                	jmp    f011477a <IDX+0x16>
	{
		index++;
f0114777:	ff 45 fc             	incl   -0x4(%ebp)

__inline__ uint8 IDX(uint32 size)
{
	size>>= LOG2_MIN_SIZE;
	int index = 0;
	while ((size>>=1) != 0)
f011477a:	d1 6d 08             	shrl   0x8(%ebp)
f011477d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0114781:	75 f4                	jne    f0114777 <IDX+0x13>
	{
		index++;
	}
	return index;
f0114783:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0114786:	c9                   	leave  
f0114787:	c3                   	ret    

f0114788 <check_dynalloc_datastruct>:

int check_dynalloc_datastruct(uint32 curSize, uint32 numOfBlksAtCurSize)
{
f0114788:	55                   	push   %ebp
f0114789:	89 e5                	mov    %esp,%ebp
f011478b:	53                   	push   %ebx
f011478c:	83 ec 44             	sub    $0x44,%esp
	int maxNumOfBlksPerPage = PAGE_SIZE / curSize;
f011478f:	b8 00 10 00 00       	mov    $0x1000,%eax
f0114794:	ba 00 00 00 00       	mov    $0x0,%edx
f0114799:	f7 75 08             	divl   0x8(%ebp)
f011479c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int expectedNumOfCompletePages = numOfBlksAtCurSize / maxNumOfBlksPerPage;
f011479f:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f01147a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01147a5:	ba 00 00 00 00       	mov    $0x0,%edx
f01147aa:	f7 f3                	div    %ebx
f01147ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int expectedNumOfInCompletePages = numOfBlksAtCurSize % maxNumOfBlksPerPage != 0? 1 : 0;
f01147af:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f01147b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01147b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01147ba:	f7 f1                	div    %ecx
f01147bc:	89 d0                	mov    %edx,%eax
f01147be:	85 c0                	test   %eax,%eax
f01147c0:	0f 95 c0             	setne  %al
f01147c3:	0f b6 c0             	movzbl %al,%eax
f01147c6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	int expectedNumOfFreeBlks = expectedNumOfInCompletePages * (maxNumOfBlksPerPage - numOfBlksAtCurSize % maxNumOfBlksPerPage);
f01147c9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f01147cc:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f01147cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01147d2:	ba 00 00 00 00       	mov    $0x0,%edx
f01147d7:	f7 f3                	div    %ebx
f01147d9:	89 d0                	mov    %edx,%eax
f01147db:	29 c1                	sub    %eax,%ecx
f01147dd:	89 ca                	mov    %ecx,%edx
f01147df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01147e2:	0f af c2             	imul   %edx,%eax
f01147e5:	89 45 d0             	mov    %eax,-0x30(%ebp)

	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
f01147e8:	c7 45 cc 00 20 00 00 	movl   $0x2000,-0x34(%ebp)
	int actualNumOfCompletePages = 0;
f01147ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int actualNumOfInCompletePages = 0;
f01147f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int actualNumOfFreeBlks = 0;
f01147fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfPages; ++i)
f0114804:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011480b:	eb 59                	jmp    f0114866 <check_dynalloc_datastruct+0xde>
	{
		if (pageBlockInfoArr[i].block_size == curSize)
f011480d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0114810:	89 d0                	mov    %edx,%eax
f0114812:	01 c0                	add    %eax,%eax
f0114814:	01 d0                	add    %edx,%eax
f0114816:	c1 e0 02             	shl    $0x2,%eax
f0114819:	05 68 d0 94 f1       	add    $0xf194d068,%eax
f011481e:	8b 00                	mov    (%eax),%eax
f0114820:	0f b7 c0             	movzwl %ax,%eax
f0114823:	3b 45 08             	cmp    0x8(%ebp),%eax
f0114826:	75 3b                	jne    f0114863 <check_dynalloc_datastruct+0xdb>
		{
			if (pageBlockInfoArr[i].num_of_free_blocks == 0)
f0114828:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011482b:	89 d0                	mov    %edx,%eax
f011482d:	01 c0                	add    %eax,%eax
f011482f:	01 d0                	add    %edx,%eax
f0114831:	c1 e0 02             	shl    $0x2,%eax
f0114834:	05 6a d0 94 f1       	add    $0xf194d06a,%eax
f0114839:	66 8b 00             	mov    (%eax),%ax
f011483c:	66 85 c0             	test   %ax,%ax
f011483f:	75 05                	jne    f0114846 <check_dynalloc_datastruct+0xbe>
			{
				actualNumOfCompletePages++;
f0114841:	ff 45 f4             	incl   -0xc(%ebp)
f0114844:	eb 1d                	jmp    f0114863 <check_dynalloc_datastruct+0xdb>
			}
			else
			{
				actualNumOfInCompletePages++;
f0114846:	ff 45 f0             	incl   -0x10(%ebp)
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
f0114849:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011484c:	89 d0                	mov    %edx,%eax
f011484e:	01 c0                	add    %eax,%eax
f0114850:	01 d0                	add    %edx,%eax
f0114852:	c1 e0 02             	shl    $0x2,%eax
f0114855:	05 6a d0 94 f1       	add    $0xf194d06a,%eax
f011485a:	66 8b 00             	mov    (%eax),%ax
f011485d:	0f b7 c0             	movzwl %ax,%eax
f0114860:	01 45 ec             	add    %eax,-0x14(%ebp)
	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
	int actualNumOfCompletePages = 0;
	int actualNumOfInCompletePages = 0;
	int actualNumOfFreeBlks = 0;
	for (int i = 0; i < numOfPages; ++i)
f0114863:	ff 45 e8             	incl   -0x18(%ebp)
f0114866:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114869:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011486c:	7c 9f                	jl     f011480d <check_dynalloc_datastruct+0x85>
				actualNumOfInCompletePages++;
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
			}
		}
	}
	if (actualNumOfCompletePages != expectedNumOfCompletePages ||
f011486e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0114871:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0114874:	75 10                	jne    f0114886 <check_dynalloc_datastruct+0xfe>
f0114876:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114879:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011487c:	75 08                	jne    f0114886 <check_dynalloc_datastruct+0xfe>
			actualNumOfInCompletePages != expectedNumOfInCompletePages ||
f011487e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114881:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0114884:	74 1c                	je     f01148a2 <check_dynalloc_datastruct+0x11a>
			actualNumOfFreeBlks != expectedNumOfFreeBlks)
	{
		cprintf_colored(TEXT_TESTERR_CLR, "PageBlkInfoArr is not set/updated correctly!\n");
f0114886:	83 ec 08             	sub    $0x8,%esp
f0114889:	68 2c aa 13 f0       	push   $0xf013aa2c
f011488e:	6a 0c                	push   $0xc
f0114890:	e8 e8 d2 fe ff       	call   f0101b7d <cprintf_colored>
f0114895:	83 c4 10             	add    $0x10,%esp
//		cprintf_colored(TEXT_cyan, "actualNumOfCompletePages = %d, expectedNumOfCompletePages = %d\n", actualNumOfCompletePages, expectedNumOfCompletePages);
//		cprintf_colored(TEXT_cyan, "actualNumOfInCompletePages = %d, expectedNumOfInCompletePages = %d\n", actualNumOfInCompletePages, expectedNumOfInCompletePages);
//		cprintf_colored(TEXT_cyan, "actualNumOfFreeBlks = %d, expectedNumOfFreeBlks = %d\n", actualNumOfFreeBlks, expectedNumOfFreeBlks);
		return 0;
f0114898:	b8 00 00 00 00       	mov    $0x0,%eax
f011489d:	e9 9d 00 00 00       	jmp    f011493f <check_dynalloc_datastruct+0x1b7>
	}

	//[2] Check freeBlkLists
	int index = IDX(curSize);
f01148a2:	83 ec 0c             	sub    $0xc,%esp
f01148a5:	ff 75 08             	pushl  0x8(%ebp)
f01148a8:	e8 b7 fe ff ff       	call   f0114764 <IDX>
f01148ad:	83 c4 10             	add    $0x10,%esp
f01148b0:	0f b6 c0             	movzbl %al,%eax
f01148b3:	89 45 c8             	mov    %eax,-0x38(%ebp)
	struct BlockElement_List *ptrList = &freeBlockLists[index];
f01148b6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01148b9:	c1 e0 04             	shl    $0x4,%eax
f01148bc:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f01148c1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	int n = 0;
f01148c4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f01148cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148ce:	8b 00                	mov    (%eax),%eax
f01148d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01148d3:	eb 0c                	jmp    f01148e1 <check_dynalloc_datastruct+0x159>
	{
		n++;
f01148d5:	ff 45 e4             	incl   -0x1c(%ebp)
	//[2] Check freeBlkLists
	int index = IDX(curSize);
	struct BlockElement_List *ptrList = &freeBlockLists[index];
	int n = 0;
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f01148d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148db:	8b 40 08             	mov    0x8(%eax),%eax
f01148de:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01148e1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01148e5:	74 07                	je     f01148ee <check_dynalloc_datastruct+0x166>
f01148e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01148ea:	8b 00                	mov    (%eax),%eax
f01148ec:	eb 05                	jmp    f01148f3 <check_dynalloc_datastruct+0x16b>
f01148ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01148f3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01148f6:	89 42 08             	mov    %eax,0x8(%edx)
f01148f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148fc:	8b 40 08             	mov    0x8(%eax),%eax
f01148ff:	85 c0                	test   %eax,%eax
f0114901:	75 d2                	jne    f01148d5 <check_dynalloc_datastruct+0x14d>
f0114903:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114907:	75 cc                	jne    f01148d5 <check_dynalloc_datastruct+0x14d>
	{
		n++;
	}
	if (LIST_SIZE(ptrList) != expectedNumOfFreeBlks || n != expectedNumOfFreeBlks)
f0114909:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011490c:	8b 50 0c             	mov    0xc(%eax),%edx
f011490f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114912:	39 c2                	cmp    %eax,%edx
f0114914:	75 08                	jne    f011491e <check_dynalloc_datastruct+0x196>
f0114916:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114919:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011491c:	74 1c                	je     f011493a <check_dynalloc_datastruct+0x1b2>
	{
		cprintf_colored(TEXT_TESTERR_CLR,"freeBlockLists[%d] is not updated correctly!", index);
f011491e:	83 ec 04             	sub    $0x4,%esp
f0114921:	ff 75 c8             	pushl  -0x38(%ebp)
f0114924:	68 5c aa 13 f0       	push   $0xf013aa5c
f0114929:	6a 0c                	push   $0xc
f011492b:	e8 4d d2 fe ff       	call   f0101b7d <cprintf_colored>
f0114930:	83 c4 10             	add    $0x10,%esp
		return 0;
f0114933:	b8 00 00 00 00       	mov    $0x0,%eax
f0114938:	eb 05                	jmp    f011493f <check_dynalloc_datastruct+0x1b7>
	}
	return 1;
f011493a:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011493f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0114942:	c9                   	leave  
f0114943:	c3                   	ret    

f0114944 <remove_current_mappings>:
extern uint32* ptr_page_directory;
extern void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address);
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
f0114944:	55                   	push   %ebp
f0114945:	89 e5                	mov    %esp,%ebp
f0114947:	83 ec 18             	sub    $0x18,%esp
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
f011494a:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f0114951:	76 09                	jbe    f011495c <remove_current_mappings+0x18>
f0114953:	81 7d 0c ff ff ff f5 	cmpl   $0xf5ffffff,0xc(%ebp)
f011495a:	77 16                	ja     f0114972 <remove_current_mappings+0x2e>
f011495c:	68 8c aa 13 f0       	push   $0xf013aa8c
f0114961:	68 c7 aa 13 f0       	push   $0xf013aac7
f0114966:	6a 62                	push   $0x62
f0114968:	68 dc aa 13 f0       	push   $0xf013aadc
f011496d:	e8 3d c5 fe ff       	call   f0100eaf <_panic>
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f0114972:	8b 45 08             	mov    0x8(%ebp),%eax
f0114975:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0114978:	eb 1b                	jmp    f0114995 <remove_current_mappings+0x51>
	{
		unmap_frame(ptr_page_directory, va);
f011497a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011497f:	83 ec 08             	sub    $0x8,%esp
f0114982:	ff 75 f4             	pushl  -0xc(%ebp)
f0114985:	50                   	push   %eax
f0114986:	e8 e1 52 ff ff       	call   f0109c6c <unmap_frame>
f011498b:	83 c4 10             	add    $0x10,%esp
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f011498e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0114995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0114998:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011499b:	72 dd                	jb     f011497a <remove_current_mappings+0x36>
	{
		unmap_frame(ptr_page_directory, va);
	}
}
f011499d:	90                   	nop
f011499e:	c9                   	leave  
f011499f:	c3                   	ret    

f01149a0 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f01149a0:	55                   	push   %ebp
f01149a1:	89 e5                	mov    %esp,%ebp
f01149a3:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01149a6:	83 ec 04             	sub    $0x4,%esp
f01149a9:	68 00 ab 13 f0       	push   $0xf013ab00
f01149ae:	6a 6d                	push   $0x6d
f01149b0:	68 dc aa 13 f0       	push   $0xf013aadc
f01149b5:	e8 f5 c4 fe ff       	call   f0100eaf <_panic>

f01149ba <test_initial_alloc>:
			"\nCongratulations!! test initialize_dynamic_allocator completed successfully.\n"
			"=============================================================================\n");
}

int test_initial_alloc()
{
f01149ba:	55                   	push   %ebp
f01149bb:	89 e5                	mov    %esp,%ebp
f01149bd:	83 ec 58             	sub    $0x58,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01149c0:	83 ec 04             	sub    $0x4,%esp
f01149c3:	68 60 ab 13 f0       	push   $0xf013ab60
f01149c8:	68 ac 00 00 00       	push   $0xac
f01149cd:	68 dc aa 13 f0       	push   $0xf013aadc
f01149d2:	e8 d8 c4 fe ff       	call   f0100eaf <_panic>

f01149d7 <test_alloc_block>:

	return eval;
}

void test_alloc_block()
{
f01149d7:	55                   	push   %ebp
f01149d8:	89 e5                	mov    %esp,%ebp
f01149da:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_alloc_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01149dd:	83 ec 04             	sub    $0x4,%esp
f01149e0:	68 b0 ab 13 f0       	push   $0xf013abb0
f01149e5:	68 62 01 00 00       	push   $0x162
f01149ea:	68 dc aa 13 f0       	push   $0xf013aadc
f01149ef:	e8 bb c4 fe ff       	call   f0100eaf <_panic>

f01149f4 <test_free_block>:
	cprintf_colored(TEXT_light_green, "test alloc_block Evaluation = %d%\n", eval);
	return ;
}

void test_free_block()
{
f01149f4:	55                   	push   %ebp
f01149f5:	89 e5                	mov    %esp,%ebp
f01149f7:	83 ec 78             	sub    $0x78,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01149fa:	83 ec 04             	sub    $0x4,%esp
f01149fd:	68 00 ac 13 f0       	push   $0xf013ac00
f0114a02:	68 74 01 00 00       	push   $0x174
f0114a07:	68 dc aa 13 f0       	push   $0xf013aadc
f0114a0c:	e8 9e c4 fe ff       	call   f0100eaf <_panic>

f0114a11 <test_realloc_block>:
	cprintf_colored(TEXT_light_green, "test free_block completed. Evaluation = %d%\n", eval);

}

void test_realloc_block()
{
f0114a11:	55                   	push   %ebp
f0114a12:	89 e5                	mov    %esp,%ebp
f0114a14:	83 ec 08             	sub    $0x8,%esp
	panic("unseen test");
f0114a17:	83 ec 04             	sub    $0x4,%esp
f0114a1a:	68 4d ac 13 f0       	push   $0xf013ac4d
f0114a1f:	68 92 02 00 00       	push   $0x292
f0114a24:	68 dc aa 13 f0       	push   $0xf013aadc
f0114a29:	e8 81 c4 fe ff       	call   f0100eaf <_panic>

f0114a2e <sys_check_LRU_lists>:
#include <kern/cpu/cpu.h>
#include <kern/cpu/kclock.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0114a2e:	55                   	push   %ebp
f0114a2f:	89 e5                	mov    %esp,%ebp
f0114a31:	83 ec 38             	sub    $0x38,%esp
	int active_list_validation = 1;
f0114a34:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0114a3b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	/*DISABLE THE INTERRUPT DURING THE CHECKING TO AVOID CLOCK INTERRUPTS*/
	pushcli(); kclock_stop();
f0114a42:	e8 7b 3b ff ff       	call   f01085c2 <pushcli>
f0114a47:	e8 d9 12 ff ff       	call   f0105d25 <kclock_stop>
	{
		struct Env* cur_env = get_cpu_proc();
f0114a4c:	e8 f7 8b ff ff       	call   f010d648 <get_cpu_proc>
f0114a51:	89 45 e0             	mov    %eax,-0x20(%ebp)
		assert(cur_env != NULL);
f0114a54:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114a58:	75 16                	jne    f0114a70 <sys_check_LRU_lists+0x42>
f0114a5a:	68 5c ac 13 f0       	push   $0xf013ac5c
f0114a5f:	68 6c ac 13 f0       	push   $0xf013ac6c
f0114a64:	6a 18                	push   $0x18
f0114a66:	68 81 ac 13 f0       	push   $0xf013ac81
f0114a6b:	e8 3f c4 fe ff       	call   f0100eaf <_panic>
		cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0114a70:	83 ec 0c             	sub    $0xc,%esp
f0114a73:	68 a0 ac 13 f0       	push   $0xf013aca0
f0114a78:	e8 d0 d0 fe ff       	call   f0101b4d <cprintf>
f0114a7d:	83 c4 10             	add    $0x10,%esp
		env_page_ws_print(cur_env);
f0114a80:	83 ec 0c             	sub    $0xc,%esp
f0114a83:	ff 75 e0             	pushl  -0x20(%ebp)
f0114a86:	e8 f4 73 ff ff       	call   f010be7f <env_page_ws_print>
f0114a8b:	83 c4 10             	add    $0x10,%esp

		struct Env* env = cur_env;
f0114a8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114a91:	89 45 dc             	mov    %eax,-0x24(%ebp)
		struct WorkingSetElement* ptr_WS_element;

		//1- Check active list content if not null
		if(active_list_content != NULL)
f0114a94:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0114a98:	0f 84 a5 00 00 00    	je     f0114b43 <sys_check_LRU_lists+0x115>
		{
			int idx_active_list = 0;
f0114a9e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0114aa5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114aa8:	8b 80 44 06 00 00    	mov    0x644(%eax),%eax
f0114aae:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0114ab1:	eb 4a                	jmp    f0114afd <sys_check_LRU_lists+0xcf>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0114ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114ab6:	8b 00                	mov    (%eax),%eax
f0114ab8:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0114abb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114abe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114ac3:	89 c2                	mov    %eax,%edx
f0114ac5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114ac8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0114acf:	8b 45 08             	mov    0x8(%ebp),%eax
f0114ad2:	01 c8                	add    %ecx,%eax
f0114ad4:	8b 00                	mov    (%eax),%eax
f0114ad6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0114ad9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0114adc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114ae1:	39 c2                	cmp    %eax,%edx
f0114ae3:	74 09                	je     f0114aee <sys_check_LRU_lists+0xc0>
				{
					active_list_validation = 0;
f0114ae5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					break;
f0114aec:	eb 3e                	jmp    f0114b2c <sys_check_LRU_lists+0xfe>
				}
				idx_active_list++;
f0114aee:	ff 45 e8             	incl   -0x18(%ebp)

		//1- Check active list content if not null
		if(active_list_content != NULL)
		{
			int idx_active_list = 0;
			LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0114af1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114af4:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f0114afa:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0114afd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0114b01:	74 08                	je     f0114b0b <sys_check_LRU_lists+0xdd>
f0114b03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114b06:	8b 40 10             	mov    0x10(%eax),%eax
f0114b09:	eb 05                	jmp    f0114b10 <sys_check_LRU_lists+0xe2>
f0114b0b:	b8 00 00 00 00       	mov    $0x0,%eax
f0114b10:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0114b13:	89 82 4c 06 00 00    	mov    %eax,0x64c(%edx)
f0114b19:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114b1c:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f0114b22:	85 c0                	test   %eax,%eax
f0114b24:	75 8d                	jne    f0114ab3 <sys_check_LRU_lists+0x85>
f0114b26:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0114b2a:	75 87                	jne    f0114ab3 <sys_check_LRU_lists+0x85>
					active_list_validation = 0;
					break;
				}
				idx_active_list++;
			}
			if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0114b2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114b2f:	8b 90 50 06 00 00    	mov    0x650(%eax),%edx
f0114b35:	8b 45 10             	mov    0x10(%ebp),%eax
f0114b38:	39 c2                	cmp    %eax,%edx
f0114b3a:	74 07                	je     f0114b43 <sys_check_LRU_lists+0x115>
			{
				active_list_validation = 0;
f0114b3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

			}
		}

		//2- Check second chance list content if not null
		if(second_list_content != NULL)
f0114b43:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0114b47:	0f 84 a5 00 00 00    	je     f0114bf2 <sys_check_LRU_lists+0x1c4>
		{
			int idx_second_list = 0;
f0114b4d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0114b54:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114b57:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f0114b5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0114b60:	eb 4a                	jmp    f0114bac <sys_check_LRU_lists+0x17e>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0114b62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114b65:	8b 00                	mov    (%eax),%eax
f0114b67:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114b6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114b6d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114b72:	89 c2                	mov    %eax,%edx
f0114b74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114b77:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0114b7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114b81:	01 c8                	add    %ecx,%eax
f0114b83:	8b 00                	mov    (%eax),%eax
f0114b85:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0114b88:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114b8b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114b90:	39 c2                	cmp    %eax,%edx
f0114b92:	74 09                	je     f0114b9d <sys_check_LRU_lists+0x16f>
				{
					second_list_validation = 0;
f0114b94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					break;
f0114b9b:	eb 3e                	jmp    f0114bdb <sys_check_LRU_lists+0x1ad>
				}
				idx_second_list++;
f0114b9d:	ff 45 e4             	incl   -0x1c(%ebp)

		//2- Check second chance list content if not null
		if(second_list_content != NULL)
		{
			int idx_second_list = 0;
			LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0114ba0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114ba3:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f0114ba9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0114bac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0114bb0:	74 08                	je     f0114bba <sys_check_LRU_lists+0x18c>
f0114bb2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114bb5:	8b 40 10             	mov    0x10(%eax),%eax
f0114bb8:	eb 05                	jmp    f0114bbf <sys_check_LRU_lists+0x191>
f0114bba:	b8 00 00 00 00       	mov    $0x0,%eax
f0114bbf:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0114bc2:	89 82 5c 06 00 00    	mov    %eax,0x65c(%edx)
f0114bc8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114bcb:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f0114bd1:	85 c0                	test   %eax,%eax
f0114bd3:	75 8d                	jne    f0114b62 <sys_check_LRU_lists+0x134>
f0114bd5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0114bd9:	75 87                	jne    f0114b62 <sys_check_LRU_lists+0x134>
					second_list_validation = 0;
					break;
				}
				idx_second_list++;
			}
			if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0114bdb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114bde:	8b 90 60 06 00 00    	mov    0x660(%eax),%edx
f0114be4:	8b 45 14             	mov    0x14(%ebp),%eax
f0114be7:	39 c2                	cmp    %eax,%edx
f0114be9:	74 07                	je     f0114bf2 <sys_check_LRU_lists+0x1c4>
				second_list_validation = 0;
f0114beb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		}
	}
	/*REENABLE THE INTERRUPT */
	popcli(); kclock_resume();
f0114bf2:	e8 1d 3a ff ff       	call   f0108614 <popcli>
f0114bf7:	e8 51 11 ff ff       	call   f0105d4d <kclock_resume>

	return active_list_validation&second_list_validation;
f0114bfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0114bff:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0114c02:	c9                   	leave  
f0114c03:	c3                   	ret    

f0114c04 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0114c04:	55                   	push   %ebp
f0114c05:	89 e5                	mov    %esp,%ebp
f0114c07:	83 ec 38             	sub    $0x38,%esp
	int list_validation_count = 0;
f0114c0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	/*DISABLE THE INTERRUPT DURING THE CHECKING TO AVOID CLOCK INTERRUPTS*/
	pushcli(); kclock_stop();
f0114c11:	e8 ac 39 ff ff       	call   f01085c2 <pushcli>
f0114c16:	e8 0a 11 ff ff       	call   f0105d25 <kclock_stop>
	{
		struct Env* cur_env = get_cpu_proc();
f0114c1b:	e8 28 8a ff ff       	call   f010d648 <get_cpu_proc>
f0114c20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		assert(cur_env != NULL);
f0114c23:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0114c27:	75 16                	jne    f0114c3f <sys_check_LRU_lists_free+0x3b>
f0114c29:	68 5c ac 13 f0       	push   $0xf013ac5c
f0114c2e:	68 6c ac 13 f0       	push   $0xf013ac6c
f0114c33:	6a 53                	push   $0x53
f0114c35:	68 81 ac 13 f0       	push   $0xf013ac81
f0114c3a:	e8 70 c2 fe ff       	call   f0100eaf <_panic>
		struct Env* env = cur_env;
f0114c3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114c42:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct WorkingSetElement* ptr_WS_element;

		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0114c45:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114c48:	8b 80 44 06 00 00    	mov    0x644(%eax),%eax
f0114c4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0114c51:	eb 5d                	jmp    f0114cb0 <sys_check_LRU_lists_free+0xac>
		{
			for(int var = 0; var < list_size; var++)
f0114c53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0114c5a:	eb 3a                	jmp    f0114c96 <sys_check_LRU_lists_free+0x92>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0114c5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114c5f:	8b 00                	mov    (%eax),%eax
f0114c61:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0114c64:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114c67:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114c6c:	89 c2                	mov    %eax,%edx
f0114c6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114c71:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0114c78:	8b 45 08             	mov    0x8(%ebp),%eax
f0114c7b:	01 c8                	add    %ecx,%eax
f0114c7d:	8b 00                	mov    (%eax),%eax
f0114c7f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0114c82:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114c85:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114c8a:	39 c2                	cmp    %eax,%edx
f0114c8c:	75 05                	jne    f0114c93 <sys_check_LRU_lists_free+0x8f>
				{
					list_validation_count++;
f0114c8e:	ff 45 f4             	incl   -0xc(%ebp)
					break;
f0114c91:	eb 0b                	jmp    f0114c9e <sys_check_LRU_lists_free+0x9a>
		struct Env* env = cur_env;
		struct WorkingSetElement* ptr_WS_element;

		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
		{
			for(int var = 0; var < list_size; var++)
f0114c93:	ff 45 ec             	incl   -0x14(%ebp)
f0114c96:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114c99:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0114c9c:	7c be                	jl     f0114c5c <sys_check_LRU_lists_free+0x58>
				{
					list_validation_count++;
					break;
				}
			}
			if(list_validation_count > 0)
f0114c9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0114ca2:	7f 45                	jg     f0114ce9 <sys_check_LRU_lists_free+0xe5>
		struct Env* cur_env = get_cpu_proc();
		assert(cur_env != NULL);
		struct Env* env = cur_env;
		struct WorkingSetElement* ptr_WS_element;

		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0114ca4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114ca7:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f0114cad:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0114cb0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0114cb4:	74 08                	je     f0114cbe <sys_check_LRU_lists_free+0xba>
f0114cb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114cb9:	8b 40 10             	mov    0x10(%eax),%eax
f0114cbc:	eb 05                	jmp    f0114cc3 <sys_check_LRU_lists_free+0xbf>
f0114cbe:	b8 00 00 00 00       	mov    $0x0,%eax
f0114cc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0114cc6:	89 82 4c 06 00 00    	mov    %eax,0x64c(%edx)
f0114ccc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114ccf:	8b 80 4c 06 00 00    	mov    0x64c(%eax),%eax
f0114cd5:	85 c0                	test   %eax,%eax
f0114cd7:	0f 85 76 ff ff ff    	jne    f0114c53 <sys_check_LRU_lists_free+0x4f>
f0114cdd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0114ce1:	0f 85 6c ff ff ff    	jne    f0114c53 <sys_check_LRU_lists_free+0x4f>
f0114ce7:	eb 01                	jmp    f0114cea <sys_check_LRU_lists_free+0xe6>
					list_validation_count++;
					break;
				}
			}
			if(list_validation_count > 0)
				break;
f0114ce9:	90                   	nop
		}


		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0114cea:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114ced:	8b 80 54 06 00 00    	mov    0x654(%eax),%eax
f0114cf3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0114cf6:	eb 5d                	jmp    f0114d55 <sys_check_LRU_lists_free+0x151>
		{
			for(int var = 0; var < list_size; var++)
f0114cf8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0114cff:	eb 3a                	jmp    f0114d3b <sys_check_LRU_lists_free+0x137>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0114d01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114d04:	8b 00                	mov    (%eax),%eax
f0114d06:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0114d09:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0114d0c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114d11:	89 c2                	mov    %eax,%edx
f0114d13:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114d16:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0114d1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0114d20:	01 c8                	add    %ecx,%eax
f0114d22:	8b 00                	mov    (%eax),%eax
f0114d24:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114d27:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d2a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114d2f:	39 c2                	cmp    %eax,%edx
f0114d31:	75 05                	jne    f0114d38 <sys_check_LRU_lists_free+0x134>
				{
					list_validation_count++;
f0114d33:	ff 45 f4             	incl   -0xc(%ebp)
					break;
f0114d36:	eb 0b                	jmp    f0114d43 <sys_check_LRU_lists_free+0x13f>
		}


		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
		{
			for(int var = 0; var < list_size; var++)
f0114d38:	ff 45 e8             	incl   -0x18(%ebp)
f0114d3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114d3e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0114d41:	7c be                	jl     f0114d01 <sys_check_LRU_lists_free+0xfd>
				{
					list_validation_count++;
					break;
				}
			}
			if(list_validation_count > 0)
f0114d43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0114d47:	7f 45                	jg     f0114d8e <sys_check_LRU_lists_free+0x18a>
			if(list_validation_count > 0)
				break;
		}


		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0114d49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114d4c:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f0114d52:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0114d55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0114d59:	74 08                	je     f0114d63 <sys_check_LRU_lists_free+0x15f>
f0114d5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114d5e:	8b 40 10             	mov    0x10(%eax),%eax
f0114d61:	eb 05                	jmp    f0114d68 <sys_check_LRU_lists_free+0x164>
f0114d63:	b8 00 00 00 00       	mov    $0x0,%eax
f0114d68:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0114d6b:	89 82 5c 06 00 00    	mov    %eax,0x65c(%edx)
f0114d71:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114d74:	8b 80 5c 06 00 00    	mov    0x65c(%eax),%eax
f0114d7a:	85 c0                	test   %eax,%eax
f0114d7c:	0f 85 76 ff ff ff    	jne    f0114cf8 <sys_check_LRU_lists_free+0xf4>
f0114d82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0114d86:	0f 85 6c ff ff ff    	jne    f0114cf8 <sys_check_LRU_lists_free+0xf4>
f0114d8c:	eb 01                	jmp    f0114d8f <sys_check_LRU_lists_free+0x18b>
					list_validation_count++;
					break;
				}
			}
			if(list_validation_count > 0)
				break;
f0114d8e:	90                   	nop

		}
	}
	/*REENABLE THE INTERRUPT */
	popcli(); kclock_resume();
f0114d8f:	e8 80 38 ff ff       	call   f0108614 <popcli>
f0114d94:	e8 b4 0f ff ff       	call   f0105d4d <kclock_resume>

	return list_validation_count;
f0114d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0114d9c:	c9                   	leave  
f0114d9d:	c3                   	ret    

f0114d9e <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0114d9e:	55                   	push   %ebp
f0114d9f:	89 e5                	mov    %esp,%ebp
f0114da1:	83 ec 78             	sub    $0x78,%esp
#if USE_KHEAP
	int WS_list_validation = 1;
f0114da4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	/*DISABLE THE INTERRUPT DURING THE CHECKING TO AVOID CLOCK INTERRUPTS*/
	pushcli(); kclock_stop();
f0114dab:	e8 12 38 ff ff       	call   f01085c2 <pushcli>
f0114db0:	e8 70 0f ff ff       	call   f0105d25 <kclock_stop>
	{
//		cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
//		env_page_ws_print(get_cpu_proc());
		struct Env* cur_env = get_cpu_proc();
f0114db5:	e8 8e 88 ff ff       	call   f010d648 <get_cpu_proc>
f0114dba:	89 45 d0             	mov    %eax,-0x30(%ebp)
		assert(cur_env != NULL);
f0114dbd:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0114dc1:	75 19                	jne    f0114ddc <sys_check_WS_list+0x3e>
f0114dc3:	68 5c ac 13 f0       	push   $0xf013ac5c
f0114dc8:	68 6c ac 13 f0       	push   $0xf013ac6c
f0114dcd:	68 8c 00 00 00       	push   $0x8c
f0114dd2:	68 81 ac 13 f0       	push   $0xf013ac81
f0114dd7:	e8 d3 c0 fe ff       	call   f0100eaf <_panic>
		struct Env* env = cur_env;
f0114ddc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114ddf:	89 45 cc             	mov    %eax,-0x34(%ebp)
		struct WorkingSetElement* ptr_WS_element;

		if (chk_status == 0 || chk_status == 1)
f0114de2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0114de6:	74 06                	je     f0114dee <sys_check_WS_list+0x50>
f0114de8:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0114dec:	75 17                	jne    f0114e05 <sys_check_WS_list+0x67>
		{
			if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0114dee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114df1:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f0114df7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0114dfa:	39 c2                	cmp    %eax,%edx
f0114dfc:	74 07                	je     f0114e05 <sys_check_WS_list+0x67>
			{
				WS_list_validation = 0;
f0114dfe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			}
		}
		//if it's required to check the last_WS_element
		if (last_WS_element_content != 0)
f0114e05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0114e09:	74 31                	je     f0114e3c <sys_check_WS_list+0x9e>
		{
			if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0114e0b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114e0e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0114e14:	8b 00                	mov    (%eax),%eax
f0114e16:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114e19:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114e1c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114e21:	89 c2                	mov    %eax,%edx
f0114e23:	8b 45 10             	mov    0x10(%ebp),%eax
f0114e26:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0114e29:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114e2c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114e31:	39 c2                	cmp    %eax,%edx
f0114e33:	74 07                	je     f0114e3c <sys_check_WS_list+0x9e>
			{
				WS_list_validation = 0;
f0114e35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			}
		}

		if (WS_list_validation)
f0114e3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0114e40:	0f 84 8c 03 00 00    	je     f01151d2 <sys_check_WS_list+0x434>
		{
			//if the order of the content is important to check
			if (chk_status == 1)
f0114e46:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0114e4a:	0f 85 65 01 00 00    	jne    f0114fb5 <sys_check_WS_list+0x217>
			{
				int idx_WS_list = 0;
f0114e50:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

				//Search for the correct index of the current WS element (if any)
				if (env->page_last_WS_element)
f0114e57:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114e5a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0114e60:	85 c0                	test   %eax,%eax
f0114e62:	74 54                	je     f0114eb8 <sys_check_WS_list+0x11a>
				{
					for (int i = 0; i < actual_WS_list_size; ++i)
f0114e64:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0114e6b:	eb 43                	jmp    f0114eb0 <sys_check_WS_list+0x112>
					{
						if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE))
f0114e6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114e70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0114e77:	8b 45 08             	mov    0x8(%ebp),%eax
f0114e7a:	01 d0                	add    %edx,%eax
f0114e7c:	8b 00                	mov    (%eax),%eax
f0114e7e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0114e81:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e84:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114e89:	89 c2                	mov    %eax,%edx
f0114e8b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114e8e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0114e94:	8b 00                	mov    (%eax),%eax
f0114e96:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114e99:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e9c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114ea1:	39 c2                	cmp    %eax,%edx
f0114ea3:	75 08                	jne    f0114ead <sys_check_WS_list+0x10f>
						{
							idx_WS_list = i ;
f0114ea5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114ea8:	89 45 ec             	mov    %eax,-0x14(%ebp)
							break;
f0114eab:	eb 0b                	jmp    f0114eb8 <sys_check_WS_list+0x11a>
				int idx_WS_list = 0;

				//Search for the correct index of the current WS element (if any)
				if (env->page_last_WS_element)
				{
					for (int i = 0; i < actual_WS_list_size; ++i)
f0114ead:	ff 45 e8             	incl   -0x18(%ebp)
f0114eb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0114eb3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0114eb6:	7c b5                	jl     f0114e6d <sys_check_WS_list+0xcf>
						}
					}
				}
				//cprintf("index of last WS element = %d\n",idx_WS_list);
				//Check the expected content starting from last WS element (if any)
				if (env->page_last_WS_element)
f0114eb8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114ebb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0114ec1:	85 c0                	test   %eax,%eax
f0114ec3:	74 0e                	je     f0114ed3 <sys_check_WS_list+0x135>
					ptr_WS_element = env->page_last_WS_element;
f0114ec5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114ec8:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0114ece:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0114ed1:	eb 0c                	jmp    f0114edf <sys_check_WS_list+0x141>
				else
					ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0114ed3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114ed6:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0114edc:	89 45 f0             	mov    %eax,-0x10(%ebp)

				//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

				for (int i = 0; i < actual_WS_list_size; ++i)
f0114edf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0114ee6:	e9 b9 00 00 00       	jmp    f0114fa4 <sys_check_WS_list+0x206>
				{
					//cprintf("check against index %d, va = %x\n", idx_WS_list, ptr_WS_element->virtual_address);
					if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0114eeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114eee:	8b 00                	mov    (%eax),%eax
f0114ef0:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0114ef3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114ef6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114efb:	89 c2                	mov    %eax,%edx
f0114efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114f00:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0114f07:	8b 45 08             	mov    0x8(%ebp),%eax
f0114f0a:	01 c8                	add    %ecx,%eax
f0114f0c:	8b 00                	mov    (%eax),%eax
f0114f0e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0114f11:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f14:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114f19:	39 c2                	cmp    %eax,%edx
f0114f1b:	74 4c                	je     f0114f69 <sys_check_WS_list+0x1cb>
					{
						cprintf("WS MISMATCHED @INDEX %d!!! Actual = %x Expected = %x\n",idx_WS_list, ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE), ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE));
f0114f1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114f20:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0114f27:	8b 45 08             	mov    0x8(%ebp),%eax
f0114f2a:	01 d0                	add    %edx,%eax
f0114f2c:	8b 00                	mov    (%eax),%eax
f0114f2e:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0114f31:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114f34:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114f39:	89 c2                	mov    %eax,%edx
f0114f3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114f3e:	8b 00                	mov    (%eax),%eax
f0114f40:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0114f43:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114f46:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114f4b:	52                   	push   %edx
f0114f4c:	50                   	push   %eax
f0114f4d:	ff 75 ec             	pushl  -0x14(%ebp)
f0114f50:	68 c8 ac 13 f0       	push   $0xf013acc8
f0114f55:	e8 f3 cb fe ff       	call   f0101b4d <cprintf>
f0114f5a:	83 c4 10             	add    $0x10,%esp
						WS_list_validation = 0;
f0114f5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
						break;
f0114f64:	e9 69 02 00 00       	jmp    f01151d2 <sys_check_WS_list+0x434>
					}
					idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0114f69:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0114f6c:	40                   	inc    %eax
f0114f6d:	89 c2                	mov    %eax,%edx
f0114f6f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114f72:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0114f78:	89 d0                	mov    %edx,%eax
f0114f7a:	ba 00 00 00 00       	mov    $0x0,%edx
f0114f7f:	f7 f1                	div    %ecx
f0114f81:	89 d0                	mov    %edx,%eax
f0114f83:	89 45 ec             	mov    %eax,-0x14(%ebp)
					ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0114f86:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114f89:	8b 40 10             	mov    0x10(%eax),%eax
f0114f8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
					if (ptr_WS_element == NULL)
f0114f8f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0114f93:	75 0c                	jne    f0114fa1 <sys_check_WS_list+0x203>
						ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0114f95:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114f98:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0114f9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
				else
					ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

				//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

				for (int i = 0; i < actual_WS_list_size; ++i)
f0114fa1:	ff 45 e4             	incl   -0x1c(%ebp)
f0114fa4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114fa7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0114faa:	0f 8c 3b ff ff ff    	jl     f0114eeb <sys_check_WS_list+0x14d>
f0114fb0:	e9 1d 02 00 00       	jmp    f01151d2 <sys_check_WS_list+0x434>
					ptr_WS_element = LIST_NEXT(ptr_WS_element);
					if (ptr_WS_element == NULL)
						ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
				}
			}
			else if (chk_status == 0 || chk_status == 2)
f0114fb5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0114fb9:	74 0a                	je     f0114fc5 <sys_check_WS_list+0x227>
f0114fbb:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0114fbf:	0f 85 21 01 00 00    	jne    f01150e6 <sys_check_WS_list+0x348>
			{
				for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0114fc5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0114fcc:	e9 04 01 00 00       	jmp    f01150d5 <sys_check_WS_list+0x337>
				{
					bool found = 0;
f0114fd1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
					LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0114fd8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114fdb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0114fe1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0114fe4:	eb 75                	jmp    f011505b <sys_check_WS_list+0x2bd>
					{
						if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0114fe6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0114fe9:	8b 00                	mov    (%eax),%eax
f0114feb:	89 45 9c             	mov    %eax,-0x64(%ebp)
f0114fee:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114ff1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0114ff6:	89 c2                	mov    %eax,%edx
f0114ff8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0114ffb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0115002:	8b 45 08             	mov    0x8(%ebp),%eax
f0115005:	01 c8                	add    %ecx,%eax
f0115007:	8b 00                	mov    (%eax),%eax
f0115009:	89 45 98             	mov    %eax,-0x68(%ebp)
f011500c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011500f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115014:	39 c2                	cmp    %eax,%edx
f0115016:	75 37                	jne    f011504f <sys_check_WS_list+0x2b1>
						{
							//if previously found (i.e. duplicated), return false
							if (found)
f0115018:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011501c:	74 2a                	je     f0115048 <sys_check_WS_list+0x2aa>
							{
								cprintf("DUPLICATED ADDRESS IN WS!!! VA = %x\n", ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE));
f011501e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115021:	8b 00                	mov    (%eax),%eax
f0115023:	89 45 94             	mov    %eax,-0x6c(%ebp)
f0115026:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0115029:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011502e:	83 ec 08             	sub    $0x8,%esp
f0115031:	50                   	push   %eax
f0115032:	68 00 ad 13 f0       	push   $0xf013ad00
f0115037:	e8 11 cb fe ff       	call   f0101b4d <cprintf>
f011503c:	83 c4 10             	add    $0x10,%esp
								WS_list_validation = 0;
f011503f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
								break;
f0115046:	eb 4a                	jmp    f0115092 <sys_check_WS_list+0x2f4>
							}
							found = 1;
f0115048:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			else if (chk_status == 0 || chk_status == 2)
			{
				for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
				{
					bool found = 0;
					LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011504f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115052:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0115058:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011505b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011505f:	74 08                	je     f0115069 <sys_check_WS_list+0x2cb>
f0115061:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115064:	8b 40 10             	mov    0x10(%eax),%eax
f0115067:	eb 05                	jmp    f011506e <sys_check_WS_list+0x2d0>
f0115069:	b8 00 00 00 00       	mov    $0x0,%eax
f011506e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115071:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0115077:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011507a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0115080:	85 c0                	test   %eax,%eax
f0115082:	0f 85 5e ff ff ff    	jne    f0114fe6 <sys_check_WS_list+0x248>
f0115088:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011508c:	0f 85 54 ff ff ff    	jne    f0114fe6 <sys_check_WS_list+0x248>
								break;
							}
							found = 1;
						}
					}
					if (!found)
f0115092:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0115096:	75 3a                	jne    f01150d2 <sys_check_WS_list+0x334>
					{
						cprintf("ADDRESS NOT FOUND IN WS!!! VA = %x\n", ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE));
f0115098:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011509b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01150a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01150a5:	01 d0                	add    %edx,%eax
f01150a7:	8b 00                	mov    (%eax),%eax
f01150a9:	89 45 90             	mov    %eax,-0x70(%ebp)
f01150ac:	8b 45 90             	mov    -0x70(%ebp),%eax
f01150af:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01150b4:	83 ec 08             	sub    $0x8,%esp
f01150b7:	50                   	push   %eax
f01150b8:	68 28 ad 13 f0       	push   $0xf013ad28
f01150bd:	e8 8b ca fe ff       	call   f0101b4d <cprintf>
f01150c2:	83 c4 10             	add    $0x10,%esp
						WS_list_validation = 0;
f01150c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
						break;
f01150cc:	90                   	nop
						ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
				}
			}
			else if (chk_status == 0 || chk_status == 2)
			{
				for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01150cd:	e9 00 01 00 00       	jmp    f01151d2 <sys_check_WS_list+0x434>
f01150d2:	ff 45 e0             	incl   -0x20(%ebp)
f01150d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01150d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01150db:	0f 8c f0 fe ff ff    	jl     f0114fd1 <sys_check_WS_list+0x233>
f01150e1:	e9 ec 00 00 00       	jmp    f01151d2 <sys_check_WS_list+0x434>
						break;
					}
				}
			}
			//Check NON-EXITENCE of the Given Addresses
			else if (chk_status == 3)
f01150e6:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f01150ea:	0f 85 e2 00 00 00    	jne    f01151d2 <sys_check_WS_list+0x434>
			{
				for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01150f0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01150f7:	e9 ca 00 00 00       	jmp    f01151c6 <sys_check_WS_list+0x428>
				{
					bool found = 0;
f01150fc:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
					LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0115103:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115106:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011510c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011510f:	eb 47                	jmp    f0115158 <sys_check_WS_list+0x3ba>
					{
						if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0115111:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115114:	8b 00                	mov    (%eax),%eax
f0115116:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0115119:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011511c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115121:	89 c2                	mov    %eax,%edx
f0115123:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0115126:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011512d:	8b 45 08             	mov    0x8(%ebp),%eax
f0115130:	01 c8                	add    %ecx,%eax
f0115132:	8b 00                	mov    (%eax),%eax
f0115134:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0115137:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011513a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011513f:	39 c2                	cmp    %eax,%edx
f0115141:	75 09                	jne    f011514c <sys_check_WS_list+0x3ae>
						{
							found = 1;
f0115143:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
							break;
f011514a:	eb 3b                	jmp    f0115187 <sys_check_WS_list+0x3e9>
			else if (chk_status == 3)
			{
				for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
				{
					bool found = 0;
					LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011514c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011514f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0115155:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0115158:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011515c:	74 08                	je     f0115166 <sys_check_WS_list+0x3c8>
f011515e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115161:	8b 40 10             	mov    0x10(%eax),%eax
f0115164:	eb 05                	jmp    f011516b <sys_check_WS_list+0x3cd>
f0115166:	b8 00 00 00 00       	mov    $0x0,%eax
f011516b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011516e:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0115174:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115177:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011517d:	85 c0                	test   %eax,%eax
f011517f:	75 90                	jne    f0115111 <sys_check_WS_list+0x373>
f0115181:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0115185:	75 8a                	jne    f0115111 <sys_check_WS_list+0x373>
						{
							found = 1;
							break;
						}
					}
					if (found)
f0115187:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011518b:	74 36                	je     f01151c3 <sys_check_WS_list+0x425>
					{
						cprintf("ADDRESS FOUND IN WS WHILE NOT EXPECTED TO!!! VA = %x\n", ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE));
f011518d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0115190:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115197:	8b 45 08             	mov    0x8(%ebp),%eax
f011519a:	01 d0                	add    %edx,%eax
f011519c:	8b 00                	mov    (%eax),%eax
f011519e:	89 45 a0             	mov    %eax,-0x60(%ebp)
f01151a1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01151a4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01151a9:	83 ec 08             	sub    $0x8,%esp
f01151ac:	50                   	push   %eax
f01151ad:	68 4c ad 13 f0       	push   $0xf013ad4c
f01151b2:	e8 96 c9 fe ff       	call   f0101b4d <cprintf>
f01151b7:	83 c4 10             	add    $0x10,%esp
						WS_list_validation = 0;
f01151ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
						break;
f01151c1:	eb 0f                	jmp    f01151d2 <sys_check_WS_list+0x434>
				}
			}
			//Check NON-EXITENCE of the Given Addresses
			else if (chk_status == 3)
			{
				for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01151c3:	ff 45 d8             	incl   -0x28(%ebp)
f01151c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01151c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01151cc:	0f 8c 2a ff ff ff    	jl     f01150fc <sys_check_WS_list+0x35e>
				}
			}
		}
	}
	/*REENABLE THE INTERRUPT */
	popcli(); kclock_resume();
f01151d2:	e8 3d 34 ff ff       	call   f0108614 <popcli>
f01151d7:	e8 71 0b ff ff       	call   f0105d4d <kclock_resume>

	return WS_list_validation;
f01151dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f01151df:	c9                   	leave  
f01151e0:	c3                   	ret    

f01151e1 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01151e1:	55                   	push   %ebp
f01151e2:	89 e5                	mov    %esp,%ebp
f01151e4:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01151e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f01151ee:	8b 15 18 54 96 f1    	mov    0xf1965418,%edx
f01151f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01151f7:	39 c2                	cmp    %eax,%edx
f01151f9:	74 0a                	je     f0115205 <hasExpectedCommands+0x24>
		return 0;
f01151fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0115200:	e9 8b 00 00 00       	jmp    f0115290 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0115205:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f011520a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011520d:	eb 55                	jmp    f0115264 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011520f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115216:	eb 2a                	jmp    f0115242 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0115218:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011521b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115222:	8b 45 08             	mov    0x8(%ebp),%eax
f0115225:	01 d0                	add    %edx,%eax
f0115227:	8b 10                	mov    (%eax),%edx
f0115229:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011522c:	8b 00                	mov    (%eax),%eax
f011522e:	83 ec 08             	sub    $0x8,%esp
f0115231:	52                   	push   %edx
f0115232:	50                   	push   %eax
f0115233:	e8 03 dd 00 00       	call   f0122f3b <strcmp>
f0115238:	83 c4 10             	add    $0x10,%esp
f011523b:	85 c0                	test   %eax,%eax
f011523d:	74 0d                	je     f011524c <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011523f:	ff 45 f0             	incl   -0x10(%ebp)
f0115242:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115245:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0115248:	7c ce                	jl     f0115218 <hasExpectedCommands+0x37>
f011524a:	eb 01                	jmp    f011524d <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f011524c:	90                   	nop
		if (i == commandsCount)
f011524d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115250:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0115253:	75 07                	jne    f011525c <hasExpectedCommands+0x7b>
			return 0;
f0115255:	b8 00 00 00 00       	mov    $0x0,%eax
f011525a:	eb 34                	jmp    f0115290 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f011525c:	a1 14 54 96 f1       	mov    0xf1965414,%eax
f0115261:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0115264:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0115268:	74 08                	je     f0115272 <hasExpectedCommands+0x91>
f011526a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011526d:	8b 40 10             	mov    0x10(%eax),%eax
f0115270:	eb 05                	jmp    f0115277 <hasExpectedCommands+0x96>
f0115272:	b8 00 00 00 00       	mov    $0x0,%eax
f0115277:	a3 14 54 96 f1       	mov    %eax,0xf1965414
f011527c:	a1 14 54 96 f1       	mov    0xf1965414,%eax
f0115281:	85 c0                	test   %eax,%eax
f0115283:	75 8a                	jne    f011520f <hasExpectedCommands+0x2e>
f0115285:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0115289:	75 84                	jne    f011520f <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f011528b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0115290:	c9                   	leave  
f0115291:	c3                   	ret    

f0115292 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0115292:	55                   	push   %ebp
f0115293:	89 e5                	mov    %esp,%ebp
f0115295:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0115298:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011529f:	eb 2e                	jmp    f01152cf <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01152a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01152a4:	89 d0                	mov    %edx,%eax
f01152a6:	01 c0                	add    %eax,%eax
f01152a8:	01 d0                	add    %edx,%eax
f01152aa:	c1 e0 03             	shl    $0x3,%eax
f01152ad:	05 60 75 19 f0       	add    $0xf0197560,%eax
f01152b2:	8b 00                	mov    (%eax),%eax
f01152b4:	83 ec 08             	sub    $0x8,%esp
f01152b7:	ff 75 08             	pushl  0x8(%ebp)
f01152ba:	50                   	push   %eax
f01152bb:	e8 7b dc 00 00       	call   f0122f3b <strcmp>
f01152c0:	83 c4 10             	add    $0x10,%esp
f01152c3:	85 c0                	test   %eax,%eax
f01152c5:	75 05                	jne    f01152cc <getIndexOfCommand+0x3a>
			return i;
f01152c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01152ca:	eb 14                	jmp    f01152e0 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01152cc:	ff 45 f4             	incl   -0xc(%ebp)
f01152cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01152d2:	a1 a8 7b 19 f0       	mov    0xf0197ba8,%eax
f01152d7:	39 c2                	cmp    %eax,%edx
f01152d9:	72 c6                	jb     f01152a1 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01152db:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01152e0:	c9                   	leave  
f01152e1:	c3                   	ret    

f01152e2 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01152e2:	55                   	push   %ebp
f01152e3:	89 e5                	mov    %esp,%ebp
f01152e5:	57                   	push   %edi
f01152e6:	56                   	push   %esi
f01152e7:	53                   	push   %ebx
f01152e8:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f01152ee:	83 ec 0c             	sub    $0xc,%esp
f01152f1:	68 a0 ad 13 f0       	push   $0xf013ada0
f01152f6:	e8 52 c8 fe ff       	call   f0101b4d <cprintf>
f01152fb:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01152fe:	83 ec 0c             	sub    $0xc,%esp
f0115301:	68 c4 ad 13 f0       	push   $0xf013adc4
f0115306:	e8 42 c8 fe ff       	call   f0101b4d <cprintf>
f011530b:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f011530e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0115315:	c7 45 8c df ad 13 f0 	movl   $0xf013addf,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f011531c:	83 ec 08             	sub    $0x8,%esp
f011531f:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0115322:	50                   	push   %eax
f0115323:	6a 01                	push   $0x1
f0115325:	e8 b7 cd fe ff       	call   f01020e1 <process_command>
f011532a:	83 c4 10             	add    $0x10,%esp
f011532d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0115330:	83 ec 0c             	sub    $0xc,%esp
f0115333:	68 ec ad 13 f0       	push   $0xf013adec
f0115338:	e8 10 c8 fe ff       	call   f0101b4d <cprintf>
f011533d:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0115340:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0115343:	83 ec 0c             	sub    $0xc,%esp
f0115346:	50                   	push   %eax
f0115347:	e8 46 ff ff ff       	call   f0115292 <getIndexOfCommand>
f011534c:	83 c4 10             	add    $0x10,%esp
f011534f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0115352:	75 0f                	jne    f0115363 <TestAutoCompleteCommand+0x81>
f0115354:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f0115359:	85 c0                	test   %eax,%eax
f011535b:	75 06                	jne    f0115363 <TestAutoCompleteCommand+0x81>
		eval += 5;
f011535d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0115361:	eb 10                	jmp    f0115373 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0115363:	83 ec 0c             	sub    $0xc,%esp
f0115366:	68 1c ae 13 f0       	push   $0xf013ae1c
f011536b:	e8 dd c7 fe ff       	call   f0101b4d <cprintf>
f0115370:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0115373:	83 ec 0c             	sub    $0xc,%esp
f0115376:	68 6c ae 13 f0       	push   $0xf013ae6c
f011537b:	e8 cd c7 fe ff       	call   f0101b4d <cprintf>
f0115380:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0115383:	c7 45 88 92 ae 13 f0 	movl   $0xf013ae92,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f011538a:	83 ec 08             	sub    $0x8,%esp
f011538d:	8d 45 88             	lea    -0x78(%ebp),%eax
f0115390:	50                   	push   %eax
f0115391:	6a 01                	push   $0x1
f0115393:	e8 49 cd fe ff       	call   f01020e1 <process_command>
f0115398:	83 c4 10             	add    $0x10,%esp
f011539b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f011539e:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01153a2:	75 30                	jne    f01153d4 <TestAutoCompleteCommand+0xf2>
f01153a4:	8d 45 90             	lea    -0x70(%ebp),%eax
f01153a7:	bb ac b2 13 f0       	mov    $0xf013b2ac,%ebx
f01153ac:	ba 03 00 00 00       	mov    $0x3,%edx
f01153b1:	89 c7                	mov    %eax,%edi
f01153b3:	89 de                	mov    %ebx,%esi
f01153b5:	89 d1                	mov    %edx,%ecx
f01153b7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01153b9:	83 ec 08             	sub    $0x8,%esp
f01153bc:	6a 03                	push   $0x3
f01153be:	8d 45 90             	lea    -0x70(%ebp),%eax
f01153c1:	50                   	push   %eax
f01153c2:	e8 1a fe ff ff       	call   f01151e1 <hasExpectedCommands>
f01153c7:	83 c4 10             	add    $0x10,%esp
f01153ca:	85 c0                	test   %eax,%eax
f01153cc:	74 06                	je     f01153d4 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f01153ce:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01153d2:	eb 10                	jmp    f01153e4 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01153d4:	83 ec 0c             	sub    $0xc,%esp
f01153d7:	68 98 ae 13 f0       	push   $0xf013ae98
f01153dc:	e8 6c c7 fe ff       	call   f0101b4d <cprintf>
f01153e1:	83 c4 10             	add    $0x10,%esp

	// CASE3.1: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f01153e4:	83 ec 0c             	sub    $0xc,%esp
f01153e7:	68 e8 ae 13 f0       	push   $0xf013aee8
f01153ec:	e8 5c c7 fe ff       	call   f0101b4d <cprintf>
f01153f1:	83 c4 10             	add    $0x10,%esp
	char *args3_1[] = {"wm"};
f01153f4:	c7 45 84 0d af 13 f0 	movl   $0xf013af0d,-0x7c(%ebp)
	ret = process_command(ARRAY_LENGTH(args3_1), args3_1);
f01153fb:	83 ec 08             	sub    $0x8,%esp
f01153fe:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0115401:	50                   	push   %eax
f0115402:	6a 01                	push   $0x1
f0115404:	e8 d8 cc fe ff       	call   f01020e1 <process_command>
f0115409:	83 c4 10             	add    $0x10,%esp
f011540c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_1, 1))
f011540f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0115413:	75 1b                	jne    f0115430 <TestAutoCompleteCommand+0x14e>
f0115415:	83 ec 08             	sub    $0x8,%esp
f0115418:	6a 01                	push   $0x1
f011541a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011541d:	50                   	push   %eax
f011541e:	e8 be fd ff ff       	call   f01151e1 <hasExpectedCommands>
f0115423:	83 c4 10             	add    $0x10,%esp
f0115426:	85 c0                	test   %eax,%eax
f0115428:	74 06                	je     f0115430 <TestAutoCompleteCommand+0x14e>
		eval += 15;
f011542a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011542e:	eb 10                	jmp    f0115440 <TestAutoCompleteCommand+0x15e>
	else
		cprintf("#3.1: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0115430:	83 ec 0c             	sub    $0xc,%esp
f0115433:	68 10 af 13 f0       	push   $0xf013af10
f0115438:	e8 10 c7 fe ff       	call   f0101b4d <cprintf>
f011543d:	83 c4 10             	add    $0x10,%esp

	// CASE3.2: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: lru\n");
f0115440:	83 ec 0c             	sub    $0xc,%esp
f0115443:	68 6c af 13 f0       	push   $0xf013af6c
f0115448:	e8 00 c7 fe ff       	call   f0101b4d <cprintf>
f011544d:	83 c4 10             	add    $0x10,%esp
	char *args3_2[] = {"lru", "2", "1"};
f0115450:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0115456:	bb c0 b2 13 f0       	mov    $0xf013b2c0,%ebx
f011545b:	ba 03 00 00 00       	mov    $0x3,%edx
f0115460:	89 c7                	mov    %eax,%edi
f0115462:	89 de                	mov    %ebx,%esi
f0115464:	89 d1                	mov    %edx,%ecx
f0115466:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args3_2), args3_2);
f0115468:	83 ec 08             	sub    $0x8,%esp
f011546b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0115471:	50                   	push   %eax
f0115472:	6a 03                	push   $0x3
f0115474:	e8 68 cc fe ff       	call   f01020e1 <process_command>
f0115479:	83 c4 10             	add    $0x10,%esp
f011547c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_2, 1))
f011547f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0115483:	75 1e                	jne    f01154a3 <TestAutoCompleteCommand+0x1c1>
f0115485:	83 ec 08             	sub    $0x8,%esp
f0115488:	6a 01                	push   $0x1
f011548a:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0115490:	50                   	push   %eax
f0115491:	e8 4b fd ff ff       	call   f01151e1 <hasExpectedCommands>
f0115496:	83 c4 10             	add    $0x10,%esp
f0115499:	85 c0                	test   %eax,%eax
f011549b:	74 06                	je     f01154a3 <TestAutoCompleteCommand+0x1c1>
		eval += 15;
f011549d:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01154a1:	eb 10                	jmp    f01154b3 <TestAutoCompleteCommand+0x1d1>
	else
		cprintf("#3.2: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01154a3:	83 ec 0c             	sub    $0xc,%esp
f01154a6:	68 94 af 13 f0       	push   $0xf013af94
f01154ab:	e8 9d c6 fe ff       	call   f0101b4d <cprintf>
f01154b0:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01154b3:	83 ec 0c             	sub    $0xc,%esp
f01154b6:	68 f0 af 13 f0       	push   $0xf013aff0
f01154bb:	e8 8d c6 fe ff       	call   f0101b4d <cprintf>
f01154c0:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01154c3:	c7 85 74 ff ff ff 16 	movl   $0xf013b016,-0x8c(%ebp)
f01154ca:	b0 13 f0 
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01154cd:	83 ec 08             	sub    $0x8,%esp
f01154d0:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01154d6:	50                   	push   %eax
f01154d7:	6a 01                	push   $0x1
f01154d9:	e8 03 cc fe ff       	call   f01020e1 <process_command>
f01154de:	83 c4 10             	add    $0x10,%esp
f01154e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01154e4:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01154e8:	75 0f                	jne    f01154f9 <TestAutoCompleteCommand+0x217>
f01154ea:	a1 18 54 96 f1       	mov    0xf1965418,%eax
f01154ef:	85 c0                	test   %eax,%eax
f01154f1:	75 06                	jne    f01154f9 <TestAutoCompleteCommand+0x217>
		eval += 10;
f01154f3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01154f7:	eb 10                	jmp    f0115509 <TestAutoCompleteCommand+0x227>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01154f9:	83 ec 0c             	sub    $0xc,%esp
f01154fc:	68 1c b0 13 f0       	push   $0xf013b01c
f0115501:	e8 47 c6 fe ff       	call   f0101b4d <cprintf>
f0115506:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that contains he
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0115509:	83 ec 0c             	sub    $0xc,%esp
f011550c:	68 6c b0 13 f0       	push   $0xf013b06c
f0115511:	e8 37 c6 fe ff       	call   f0101b4d <cprintf>
f0115516:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0115519:	c7 85 70 ff ff ff 91 	movl   $0xf013b091,-0x90(%ebp)
f0115520:	b0 13 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0115523:	83 ec 08             	sub    $0x8,%esp
f0115526:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f011552c:	50                   	push   %eax
f011552d:	6a 01                	push   $0x1
f011552f:	e8 ad cb fe ff       	call   f01020e1 <process_command>
f0115534:	83 c4 10             	add    $0x10,%esp
f0115537:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011553a:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011553e:	75 30                	jne    f0115570 <TestAutoCompleteCommand+0x28e>
f0115540:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0115543:	bb 40 b3 13 f0       	mov    $0xf013b340,%ebx
f0115548:	ba 0c 00 00 00       	mov    $0xc,%edx
f011554d:	89 c7                	mov    %eax,%edi
f011554f:	89 de                	mov    %ebx,%esi
f0115551:	89 d1                	mov    %edx,%ecx
f0115553:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0115555:	83 ec 08             	sub    $0x8,%esp
f0115558:	6a 0c                	push   $0xc
f011555a:	8d 45 9c             	lea    -0x64(%ebp),%eax
f011555d:	50                   	push   %eax
f011555e:	e8 7e fc ff ff       	call   f01151e1 <hasExpectedCommands>
f0115563:	83 c4 10             	add    $0x10,%esp
f0115566:	85 c0                	test   %eax,%eax
f0115568:	74 06                	je     f0115570 <TestAutoCompleteCommand+0x28e>
		eval += 15;
f011556a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011556e:	eb 10                	jmp    f0115580 <TestAutoCompleteCommand+0x29e>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0115570:	83 ec 0c             	sub    $0xc,%esp
f0115573:	68 94 b0 13 f0       	push   $0xf013b094
f0115578:	e8 d0 c5 fe ff       	call   f0101b4d <cprintf>
f011557d:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that contains ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0115580:	83 ec 0c             	sub    $0xc,%esp
f0115583:	68 ec b0 13 f0       	push   $0xf013b0ec
f0115588:	e8 c0 c5 fe ff       	call   f0101b4d <cprintf>
f011558d:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0115590:	c7 85 6c ff ff ff 11 	movl   $0xf013b111,-0x94(%ebp)
f0115597:	b1 13 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f011559a:	83 ec 08             	sub    $0x8,%esp
f011559d:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f01155a3:	50                   	push   %eax
f01155a4:	6a 01                	push   $0x1
f01155a6:	e8 36 cb fe ff       	call   f01020e1 <process_command>
f01155ab:	83 c4 10             	add    $0x10,%esp
f01155ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01155b1:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01155b5:	75 30                	jne    f01155e7 <TestAutoCompleteCommand+0x305>
f01155b7:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01155ba:	bb 84 b3 13 f0       	mov    $0xf013b384,%ebx
f01155bf:	ba 05 00 00 00       	mov    $0x5,%edx
f01155c4:	89 c7                	mov    %eax,%edi
f01155c6:	89 de                	mov    %ebx,%esi
f01155c8:	89 d1                	mov    %edx,%ecx
f01155ca:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01155cc:	83 ec 08             	sub    $0x8,%esp
f01155cf:	6a 05                	push   $0x5
f01155d1:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01155d4:	50                   	push   %eax
f01155d5:	e8 07 fc ff ff       	call   f01151e1 <hasExpectedCommands>
f01155da:	83 c4 10             	add    $0x10,%esp
f01155dd:	85 c0                	test   %eax,%eax
f01155df:	74 06                	je     f01155e7 <TestAutoCompleteCommand+0x305>
		eval += 10;
f01155e1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01155e5:	eb 10                	jmp    f01155f7 <TestAutoCompleteCommand+0x315>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01155e7:	83 ec 0c             	sub    $0xc,%esp
f01155ea:	68 14 b1 13 f0       	push   $0xf013b114
f01155ef:	e8 59 c5 fe ff       	call   f0101b4d <cprintf>
f01155f4:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f01155f7:	83 ec 0c             	sub    $0xc,%esp
f01155fa:	68 6c b1 13 f0       	push   $0xf013b16c
f01155ff:	e8 49 c5 fe ff       	call   f0101b4d <cprintf>
f0115604:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0115607:	c7 85 64 ff ff ff 98 	movl   $0xf013b198,-0x9c(%ebp)
f011560e:	b1 13 f0 
f0115611:	c7 85 68 ff ff ff 9d 	movl   $0xf013b19d,-0x98(%ebp)
f0115618:	b1 13 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011561b:	83 ec 08             	sub    $0x8,%esp
f011561e:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0115624:	50                   	push   %eax
f0115625:	6a 02                	push   $0x2
f0115627:	e8 b5 ca fe ff       	call   f01020e1 <process_command>
f011562c:	83 c4 10             	add    $0x10,%esp
f011562f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0115632:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0115638:	83 ec 0c             	sub    $0xc,%esp
f011563b:	50                   	push   %eax
f011563c:	e8 51 fc ff ff       	call   f0115292 <getIndexOfCommand>
f0115641:	83 c4 10             	add    $0x10,%esp
f0115644:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0115647:	75 0f                	jne    f0115658 <TestAutoCompleteCommand+0x376>
f0115649:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f011564e:	85 c0                	test   %eax,%eax
f0115650:	75 06                	jne    f0115658 <TestAutoCompleteCommand+0x376>
		eval += 5;
f0115652:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0115656:	eb 10                	jmp    f0115668 <TestAutoCompleteCommand+0x386>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0115658:	83 ec 0c             	sub    $0xc,%esp
f011565b:	68 a4 b1 13 f0       	push   $0xf013b1a4
f0115660:	e8 e8 c4 fe ff       	call   f0101b4d <cprintf>
f0115665:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0115668:	83 ec 0c             	sub    $0xc,%esp
f011566b:	68 f4 b1 13 f0       	push   $0xf013b1f4
f0115670:	e8 d8 c4 fe ff       	call   f0101b4d <cprintf>
f0115675:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0115678:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f011567e:	bb ac b3 13 f0       	mov    $0xf013b3ac,%ebx
f0115683:	ba 03 00 00 00       	mov    $0x3,%edx
f0115688:	89 c7                	mov    %eax,%edi
f011568a:	89 de                	mov    %ebx,%esi
f011568c:	89 d1                	mov    %edx,%ecx
f011568e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0115690:	83 ec 08             	sub    $0x8,%esp
f0115693:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0115699:	50                   	push   %eax
f011569a:	6a 03                	push   $0x3
f011569c:	e8 40 ca fe ff       	call   f01020e1 <process_command>
f01156a1:	83 c4 10             	add    $0x10,%esp
f01156a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01156a7:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f01156ad:	83 ec 0c             	sub    $0xc,%esp
f01156b0:	50                   	push   %eax
f01156b1:	e8 dc fb ff ff       	call   f0115292 <getIndexOfCommand>
f01156b6:	83 c4 10             	add    $0x10,%esp
f01156b9:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01156bc:	75 0f                	jne    f01156cd <TestAutoCompleteCommand+0x3eb>
f01156be:	a1 0c 54 96 f1       	mov    0xf196540c,%eax
f01156c3:	85 c0                	test   %eax,%eax
f01156c5:	75 06                	jne    f01156cd <TestAutoCompleteCommand+0x3eb>
		eval += 10;
f01156c7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01156cb:	eb 10                	jmp    f01156dd <TestAutoCompleteCommand+0x3fb>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01156cd:	83 ec 0c             	sub    $0xc,%esp
f01156d0:	68 28 b2 13 f0       	push   $0xf013b228
f01156d5:	e8 73 c4 fe ff       	call   f0101b4d <cprintf>
f01156da:	83 c4 10             	add    $0x10,%esp

//	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
//	cprintf("=================\n\n");
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f01156dd:	83 ec 08             	sub    $0x8,%esp
f01156e0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01156e3:	68 77 b2 13 f0       	push   $0xf013b277
f01156e8:	e8 60 c4 fe ff       	call   f0101b4d <cprintf>
f01156ed:	83 c4 10             	add    $0x10,%esp

	return 0;
f01156f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01156f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01156f8:	5b                   	pop    %ebx
f01156f9:	5e                   	pop    %esi
f01156fa:	5f                   	pop    %edi
f01156fb:	5d                   	pop    %ebp
f01156fc:	c3                   	ret    

f01156fd <test_str2lower_function>:

int test_str2lower_function()
{
f01156fd:	55                   	push   %ebp
f01156fe:	89 e5                	mov    %esp,%ebp
f0115700:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0115706:	83 ec 0c             	sub    $0xc,%esp
f0115709:	68 b8 b3 13 f0       	push   $0xf013b3b8
f011570e:	e8 3a c4 fe ff       	call   f0101b4d <cprintf>
f0115713:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0115716:	83 ec 0c             	sub    $0xc,%esp
f0115719:	68 d9 b3 13 f0       	push   $0xf013b3d9
f011571e:	e8 2a c4 fe ff       	call   f0101b4d <cprintf>
f0115723:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0115726:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f011572d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0115734:	c7 45 ec f3 b3 13 f0 	movl   $0xf013b3f3,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f011573b:	83 ec 08             	sub    $0x8,%esp
f011573e:	ff 75 ec             	pushl  -0x14(%ebp)
f0115741:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0115747:	50                   	push   %eax
f0115748:	e8 7a de 00 00       	call   f01235c7 <str2lower>
f011574d:	83 c4 10             	add    $0x10,%esp
f0115750:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0115753:	83 ec 0c             	sub    $0xc,%esp
f0115756:	ff 75 e8             	pushl  -0x18(%ebp)
f0115759:	e8 d1 d6 00 00       	call   f0122e2f <strlen>
f011575e:	83 c4 10             	add    $0x10,%esp
f0115761:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0115764:	83 ec 08             	sub    $0x8,%esp
f0115767:	68 fe b3 13 f0       	push   $0xf013b3fe
f011576c:	ff 75 e8             	pushl  -0x18(%ebp)
f011576f:	e8 c7 d7 00 00       	call   f0122f3b <strcmp>
f0115774:	83 c4 10             	add    $0x10,%esp
f0115777:	85 c0                	test   %eax,%eax
f0115779:	75 13                	jne    f011578e <test_str2lower_function+0x91>
f011577b:	83 ec 0c             	sub    $0xc,%esp
f011577e:	ff 75 ec             	pushl  -0x14(%ebp)
f0115781:	e8 a9 d6 00 00       	call   f0122e2f <strlen>
f0115786:	83 c4 10             	add    $0x10,%esp
f0115789:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011578c:	74 15                	je     f01157a3 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f011578e:	83 ec 08             	sub    $0x8,%esp
f0115791:	ff 75 e8             	pushl  -0x18(%ebp)
f0115794:	68 0c b4 13 f0       	push   $0xf013b40c
f0115799:	e8 af c3 fe ff       	call   f0101b4d <cprintf>
f011579e:	83 c4 10             	add    $0x10,%esp
f01157a1:	eb 04                	jmp    f01157a7 <test_str2lower_function+0xaa>
	else
		eval += 10;
f01157a3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01157a7:	c7 45 e0 6e b4 13 f0 	movl   $0xf013b46e,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f01157ae:	83 ec 08             	sub    $0x8,%esp
f01157b1:	ff 75 e0             	pushl  -0x20(%ebp)
f01157b4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01157ba:	50                   	push   %eax
f01157bb:	e8 07 de 00 00       	call   f01235c7 <str2lower>
f01157c0:	83 c4 10             	add    $0x10,%esp
f01157c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01157c6:	83 ec 0c             	sub    $0xc,%esp
f01157c9:	ff 75 e8             	pushl  -0x18(%ebp)
f01157cc:	e8 5e d6 00 00       	call   f0122e2f <strlen>
f01157d1:	83 c4 10             	add    $0x10,%esp
f01157d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f01157d7:	83 ec 08             	sub    $0x8,%esp
f01157da:	68 6e b4 13 f0       	push   $0xf013b46e
f01157df:	ff 75 e8             	pushl  -0x18(%ebp)
f01157e2:	e8 54 d7 00 00       	call   f0122f3b <strcmp>
f01157e7:	83 c4 10             	add    $0x10,%esp
f01157ea:	85 c0                	test   %eax,%eax
f01157ec:	75 13                	jne    f0115801 <test_str2lower_function+0x104>
f01157ee:	83 ec 0c             	sub    $0xc,%esp
f01157f1:	ff 75 e0             	pushl  -0x20(%ebp)
f01157f4:	e8 36 d6 00 00       	call   f0122e2f <strlen>
f01157f9:	83 c4 10             	add    $0x10,%esp
f01157fc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01157ff:	74 15                	je     f0115816 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0115801:	83 ec 08             	sub    $0x8,%esp
f0115804:	ff 75 e8             	pushl  -0x18(%ebp)
f0115807:	68 70 b4 13 f0       	push   $0xf013b470
f011580c:	e8 3c c3 fe ff       	call   f0101b4d <cprintf>
f0115811:	83 c4 10             	add    $0x10,%esp
f0115814:	eb 04                	jmp    f011581a <test_str2lower_function+0x11d>
	else
		eval += 10;
f0115816:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011581a:	c7 45 dc c8 b4 13 f0 	movl   $0xf013b4c8,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0115821:	83 ec 08             	sub    $0x8,%esp
f0115824:	ff 75 dc             	pushl  -0x24(%ebp)
f0115827:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f011582d:	50                   	push   %eax
f011582e:	e8 94 dd 00 00       	call   f01235c7 <str2lower>
f0115833:	83 c4 10             	add    $0x10,%esp
f0115836:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0115839:	83 ec 0c             	sub    $0xc,%esp
f011583c:	ff 75 e8             	pushl  -0x18(%ebp)
f011583f:	e8 eb d5 00 00       	call   f0122e2f <strlen>
f0115844:	83 c4 10             	add    $0x10,%esp
f0115847:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011584a:	83 ec 08             	sub    $0x8,%esp
f011584d:	68 c8 b4 13 f0       	push   $0xf013b4c8
f0115852:	ff 75 e8             	pushl  -0x18(%ebp)
f0115855:	e8 e1 d6 00 00       	call   f0122f3b <strcmp>
f011585a:	83 c4 10             	add    $0x10,%esp
f011585d:	85 c0                	test   %eax,%eax
f011585f:	75 13                	jne    f0115874 <test_str2lower_function+0x177>
f0115861:	83 ec 0c             	sub    $0xc,%esp
f0115864:	ff 75 dc             	pushl  -0x24(%ebp)
f0115867:	e8 c3 d5 00 00       	call   f0122e2f <strlen>
f011586c:	83 c4 10             	add    $0x10,%esp
f011586f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0115872:	74 15                	je     f0115889 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0115874:	83 ec 08             	sub    $0x8,%esp
f0115877:	ff 75 e8             	pushl  -0x18(%ebp)
f011587a:	68 d4 b4 13 f0       	push   $0xf013b4d4
f011587f:	e8 c9 c2 fe ff       	call   f0101b4d <cprintf>
f0115884:	83 c4 10             	add    $0x10,%esp
f0115887:	eb 04                	jmp    f011588d <test_str2lower_function+0x190>
	else
		eval += 15;
f0115889:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f011588d:	c7 45 d8 37 b5 13 f0 	movl   $0xf013b537,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0115894:	83 ec 08             	sub    $0x8,%esp
f0115897:	ff 75 d8             	pushl  -0x28(%ebp)
f011589a:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01158a0:	50                   	push   %eax
f01158a1:	e8 21 dd 00 00       	call   f01235c7 <str2lower>
f01158a6:	83 c4 10             	add    $0x10,%esp
f01158a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01158ac:	83 ec 0c             	sub    $0xc,%esp
f01158af:	ff 75 e8             	pushl  -0x18(%ebp)
f01158b2:	e8 78 d5 00 00       	call   f0122e2f <strlen>
f01158b7:	83 c4 10             	add    $0x10,%esp
f01158ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f01158bd:	83 ec 08             	sub    $0x8,%esp
f01158c0:	68 37 b5 13 f0       	push   $0xf013b537
f01158c5:	ff 75 e8             	pushl  -0x18(%ebp)
f01158c8:	e8 6e d6 00 00       	call   f0122f3b <strcmp>
f01158cd:	83 c4 10             	add    $0x10,%esp
f01158d0:	85 c0                	test   %eax,%eax
f01158d2:	75 13                	jne    f01158e7 <test_str2lower_function+0x1ea>
f01158d4:	83 ec 0c             	sub    $0xc,%esp
f01158d7:	ff 75 d8             	pushl  -0x28(%ebp)
f01158da:	e8 50 d5 00 00       	call   f0122e2f <strlen>
f01158df:	83 c4 10             	add    $0x10,%esp
f01158e2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01158e5:	74 15                	je     f01158fc <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f01158e7:	83 ec 08             	sub    $0x8,%esp
f01158ea:	ff 75 e8             	pushl  -0x18(%ebp)
f01158ed:	68 44 b5 13 f0       	push   $0xf013b544
f01158f2:	e8 56 c2 fe ff       	call   f0101b4d <cprintf>
f01158f7:	83 c4 10             	add    $0x10,%esp
f01158fa:	eb 04                	jmp    f0115900 <test_str2lower_function+0x203>
	else
		eval += 15;
f01158fc:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0115900:	c7 45 d4 a6 b5 13 f0 	movl   $0xf013b5a6,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0115907:	83 ec 08             	sub    $0x8,%esp
f011590a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011590d:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0115913:	50                   	push   %eax
f0115914:	e8 ae dc 00 00       	call   f01235c7 <str2lower>
f0115919:	83 c4 10             	add    $0x10,%esp
f011591c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011591f:	83 ec 0c             	sub    $0xc,%esp
f0115922:	ff 75 e8             	pushl  -0x18(%ebp)
f0115925:	e8 05 d5 00 00       	call   f0122e2f <strlen>
f011592a:	83 c4 10             	add    $0x10,%esp
f011592d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0115930:	83 ec 08             	sub    $0x8,%esp
f0115933:	68 bc b5 13 f0       	push   $0xf013b5bc
f0115938:	ff 75 e8             	pushl  -0x18(%ebp)
f011593b:	e8 fb d5 00 00       	call   f0122f3b <strcmp>
f0115940:	83 c4 10             	add    $0x10,%esp
f0115943:	85 c0                	test   %eax,%eax
f0115945:	75 13                	jne    f011595a <test_str2lower_function+0x25d>
f0115947:	83 ec 0c             	sub    $0xc,%esp
f011594a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011594d:	e8 dd d4 00 00       	call   f0122e2f <strlen>
f0115952:	83 c4 10             	add    $0x10,%esp
f0115955:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0115958:	74 15                	je     f011596f <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f011595a:	83 ec 08             	sub    $0x8,%esp
f011595d:	ff 75 e8             	pushl  -0x18(%ebp)
f0115960:	68 d4 b5 13 f0       	push   $0xf013b5d4
f0115965:	e8 e3 c1 fe ff       	call   f0101b4d <cprintf>
f011596a:	83 c4 10             	add    $0x10,%esp
f011596d:	eb 04                	jmp    f0115973 <test_str2lower_function+0x276>
	else
		eval += 15;
f011596f:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0115973:	c7 45 d0 41 b6 13 f0 	movl   $0xf013b641,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f011597a:	83 ec 08             	sub    $0x8,%esp
f011597d:	ff 75 d0             	pushl  -0x30(%ebp)
f0115980:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0115986:	50                   	push   %eax
f0115987:	e8 3b dc 00 00       	call   f01235c7 <str2lower>
f011598c:	83 c4 10             	add    $0x10,%esp
f011598f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0115992:	83 ec 0c             	sub    $0xc,%esp
f0115995:	ff 75 e8             	pushl  -0x18(%ebp)
f0115998:	e8 92 d4 00 00       	call   f0122e2f <strlen>
f011599d:	83 c4 10             	add    $0x10,%esp
f01159a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f01159a3:	83 ec 08             	sub    $0x8,%esp
f01159a6:	68 4d b6 13 f0       	push   $0xf013b64d
f01159ab:	ff 75 e8             	pushl  -0x18(%ebp)
f01159ae:	e8 88 d5 00 00       	call   f0122f3b <strcmp>
f01159b3:	83 c4 10             	add    $0x10,%esp
f01159b6:	85 c0                	test   %eax,%eax
f01159b8:	75 13                	jne    f01159cd <test_str2lower_function+0x2d0>
f01159ba:	83 ec 0c             	sub    $0xc,%esp
f01159bd:	ff 75 d0             	pushl  -0x30(%ebp)
f01159c0:	e8 6a d4 00 00       	call   f0122e2f <strlen>
f01159c5:	83 c4 10             	add    $0x10,%esp
f01159c8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01159cb:	74 15                	je     f01159e2 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f01159cd:	83 ec 08             	sub    $0x8,%esp
f01159d0:	ff 75 e8             	pushl  -0x18(%ebp)
f01159d3:	68 5c b6 13 f0       	push   $0xf013b65c
f01159d8:	e8 70 c1 fe ff       	call   f0101b4d <cprintf>
f01159dd:	83 c4 10             	add    $0x10,%esp
f01159e0:	eb 04                	jmp    f01159e6 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f01159e2:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f01159e6:	c7 45 cc bf b6 13 f0 	movl   $0xf013b6bf,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f01159ed:	83 ec 08             	sub    $0x8,%esp
f01159f0:	ff 75 cc             	pushl  -0x34(%ebp)
f01159f3:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f01159f9:	50                   	push   %eax
f01159fa:	e8 c8 db 00 00       	call   f01235c7 <str2lower>
f01159ff:	83 c4 10             	add    $0x10,%esp
f0115a02:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0115a05:	83 ec 0c             	sub    $0xc,%esp
f0115a08:	ff 75 e8             	pushl  -0x18(%ebp)
f0115a0b:	e8 1f d4 00 00       	call   f0122e2f <strlen>
f0115a10:	83 c4 10             	add    $0x10,%esp
f0115a13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0115a16:	83 ec 08             	sub    $0x8,%esp
f0115a19:	68 da b6 13 f0       	push   $0xf013b6da
f0115a1e:	ff 75 e8             	pushl  -0x18(%ebp)
f0115a21:	e8 15 d5 00 00       	call   f0122f3b <strcmp>
f0115a26:	83 c4 10             	add    $0x10,%esp
f0115a29:	85 c0                	test   %eax,%eax
f0115a2b:	75 13                	jne    f0115a40 <test_str2lower_function+0x343>
f0115a2d:	83 ec 0c             	sub    $0xc,%esp
f0115a30:	ff 75 cc             	pushl  -0x34(%ebp)
f0115a33:	e8 f7 d3 00 00       	call   f0122e2f <strlen>
f0115a38:	83 c4 10             	add    $0x10,%esp
f0115a3b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0115a3e:	74 15                	je     f0115a55 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0115a40:	83 ec 08             	sub    $0x8,%esp
f0115a43:	ff 75 e8             	pushl  -0x18(%ebp)
f0115a46:	68 f8 b6 13 f0       	push   $0xf013b6f8
f0115a4b:	e8 fd c0 fe ff       	call   f0101b4d <cprintf>
f0115a50:	83 c4 10             	add    $0x10,%esp
f0115a53:	eb 04                	jmp    f0115a59 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0115a55:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0115a59:	83 ec 08             	sub    $0x8,%esp
f0115a5c:	ff 75 f4             	pushl  -0xc(%ebp)
f0115a5f:	68 6c b7 13 f0       	push   $0xf013b76c
f0115a64:	e8 e4 c0 fe ff       	call   f0101b4d <cprintf>
f0115a69:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0115a6c:	83 ec 0c             	sub    $0xc,%esp
f0115a6f:	68 99 b7 13 f0       	push   $0xf013b799
f0115a74:	e8 d4 c0 fe ff       	call   f0101b4d <cprintf>
f0115a79:	83 c4 10             	add    $0x10,%esp
	return 0;
f0115a7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115a81:	c9                   	leave  
f0115a82:	c3                   	ret    

f0115a83 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0115a83:	55                   	push   %ebp
f0115a84:	89 e5                	mov    %esp,%ebp
f0115a86:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0115a89:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0115a90:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0115a97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115a9e:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115aa3:	ff 75 ec             	pushl  -0x14(%ebp)
f0115aa6:	ff 75 f0             	pushl  -0x10(%ebp)
f0115aa9:	ff 75 f4             	pushl  -0xc(%ebp)
f0115aac:	50                   	push   %eax
f0115aad:	e8 aa 5a ff ff       	call   f010b55c <pt_set_page_permissions>
f0115ab2:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115ab5:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115aba:	ff 75 ec             	pushl  -0x14(%ebp)
f0115abd:	ff 75 f0             	pushl  -0x10(%ebp)
f0115ac0:	ff 75 f4             	pushl  -0xc(%ebp)
f0115ac3:	50                   	push   %eax
f0115ac4:	e8 02 4f 00 00       	call   f011a9cb <CP>
f0115ac9:	83 c4 10             	add    $0x10,%esp
f0115acc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0115acf:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0115ad3:	74 17                	je     f0115aec <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0115ad5:	83 ec 04             	sub    $0x4,%esp
f0115ad8:	68 b0 b7 13 f0       	push   $0xf013b7b0
f0115add:	68 2c 01 00 00       	push   $0x12c
f0115ae2:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115ae7:	e8 c3 b3 fe ff       	call   f0100eaf <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0115aec:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0115af3:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0115afa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115b01:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115b06:	ff 75 ec             	pushl  -0x14(%ebp)
f0115b09:	ff 75 f0             	pushl  -0x10(%ebp)
f0115b0c:	ff 75 f4             	pushl  -0xc(%ebp)
f0115b0f:	50                   	push   %eax
f0115b10:	e8 47 5a ff ff       	call   f010b55c <pt_set_page_permissions>
f0115b15:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115b18:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115b1d:	ff 75 ec             	pushl  -0x14(%ebp)
f0115b20:	ff 75 f0             	pushl  -0x10(%ebp)
f0115b23:	ff 75 f4             	pushl  -0xc(%ebp)
f0115b26:	50                   	push   %eax
f0115b27:	e8 9f 4e 00 00       	call   f011a9cb <CP>
f0115b2c:	83 c4 10             	add    $0x10,%esp
f0115b2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0115b32:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0115b36:	74 17                	je     f0115b4f <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0115b38:	83 ec 04             	sub    $0x4,%esp
f0115b3b:	68 f0 b7 13 f0       	push   $0xf013b7f0
f0115b40:	68 38 01 00 00       	push   $0x138
f0115b45:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115b4a:	e8 60 b3 fe ff       	call   f0100eaf <_panic>
	}

	va = 0xEF800000;
f0115b4f:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0115b56:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0115b5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115b64:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115b69:	ff 75 ec             	pushl  -0x14(%ebp)
f0115b6c:	ff 75 f0             	pushl  -0x10(%ebp)
f0115b6f:	ff 75 f4             	pushl  -0xc(%ebp)
f0115b72:	50                   	push   %eax
f0115b73:	e8 e4 59 ff ff       	call   f010b55c <pt_set_page_permissions>
f0115b78:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115b7b:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115b80:	ff 75 ec             	pushl  -0x14(%ebp)
f0115b83:	ff 75 f0             	pushl  -0x10(%ebp)
f0115b86:	ff 75 f4             	pushl  -0xc(%ebp)
f0115b89:	50                   	push   %eax
f0115b8a:	e8 3c 4e 00 00       	call   f011a9cb <CP>
f0115b8f:	83 c4 10             	add    $0x10,%esp
f0115b92:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0115b95:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0115b99:	74 17                	je     f0115bb2 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0115b9b:	83 ec 04             	sub    $0x4,%esp
f0115b9e:	68 14 b8 13 f0       	push   $0xf013b814
f0115ba3:	68 43 01 00 00       	push   $0x143
f0115ba8:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115bad:	e8 fd b2 fe ff       	call   f0100eaf <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0115bb2:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0115bb9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0115bc0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115bc7:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115bcc:	ff 75 ec             	pushl  -0x14(%ebp)
f0115bcf:	ff 75 f0             	pushl  -0x10(%ebp)
f0115bd2:	ff 75 f4             	pushl  -0xc(%ebp)
f0115bd5:	50                   	push   %eax
f0115bd6:	e8 81 59 ff ff       	call   f010b55c <pt_set_page_permissions>
f0115bdb:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115bde:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115be3:	ff 75 ec             	pushl  -0x14(%ebp)
f0115be6:	ff 75 f0             	pushl  -0x10(%ebp)
f0115be9:	ff 75 f4             	pushl  -0xc(%ebp)
f0115bec:	50                   	push   %eax
f0115bed:	e8 d9 4d 00 00       	call   f011a9cb <CP>
f0115bf2:	83 c4 10             	add    $0x10,%esp
f0115bf5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0115bf8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0115bfc:	74 17                	je     f0115c15 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0115bfe:	83 ec 04             	sub    $0x4,%esp
f0115c01:	68 38 b8 13 f0       	push   $0xf013b838
f0115c06:	68 4f 01 00 00       	push   $0x14f
f0115c0b:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115c10:	e8 9a b2 fe ff       	call   f0100eaf <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0115c15:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0115c1c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0115c23:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115c2a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115c2f:	ff 75 ec             	pushl  -0x14(%ebp)
f0115c32:	ff 75 f0             	pushl  -0x10(%ebp)
f0115c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0115c38:	50                   	push   %eax
f0115c39:	e8 1e 59 ff ff       	call   f010b55c <pt_set_page_permissions>
f0115c3e:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115c41:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115c46:	ff 75 ec             	pushl  -0x14(%ebp)
f0115c49:	ff 75 f0             	pushl  -0x10(%ebp)
f0115c4c:	ff 75 f4             	pushl  -0xc(%ebp)
f0115c4f:	50                   	push   %eax
f0115c50:	e8 76 4d 00 00       	call   f011a9cb <CP>
f0115c55:	83 c4 10             	add    $0x10,%esp
f0115c58:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0115c5b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0115c5f:	74 17                	je     f0115c78 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0115c61:	83 ec 04             	sub    $0x4,%esp
f0115c64:	68 5c b8 13 f0       	push   $0xf013b85c
f0115c69:	68 5b 01 00 00       	push   $0x15b
f0115c6e:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115c73:	e8 37 b2 fe ff       	call   f0100eaf <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0115c78:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0115c7f:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0115c86:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115c8d:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115c92:	ff 75 ec             	pushl  -0x14(%ebp)
f0115c95:	ff 75 f0             	pushl  -0x10(%ebp)
f0115c98:	ff 75 f4             	pushl  -0xc(%ebp)
f0115c9b:	50                   	push   %eax
f0115c9c:	e8 bb 58 ff ff       	call   f010b55c <pt_set_page_permissions>
f0115ca1:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115ca4:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115ca9:	ff 75 ec             	pushl  -0x14(%ebp)
f0115cac:	ff 75 f0             	pushl  -0x10(%ebp)
f0115caf:	ff 75 f4             	pushl  -0xc(%ebp)
f0115cb2:	50                   	push   %eax
f0115cb3:	e8 13 4d 00 00       	call   f011a9cb <CP>
f0115cb8:	83 c4 10             	add    $0x10,%esp
f0115cbb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0115cbe:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0115cc2:	74 17                	je     f0115cdb <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0115cc4:	83 ec 04             	sub    $0x4,%esp
f0115cc7:	68 80 b8 13 f0       	push   $0xf013b880
f0115ccc:	68 67 01 00 00       	push   $0x167
f0115cd1:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115cd6:	e8 d4 b1 fe ff       	call   f0100eaf <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0115cdb:	83 ec 0c             	sub    $0xc,%esp
f0115cde:	68 ac b8 13 f0       	push   $0xf013b8ac
f0115ce3:	e8 65 be fe ff       	call   f0101b4d <cprintf>
f0115ce8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0115ceb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115cf0:	c9                   	leave  
f0115cf1:	c3                   	ret    

f0115cf2 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0115cf2:	55                   	push   %ebp
f0115cf3:	89 e5                	mov    %esp,%ebp
f0115cf5:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0115cf8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0115cff:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0115d06:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0115d0d:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115d12:	ff 75 ec             	pushl  -0x14(%ebp)
f0115d15:	ff 75 f0             	pushl  -0x10(%ebp)
f0115d18:	ff 75 f4             	pushl  -0xc(%ebp)
f0115d1b:	50                   	push   %eax
f0115d1c:	e8 3b 58 ff ff       	call   f010b55c <pt_set_page_permissions>
f0115d21:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0115d24:	83 ec 04             	sub    $0x4,%esp
f0115d27:	68 fc b8 13 f0       	push   $0xf013b8fc
f0115d2c:	68 74 01 00 00       	push   $0x174
f0115d31:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115d36:	e8 74 b1 fe ff       	call   f0100eaf <_panic>

f0115d3b <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0115d3b:	55                   	push   %ebp
f0115d3c:	89 e5                	mov    %esp,%ebp
f0115d3e:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0115d41:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0115d48:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115d4d:	83 ec 08             	sub    $0x8,%esp
f0115d50:	ff 75 f4             	pushl  -0xc(%ebp)
f0115d53:	50                   	push   %eax
f0115d54:	e8 c8 58 ff ff       	call   f010b621 <pt_get_page_permissions>
f0115d59:	83 c4 10             	add    $0x10,%esp
f0115d5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0115d5f:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0115d63:	74 17                	je     f0115d7c <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0115d65:	83 ec 04             	sub    $0x4,%esp
f0115d68:	68 98 b9 13 f0       	push   $0xf013b998
f0115d6d:	68 82 01 00 00       	push   $0x182
f0115d72:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115d77:	e8 33 b1 fe ff       	call   f0100eaf <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0115d7c:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0115d83:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115d88:	83 ec 08             	sub    $0x8,%esp
f0115d8b:	ff 75 f4             	pushl  -0xc(%ebp)
f0115d8e:	50                   	push   %eax
f0115d8f:	e8 8d 58 ff ff       	call   f010b621 <pt_get_page_permissions>
f0115d94:	83 c4 10             	add    $0x10,%esp
f0115d97:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0115d9a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0115d9e:	74 17                	je     f0115db7 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0115da0:	83 ec 04             	sub    $0x4,%esp
f0115da3:	68 bc b9 13 f0       	push   $0xf013b9bc
f0115da8:	68 8a 01 00 00       	push   $0x18a
f0115dad:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115db2:	e8 f8 b0 fe ff       	call   f0100eaf <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0115db7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0115dbe:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115dc3:	83 ec 08             	sub    $0x8,%esp
f0115dc6:	ff 75 f4             	pushl  -0xc(%ebp)
f0115dc9:	50                   	push   %eax
f0115dca:	e8 52 58 ff ff       	call   f010b621 <pt_get_page_permissions>
f0115dcf:	83 c4 10             	add    $0x10,%esp
f0115dd2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0115dd5:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0115dd9:	74 17                	je     f0115df2 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0115ddb:	83 ec 04             	sub    $0x4,%esp
f0115dde:	68 e0 b9 13 f0       	push   $0xf013b9e0
f0115de3:	68 92 01 00 00       	push   $0x192
f0115de8:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115ded:	e8 bd b0 fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF1000000;
f0115df2:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0115df9:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115dfe:	83 ec 08             	sub    $0x8,%esp
f0115e01:	ff 75 f4             	pushl  -0xc(%ebp)
f0115e04:	50                   	push   %eax
f0115e05:	e8 17 58 ff ff       	call   f010b621 <pt_get_page_permissions>
f0115e0a:	83 c4 10             	add    $0x10,%esp
f0115e0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0115e10:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0115e14:	74 17                	je     f0115e2d <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0115e16:	83 ec 04             	sub    $0x4,%esp
f0115e19:	68 04 ba 13 f0       	push   $0xf013ba04
f0115e1e:	68 99 01 00 00       	push   $0x199
f0115e23:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115e28:	e8 82 b0 fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0001000;
f0115e2d:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0115e34:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115e39:	83 ec 08             	sub    $0x8,%esp
f0115e3c:	ff 75 f4             	pushl  -0xc(%ebp)
f0115e3f:	50                   	push   %eax
f0115e40:	e8 dc 57 ff ff       	call   f010b621 <pt_get_page_permissions>
f0115e45:	83 c4 10             	add    $0x10,%esp
f0115e48:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0115e4b:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0115e4f:	74 17                	je     f0115e68 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0115e51:	83 ec 04             	sub    $0x4,%esp
f0115e54:	68 28 ba 13 f0       	push   $0xf013ba28
f0115e59:	68 a0 01 00 00       	push   $0x1a0
f0115e5e:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115e63:	e8 47 b0 fe ff       	call   f0100eaf <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0115e68:	83 ec 0c             	sub    $0xc,%esp
f0115e6b:	68 4c ba 13 f0       	push   $0xf013ba4c
f0115e70:	e8 d8 bc fe ff       	call   f0101b4d <cprintf>
f0115e75:	83 c4 10             	add    $0x10,%esp
	return 0;
f0115e78:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115e7d:	c9                   	leave  
f0115e7e:	c3                   	ret    

f0115e7f <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0115e7f:	55                   	push   %ebp
f0115e80:	89 e5                	mov    %esp,%ebp
f0115e82:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0115e85:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0115e8c:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115e91:	83 ec 08             	sub    $0x8,%esp
f0115e94:	ff 75 f4             	pushl  -0xc(%ebp)
f0115e97:	50                   	push   %eax
f0115e98:	e8 cd 57 ff ff       	call   f010b66a <pt_clear_page_table_entry>
f0115e9d:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0115ea0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115ea5:	83 ec 08             	sub    $0x8,%esp
f0115ea8:	ff 75 f4             	pushl  -0xc(%ebp)
f0115eab:	50                   	push   %eax
f0115eac:	e8 76 4a 00 00       	call   f011a927 <CE>
f0115eb1:	83 c4 10             	add    $0x10,%esp
f0115eb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0115eb7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0115ebb:	74 17                	je     f0115ed4 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0115ebd:	83 ec 04             	sub    $0x4,%esp
f0115ec0:	68 94 ba 13 f0       	push   $0xf013ba94
f0115ec5:	68 b0 01 00 00       	push   $0x1b0
f0115eca:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115ecf:	e8 db af fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0001000;
f0115ed4:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0115edb:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115ee0:	83 ec 08             	sub    $0x8,%esp
f0115ee3:	ff 75 f4             	pushl  -0xc(%ebp)
f0115ee6:	50                   	push   %eax
f0115ee7:	e8 7e 57 ff ff       	call   f010b66a <pt_clear_page_table_entry>
f0115eec:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0115eef:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115ef4:	83 ec 08             	sub    $0x8,%esp
f0115ef7:	ff 75 f4             	pushl  -0xc(%ebp)
f0115efa:	50                   	push   %eax
f0115efb:	e8 27 4a 00 00       	call   f011a927 <CE>
f0115f00:	83 c4 10             	add    $0x10,%esp
f0115f03:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0115f06:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0115f0a:	74 17                	je     f0115f23 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0115f0c:	83 ec 04             	sub    $0x4,%esp
f0115f0f:	68 c0 ba 13 f0       	push   $0xf013bac0
f0115f14:	68 b8 01 00 00       	push   $0x1b8
f0115f19:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115f1e:	e8 8c af fe ff       	call   f0100eaf <_panic>
	}

	va = 0xEF800000;
f0115f23:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0115f2a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115f2f:	83 ec 08             	sub    $0x8,%esp
f0115f32:	ff 75 f4             	pushl  -0xc(%ebp)
f0115f35:	50                   	push   %eax
f0115f36:	e8 2f 57 ff ff       	call   f010b66a <pt_clear_page_table_entry>
f0115f3b:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0115f3e:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115f43:	83 ec 08             	sub    $0x8,%esp
f0115f46:	ff 75 f4             	pushl  -0xc(%ebp)
f0115f49:	50                   	push   %eax
f0115f4a:	e8 d8 49 00 00       	call   f011a927 <CE>
f0115f4f:	83 c4 10             	add    $0x10,%esp
f0115f52:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0115f55:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0115f59:	74 17                	je     f0115f72 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0115f5b:	83 ec 04             	sub    $0x4,%esp
f0115f5e:	68 ec ba 13 f0       	push   $0xf013baec
f0115f63:	68 c0 01 00 00       	push   $0x1c0
f0115f68:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115f6d:	e8 3d af fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0000000;
f0115f72:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0115f79:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115f7e:	83 ec 08             	sub    $0x8,%esp
f0115f81:	ff 75 f4             	pushl  -0xc(%ebp)
f0115f84:	50                   	push   %eax
f0115f85:	e8 e0 56 ff ff       	call   f010b66a <pt_clear_page_table_entry>
f0115f8a:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0115f8d:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115f92:	83 ec 08             	sub    $0x8,%esp
f0115f95:	ff 75 f4             	pushl  -0xc(%ebp)
f0115f98:	50                   	push   %eax
f0115f99:	e8 89 49 00 00       	call   f011a927 <CE>
f0115f9e:	83 c4 10             	add    $0x10,%esp
f0115fa1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0115fa4:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0115fa8:	74 17                	je     f0115fc1 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0115faa:	83 ec 04             	sub    $0x4,%esp
f0115fad:	68 18 bb 13 f0       	push   $0xf013bb18
f0115fb2:	68 c8 01 00 00       	push   $0x1c8
f0115fb7:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0115fbc:	e8 ee ae fe ff       	call   f0100eaf <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0115fc1:	83 ec 0c             	sub    $0xc,%esp
f0115fc4:	68 44 bb 13 f0       	push   $0xf013bb44
f0115fc9:	e8 7f bb fe ff       	call   f0101b4d <cprintf>
f0115fce:	83 c4 10             	add    $0x10,%esp
	return 0;
f0115fd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115fd6:	c9                   	leave  
f0115fd7:	c3                   	ret    

f0115fd8 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0115fd8:	55                   	push   %ebp
f0115fd9:	89 e5                	mov    %esp,%ebp
f0115fdb:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0115fde:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0115fe5:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0115fea:	83 ec 08             	sub    $0x8,%esp
f0115fed:	ff 75 f4             	pushl  -0xc(%ebp)
f0115ff0:	50                   	push   %eax
f0115ff1:	e8 74 56 ff ff       	call   f010b66a <pt_clear_page_table_entry>
f0115ff6:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0115ff9:	83 ec 04             	sub    $0x4,%esp
f0115ffc:	68 90 bb 13 f0       	push   $0xf013bb90
f0116001:	68 d3 01 00 00       	push   $0x1d3
f0116006:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011600b:	e8 9f ae fe ff       	call   f0100eaf <_panic>

f0116010 <test_virtual_to_physical>:

//=====================================
// 4) TEST CONVERTING VA 2 PA:
//=====================================
int test_virtual_to_physical()
{
f0116010:	55                   	push   %ebp
f0116011:	89 e5                	mov    %esp,%ebp
f0116013:	57                   	push   %edi
f0116014:	56                   	push   %esi
f0116015:	53                   	push   %ebx
f0116016:	81 ec ac 01 00 00    	sub    $0x1ac,%esp
	int kilo = 1024 ;
f011601c:	c7 45 e4 00 04 00 00 	movl   $0x400,-0x1c(%ebp)
	int mega = 1024*1024 ;
f0116023:	c7 45 e0 00 00 10 00 	movl   $0x100000,-0x20(%ebp)
	uint32 va;
	ClearUserSpace(ptr_page_directory);
f011602a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011602f:	83 ec 0c             	sub    $0xc,%esp
f0116032:	50                   	push   %eax
f0116033:	e8 d1 49 00 00       	call   f011aa09 <ClearUserSpace>
f0116038:	83 c4 10             	add    $0x10,%esp

	//============================
	//Case 1: Check getting pa of a va with NO table
	va = 0xeebfe000;
f011603b:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	int pa = virtual_to_physical(ptr_page_directory, va);
f0116042:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116047:	83 ec 08             	sub    $0x8,%esp
f011604a:	ff 75 dc             	pushl  -0x24(%ebp)
f011604d:	50                   	push   %eax
f011604e:	e8 31 56 ff ff       	call   f010b684 <virtual_to_physical>
f0116053:	83 c4 10             	add    $0x10,%esp
f0116056:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %d\n", va, CA(ptr_page_directory, va), pa);
	if(pa != -1)
f0116059:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
f011605d:	74 17                	je     f0116076 <test_virtual_to_physical+0x66>
		panic("[EVAL] #1 Test of virtual_to_physical Entry Failed.\n");
f011605f:	83 ec 04             	sub    $0x4,%esp
f0116062:	68 28 bc 13 f0       	push   $0xf013bc28
f0116067:	68 e8 01 00 00       	push   $0x1e8
f011606c:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116071:	e8 39 ae fe ff       	call   f0100eaf <_panic>

	//============================
	//Case 2: Check getting pa of a va with a table
	va = 0xf0000000;
f0116076:	c7 45 dc 00 00 00 f0 	movl   $0xf0000000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011607d:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116082:	83 ec 08             	sub    $0x8,%esp
f0116085:	ff 75 dc             	pushl  -0x24(%ebp)
f0116088:	50                   	push   %eax
f0116089:	e8 f6 55 ff ff       	call   f010b684 <virtual_to_physical>
f011608e:	83 c4 10             	add    $0x10,%esp
f0116091:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0116094:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116099:	83 ec 08             	sub    $0x8,%esp
f011609c:	ff 75 dc             	pushl  -0x24(%ebp)
f011609f:	50                   	push   %eax
f01160a0:	e8 63 48 00 00       	call   f011a908 <CA>
f01160a5:	83 c4 10             	add    $0x10,%esp
f01160a8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01160ab:	74 17                	je     f01160c4 <test_virtual_to_physical+0xb4>
		panic("[EVAL] #2 Test of virtual_to_physical Entry Failed.\n");
f01160ad:	83 ec 04             	sub    $0x4,%esp
f01160b0:	68 60 bc 13 f0       	push   $0xf013bc60
f01160b5:	68 f1 01 00 00       	push   $0x1f1
f01160ba:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01160bf:	e8 eb ad fe ff       	call   f0100eaf <_panic>

	//============================
	char ap1[100] = "ap 0x2800000";execute_command(ap1);
f01160c4:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01160ca:	bb 2c be 13 f0       	mov    $0xf013be2c,%ebx
f01160cf:	ba 0d 00 00 00       	mov    $0xd,%edx
f01160d4:	89 c7                	mov    %eax,%edi
f01160d6:	89 de                	mov    %ebx,%esi
f01160d8:	89 d1                	mov    %edx,%ecx
f01160da:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01160dc:	8d 55 81             	lea    -0x7f(%ebp),%edx
f01160df:	b9 57 00 00 00       	mov    $0x57,%ecx
f01160e4:	b0 00                	mov    $0x0,%al
f01160e6:	89 d7                	mov    %edx,%edi
f01160e8:	f3 aa                	rep stos %al,%es:(%edi)
f01160ea:	83 ec 0c             	sub    $0xc,%esp
f01160ed:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01160f3:	50                   	push   %eax
f01160f4:	e8 13 bd fe ff       	call   f0101e0c <execute_command>
f01160f9:	83 c4 10             	add    $0x10,%esp
	va = 0x2800000;
f01160fc:	c7 45 dc 00 00 80 02 	movl   $0x2800000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0116103:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116108:	83 ec 08             	sub    $0x8,%esp
f011610b:	ff 75 dc             	pushl  -0x24(%ebp)
f011610e:	50                   	push   %eax
f011610f:	e8 70 55 ff ff       	call   f010b684 <virtual_to_physical>
f0116114:	83 c4 10             	add    $0x10,%esp
f0116117:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f011611a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011611f:	83 ec 08             	sub    $0x8,%esp
f0116122:	ff 75 dc             	pushl  -0x24(%ebp)
f0116125:	50                   	push   %eax
f0116126:	e8 dd 47 00 00       	call   f011a908 <CA>
f011612b:	83 c4 10             	add    $0x10,%esp
f011612e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0116131:	74 17                	je     f011614a <test_virtual_to_physical+0x13a>
		panic("[EVAL] #3 Test of virtual_to_physical Entry Failed.\n");
f0116133:	83 ec 04             	sub    $0x4,%esp
f0116136:	68 98 bc 13 f0       	push   $0xf013bc98
f011613b:	68 fa 01 00 00       	push   $0x1fa
f0116140:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116145:	e8 65 ad fe ff       	call   f0100eaf <_panic>

	//============================
	char ap2[100] = "ap 0x2801000";execute_command(ap2);
f011614a:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f0116150:	bb 90 be 13 f0       	mov    $0xf013be90,%ebx
f0116155:	ba 0d 00 00 00       	mov    $0xd,%edx
f011615a:	89 c7                	mov    %eax,%edi
f011615c:	89 de                	mov    %ebx,%esi
f011615e:	89 d1                	mov    %edx,%ecx
f0116160:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116162:	8d 95 1d ff ff ff    	lea    -0xe3(%ebp),%edx
f0116168:	b9 57 00 00 00       	mov    $0x57,%ecx
f011616d:	b0 00                	mov    $0x0,%al
f011616f:	89 d7                	mov    %edx,%edi
f0116171:	f3 aa                	rep stos %al,%es:(%edi)
f0116173:	83 ec 0c             	sub    $0xc,%esp
f0116176:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f011617c:	50                   	push   %eax
f011617d:	e8 8a bc fe ff       	call   f0101e0c <execute_command>
f0116182:	83 c4 10             	add    $0x10,%esp
	va = 0x2801000;
f0116185:	c7 45 dc 00 10 80 02 	movl   $0x2801000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011618c:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116191:	83 ec 08             	sub    $0x8,%esp
f0116194:	ff 75 dc             	pushl  -0x24(%ebp)
f0116197:	50                   	push   %eax
f0116198:	e8 e7 54 ff ff       	call   f010b684 <virtual_to_physical>
f011619d:	83 c4 10             	add    $0x10,%esp
f01161a0:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01161a3:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01161a8:	83 ec 08             	sub    $0x8,%esp
f01161ab:	ff 75 dc             	pushl  -0x24(%ebp)
f01161ae:	50                   	push   %eax
f01161af:	e8 54 47 00 00       	call   f011a908 <CA>
f01161b4:	83 c4 10             	add    $0x10,%esp
f01161b7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01161ba:	74 17                	je     f01161d3 <test_virtual_to_physical+0x1c3>
		panic("[EVAL] #4 Test of virtual_to_physical Entry Failed.\n");
f01161bc:	83 ec 04             	sub    $0x4,%esp
f01161bf:	68 d0 bc 13 f0       	push   $0xf013bcd0
f01161c4:	68 03 02 00 00       	push   $0x203
f01161c9:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01161ce:	e8 dc ac fe ff       	call   f0100eaf <_panic>

	//============================
	char ap3[100] = "ap 0x2802000";execute_command(ap3);
f01161d3:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f01161d9:	bb f4 be 13 f0       	mov    $0xf013bef4,%ebx
f01161de:	ba 0d 00 00 00       	mov    $0xd,%edx
f01161e3:	89 c7                	mov    %eax,%edi
f01161e5:	89 de                	mov    %ebx,%esi
f01161e7:	89 d1                	mov    %edx,%ecx
f01161e9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01161eb:	8d 95 b9 fe ff ff    	lea    -0x147(%ebp),%edx
f01161f1:	b9 57 00 00 00       	mov    $0x57,%ecx
f01161f6:	b0 00                	mov    $0x0,%al
f01161f8:	89 d7                	mov    %edx,%edi
f01161fa:	f3 aa                	rep stos %al,%es:(%edi)
f01161fc:	83 ec 0c             	sub    $0xc,%esp
f01161ff:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f0116205:	50                   	push   %eax
f0116206:	e8 01 bc fe ff       	call   f0101e0c <execute_command>
f011620b:	83 c4 10             	add    $0x10,%esp
	va = 0x2802000;
f011620e:	c7 45 dc 00 20 80 02 	movl   $0x2802000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0116215:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011621a:	83 ec 08             	sub    $0x8,%esp
f011621d:	ff 75 dc             	pushl  -0x24(%ebp)
f0116220:	50                   	push   %eax
f0116221:	e8 5e 54 ff ff       	call   f010b684 <virtual_to_physical>
f0116226:	83 c4 10             	add    $0x10,%esp
f0116229:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f011622c:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116231:	83 ec 08             	sub    $0x8,%esp
f0116234:	ff 75 dc             	pushl  -0x24(%ebp)
f0116237:	50                   	push   %eax
f0116238:	e8 cb 46 00 00       	call   f011a908 <CA>
f011623d:	83 c4 10             	add    $0x10,%esp
f0116240:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0116243:	74 17                	je     f011625c <test_virtual_to_physical+0x24c>
		panic("[EVAL] #5 Test of virtual_to_physical Entry Failed.\n");
f0116245:	83 ec 04             	sub    $0x4,%esp
f0116248:	68 08 bd 13 f0       	push   $0xf013bd08
f011624d:	68 0c 02 00 00       	push   $0x20c
f0116252:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116257:	e8 53 ac fe ff       	call   f0100eaf <_panic>

	//============================
	va = 0xF0001000;
f011625c:	c7 45 dc 00 10 00 f0 	movl   $0xf0001000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0116263:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116268:	83 ec 08             	sub    $0x8,%esp
f011626b:	ff 75 dc             	pushl  -0x24(%ebp)
f011626e:	50                   	push   %eax
f011626f:	e8 10 54 ff ff       	call   f010b684 <virtual_to_physical>
f0116274:	83 c4 10             	add    $0x10,%esp
f0116277:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f011627a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011627f:	83 ec 08             	sub    $0x8,%esp
f0116282:	ff 75 dc             	pushl  -0x24(%ebp)
f0116285:	50                   	push   %eax
f0116286:	e8 7d 46 00 00       	call   f011a908 <CA>
f011628b:	83 c4 10             	add    $0x10,%esp
f011628e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0116291:	74 17                	je     f01162aa <test_virtual_to_physical+0x29a>
		panic("[EVAL] #6 Test of virtual_to_physical Entry Failed.\n");
f0116293:	83 ec 04             	sub    $0x4,%esp
f0116296:	68 40 bd 13 f0       	push   $0xf013bd40
f011629b:	68 14 02 00 00       	push   $0x214
f01162a0:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01162a5:	e8 05 ac fe ff       	call   f0100eaf <_panic>

	//============================
	va = 0xF0001005;
f01162aa:	c7 45 dc 05 10 00 f0 	movl   $0xf0001005,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01162b1:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01162b6:	83 ec 08             	sub    $0x8,%esp
f01162b9:	ff 75 dc             	pushl  -0x24(%ebp)
f01162bc:	50                   	push   %eax
f01162bd:	e8 c2 53 ff ff       	call   f010b684 <virtual_to_physical>
f01162c2:	83 c4 10             	add    $0x10,%esp
f01162c5:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01162c8:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01162cd:	83 ec 08             	sub    $0x8,%esp
f01162d0:	ff 75 dc             	pushl  -0x24(%ebp)
f01162d3:	50                   	push   %eax
f01162d4:	e8 2f 46 00 00       	call   f011a908 <CA>
f01162d9:	83 c4 10             	add    $0x10,%esp
f01162dc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01162df:	74 17                	je     f01162f8 <test_virtual_to_physical+0x2e8>
		panic("[EVAL] #7 Test of virtual_to_physical Entry Failed.\n");
f01162e1:	83 ec 04             	sub    $0x4,%esp
f01162e4:	68 78 bd 13 f0       	push   $0xf013bd78
f01162e9:	68 1c 02 00 00       	push   $0x21c
f01162ee:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01162f3:	e8 b7 ab fe ff       	call   f0100eaf <_panic>

	//============================
	char ap4[100] = "ap 0xeebfe000";execute_command(ap4);
f01162f8:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f01162fe:	bb 58 bf 13 f0       	mov    $0xf013bf58,%ebx
f0116303:	ba 0e 00 00 00       	mov    $0xe,%edx
f0116308:	89 c7                	mov    %eax,%edi
f011630a:	89 de                	mov    %ebx,%esi
f011630c:	89 d1                	mov    %edx,%ecx
f011630e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116310:	8d 95 56 fe ff ff    	lea    -0x1aa(%ebp),%edx
f0116316:	b9 56 00 00 00       	mov    $0x56,%ecx
f011631b:	b0 00                	mov    $0x0,%al
f011631d:	89 d7                	mov    %edx,%edi
f011631f:	f3 aa                	rep stos %al,%es:(%edi)
f0116321:	83 ec 0c             	sub    $0xc,%esp
f0116324:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f011632a:	50                   	push   %eax
f011632b:	e8 dc ba fe ff       	call   f0101e0c <execute_command>
f0116330:	83 c4 10             	add    $0x10,%esp
	va = 0xeebfe000;
f0116333:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011633a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011633f:	83 ec 08             	sub    $0x8,%esp
f0116342:	ff 75 dc             	pushl  -0x24(%ebp)
f0116345:	50                   	push   %eax
f0116346:	e8 39 53 ff ff       	call   f010b684 <virtual_to_physical>
f011634b:	83 c4 10             	add    $0x10,%esp
f011634e:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0116351:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0116356:	83 ec 08             	sub    $0x8,%esp
f0116359:	ff 75 dc             	pushl  -0x24(%ebp)
f011635c:	50                   	push   %eax
f011635d:	e8 a6 45 00 00       	call   f011a908 <CA>
f0116362:	83 c4 10             	add    $0x10,%esp
f0116365:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0116368:	74 17                	je     f0116381 <test_virtual_to_physical+0x371>
		panic("[EVAL] #8 Test of virtual_to_physical Entry Failed.\n");
f011636a:	83 ec 04             	sub    $0x4,%esp
f011636d:	68 b0 bd 13 f0       	push   $0xf013bdb0
f0116372:	68 25 02 00 00       	push   $0x225
f0116377:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011637c:	e8 2e ab fe ff       	call   f0100eaf <_panic>

	//============================
	cprintf("Congratulations!! test virtual_to_physical completed successfully.\n");
f0116381:	83 ec 0c             	sub    $0xc,%esp
f0116384:	68 e8 bd 13 f0       	push   $0xf013bde8
f0116389:	e8 bf b7 fe ff       	call   f0101b4d <cprintf>
f011638e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0116391:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116396:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116399:	5b                   	pop    %ebx
f011639a:	5e                   	pop    %esi
f011639b:	5f                   	pop    %edi
f011639c:	5d                   	pop    %ebp
f011639d:	c3                   	ret    

f011639e <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f011639e:	55                   	push   %ebp
f011639f:	89 e5                	mov    %esp,%ebp
f01163a1:	57                   	push   %edi
f01163a2:	56                   	push   %esi
f01163a3:	53                   	push   %ebx
f01163a4:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01163aa:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01163b0:	bb 6c c2 13 f0       	mov    $0xf013c26c,%ebx
f01163b5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01163ba:	89 c7                	mov    %eax,%edi
f01163bc:	89 de                	mov    %ebx,%esi
f01163be:	89 d1                	mov    %edx,%ecx
f01163c0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01163c2:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01163c8:	b9 23 00 00 00       	mov    $0x23,%ecx
f01163cd:	b0 00                	mov    $0x0,%al
f01163cf:	89 d7                	mov    %edx,%edi
f01163d1:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01163d3:	6a 00                	push   $0x0
f01163d5:	6a 0a                	push   $0xa
f01163d7:	6a 14                	push   $0x14
f01163d9:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01163df:	50                   	push   %eax
f01163e0:	e8 ac 66 ff ff       	call   f010ca91 <env_create>
f01163e5:	83 c4 10             	add    $0x10,%esp
f01163e8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01163eb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01163ee:	8b 40 64             	mov    0x64(%eax),%eax
f01163f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01163f4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01163f7:	8b 40 68             	mov    0x68(%eax),%eax
f01163fa:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01163fd:	8b 45 90             	mov    -0x70(%ebp),%eax
f0116400:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0116403:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f011640a:	75 70 20 
f011640d:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0116414:	00 00 00 
f0116417:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f011641d:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116422:	b8 00 00 00 00       	mov    $0x0,%eax
f0116427:	89 d7                	mov    %edx,%edi
f0116429:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011642b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011642e:	8b 40 10             	mov    0x10(%eax),%eax
f0116431:	83 ec 08             	sub    $0x8,%esp
f0116434:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f011643a:	52                   	push   %edx
f011643b:	50                   	push   %eax
f011643c:	e8 43 cf 00 00       	call   f0123384 <ltostr>
f0116441:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116444:	83 ec 04             	sub    $0x4,%esp
f0116447:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011644d:	50                   	push   %eax
f011644e:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0116454:	50                   	push   %eax
f0116455:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f011645b:	50                   	push   %eax
f011645c:	e8 fc cf 00 00       	call   f012345d <strcconcat>
f0116461:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0116464:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f011646b:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0116472:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0116479:	83 ec 0c             	sub    $0xc,%esp
f011647c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011647f:	e8 85 45 00 00       	call   f011aa09 <ClearUserSpace>
f0116484:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0116487:	83 ec 04             	sub    $0x4,%esp
f011648a:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0116490:	50                   	push   %eax
f0116491:	68 bc bf 13 f0       	push   $0xf013bfbc
f0116496:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011649c:	50                   	push   %eax
f011649d:	e8 bb cf 00 00       	call   f012345d <strcconcat>
f01164a2:	83 c4 10             	add    $0x10,%esp
f01164a5:	83 ec 0c             	sub    $0xc,%esp
f01164a8:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01164ae:	50                   	push   %eax
f01164af:	e8 58 b9 fe ff       	call   f0101e0c <execute_command>
f01164b4:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01164b7:	83 ec 04             	sub    $0x4,%esp
f01164ba:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01164c0:	50                   	push   %eax
f01164c1:	68 c7 bf 13 f0       	push   $0xf013bfc7
f01164c6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01164cc:	50                   	push   %eax
f01164cd:	e8 8b cf 00 00       	call   f012345d <strcconcat>
f01164d2:	83 c4 10             	add    $0x10,%esp
f01164d5:	83 ec 0c             	sub    $0xc,%esp
f01164d8:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01164de:	50                   	push   %eax
f01164df:	e8 28 b9 fe ff       	call   f0101e0c <execute_command>
f01164e4:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01164e7:	83 ec 04             	sub    $0x4,%esp
f01164ea:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01164f0:	50                   	push   %eax
f01164f1:	68 d2 bf 13 f0       	push   $0xf013bfd2
f01164f6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01164fc:	50                   	push   %eax
f01164fd:	e8 5b cf 00 00       	call   f012345d <strcconcat>
f0116502:	83 c4 10             	add    $0x10,%esp
f0116505:	83 ec 0c             	sub    $0xc,%esp
f0116508:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f011650e:	50                   	push   %eax
f011650f:	e8 f8 b8 fe ff       	call   f0101e0c <execute_command>
f0116514:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0116517:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f011651e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116521:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0116524:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f011652b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011652e:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0116531:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0116538:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011653b:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f011653e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116541:	83 ec 08             	sub    $0x8,%esp
f0116544:	50                   	push   %eax
f0116545:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116548:	e8 9d 44 00 00       	call   f011a9ea <GP>
f011654d:	83 c4 10             	add    $0x10,%esp
f0116550:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0116553:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f011655a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0116561:	e8 20 a1 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116566:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0116569:	83 ec 0c             	sub    $0xc,%esp
f011656c:	68 e0 bf 13 f0       	push   $0xf013bfe0
f0116571:	e8 d7 b5 fe ff       	call   f0101b4d <cprintf>
f0116576:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0116579:	6a 03                	push   $0x3
f011657b:	68 00 00 90 02       	push   $0x2900000
f0116580:	68 00 00 80 02       	push   $0x2800000
f0116585:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116588:	e8 2e 60 ff ff       	call   f010c5bb <cut_paste_pages>
f011658d:	83 c4 10             	add    $0x10,%esp
f0116590:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0116593:	e8 ee a0 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116598:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f011659b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01165a2:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01165a6:	75 08                	jne    f01165b0 <test_cut_paste_pages+0x212>
f01165a8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01165ab:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01165ae:	74 2b                	je     f01165db <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01165b0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01165b3:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01165b6:	83 ec 0c             	sub    $0xc,%esp
f01165b9:	50                   	push   %eax
f01165ba:	ff 75 b4             	pushl  -0x4c(%ebp)
f01165bd:	68 10 c0 13 f0       	push   $0xf013c010
f01165c2:	68 63 02 00 00       	push   $0x263
f01165c7:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01165cc:	e8 83 aa fe ff       	call   f0101054 <_warn>
f01165d1:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01165d4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f01165db:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01165df:	74 04                	je     f01165e5 <test_cut_paste_pages+0x247>
f01165e1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01165e5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01165ec:	83 ec 08             	sub    $0x8,%esp
f01165ef:	6a 00                	push   $0x0
f01165f1:	6a 01                	push   $0x1
f01165f3:	6a 00                	push   $0x0
f01165f5:	68 ff 0f 00 00       	push   $0xfff
f01165fa:	ff 75 bc             	pushl  -0x44(%ebp)
f01165fd:	6a 01                	push   $0x1
f01165ff:	68 00 30 00 00       	push   $0x3000
f0116604:	68 00 00 90 02       	push   $0x2900000
f0116609:	68 00 00 80 02       	push   $0x2800000
f011660e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116611:	e8 27 44 00 00       	call   f011aa3d <CCP>
f0116616:	83 c4 30             	add    $0x30,%esp
f0116619:	83 f8 01             	cmp    $0x1,%eax
f011661c:	74 21                	je     f011663f <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011661e:	83 ec 04             	sub    $0x4,%esp
f0116621:	68 64 c0 13 f0       	push   $0xf013c064
f0116626:	68 6b 02 00 00       	push   $0x26b
f011662b:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116630:	e8 1f aa fe ff       	call   f0101054 <_warn>
f0116635:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0116638:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f011663f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116643:	74 04                	je     f0116649 <test_cut_paste_pages+0x2ab>
f0116645:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0116649:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0116650:	83 ec 04             	sub    $0x4,%esp
f0116653:	6a 00                	push   $0x0
f0116655:	68 00 00 90 02       	push   $0x2900000
f011665a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011665d:	e8 b7 41 00 00       	call   f011a819 <CB>
f0116662:	83 c4 10             	add    $0x10,%esp
f0116665:	85 c0                	test   %eax,%eax
f0116667:	0f 84 f6 00 00 00    	je     f0116763 <test_cut_paste_pages+0x3c5>
f011666d:	83 ec 04             	sub    $0x4,%esp
f0116670:	6a 00                	push   $0x0
f0116672:	68 00 10 90 02       	push   $0x2901000
f0116677:	ff 75 d4             	pushl  -0x2c(%ebp)
f011667a:	e8 9a 41 00 00       	call   f011a819 <CB>
f011667f:	83 c4 10             	add    $0x10,%esp
f0116682:	85 c0                	test   %eax,%eax
f0116684:	0f 84 d9 00 00 00    	je     f0116763 <test_cut_paste_pages+0x3c5>
f011668a:	83 ec 04             	sub    $0x4,%esp
f011668d:	6a 00                	push   $0x0
f011668f:	68 00 20 90 02       	push   $0x2902000
f0116694:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116697:	e8 7d 41 00 00       	call   f011a819 <CB>
f011669c:	83 c4 10             	add    $0x10,%esp
f011669f:	85 c0                	test   %eax,%eax
f01166a1:	0f 84 bc 00 00 00    	je     f0116763 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01166a7:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f01166ae:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01166b5:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01166bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01166bf:	8a 00                	mov    (%eax),%al
f01166c1:	3c 61                	cmp    $0x61,%al
f01166c3:	75 12                	jne    f01166d7 <test_cut_paste_pages+0x339>
f01166c5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01166c8:	8a 00                	mov    (%eax),%al
f01166ca:	3c 62                	cmp    $0x62,%al
f01166cc:	75 09                	jne    f01166d7 <test_cut_paste_pages+0x339>
f01166ce:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01166d1:	8a 00                	mov    (%eax),%al
f01166d3:	3c 63                	cmp    $0x63,%al
f01166d5:	74 21                	je     f01166f8 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01166d7:	83 ec 04             	sub    $0x4,%esp
f01166da:	68 b0 c0 13 f0       	push   $0xf013c0b0
f01166df:	68 78 02 00 00       	push   $0x278
f01166e4:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01166e9:	e8 66 a9 fe ff       	call   f0101054 <_warn>
f01166ee:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01166f1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01166f8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01166fc:	74 04                	je     f0116702 <test_cut_paste_pages+0x364>
f01166fe:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116702:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0116709:	83 ec 04             	sub    $0x4,%esp
f011670c:	6a 01                	push   $0x1
f011670e:	68 00 10 90 02       	push   $0x2901000
f0116713:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116716:	e8 fe 40 00 00       	call   f011a819 <CB>
f011671b:	83 c4 10             	add    $0x10,%esp
f011671e:	85 c0                	test   %eax,%eax
f0116720:	74 41                	je     f0116763 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0116722:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116725:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0116728:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011672b:	8a 00                	mov    (%eax),%al
f011672d:	3c 79                	cmp    $0x79,%al
f011672f:	74 21                	je     f0116752 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0116731:	83 ec 04             	sub    $0x4,%esp
f0116734:	68 b0 c0 13 f0       	push   $0xf013c0b0
f0116739:	68 83 02 00 00       	push   $0x283
f011673e:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116743:	e8 0c a9 fe ff       	call   f0101054 <_warn>
f0116748:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011674b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0116752:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116756:	74 04                	je     f011675c <test_cut_paste_pages+0x3be>
f0116758:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011675c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0116763:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116766:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0116769:	6a 02                	push   $0x2
f011676b:	68 00 f0 bf 02       	push   $0x2bff000
f0116770:	68 00 10 90 02       	push   $0x2901000
f0116775:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116778:	e8 3e 5e ff ff       	call   f010c5bb <cut_paste_pages>
f011677d:	83 c4 10             	add    $0x10,%esp
f0116780:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0116783:	e8 fe 9e ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116788:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f011678b:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011678f:	75 0b                	jne    f011679c <test_cut_paste_pages+0x3fe>
f0116791:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116794:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0116797:	83 f8 01             	cmp    $0x1,%eax
f011679a:	74 2b                	je     f01167c7 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f011679c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011679f:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01167a2:	83 ec 0c             	sub    $0xc,%esp
f01167a5:	50                   	push   %eax
f01167a6:	ff 75 b4             	pushl  -0x4c(%ebp)
f01167a9:	68 10 c0 13 f0       	push   $0xf013c010
f01167ae:	68 94 02 00 00       	push   $0x294
f01167b3:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01167b8:	e8 97 a8 fe ff       	call   f0101054 <_warn>
f01167bd:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01167c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01167c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01167cb:	74 04                	je     f01167d1 <test_cut_paste_pages+0x433>
f01167cd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01167d1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01167d8:	83 ec 08             	sub    $0x8,%esp
f01167db:	6a 00                	push   $0x0
f01167dd:	6a 01                	push   $0x1
f01167df:	6a 00                	push   $0x0
f01167e1:	68 ff 0f 00 00       	push   $0xfff
f01167e6:	ff 75 bc             	pushl  -0x44(%ebp)
f01167e9:	6a 01                	push   $0x1
f01167eb:	68 00 20 00 00       	push   $0x2000
f01167f0:	68 00 f0 bf 02       	push   $0x2bff000
f01167f5:	68 00 10 90 02       	push   $0x2901000
f01167fa:	ff 75 d4             	pushl  -0x2c(%ebp)
f01167fd:	e8 3b 42 00 00       	call   f011aa3d <CCP>
f0116802:	83 c4 30             	add    $0x30,%esp
f0116805:	83 f8 01             	cmp    $0x1,%eax
f0116808:	74 21                	je     f011682b <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011680a:	83 ec 04             	sub    $0x4,%esp
f011680d:	68 64 c0 13 f0       	push   $0xf013c064
f0116812:	68 9c 02 00 00       	push   $0x29c
f0116817:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011681c:	e8 33 a8 fe ff       	call   f0101054 <_warn>
f0116821:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0116824:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011682b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011682f:	74 04                	je     f0116835 <test_cut_paste_pages+0x497>
f0116831:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0116835:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f011683c:	83 ec 04             	sub    $0x4,%esp
f011683f:	6a 00                	push   $0x0
f0116841:	68 ff f7 bf 02       	push   $0x2bff7ff
f0116846:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116849:	e8 cb 3f 00 00       	call   f011a819 <CB>
f011684e:	83 c4 10             	add    $0x10,%esp
f0116851:	85 c0                	test   %eax,%eax
f0116853:	74 6b                	je     f01168c0 <test_cut_paste_pages+0x522>
f0116855:	83 ec 04             	sub    $0x4,%esp
f0116858:	6a 00                	push   $0x0
f011685a:	68 ff 0f c0 02       	push   $0x2c00fff
f011685f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116862:	e8 b2 3f 00 00       	call   f011a819 <CB>
f0116867:	83 c4 10             	add    $0x10,%esp
f011686a:	85 c0                	test   %eax,%eax
f011686c:	74 52                	je     f01168c0 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f011686e:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0116875:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f011687c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011687f:	8a 00                	mov    (%eax),%al
f0116881:	3c 79                	cmp    $0x79,%al
f0116883:	75 09                	jne    f011688e <test_cut_paste_pages+0x4f0>
f0116885:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116888:	8a 00                	mov    (%eax),%al
f011688a:	3c 63                	cmp    $0x63,%al
f011688c:	74 21                	je     f01168af <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011688e:	83 ec 04             	sub    $0x4,%esp
f0116891:	68 b0 c0 13 f0       	push   $0xf013c0b0
f0116896:	68 a8 02 00 00       	push   $0x2a8
f011689b:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01168a0:	e8 af a7 fe ff       	call   f0101054 <_warn>
f01168a5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01168a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01168af:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01168b3:	74 04                	je     f01168b9 <test_cut_paste_pages+0x51b>
f01168b5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01168b9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01168c0:	83 ec 0c             	sub    $0xc,%esp
f01168c3:	68 e9 c0 13 f0       	push   $0xf013c0e9
f01168c8:	e8 80 b2 fe ff       	call   f0101b4d <cprintf>
f01168cd:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f01168d0:	83 ec 0c             	sub    $0xc,%esp
f01168d3:	68 f8 c0 13 f0       	push   $0xf013c0f8
f01168d8:	e8 70 b2 fe ff       	call   f0101b4d <cprintf>
f01168dd:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01168e0:	83 ec 04             	sub    $0x4,%esp
f01168e3:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01168e9:	50                   	push   %eax
f01168ea:	68 21 c1 13 f0       	push   $0xf013c121
f01168ef:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01168f5:	50                   	push   %eax
f01168f6:	e8 62 cb 00 00       	call   f012345d <strcconcat>
f01168fb:	83 c4 10             	add    $0x10,%esp
f01168fe:	83 ec 0c             	sub    $0xc,%esp
f0116901:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0116907:	50                   	push   %eax
f0116908:	e8 ff b4 fe ff       	call   f0101e0c <execute_command>
f011690d:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0116910:	83 ec 04             	sub    $0x4,%esp
f0116913:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0116919:	50                   	push   %eax
f011691a:	68 2c c1 13 f0       	push   $0xf013c12c
f011691f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0116925:	50                   	push   %eax
f0116926:	e8 32 cb 00 00       	call   f012345d <strcconcat>
f011692b:	83 c4 10             	add    $0x10,%esp
f011692e:	83 ec 0c             	sub    $0xc,%esp
f0116931:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0116937:	50                   	push   %eax
f0116938:	e8 cf b4 fe ff       	call   f0101e0c <execute_command>
f011693d:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0116940:	83 ec 04             	sub    $0x4,%esp
f0116943:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0116949:	50                   	push   %eax
f011694a:	68 37 c1 13 f0       	push   $0xf013c137
f011694f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0116955:	50                   	push   %eax
f0116956:	e8 02 cb 00 00       	call   f012345d <strcconcat>
f011695b:	83 c4 10             	add    $0x10,%esp
f011695e:	83 ec 0c             	sub    $0xc,%esp
f0116961:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0116967:	50                   	push   %eax
f0116968:	e8 9f b4 fe ff       	call   f0101e0c <execute_command>
f011696d:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0116970:	83 ec 04             	sub    $0x4,%esp
f0116973:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0116979:	50                   	push   %eax
f011697a:	68 42 c1 13 f0       	push   $0xf013c142
f011697f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0116985:	50                   	push   %eax
f0116986:	e8 d2 ca 00 00       	call   f012345d <strcconcat>
f011698b:	83 c4 10             	add    $0x10,%esp
f011698e:	83 ec 0c             	sub    $0xc,%esp
f0116991:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0116997:	50                   	push   %eax
f0116998:	e8 6f b4 fe ff       	call   f0101e0c <execute_command>
f011699d:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f01169a0:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f01169a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169aa:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f01169ad:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f01169b4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169b7:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f01169ba:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f01169c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169c4:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f01169c7:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f01169ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169d1:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f01169d4:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f01169db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169de:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01169e1:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01169e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169eb:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01169ee:	83 ec 08             	sub    $0x8,%esp
f01169f1:	68 00 00 c0 01       	push   $0x1c00000
f01169f6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01169f9:	e8 ec 3f 00 00       	call   f011a9ea <GP>
f01169fe:	83 c4 10             	add    $0x10,%esp
f0116a01:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0116a04:	83 ec 08             	sub    $0x8,%esp
f0116a07:	68 00 00 40 01       	push   $0x1400000
f0116a0c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116a0f:	e8 d6 3f 00 00       	call   f011a9ea <GP>
f0116a14:	83 c4 10             	add    $0x10,%esp
f0116a17:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0116a1a:	e8 67 9c ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116a1f:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0116a22:	6a 01                	push   $0x1
f0116a24:	68 00 00 40 01       	push   $0x1400000
f0116a29:	68 00 00 c0 01       	push   $0x1c00000
f0116a2e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116a31:	e8 85 5b ff ff       	call   f010c5bb <cut_paste_pages>
f0116a36:	83 c4 10             	add    $0x10,%esp
f0116a39:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0116a3c:	e8 45 9c ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116a41:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0116a44:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0116a48:	75 08                	jne    f0116a52 <test_cut_paste_pages+0x6b4>
f0116a4a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116a4d:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0116a50:	74 2b                	je     f0116a7d <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0116a52:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116a55:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0116a58:	83 ec 0c             	sub    $0xc,%esp
f0116a5b:	50                   	push   %eax
f0116a5c:	ff 75 b4             	pushl  -0x4c(%ebp)
f0116a5f:	68 50 c1 13 f0       	push   $0xf013c150
f0116a64:	68 cb 02 00 00       	push   $0x2cb
f0116a69:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116a6e:	e8 e1 a5 fe ff       	call   f0101054 <_warn>
f0116a73:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0116a76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0116a7d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116a81:	74 04                	je     f0116a87 <test_cut_paste_pages+0x6e9>
f0116a83:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0116a87:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0116a8e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0116a95:	83 ec 08             	sub    $0x8,%esp
f0116a98:	6a 00                	push   $0x0
f0116a9a:	68 ff 0f 00 00       	push   $0xfff
f0116a9f:	ff 75 a4             	pushl  -0x5c(%ebp)
f0116aa2:	68 ff 0f 00 00       	push   $0xfff
f0116aa7:	ff 75 a0             	pushl  -0x60(%ebp)
f0116aaa:	6a 01                	push   $0x1
f0116aac:	68 00 10 00 00       	push   $0x1000
f0116ab1:	68 00 00 40 01       	push   $0x1400000
f0116ab6:	68 00 00 c0 01       	push   $0x1c00000
f0116abb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116abe:	e8 7a 3f 00 00       	call   f011aa3d <CCP>
f0116ac3:	83 c4 30             	add    $0x30,%esp
f0116ac6:	83 f8 01             	cmp    $0x1,%eax
f0116ac9:	74 28                	je     f0116af3 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0116acb:	83 ec 04             	sub    $0x4,%esp
f0116ace:	68 64 c0 13 f0       	push   $0xf013c064
f0116ad3:	68 d4 02 00 00       	push   $0x2d4
f0116ad8:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116add:	e8 72 a5 fe ff       	call   f0101054 <_warn>
f0116ae2:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0116ae5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0116aec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0116af3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116af7:	74 04                	je     f0116afd <test_cut_paste_pages+0x75f>
f0116af9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0116afd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0116b04:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0116b08:	0f 84 92 00 00 00    	je     f0116ba0 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0116b0e:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0116b15:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0116b1c:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0116b23:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0116b2a:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0116b31:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0116b38:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b3b:	8a 00                	mov    (%eax),%al
f0116b3d:	3c 61                	cmp    $0x61,%al
f0116b3f:	75 2d                	jne    f0116b6e <test_cut_paste_pages+0x7d0>
f0116b41:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116b44:	8a 00                	mov    (%eax),%al
f0116b46:	3c 78                	cmp    $0x78,%al
f0116b48:	75 24                	jne    f0116b6e <test_cut_paste_pages+0x7d0>
f0116b4a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116b4d:	8a 00                	mov    (%eax),%al
f0116b4f:	3c 62                	cmp    $0x62,%al
f0116b51:	75 1b                	jne    f0116b6e <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0116b53:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116b56:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0116b58:	3c 79                	cmp    $0x79,%al
f0116b5a:	75 12                	jne    f0116b6e <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0116b5c:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116b5f:	8a 00                	mov    (%eax),%al
f0116b61:	3c 63                	cmp    $0x63,%al
f0116b63:	75 09                	jne    f0116b6e <test_cut_paste_pages+0x7d0>
f0116b65:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116b68:	8a 00                	mov    (%eax),%al
f0116b6a:	3c 7a                	cmp    $0x7a,%al
f0116b6c:	74 21                	je     f0116b8f <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0116b6e:	83 ec 04             	sub    $0x4,%esp
f0116b71:	68 b0 c0 13 f0       	push   $0xf013c0b0
f0116b76:	68 e6 02 00 00       	push   $0x2e6
f0116b7b:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116b80:	e8 cf a4 fe ff       	call   f0101054 <_warn>
f0116b85:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116b88:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0116b8f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116b93:	74 04                	je     f0116b99 <test_cut_paste_pages+0x7fb>
f0116b95:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116b99:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0116ba0:	e8 e1 9a ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116ba5:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0116ba8:	6a 03                	push   $0x3
f0116baa:	68 00 f0 bf 01       	push   $0x1bff000
f0116baf:	68 00 00 40 01       	push   $0x1400000
f0116bb4:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116bb7:	e8 ff 59 ff ff       	call   f010c5bb <cut_paste_pages>
f0116bbc:	83 c4 10             	add    $0x10,%esp
f0116bbf:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0116bc2:	e8 bf 9a ff ff       	call   f0110686 <sys_calculate_free_frames>
f0116bc7:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0116bca:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0116bce:	75 08                	jne    f0116bd8 <test_cut_paste_pages+0x83a>
f0116bd0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116bd3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0116bd6:	74 2b                	je     f0116c03 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0116bd8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116bdb:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0116bde:	83 ec 0c             	sub    $0xc,%esp
f0116be1:	50                   	push   %eax
f0116be2:	ff 75 b4             	pushl  -0x4c(%ebp)
f0116be5:	68 50 c1 13 f0       	push   $0xf013c150
f0116bea:	68 f5 02 00 00       	push   $0x2f5
f0116bef:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116bf4:	e8 5b a4 fe ff       	call   f0101054 <_warn>
f0116bf9:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0116bfc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0116c03:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116c07:	74 04                	je     f0116c0d <test_cut_paste_pages+0x86f>
f0116c09:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0116c0d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0116c14:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0116c1b:	83 ec 04             	sub    $0x4,%esp
f0116c1e:	6a 00                	push   $0x0
f0116c20:	68 00 00 40 01       	push   $0x1400000
f0116c25:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116c28:	e8 ec 3b 00 00       	call   f011a819 <CB>
f0116c2d:	83 c4 10             	add    $0x10,%esp
f0116c30:	83 f8 01             	cmp    $0x1,%eax
f0116c33:	0f 85 80 00 00 00    	jne    f0116cb9 <test_cut_paste_pages+0x91b>
f0116c39:	83 ec 04             	sub    $0x4,%esp
f0116c3c:	6a 00                	push   $0x0
f0116c3e:	68 00 10 40 01       	push   $0x1401000
f0116c43:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116c46:	e8 ce 3b 00 00       	call   f011a819 <CB>
f0116c4b:	83 c4 10             	add    $0x10,%esp
f0116c4e:	83 f8 01             	cmp    $0x1,%eax
f0116c51:	75 66                	jne    f0116cb9 <test_cut_paste_pages+0x91b>
f0116c53:	83 ec 04             	sub    $0x4,%esp
f0116c56:	6a 00                	push   $0x0
f0116c58:	68 00 20 40 01       	push   $0x1402000
f0116c5d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116c60:	e8 b4 3b 00 00       	call   f011a819 <CB>
f0116c65:	83 c4 10             	add    $0x10,%esp
f0116c68:	83 f8 01             	cmp    $0x1,%eax
f0116c6b:	75 4c                	jne    f0116cb9 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0116c6d:	83 ec 04             	sub    $0x4,%esp
f0116c70:	6a 00                	push   $0x0
f0116c72:	68 00 f0 bf 01       	push   $0x1bff000
f0116c77:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116c7a:	e8 9a 3b 00 00       	call   f011a819 <CB>
f0116c7f:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0116c82:	85 c0                	test   %eax,%eax
f0116c84:	75 33                	jne    f0116cb9 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0116c86:	83 ec 04             	sub    $0x4,%esp
f0116c89:	6a 00                	push   $0x0
f0116c8b:	68 00 00 c0 01       	push   $0x1c00000
f0116c90:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116c93:	e8 81 3b 00 00       	call   f011a819 <CB>
f0116c98:	83 c4 10             	add    $0x10,%esp
f0116c9b:	83 f8 01             	cmp    $0x1,%eax
f0116c9e:	75 19                	jne    f0116cb9 <test_cut_paste_pages+0x91b>
f0116ca0:	83 ec 04             	sub    $0x4,%esp
f0116ca3:	6a 00                	push   $0x0
f0116ca5:	68 00 10 c0 01       	push   $0x1c01000
f0116caa:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116cad:	e8 67 3b 00 00       	call   f011a819 <CB>
f0116cb2:	83 c4 10             	add    $0x10,%esp
f0116cb5:	85 c0                	test   %eax,%eax
f0116cb7:	74 28                	je     f0116ce1 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0116cb9:	83 ec 04             	sub    $0x4,%esp
f0116cbc:	68 b0 c1 13 f0       	push   $0xf013c1b0
f0116cc1:	68 fe 02 00 00       	push   $0x2fe
f0116cc6:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116ccb:	e8 84 a3 fe ff       	call   f0101054 <_warn>
f0116cd0:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0116cd3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0116cda:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0116ce1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116ce5:	74 04                	je     f0116ceb <test_cut_paste_pages+0x94d>
f0116ce7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0116ceb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0116cf2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0116cf6:	0f 84 99 00 00 00    	je     f0116d95 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0116cfc:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0116d03:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0116d0a:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0116d11:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0116d18:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0116d1f:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0116d26:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116d29:	8a 00                	mov    (%eax),%al
f0116d2b:	3c 61                	cmp    $0x61,%al
f0116d2d:	75 2d                	jne    f0116d5c <test_cut_paste_pages+0x9be>
f0116d2f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116d32:	8a 00                	mov    (%eax),%al
f0116d34:	3c 78                	cmp    $0x78,%al
f0116d36:	75 24                	jne    f0116d5c <test_cut_paste_pages+0x9be>
f0116d38:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d3b:	8a 00                	mov    (%eax),%al
f0116d3d:	3c 62                	cmp    $0x62,%al
f0116d3f:	75 1b                	jne    f0116d5c <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0116d41:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116d44:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0116d46:	3c 79                	cmp    $0x79,%al
f0116d48:	75 12                	jne    f0116d5c <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0116d4a:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116d4d:	8a 00                	mov    (%eax),%al
f0116d4f:	3c 63                	cmp    $0x63,%al
f0116d51:	75 09                	jne    f0116d5c <test_cut_paste_pages+0x9be>
f0116d53:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116d56:	8a 00                	mov    (%eax),%al
f0116d58:	3c 7a                	cmp    $0x7a,%al
f0116d5a:	74 28                	je     f0116d84 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0116d5c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0116d63:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0116d6a:	83 ec 04             	sub    $0x4,%esp
f0116d6d:	68 b0 c0 13 f0       	push   $0xf013c0b0
f0116d72:	68 12 03 00 00       	push   $0x312
f0116d77:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0116d7c:	e8 d3 a2 fe ff       	call   f0101054 <_warn>
f0116d81:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0116d84:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0116d88:	74 04                	je     f0116d8e <test_cut_paste_pages+0x9f0>
f0116d8a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116d8e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0116d95:	83 ec 0c             	sub    $0xc,%esp
f0116d98:	68 e9 c1 13 f0       	push   $0xf013c1e9
f0116d9d:	e8 ab ad fe ff       	call   f0101b4d <cprintf>
f0116da2:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0116da5:	83 ec 08             	sub    $0x8,%esp
f0116da8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116dab:	68 f8 c1 13 f0       	push   $0xf013c1f8
f0116db0:	e8 98 ad fe ff       	call   f0101b4d <cprintf>
f0116db5:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116db8:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116dbc:	75 10                	jne    f0116dce <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0116dbe:	83 ec 0c             	sub    $0xc,%esp
f0116dc1:	68 2c c2 13 f0       	push   $0xf013c22c
f0116dc6:	e8 82 ad fe ff       	call   f0101b4d <cprintf>
f0116dcb:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116dce:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f0116dd3:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0116dd6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116dd9:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116ddc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116de1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116de4:	5b                   	pop    %ebx
f0116de5:	5e                   	pop    %esi
f0116de6:	5f                   	pop    %edi
f0116de7:	5d                   	pop    %ebp
f0116de8:	c3                   	ret    

f0116de9 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0116de9:	55                   	push   %ebp
f0116dea:	89 e5                	mov    %esp,%ebp
f0116dec:	57                   	push   %edi
f0116ded:	56                   	push   %esi
f0116dee:	53                   	push   %ebx
f0116def:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0116df5:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0116dfb:	bb 6c c2 13 f0       	mov    $0xf013c26c,%ebx
f0116e00:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116e05:	89 c7                	mov    %eax,%edi
f0116e07:	89 de                	mov    %ebx,%esi
f0116e09:	89 d1                	mov    %edx,%ecx
f0116e0b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116e0d:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0116e13:	b9 23 00 00 00       	mov    $0x23,%ecx
f0116e18:	b0 00                	mov    $0x0,%al
f0116e1a:	89 d7                	mov    %edx,%edi
f0116e1c:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0116e1e:	6a 00                	push   $0x0
f0116e20:	6a 0a                	push   $0xa
f0116e22:	6a 14                	push   $0x14
f0116e24:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0116e2a:	50                   	push   %eax
f0116e2b:	e8 61 5c ff ff       	call   f010ca91 <env_create>
f0116e30:	83 c4 10             	add    $0x10,%esp
f0116e33:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116e36:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116e39:	8b 40 64             	mov    0x64(%eax),%eax
f0116e3c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0116e3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116e42:	8b 40 68             	mov    0x68(%eax),%eax
f0116e45:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0116e4b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0116e51:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0116e54:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0116e5b:	75 70 20 
f0116e5e:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0116e65:	00 00 00 
f0116e68:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0116e6e:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116e73:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e78:	89 d7                	mov    %edx,%edi
f0116e7a:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116e7c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116e7f:	8b 40 10             	mov    0x10(%eax),%eax
f0116e82:	83 ec 08             	sub    $0x8,%esp
f0116e85:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0116e8b:	52                   	push   %edx
f0116e8c:	50                   	push   %eax
f0116e8d:	e8 f2 c4 00 00       	call   f0123384 <ltostr>
f0116e92:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116e95:	83 ec 04             	sub    $0x4,%esp
f0116e98:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0116e9e:	50                   	push   %eax
f0116e9f:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0116ea5:	50                   	push   %eax
f0116ea6:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0116eac:	50                   	push   %eax
f0116ead:	e8 ab c5 00 00       	call   f012345d <strcconcat>
f0116eb2:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0116eb5:	83 ec 0c             	sub    $0xc,%esp
f0116eb8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0116ebb:	e8 49 3b 00 00       	call   f011aa09 <ClearUserSpace>
f0116ec0:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0116ec3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0116eca:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0116ed1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0116ed8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0116edf:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0116ee6:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0116eed:	83 ec 0c             	sub    $0xc,%esp
f0116ef0:	68 a0 c2 13 f0       	push   $0xf013c2a0
f0116ef5:	e8 53 ac fe ff       	call   f0101b4d <cprintf>
f0116efa:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0116efd:	83 ec 04             	sub    $0x4,%esp
f0116f00:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0116f06:	50                   	push   %eax
f0116f07:	68 d6 c2 13 f0       	push   $0xf013c2d6
f0116f0c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0116f12:	50                   	push   %eax
f0116f13:	e8 45 c5 00 00       	call   f012345d <strcconcat>
f0116f18:	83 c4 10             	add    $0x10,%esp
f0116f1b:	83 ec 0c             	sub    $0xc,%esp
f0116f1e:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0116f24:	50                   	push   %eax
f0116f25:	e8 e2 ae fe ff       	call   f0101e0c <execute_command>
f0116f2a:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0116f2d:	83 ec 04             	sub    $0x4,%esp
f0116f30:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0116f36:	50                   	push   %eax
f0116f37:	68 db c2 13 f0       	push   $0xf013c2db
f0116f3c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0116f42:	50                   	push   %eax
f0116f43:	e8 15 c5 00 00       	call   f012345d <strcconcat>
f0116f48:	83 c4 10             	add    $0x10,%esp
f0116f4b:	83 ec 0c             	sub    $0xc,%esp
f0116f4e:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0116f54:	50                   	push   %eax
f0116f55:	e8 b2 ae fe ff       	call   f0101e0c <execute_command>
f0116f5a:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0116f5d:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0116f63:	bb e1 c5 13 f0       	mov    $0xf013c5e1,%ebx
f0116f68:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116f6d:	89 c7                	mov    %eax,%edi
f0116f6f:	89 de                	mov    %ebx,%esi
f0116f71:	89 d1                	mov    %edx,%ecx
f0116f73:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116f75:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0116f7b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0116f80:	b0 00                	mov    $0x0,%al
f0116f82:	89 d7                	mov    %edx,%edi
f0116f84:	f3 aa                	rep stos %al,%es:(%edi)
f0116f86:	83 ec 0c             	sub    $0xc,%esp
f0116f89:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0116f8f:	50                   	push   %eax
f0116f90:	e8 77 ae fe ff       	call   f0101e0c <execute_command>
f0116f95:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0116f98:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0116f9e:	bb 45 c6 13 f0       	mov    $0xf013c645,%ebx
f0116fa3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116fa8:	89 c7                	mov    %eax,%edi
f0116faa:	89 de                	mov    %ebx,%esi
f0116fac:	89 d1                	mov    %edx,%ecx
f0116fae:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116fb0:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0116fb6:	b9 55 00 00 00       	mov    $0x55,%ecx
f0116fbb:	b0 00                	mov    $0x0,%al
f0116fbd:	89 d7                	mov    %edx,%edi
f0116fbf:	f3 aa                	rep stos %al,%es:(%edi)
f0116fc1:	83 ec 0c             	sub    $0xc,%esp
f0116fc4:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0116fca:	50                   	push   %eax
f0116fcb:	e8 3c ae fe ff       	call   f0101e0c <execute_command>
f0116fd0:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0116fd3:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0116fd9:	bb a9 c6 13 f0       	mov    $0xf013c6a9,%ebx
f0116fde:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116fe3:	89 c7                	mov    %eax,%edi
f0116fe5:	89 de                	mov    %ebx,%esi
f0116fe7:	89 d1                	mov    %edx,%ecx
f0116fe9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116feb:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0116ff1:	b9 55 00 00 00       	mov    $0x55,%ecx
f0116ff6:	b0 00                	mov    $0x0,%al
f0116ff8:	89 d7                	mov    %edx,%edi
f0116ffa:	f3 aa                	rep stos %al,%es:(%edi)
f0116ffc:	83 ec 0c             	sub    $0xc,%esp
f0116fff:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0117005:	50                   	push   %eax
f0117006:	e8 01 ae fe ff       	call   f0101e0c <execute_command>
f011700b:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f011700e:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0117014:	bb 0d c7 13 f0       	mov    $0xf013c70d,%ebx
f0117019:	ba 0f 00 00 00       	mov    $0xf,%edx
f011701e:	89 c7                	mov    %eax,%edi
f0117020:	89 de                	mov    %ebx,%esi
f0117022:	89 d1                	mov    %edx,%ecx
f0117024:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117026:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011702c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117031:	b0 00                	mov    $0x0,%al
f0117033:	89 d7                	mov    %edx,%edi
f0117035:	f3 aa                	rep stos %al,%es:(%edi)
f0117037:	83 ec 0c             	sub    $0xc,%esp
f011703a:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0117040:	50                   	push   %eax
f0117041:	e8 c6 ad fe ff       	call   f0101e0c <execute_command>
f0117046:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0117049:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011704f:	bb 71 c7 13 f0       	mov    $0xf013c771,%ebx
f0117054:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117059:	89 c7                	mov    %eax,%edi
f011705b:	89 de                	mov    %ebx,%esi
f011705d:	89 d1                	mov    %edx,%ecx
f011705f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117061:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0117067:	b9 55 00 00 00       	mov    $0x55,%ecx
f011706c:	b0 00                	mov    $0x0,%al
f011706e:	89 d7                	mov    %edx,%edi
f0117070:	f3 aa                	rep stos %al,%es:(%edi)
f0117072:	83 ec 0c             	sub    $0xc,%esp
f0117075:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011707b:	50                   	push   %eax
f011707c:	e8 8b ad fe ff       	call   f0101e0c <execute_command>
f0117081:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0117084:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011708a:	bb d5 c7 13 f0       	mov    $0xf013c7d5,%ebx
f011708f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117094:	89 c7                	mov    %eax,%edi
f0117096:	89 de                	mov    %ebx,%esi
f0117098:	89 d1                	mov    %edx,%ecx
f011709a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011709c:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01170a2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01170a7:	b0 00                	mov    $0x0,%al
f01170a9:	89 d7                	mov    %edx,%edi
f01170ab:	f3 aa                	rep stos %al,%es:(%edi)
f01170ad:	83 ec 0c             	sub    $0xc,%esp
f01170b0:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01170b6:	50                   	push   %eax
f01170b7:	e8 50 ad fe ff       	call   f0101e0c <execute_command>
f01170bc:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01170bf:	83 ec 04             	sub    $0x4,%esp
f01170c2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01170c8:	50                   	push   %eax
f01170c9:	68 e3 c2 13 f0       	push   $0xf013c2e3
f01170ce:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01170d4:	50                   	push   %eax
f01170d5:	e8 83 c3 00 00       	call   f012345d <strcconcat>
f01170da:	83 c4 10             	add    $0x10,%esp
f01170dd:	83 ec 0c             	sub    $0xc,%esp
f01170e0:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01170e6:	50                   	push   %eax
f01170e7:	e8 20 ad fe ff       	call   f0101e0c <execute_command>
f01170ec:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f01170ef:	83 ec 04             	sub    $0x4,%esp
f01170f2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01170f8:	50                   	push   %eax
f01170f9:	68 ed c2 13 f0       	push   $0xf013c2ed
f01170fe:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0117104:	50                   	push   %eax
f0117105:	e8 53 c3 00 00       	call   f012345d <strcconcat>
f011710a:	83 c4 10             	add    $0x10,%esp
f011710d:	83 ec 0c             	sub    $0xc,%esp
f0117110:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117116:	50                   	push   %eax
f0117117:	e8 f0 ac fe ff       	call   f0101e0c <execute_command>
f011711c:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f011711f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0117125:	bb 39 c8 13 f0       	mov    $0xf013c839,%ebx
f011712a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011712f:	89 c7                	mov    %eax,%edi
f0117131:	89 de                	mov    %ebx,%esi
f0117133:	89 d1                	mov    %edx,%ecx
f0117135:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117137:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011713d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117142:	b0 00                	mov    $0x0,%al
f0117144:	89 d7                	mov    %edx,%edi
f0117146:	f3 aa                	rep stos %al,%es:(%edi)
f0117148:	83 ec 0c             	sub    $0xc,%esp
f011714b:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0117151:	50                   	push   %eax
f0117152:	e8 b5 ac fe ff       	call   f0101e0c <execute_command>
f0117157:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f011715a:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0117160:	bb 9d c8 13 f0       	mov    $0xf013c89d,%ebx
f0117165:	ba 0f 00 00 00       	mov    $0xf,%edx
f011716a:	89 c7                	mov    %eax,%edi
f011716c:	89 de                	mov    %ebx,%esi
f011716e:	89 d1                	mov    %edx,%ecx
f0117170:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117172:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0117178:	b9 55 00 00 00       	mov    $0x55,%ecx
f011717d:	b0 00                	mov    $0x0,%al
f011717f:	89 d7                	mov    %edx,%edi
f0117181:	f3 aa                	rep stos %al,%es:(%edi)
f0117183:	83 ec 0c             	sub    $0xc,%esp
f0117186:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011718c:	50                   	push   %eax
f011718d:	e8 7a ac fe ff       	call   f0101e0c <execute_command>
f0117192:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0117195:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011719b:	bb 01 c9 13 f0       	mov    $0xf013c901,%ebx
f01171a0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01171a5:	89 c7                	mov    %eax,%edi
f01171a7:	89 de                	mov    %ebx,%esi
f01171a9:	89 d1                	mov    %edx,%ecx
f01171ab:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01171ad:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01171b3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01171b8:	b0 00                	mov    $0x0,%al
f01171ba:	89 d7                	mov    %edx,%edi
f01171bc:	f3 aa                	rep stos %al,%es:(%edi)
f01171be:	83 ec 0c             	sub    $0xc,%esp
f01171c1:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01171c7:	50                   	push   %eax
f01171c8:	e8 3f ac fe ff       	call   f0101e0c <execute_command>
f01171cd:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f01171d0:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01171d7:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f01171de:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f01171e5:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f01171ec:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f01171f3:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f01171fa:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0117201:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0117208:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f011720f:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0117216:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f011721d:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0117224:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117227:	8a 00                	mov    (%eax),%al
f0117229:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f011722f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117232:	8a 00                	mov    (%eax),%al
f0117234:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f011723a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011723d:	8a 00                	mov    (%eax),%al
f011723f:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0117245:	e8 3c 94 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011724a:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f011724d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0117250:	89 d0                	mov    %edx,%eax
f0117252:	01 c0                	add    %eax,%eax
f0117254:	01 d0                	add    %edx,%eax
f0117256:	01 c0                	add    %eax,%eax
f0117258:	50                   	push   %eax
f0117259:	68 00 00 10 00       	push   $0x100000
f011725e:	6a 00                	push   $0x0
f0117260:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117263:	e8 6d 53 ff ff       	call   f010c5d5 <copy_paste_chunk>
f0117268:	83 c4 10             	add    $0x10,%esp
f011726b:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011726e:	e8 13 94 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117273:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0117276:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011727d:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0117281:	75 08                	jne    f011728b <test_copy_paste_chunk+0x4a2>
f0117283:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0117286:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0117289:	74 2b                	je     f01172b6 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011728b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011728e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0117291:	83 ec 0c             	sub    $0xc,%esp
f0117294:	50                   	push   %eax
f0117295:	ff 75 88             	pushl  -0x78(%ebp)
f0117298:	68 fc c2 13 f0       	push   $0xf013c2fc
f011729d:	68 65 03 00 00       	push   $0x365
f01172a2:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01172a7:	e8 a8 9d fe ff       	call   f0101054 <_warn>
f01172ac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01172af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01172b6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01172ba:	74 04                	je     f01172c0 <test_copy_paste_chunk+0x4d7>
f01172bc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01172c0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01172c7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01172ca:	8a 00                	mov    (%eax),%al
f01172cc:	3c 61                	cmp    $0x61,%al
f01172ce:	75 75                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f01172d0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01172d3:	8a 00                	mov    (%eax),%al
f01172d5:	3c 78                	cmp    $0x78,%al
f01172d7:	75 6c                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f01172d9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01172dc:	8a 00                	mov    (%eax),%al
f01172de:	3c 62                	cmp    $0x62,%al
f01172e0:	75 63                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f01172e2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01172e5:	8a 00                	mov    (%eax),%al
f01172e7:	3c 79                	cmp    $0x79,%al
f01172e9:	75 5a                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f01172eb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01172ee:	8a 00                	mov    (%eax),%al
f01172f0:	3c 63                	cmp    $0x63,%al
f01172f2:	75 51                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f01172f4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01172f7:	8a 00                	mov    (%eax),%al
f01172f9:	3c 7a                	cmp    $0x7a,%al
f01172fb:	75 48                	jne    f0117345 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f01172fd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117300:	8a 00                	mov    (%eax),%al
f0117302:	3c 64                	cmp    $0x64,%al
f0117304:	75 3f                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f0117306:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117309:	8a 10                	mov    (%eax),%dl
f011730b:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0117311:	38 c2                	cmp    %al,%dl
f0117313:	75 30                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f0117315:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117318:	8a 00                	mov    (%eax),%al
f011731a:	3c 65                	cmp    $0x65,%al
f011731c:	75 27                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f011731e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117321:	8a 10                	mov    (%eax),%dl
f0117323:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0117329:	38 c2                	cmp    %al,%dl
f011732b:	75 18                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f011732d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117330:	8a 00                	mov    (%eax),%al
f0117332:	3c 66                	cmp    $0x66,%al
f0117334:	75 0f                	jne    f0117345 <test_copy_paste_chunk+0x55c>
f0117336:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117339:	8a 10                	mov    (%eax),%dl
f011733b:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0117341:	38 c2                	cmp    %al,%dl
f0117343:	74 21                	je     f0117366 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0117345:	83 ec 04             	sub    $0x4,%esp
f0117348:	68 60 c3 13 f0       	push   $0xf013c360
f011734d:	68 6e 03 00 00       	push   $0x36e
f0117352:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117357:	e8 f8 9c fe ff       	call   f0101054 <_warn>
f011735c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011735f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0117366:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011736a:	74 04                	je     f0117370 <test_copy_paste_chunk+0x587>
f011736c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117370:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0117377:	83 ec 0c             	sub    $0xc,%esp
f011737a:	68 9a c3 13 f0       	push   $0xf013c39a
f011737f:	e8 c9 a7 fe ff       	call   f0101b4d <cprintf>
f0117384:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0117387:	83 ec 0c             	sub    $0xc,%esp
f011738a:	68 ac c3 13 f0       	push   $0xf013c3ac
f011738f:	e8 b9 a7 fe ff       	call   f0101b4d <cprintf>
f0117394:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0117397:	83 ec 04             	sub    $0x4,%esp
f011739a:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01173a0:	50                   	push   %eax
f01173a1:	68 e2 c3 13 f0       	push   $0xf013c3e2
f01173a6:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01173ac:	50                   	push   %eax
f01173ad:	e8 ab c0 00 00       	call   f012345d <strcconcat>
f01173b2:	83 c4 10             	add    $0x10,%esp
f01173b5:	83 ec 0c             	sub    $0xc,%esp
f01173b8:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01173be:	50                   	push   %eax
f01173bf:	e8 48 aa fe ff       	call   f0101e0c <execute_command>
f01173c4:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01173c7:	83 ec 04             	sub    $0x4,%esp
f01173ca:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01173d0:	50                   	push   %eax
f01173d1:	68 ec c3 13 f0       	push   $0xf013c3ec
f01173d6:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01173dc:	50                   	push   %eax
f01173dd:	e8 7b c0 00 00       	call   f012345d <strcconcat>
f01173e2:	83 c4 10             	add    $0x10,%esp
f01173e5:	83 ec 0c             	sub    $0xc,%esp
f01173e8:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01173ee:	50                   	push   %eax
f01173ef:	e8 18 aa fe ff       	call   f0101e0c <execute_command>
f01173f4:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f01173f7:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01173fd:	bb 65 c9 13 f0       	mov    $0xf013c965,%ebx
f0117402:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117407:	89 c7                	mov    %eax,%edi
f0117409:	89 de                	mov    %ebx,%esi
f011740b:	89 d1                	mov    %edx,%ecx
f011740d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011740f:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0117415:	b9 55 00 00 00       	mov    $0x55,%ecx
f011741a:	b0 00                	mov    $0x0,%al
f011741c:	89 d7                	mov    %edx,%edi
f011741e:	f3 aa                	rep stos %al,%es:(%edi)
f0117420:	83 ec 0c             	sub    $0xc,%esp
f0117423:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0117429:	50                   	push   %eax
f011742a:	e8 dd a9 fe ff       	call   f0101e0c <execute_command>
f011742f:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0117432:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0117438:	bb c9 c9 13 f0       	mov    $0xf013c9c9,%ebx
f011743d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117442:	89 c7                	mov    %eax,%edi
f0117444:	89 de                	mov    %ebx,%esi
f0117446:	89 d1                	mov    %edx,%ecx
f0117448:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011744a:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0117450:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117455:	b0 00                	mov    $0x0,%al
f0117457:	89 d7                	mov    %edx,%edi
f0117459:	f3 aa                	rep stos %al,%es:(%edi)
f011745b:	83 ec 0c             	sub    $0xc,%esp
f011745e:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0117464:	50                   	push   %eax
f0117465:	e8 a2 a9 fe ff       	call   f0101e0c <execute_command>
f011746a:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f011746d:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0117473:	bb 2d ca 13 f0       	mov    $0xf013ca2d,%ebx
f0117478:	ba 0f 00 00 00       	mov    $0xf,%edx
f011747d:	89 c7                	mov    %eax,%edi
f011747f:	89 de                	mov    %ebx,%esi
f0117481:	89 d1                	mov    %edx,%ecx
f0117483:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117485:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f011748b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117490:	b0 00                	mov    $0x0,%al
f0117492:	89 d7                	mov    %edx,%edi
f0117494:	f3 aa                	rep stos %al,%es:(%edi)
f0117496:	83 ec 0c             	sub    $0xc,%esp
f0117499:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011749f:	50                   	push   %eax
f01174a0:	e8 67 a9 fe ff       	call   f0101e0c <execute_command>
f01174a5:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01174a8:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01174ae:	bb 91 ca 13 f0       	mov    $0xf013ca91,%ebx
f01174b3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01174b8:	89 c7                	mov    %eax,%edi
f01174ba:	89 de                	mov    %ebx,%esi
f01174bc:	89 d1                	mov    %edx,%ecx
f01174be:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01174c0:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01174c6:	b9 55 00 00 00       	mov    $0x55,%ecx
f01174cb:	b0 00                	mov    $0x0,%al
f01174cd:	89 d7                	mov    %edx,%edi
f01174cf:	f3 aa                	rep stos %al,%es:(%edi)
f01174d1:	83 ec 0c             	sub    $0xc,%esp
f01174d4:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01174da:	50                   	push   %eax
f01174db:	e8 2c a9 fe ff       	call   f0101e0c <execute_command>
f01174e0:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01174e3:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01174e9:	bb f5 ca 13 f0       	mov    $0xf013caf5,%ebx
f01174ee:	ba 0f 00 00 00       	mov    $0xf,%edx
f01174f3:	89 c7                	mov    %eax,%edi
f01174f5:	89 de                	mov    %ebx,%esi
f01174f7:	89 d1                	mov    %edx,%ecx
f01174f9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01174fb:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0117501:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117506:	b0 00                	mov    $0x0,%al
f0117508:	89 d7                	mov    %edx,%edi
f011750a:	f3 aa                	rep stos %al,%es:(%edi)
f011750c:	83 ec 0c             	sub    $0xc,%esp
f011750f:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0117515:	50                   	push   %eax
f0117516:	e8 f1 a8 fe ff       	call   f0101e0c <execute_command>
f011751b:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f011751e:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0117524:	bb 59 cb 13 f0       	mov    $0xf013cb59,%ebx
f0117529:	ba 0f 00 00 00       	mov    $0xf,%edx
f011752e:	89 c7                	mov    %eax,%edi
f0117530:	89 de                	mov    %ebx,%esi
f0117532:	89 d1                	mov    %edx,%ecx
f0117534:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117536:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011753c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117541:	b0 00                	mov    $0x0,%al
f0117543:	89 d7                	mov    %edx,%edi
f0117545:	f3 aa                	rep stos %al,%es:(%edi)
f0117547:	83 ec 0c             	sub    $0xc,%esp
f011754a:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0117550:	50                   	push   %eax
f0117551:	e8 b6 a8 fe ff       	call   f0101e0c <execute_command>
f0117556:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0117559:	83 ec 04             	sub    $0x4,%esp
f011755c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117562:	50                   	push   %eax
f0117563:	68 f6 c3 13 f0       	push   $0xf013c3f6
f0117568:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011756e:	50                   	push   %eax
f011756f:	e8 e9 be 00 00       	call   f012345d <strcconcat>
f0117574:	83 c4 10             	add    $0x10,%esp
f0117577:	83 ec 0c             	sub    $0xc,%esp
f011757a:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117580:	50                   	push   %eax
f0117581:	e8 86 a8 fe ff       	call   f0101e0c <execute_command>
f0117586:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0117589:	83 ec 04             	sub    $0x4,%esp
f011758c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117592:	50                   	push   %eax
f0117593:	68 00 c4 13 f0       	push   $0xf013c400
f0117598:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011759e:	50                   	push   %eax
f011759f:	e8 b9 be 00 00       	call   f012345d <strcconcat>
f01175a4:	83 c4 10             	add    $0x10,%esp
f01175a7:	83 ec 0c             	sub    $0xc,%esp
f01175aa:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01175b0:	50                   	push   %eax
f01175b1:	e8 56 a8 fe ff       	call   f0101e0c <execute_command>
f01175b6:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01175b9:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01175bf:	bb bd cb 13 f0       	mov    $0xf013cbbd,%ebx
f01175c4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01175c9:	89 c7                	mov    %eax,%edi
f01175cb:	89 de                	mov    %ebx,%esi
f01175cd:	89 d1                	mov    %edx,%ecx
f01175cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01175d1:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01175d7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01175dc:	b0 00                	mov    $0x0,%al
f01175de:	89 d7                	mov    %edx,%edi
f01175e0:	f3 aa                	rep stos %al,%es:(%edi)
f01175e2:	83 ec 0c             	sub    $0xc,%esp
f01175e5:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01175eb:	50                   	push   %eax
f01175ec:	e8 1b a8 fe ff       	call   f0101e0c <execute_command>
f01175f1:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01175f4:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01175fa:	bb 21 cc 13 f0       	mov    $0xf013cc21,%ebx
f01175ff:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117604:	89 c7                	mov    %eax,%edi
f0117606:	89 de                	mov    %ebx,%esi
f0117608:	89 d1                	mov    %edx,%ecx
f011760a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011760c:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0117612:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117617:	b0 00                	mov    $0x0,%al
f0117619:	89 d7                	mov    %edx,%edi
f011761b:	f3 aa                	rep stos %al,%es:(%edi)
f011761d:	83 ec 0c             	sub    $0xc,%esp
f0117620:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0117626:	50                   	push   %eax
f0117627:	e8 e0 a7 fe ff       	call   f0101e0c <execute_command>
f011762c:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f011762f:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0117635:	bb 85 cc 13 f0       	mov    $0xf013cc85,%ebx
f011763a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011763f:	89 c7                	mov    %eax,%edi
f0117641:	89 de                	mov    %ebx,%esi
f0117643:	89 d1                	mov    %edx,%ecx
f0117645:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117647:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011764d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117652:	b0 00                	mov    $0x0,%al
f0117654:	89 d7                	mov    %edx,%edi
f0117656:	f3 aa                	rep stos %al,%es:(%edi)
f0117658:	83 ec 0c             	sub    $0xc,%esp
f011765b:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0117661:	50                   	push   %eax
f0117662:	e8 a5 a7 fe ff       	call   f0101e0c <execute_command>
f0117667:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f011766a:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0117671:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0117678:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f011767f:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0117686:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f011768d:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0117694:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f011769b:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01176a2:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01176a9:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f01176b0:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01176b7:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01176be:	8b 45 90             	mov    -0x70(%ebp),%eax
f01176c1:	8a 00                	mov    (%eax),%al
f01176c3:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01176c9:	e8 b8 8f ff ff       	call   f0110686 <sys_calculate_free_frames>
f01176ce:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f01176d1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01176d4:	89 d0                	mov    %edx,%eax
f01176d6:	01 c0                	add    %eax,%eax
f01176d8:	01 d0                	add    %edx,%eax
f01176da:	01 c0                	add    %eax,%eax
f01176dc:	50                   	push   %eax
f01176dd:	68 00 00 40 00       	push   $0x400000
f01176e2:	68 00 00 20 00       	push   $0x200000
f01176e7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01176ea:	e8 e6 4e ff ff       	call   f010c5d5 <copy_paste_chunk>
f01176ef:	83 c4 10             	add    $0x10,%esp
f01176f2:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01176f5:	e8 8c 8f ff ff       	call   f0110686 <sys_calculate_free_frames>
f01176fa:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01176fd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0117704:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0117708:	75 08                	jne    f0117712 <test_copy_paste_chunk+0x929>
f011770a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011770d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0117710:	74 2b                	je     f011773d <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0117712:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0117715:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0117718:	83 ec 0c             	sub    $0xc,%esp
f011771b:	50                   	push   %eax
f011771c:	ff 75 80             	pushl  -0x80(%ebp)
f011771f:	68 0c c4 13 f0       	push   $0xf013c40c
f0117724:	68 9e 03 00 00       	push   $0x39e
f0117729:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011772e:	e8 21 99 fe ff       	call   f0101054 <_warn>
f0117733:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117736:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011773d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117741:	74 04                	je     f0117747 <test_copy_paste_chunk+0x95e>
f0117743:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117747:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f011774e:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0117755:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0117758:	83 ec 08             	sub    $0x8,%esp
f011775b:	6a 01                	push   $0x1
f011775d:	6a 07                	push   $0x7
f011775f:	6a 07                	push   $0x7
f0117761:	6a 07                	push   $0x7
f0117763:	6a 07                	push   $0x7
f0117765:	6a 01                	push   $0x1
f0117767:	68 00 20 00 00       	push   $0x2000
f011776c:	68 00 00 40 00       	push   $0x400000
f0117771:	68 00 00 20 00       	push   $0x200000
f0117776:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117779:	e8 bf 32 00 00       	call   f011aa3d <CCP>
f011777e:	83 c4 30             	add    $0x30,%esp
f0117781:	83 f8 01             	cmp    $0x1,%eax
f0117784:	74 2b                	je     f01177b1 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0117786:	83 ec 04             	sub    $0x4,%esp
f0117789:	68 60 c4 13 f0       	push   $0xf013c460
f011778e:	68 a7 03 00 00       	push   $0x3a7
f0117793:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117798:	e8 b7 98 fe ff       	call   f0101054 <_warn>
f011779d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01177a0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f01177a7:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f01177ae:	00 00 00 
		}
		if (correct) eval += 5 ;
f01177b1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01177b5:	74 04                	je     f01177bb <test_copy_paste_chunk+0x9d2>
f01177b7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01177bb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f01177c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01177c5:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f01177c8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177cb:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f01177ce:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01177d1:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f01177d4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01177d7:	8a 00                	mov    (%eax),%al
f01177d9:	3c 61                	cmp    $0x61,%al
f01177db:	75 69                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f01177dd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01177e0:	8a 00                	mov    (%eax),%al
f01177e2:	3c 61                	cmp    $0x61,%al
f01177e4:	75 60                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f01177e6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01177e9:	8a 00                	mov    (%eax),%al
f01177eb:	3c 79                	cmp    $0x79,%al
f01177ed:	75 57                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f01177ef:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01177f2:	8a 00                	mov    (%eax),%al
f01177f4:	3c 62                	cmp    $0x62,%al
f01177f6:	75 4e                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f01177f8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01177fb:	8a 00                	mov    (%eax),%al
f01177fd:	3c 63                	cmp    $0x63,%al
f01177ff:	75 45                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f0117801:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117804:	8a 00                	mov    (%eax),%al
f0117806:	3c 7a                	cmp    $0x7a,%al
f0117808:	75 3c                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f011780a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011780d:	8a 00                	mov    (%eax),%al
f011780f:	3c 77                	cmp    $0x77,%al
f0117811:	75 33                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f0117813:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117816:	8a 00                	mov    (%eax),%al
f0117818:	3c 64                	cmp    $0x64,%al
f011781a:	75 2a                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f011781c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011781f:	8a 00                	mov    (%eax),%al
f0117821:	3c 65                	cmp    $0x65,%al
f0117823:	75 21                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f0117825:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117828:	8a 00                	mov    (%eax),%al
f011782a:	3c 65                	cmp    $0x65,%al
f011782c:	75 18                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f011782e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117831:	8a 00                	mov    (%eax),%al
f0117833:	3c 66                	cmp    $0x66,%al
f0117835:	75 0f                	jne    f0117846 <test_copy_paste_chunk+0xa5d>
f0117837:	8b 45 90             	mov    -0x70(%ebp),%eax
f011783a:	8a 10                	mov    (%eax),%dl
f011783c:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0117842:	38 c2                	cmp    %al,%dl
f0117844:	74 21                	je     f0117867 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0117846:	83 ec 04             	sub    $0x4,%esp
f0117849:	68 60 c3 13 f0       	push   $0xf013c360
f011784e:	68 b5 03 00 00       	push   $0x3b5
f0117853:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117858:	e8 f7 97 fe ff       	call   f0101054 <_warn>
f011785d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0117860:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0117867:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011786b:	74 04                	je     f0117871 <test_copy_paste_chunk+0xa88>
f011786d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117871:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0117878:	8b 45 98             	mov    -0x68(%ebp),%eax
f011787b:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011787e:	e8 03 8e ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117883:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0117886:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117889:	89 c2                	mov    %eax,%edx
f011788b:	01 d2                	add    %edx,%edx
f011788d:	01 d0                	add    %edx,%eax
f011788f:	50                   	push   %eax
f0117890:	68 00 08 20 00       	push   $0x200800
f0117895:	68 00 08 40 00       	push   $0x400800
f011789a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011789d:	e8 33 4d ff ff       	call   f010c5d5 <copy_paste_chunk>
f01178a2:	83 c4 10             	add    $0x10,%esp
f01178a5:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01178a8:	e8 d9 8d ff ff       	call   f0110686 <sys_calculate_free_frames>
f01178ad:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01178b0:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01178b4:	75 08                	jne    f01178be <test_copy_paste_chunk+0xad5>
f01178b6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01178b9:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01178bc:	74 2b                	je     f01178e9 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01178be:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01178c1:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01178c4:	83 ec 0c             	sub    $0xc,%esp
f01178c7:	50                   	push   %eax
f01178c8:	ff 75 80             	pushl  -0x80(%ebp)
f01178cb:	68 0c c4 13 f0       	push   $0xf013c40c
f01178d0:	68 c5 03 00 00       	push   $0x3c5
f01178d5:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01178da:	e8 75 97 fe ff       	call   f0101054 <_warn>
f01178df:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01178e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01178e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01178ed:	74 04                	je     f01178f3 <test_copy_paste_chunk+0xb0a>
f01178ef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01178f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01178fa:	83 ec 08             	sub    $0x8,%esp
f01178fd:	6a 01                	push   $0x1
f01178ff:	6a 07                	push   $0x7
f0117901:	6a 07                	push   $0x7
f0117903:	6a 07                	push   $0x7
f0117905:	6a 07                	push   $0x7
f0117907:	6a 01                	push   $0x1
f0117909:	68 00 20 00 00       	push   $0x2000
f011790e:	68 00 00 20 00       	push   $0x200000
f0117913:	68 00 00 40 00       	push   $0x400000
f0117918:	ff 75 d4             	pushl  -0x2c(%ebp)
f011791b:	e8 1d 31 00 00       	call   f011aa3d <CCP>
f0117920:	83 c4 30             	add    $0x30,%esp
f0117923:	83 f8 01             	cmp    $0x1,%eax
f0117926:	74 21                	je     f0117949 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0117928:	83 ec 04             	sub    $0x4,%esp
f011792b:	68 ac c4 13 f0       	push   $0xf013c4ac
f0117930:	68 cd 03 00 00       	push   $0x3cd
f0117935:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011793a:	e8 15 97 fe ff       	call   f0101054 <_warn>
f011793f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0117942:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0117949:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011794d:	74 04                	je     f0117953 <test_copy_paste_chunk+0xb6a>
f011794f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117953:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011795a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011795d:	8a 00                	mov    (%eax),%al
f011795f:	3c 61                	cmp    $0x61,%al
f0117961:	75 69                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f0117963:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117966:	8a 00                	mov    (%eax),%al
f0117968:	3c 61                	cmp    $0x61,%al
f011796a:	75 60                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f011796c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011796f:	8a 00                	mov    (%eax),%al
f0117971:	3c 79                	cmp    $0x79,%al
f0117973:	75 57                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f0117975:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117978:	8a 00                	mov    (%eax),%al
f011797a:	3c 62                	cmp    $0x62,%al
f011797c:	75 4e                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f011797e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117981:	8a 00                	mov    (%eax),%al
f0117983:	3c 7a                	cmp    $0x7a,%al
f0117985:	75 45                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f0117987:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011798a:	8a 00                	mov    (%eax),%al
f011798c:	3c 7a                	cmp    $0x7a,%al
f011798e:	75 3c                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0117990:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117993:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0117995:	3c 64                	cmp    $0x64,%al
f0117997:	75 33                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0117999:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011799c:	8a 00                	mov    (%eax),%al
f011799e:	3c 64                	cmp    $0x64,%al
f01179a0:	75 2a                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f01179a2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01179a5:	8a 00                	mov    (%eax),%al
f01179a7:	3c 65                	cmp    $0x65,%al
f01179a9:	75 21                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f01179ab:	8b 45 98             	mov    -0x68(%ebp),%eax
f01179ae:	8a 00                	mov    (%eax),%al
f01179b0:	3c 78                	cmp    $0x78,%al
f01179b2:	75 18                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f01179b4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01179b7:	8a 00                	mov    (%eax),%al
f01179b9:	3c 66                	cmp    $0x66,%al
f01179bb:	75 0f                	jne    f01179cc <test_copy_paste_chunk+0xbe3>
f01179bd:	8b 45 90             	mov    -0x70(%ebp),%eax
f01179c0:	8a 10                	mov    (%eax),%dl
f01179c2:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01179c8:	38 c2                	cmp    %al,%dl
f01179ca:	74 21                	je     f01179ed <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01179cc:	83 ec 04             	sub    $0x4,%esp
f01179cf:	68 60 c3 13 f0       	push   $0xf013c360
f01179d4:	68 d6 03 00 00       	push   $0x3d6
f01179d9:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01179de:	e8 71 96 fe ff       	call   f0101054 <_warn>
f01179e3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01179e6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01179ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01179f1:	74 04                	je     f01179f7 <test_copy_paste_chunk+0xc0e>
f01179f3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01179f7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f01179fe:	83 ec 0c             	sub    $0xc,%esp
f0117a01:	68 f7 c4 13 f0       	push   $0xf013c4f7
f0117a06:	e8 42 a1 fe ff       	call   f0101b4d <cprintf>
f0117a0b:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0117a0e:	83 ec 0c             	sub    $0xc,%esp
f0117a11:	68 08 c5 13 f0       	push   $0xf013c508
f0117a16:	e8 32 a1 fe ff       	call   f0101b4d <cprintf>
f0117a1b:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0117a1e:	83 ec 04             	sub    $0x4,%esp
f0117a21:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117a27:	50                   	push   %eax
f0117a28:	68 3c c5 13 f0       	push   $0xf013c53c
f0117a2d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0117a33:	50                   	push   %eax
f0117a34:	e8 24 ba 00 00       	call   f012345d <strcconcat>
f0117a39:	83 c4 10             	add    $0x10,%esp
f0117a3c:	83 ec 0c             	sub    $0xc,%esp
f0117a3f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117a45:	50                   	push   %eax
f0117a46:	e8 c1 a3 fe ff       	call   f0101e0c <execute_command>
f0117a4b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0117a4e:	83 ec 04             	sub    $0x4,%esp
f0117a51:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117a57:	50                   	push   %eax
f0117a58:	68 46 c5 13 f0       	push   $0xf013c546
f0117a5d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0117a63:	50                   	push   %eax
f0117a64:	e8 f4 b9 00 00       	call   f012345d <strcconcat>
f0117a69:	83 c4 10             	add    $0x10,%esp
f0117a6c:	83 ec 0c             	sub    $0xc,%esp
f0117a6f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117a75:	50                   	push   %eax
f0117a76:	e8 91 a3 fe ff       	call   f0101e0c <execute_command>
f0117a7b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0117a7e:	83 ec 04             	sub    $0x4,%esp
f0117a81:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117a87:	50                   	push   %eax
f0117a88:	68 50 c5 13 f0       	push   $0xf013c550
f0117a8d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0117a93:	50                   	push   %eax
f0117a94:	e8 c4 b9 00 00       	call   f012345d <strcconcat>
f0117a99:	83 c4 10             	add    $0x10,%esp
f0117a9c:	83 ec 0c             	sub    $0xc,%esp
f0117a9f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0117aa5:	50                   	push   %eax
f0117aa6:	e8 61 a3 fe ff       	call   f0101e0c <execute_command>
f0117aab:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0117aae:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0117ab4:	bb e9 cc 13 f0       	mov    $0xf013cce9,%ebx
f0117ab9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117abe:	89 c7                	mov    %eax,%edi
f0117ac0:	89 de                	mov    %ebx,%esi
f0117ac2:	89 d1                	mov    %edx,%ecx
f0117ac4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117ac6:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0117acc:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117ad1:	b0 00                	mov    $0x0,%al
f0117ad3:	89 d7                	mov    %edx,%edi
f0117ad5:	f3 aa                	rep stos %al,%es:(%edi)
f0117ad7:	83 ec 0c             	sub    $0xc,%esp
f0117ada:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0117ae0:	50                   	push   %eax
f0117ae1:	e8 26 a3 fe ff       	call   f0101e0c <execute_command>
f0117ae6:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0117ae9:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0117aef:	bb 4d cd 13 f0       	mov    $0xf013cd4d,%ebx
f0117af4:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117af9:	89 c7                	mov    %eax,%edi
f0117afb:	89 de                	mov    %ebx,%esi
f0117afd:	89 d1                	mov    %edx,%ecx
f0117aff:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117b01:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0117b07:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117b0c:	b0 00                	mov    $0x0,%al
f0117b0e:	89 d7                	mov    %edx,%edi
f0117b10:	f3 aa                	rep stos %al,%es:(%edi)
f0117b12:	83 ec 0c             	sub    $0xc,%esp
f0117b15:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0117b1b:	50                   	push   %eax
f0117b1c:	e8 eb a2 fe ff       	call   f0101e0c <execute_command>
f0117b21:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0117b24:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0117b2a:	bb b1 cd 13 f0       	mov    $0xf013cdb1,%ebx
f0117b2f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117b34:	89 c7                	mov    %eax,%edi
f0117b36:	89 de                	mov    %ebx,%esi
f0117b38:	89 d1                	mov    %edx,%ecx
f0117b3a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117b3c:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0117b42:	b9 55 00 00 00       	mov    $0x55,%ecx
f0117b47:	b0 00                	mov    $0x0,%al
f0117b49:	89 d7                	mov    %edx,%edi
f0117b4b:	f3 aa                	rep stos %al,%es:(%edi)
f0117b4d:	83 ec 0c             	sub    $0xc,%esp
f0117b50:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0117b56:	50                   	push   %eax
f0117b57:	e8 b0 a2 fe ff       	call   f0101e0c <execute_command>
f0117b5c:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0117b5f:	e8 22 8b ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117b64:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0117b67:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0117b6a:	89 d0                	mov    %edx,%eax
f0117b6c:	01 c0                	add    %eax,%eax
f0117b6e:	01 d0                	add    %edx,%eax
f0117b70:	c1 e0 02             	shl    $0x2,%eax
f0117b73:	50                   	push   %eax
f0117b74:	68 00 00 90 00       	push   $0x900000
f0117b79:	68 00 00 80 00       	push   $0x800000
f0117b7e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117b81:	e8 4f 4a ff ff       	call   f010c5d5 <copy_paste_chunk>
f0117b86:	83 c4 10             	add    $0x10,%esp
f0117b89:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0117b8f:	e8 f2 8a ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117b94:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0117b97:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0117b9e:	75 0b                	jne    f0117bab <test_copy_paste_chunk+0xdc2>
f0117ba0:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0117ba3:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0117ba6:	83 f8 03             	cmp    $0x3,%eax
f0117ba9:	74 2e                	je     f0117bd9 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0117bab:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0117bae:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0117bb1:	83 ec 0c             	sub    $0xc,%esp
f0117bb4:	50                   	push   %eax
f0117bb5:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0117bbb:	68 0c c4 13 f0       	push   $0xf013c40c
f0117bc0:	68 f4 03 00 00       	push   $0x3f4
f0117bc5:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117bca:	e8 85 94 fe ff       	call   f0101054 <_warn>
f0117bcf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117bd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0117bd9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117bdd:	74 04                	je     f0117be3 <test_copy_paste_chunk+0xdfa>
f0117bdf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117be3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0117bea:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0117bf1:	83 ec 08             	sub    $0x8,%esp
f0117bf4:	6a 01                	push   $0x1
f0117bf6:	6a 07                	push   $0x7
f0117bf8:	6a 07                	push   $0x7
f0117bfa:	6a 07                	push   $0x7
f0117bfc:	6a 07                	push   $0x7
f0117bfe:	6a 01                	push   $0x1
f0117c00:	68 00 30 00 00       	push   $0x3000
f0117c05:	68 00 00 90 00       	push   $0x900000
f0117c0a:	68 00 00 80 00       	push   $0x800000
f0117c0f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117c12:	e8 26 2e 00 00       	call   f011aa3d <CCP>
f0117c17:	83 c4 30             	add    $0x30,%esp
f0117c1a:	83 f8 01             	cmp    $0x1,%eax
f0117c1d:	74 28                	je     f0117c47 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0117c1f:	83 ec 04             	sub    $0x4,%esp
f0117c22:	68 ac c4 13 f0       	push   $0xf013c4ac
f0117c27:	68 fd 03 00 00       	push   $0x3fd
f0117c2c:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117c31:	e8 1e 94 fe ff       	call   f0101054 <_warn>
f0117c36:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0117c39:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0117c40:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0117c47:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117c4b:	74 04                	je     f0117c51 <test_copy_paste_chunk+0xe68>
f0117c4d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117c51:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0117c58:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0117c5c:	0f 84 9e 00 00 00    	je     f0117d00 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0117c62:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0117c69:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0117c70:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0117c77:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0117c7e:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0117c85:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0117c8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117c8f:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0117c92:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117c95:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0117c98:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117c9b:	8a 00                	mov    (%eax),%al
f0117c9d:	3c 61                	cmp    $0x61,%al
f0117c9f:	75 2d                	jne    f0117cce <test_copy_paste_chunk+0xee5>
f0117ca1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117ca4:	8a 00                	mov    (%eax),%al
f0117ca6:	3c 61                	cmp    $0x61,%al
f0117ca8:	75 24                	jne    f0117cce <test_copy_paste_chunk+0xee5>
f0117caa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117cad:	8a 00                	mov    (%eax),%al
f0117caf:	3c 79                	cmp    $0x79,%al
f0117cb1:	75 1b                	jne    f0117cce <test_copy_paste_chunk+0xee5>
f0117cb3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117cb6:	8a 00                	mov    (%eax),%al
f0117cb8:	3c 62                	cmp    $0x62,%al
f0117cba:	75 12                	jne    f0117cce <test_copy_paste_chunk+0xee5>
f0117cbc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117cbf:	8a 00                	mov    (%eax),%al
f0117cc1:	3c 63                	cmp    $0x63,%al
f0117cc3:	75 09                	jne    f0117cce <test_copy_paste_chunk+0xee5>
f0117cc5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117cc8:	8a 00                	mov    (%eax),%al
f0117cca:	3c 7a                	cmp    $0x7a,%al
f0117ccc:	74 21                	je     f0117cef <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0117cce:	83 ec 04             	sub    $0x4,%esp
f0117cd1:	68 60 c3 13 f0       	push   $0xf013c360
f0117cd6:	68 0f 04 00 00       	push   $0x40f
f0117cdb:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117ce0:	e8 6f 93 fe ff       	call   f0101054 <_warn>
f0117ce5:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0117ce8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0117cef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117cf3:	74 04                	je     f0117cf9 <test_copy_paste_chunk+0xf10>
f0117cf5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0117cf9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0117d00:	e8 81 89 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117d05:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0117d08:	6a 00                	push   $0x0
f0117d0a:	6a 02                	push   $0x2
f0117d0c:	68 00 10 90 00       	push   $0x901000
f0117d11:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117d14:	e8 b1 2b 00 00       	call   f011a8ca <SB>
f0117d19:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0117d1c:	6a 00                	push   $0x0
f0117d1e:	6a 02                	push   $0x2
f0117d20:	68 00 20 90 00       	push   $0x902000
f0117d25:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117d28:	e8 9d 2b 00 00       	call   f011a8ca <SB>
f0117d2d:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0117d30:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117d33:	c1 e0 03             	shl    $0x3,%eax
f0117d36:	50                   	push   %eax
f0117d37:	68 00 f0 bf 00       	push   $0xbff000
f0117d3c:	68 00 10 90 00       	push   $0x901000
f0117d41:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117d44:	e8 8c 48 ff ff       	call   f010c5d5 <copy_paste_chunk>
f0117d49:	83 c4 10             	add    $0x10,%esp
f0117d4c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0117d52:	e8 2f 89 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117d57:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0117d5a:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0117d61:	75 0b                	jne    f0117d6e <test_copy_paste_chunk+0xf85>
f0117d63:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0117d66:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0117d69:	83 f8 03             	cmp    $0x3,%eax
f0117d6c:	74 2e                	je     f0117d9c <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0117d6e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0117d71:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0117d74:	83 ec 0c             	sub    $0xc,%esp
f0117d77:	50                   	push   %eax
f0117d78:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0117d7e:	68 0c c4 13 f0       	push   $0xf013c40c
f0117d83:	68 1f 04 00 00       	push   $0x41f
f0117d88:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117d8d:	e8 c2 92 fe ff       	call   f0101054 <_warn>
f0117d92:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117d95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0117d9c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117da0:	74 04                	je     f0117da6 <test_copy_paste_chunk+0xfbd>
f0117da2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117da6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0117dad:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0117db4:	83 ec 08             	sub    $0x8,%esp
f0117db7:	6a 01                	push   $0x1
f0117db9:	6a 07                	push   $0x7
f0117dbb:	6a 03                	push   $0x3
f0117dbd:	6a 07                	push   $0x7
f0117dbf:	6a 03                	push   $0x3
f0117dc1:	6a 01                	push   $0x1
f0117dc3:	68 00 20 00 00       	push   $0x2000
f0117dc8:	68 00 f0 bf 00       	push   $0xbff000
f0117dcd:	68 00 10 90 00       	push   $0x901000
f0117dd2:	ff 75 d4             	pushl  -0x2c(%ebp)
f0117dd5:	e8 63 2c 00 00       	call   f011aa3d <CCP>
f0117dda:	83 c4 30             	add    $0x30,%esp
f0117ddd:	83 f8 01             	cmp    $0x1,%eax
f0117de0:	74 28                	je     f0117e0a <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0117de2:	83 ec 04             	sub    $0x4,%esp
f0117de5:	68 ac c4 13 f0       	push   $0xf013c4ac
f0117dea:	68 28 04 00 00       	push   $0x428
f0117def:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117df4:	e8 5b 92 fe ff       	call   f0101054 <_warn>
f0117df9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0117dfc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0117e03:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0117e0a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117e0e:	74 04                	je     f0117e14 <test_copy_paste_chunk+0x102b>
f0117e10:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117e14:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0117e1b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0117e1f:	74 72                	je     f0117e93 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0117e21:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0117e28:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0117e2f:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0117e36:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0117e3d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117e40:	8a 00                	mov    (%eax),%al
f0117e42:	3c 62                	cmp    $0x62,%al
f0117e44:	75 1b                	jne    f0117e61 <test_copy_paste_chunk+0x1078>
f0117e46:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117e49:	8a 00                	mov    (%eax),%al
f0117e4b:	3c 62                	cmp    $0x62,%al
f0117e4d:	75 12                	jne    f0117e61 <test_copy_paste_chunk+0x1078>
f0117e4f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117e52:	8a 00                	mov    (%eax),%al
f0117e54:	3c 7a                	cmp    $0x7a,%al
f0117e56:	75 09                	jne    f0117e61 <test_copy_paste_chunk+0x1078>
f0117e58:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117e5b:	8a 00                	mov    (%eax),%al
f0117e5d:	3c 7a                	cmp    $0x7a,%al
f0117e5f:	74 21                	je     f0117e82 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0117e61:	83 ec 04             	sub    $0x4,%esp
f0117e64:	68 60 c3 13 f0       	push   $0xf013c360
f0117e69:	68 34 04 00 00       	push   $0x434
f0117e6e:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0117e73:	e8 dc 91 fe ff       	call   f0101054 <_warn>
f0117e78:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0117e7b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0117e82:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117e86:	74 04                	je     f0117e8c <test_copy_paste_chunk+0x10a3>
f0117e88:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0117e8c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0117e93:	83 ec 0c             	sub    $0xc,%esp
f0117e96:	68 5a c5 13 f0       	push   $0xf013c55a
f0117e9b:	e8 ad 9c fe ff       	call   f0101b4d <cprintf>
f0117ea0:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0117ea3:	83 ec 08             	sub    $0x8,%esp
f0117ea6:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117ea9:	68 6c c5 13 f0       	push   $0xf013c56c
f0117eae:	e8 9a 9c fe ff       	call   f0101b4d <cprintf>
f0117eb3:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0117eb6:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0117eba:	75 10                	jne    f0117ecc <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0117ebc:	83 ec 0c             	sub    $0xc,%esp
f0117ebf:	68 a0 c5 13 f0       	push   $0xf013c5a0
f0117ec4:	e8 84 9c fe ff       	call   f0101b4d <cprintf>
f0117ec9:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0117ecc:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f0117ed1:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0117ed4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117ed7:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0117eda:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117edf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0117ee2:	5b                   	pop    %ebx
f0117ee3:	5e                   	pop    %esi
f0117ee4:	5f                   	pop    %edi
f0117ee5:	5d                   	pop    %ebp
f0117ee6:	c3                   	ret    

f0117ee7 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0117ee7:	55                   	push   %ebp
f0117ee8:	89 e5                	mov    %esp,%ebp
f0117eea:	57                   	push   %edi
f0117eeb:	56                   	push   %esi
f0117eec:	53                   	push   %ebx
f0117eed:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0117ef3:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0117ef9:	bb 6c c2 13 f0       	mov    $0xf013c26c,%ebx
f0117efe:	ba 0f 00 00 00       	mov    $0xf,%edx
f0117f03:	89 c7                	mov    %eax,%edi
f0117f05:	89 de                	mov    %ebx,%esi
f0117f07:	89 d1                	mov    %edx,%ecx
f0117f09:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117f0b:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0117f11:	b9 23 00 00 00       	mov    $0x23,%ecx
f0117f16:	b0 00                	mov    $0x0,%al
f0117f18:	89 d7                	mov    %edx,%edi
f0117f1a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0117f1c:	6a 00                	push   $0x0
f0117f1e:	6a 0a                	push   $0xa
f0117f20:	6a 14                	push   $0x14
f0117f22:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0117f28:	50                   	push   %eax
f0117f29:	e8 63 4b ff ff       	call   f010ca91 <env_create>
f0117f2e:	83 c4 10             	add    $0x10,%esp
f0117f31:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0117f34:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117f37:	8b 40 64             	mov    0x64(%eax),%eax
f0117f3a:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0117f3d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117f40:	8b 40 68             	mov    0x68(%eax),%eax
f0117f43:	89 45 80             	mov    %eax,-0x80(%ebp)
f0117f46:	8b 45 80             	mov    -0x80(%ebp),%eax
f0117f49:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0117f4c:	83 ec 0c             	sub    $0xc,%esp
f0117f4f:	ff 75 cc             	pushl  -0x34(%ebp)
f0117f52:	e8 b2 2a 00 00       	call   f011aa09 <ClearUserSpace>
f0117f57:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0117f5a:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0117f61:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0117f68:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0117f6f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0117f73:	83 ec 0c             	sub    $0xc,%esp
f0117f76:	68 18 ce 13 f0       	push   $0xf013ce18
f0117f7b:	e8 cd 9b fe ff       	call   f0101b4d <cprintf>
f0117f80:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0117f83:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0117f8a:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0117f91:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117f94:	8a 00                	mov    (%eax),%al
f0117f96:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0117f9c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117f9f:	8a 00                	mov    (%eax),%al
f0117fa1:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0117fa7:	e8 da 86 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117fac:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0117faf:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0117fb2:	89 d0                	mov    %edx,%eax
f0117fb4:	01 c0                	add    %eax,%eax
f0117fb6:	01 d0                	add    %edx,%eax
f0117fb8:	01 c0                	add    %eax,%eax
f0117fba:	83 ec 0c             	sub    $0xc,%esp
f0117fbd:	6a 02                	push   $0x2
f0117fbf:	50                   	push   %eax
f0117fc0:	68 00 40 10 f0       	push   $0xf0104000
f0117fc5:	68 00 00 10 f0       	push   $0xf0100000
f0117fca:	ff 75 cc             	pushl  -0x34(%ebp)
f0117fcd:	e8 1d 46 ff ff       	call   f010c5ef <share_chunk>
f0117fd2:	83 c4 20             	add    $0x20,%esp
f0117fd5:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0117fd8:	e8 a9 86 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0117fdd:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0117fe0:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0117fe4:	75 08                	jne    f0117fee <test_share_chunk+0x107>
f0117fe6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117fe9:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0117fec:	74 28                	je     f0118016 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0117fee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117ff1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0117ff4:	83 ec 0c             	sub    $0xc,%esp
f0117ff7:	50                   	push   %eax
f0117ff8:	ff 75 b0             	pushl  -0x50(%ebp)
f0117ffb:	68 44 ce 13 f0       	push   $0xf013ce44
f0118000:	68 70 04 00 00       	push   $0x470
f0118005:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011800a:	e8 45 90 fe ff       	call   f0101054 <_warn>
f011800f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118012:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118016:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011801a:	74 04                	je     f0118020 <test_share_chunk+0x139>
f011801c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0118020:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0118024:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118027:	c1 e0 03             	shl    $0x3,%eax
f011802a:	83 ec 08             	sub    $0x8,%esp
f011802d:	68 fd 00 00 00       	push   $0xfd
f0118032:	6a 07                	push   $0x7
f0118034:	6a 03                	push   $0x3
f0118036:	6a 07                	push   $0x7
f0118038:	6a 03                	push   $0x3
f011803a:	6a 01                	push   $0x1
f011803c:	50                   	push   %eax
f011803d:	68 00 40 10 f0       	push   $0xf0104000
f0118042:	68 00 00 10 f0       	push   $0xf0100000
f0118047:	ff 75 cc             	pushl  -0x34(%ebp)
f011804a:	e8 ee 29 00 00       	call   f011aa3d <CCP>
f011804f:	83 c4 30             	add    $0x30,%esp
f0118052:	85 c0                	test   %eax,%eax
f0118054:	75 1e                	jne    f0118074 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0118056:	83 ec 04             	sub    $0x4,%esp
f0118059:	68 a0 ce 13 f0       	push   $0xf013cea0
f011805e:	68 78 04 00 00       	push   $0x478
f0118063:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118068:	e8 e7 8f fe ff       	call   f0101054 <_warn>
f011806d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118070:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118074:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118078:	74 04                	je     f011807e <test_share_chunk+0x197>
f011807a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f011807e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118081:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0118084:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118087:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f011808a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011808d:	8a 00                	mov    (%eax),%al
f011808f:	3c 41                	cmp    $0x41,%al
f0118091:	75 09                	jne    f011809c <test_share_chunk+0x1b5>
f0118093:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118096:	8a 00                	mov    (%eax),%al
f0118098:	3c 42                	cmp    $0x42,%al
f011809a:	74 1e                	je     f01180ba <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011809c:	83 ec 04             	sub    $0x4,%esp
f011809f:	68 e8 ce 13 f0       	push   $0xf013cee8
f01180a4:	68 82 04 00 00       	push   $0x482
f01180a9:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01180ae:	e8 a1 8f fe ff       	call   f0101054 <_warn>
f01180b3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01180b6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01180ba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01180be:	74 04                	je     f01180c4 <test_share_chunk+0x1dd>
f01180c0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01180c4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01180c8:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f01180ce:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01180d1:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f01180d3:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f01180d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01180dc:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f01180de:	83 ec 0c             	sub    $0xc,%esp
f01180e1:	68 1d cf 13 f0       	push   $0xf013cf1d
f01180e6:	e8 62 9a fe ff       	call   f0101b4d <cprintf>
f01180eb:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f01180ee:	83 ec 0c             	sub    $0xc,%esp
f01180f1:	68 2c cf 13 f0       	push   $0xf013cf2c
f01180f6:	e8 52 9a fe ff       	call   f0101b4d <cprintf>
f01180fb:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01180fe:	e8 83 85 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118103:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0118106:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118109:	c1 e0 05             	shl    $0x5,%eax
f011810c:	83 ec 0c             	sub    $0xc,%esp
f011810f:	68 02 0e 00 00       	push   $0xe02
f0118114:	50                   	push   %eax
f0118115:	68 00 00 00 40       	push   $0x40000000
f011811a:	68 00 00 00 f0       	push   $0xf0000000
f011811f:	ff 75 cc             	pushl  -0x34(%ebp)
f0118122:	e8 c8 44 ff ff       	call   f010c5ef <share_chunk>
f0118127:	83 c4 20             	add    $0x20,%esp
f011812a:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011812d:	e8 54 85 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118132:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0118135:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0118139:	75 1f                	jne    f011815a <test_share_chunk+0x273>
f011813b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011813e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118141:	89 c1                	mov    %eax,%ecx
f0118143:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118146:	c1 e0 05             	shl    $0x5,%eax
f0118149:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011814c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0118153:	99                   	cltd   
f0118154:	f7 fb                	idiv   %ebx
f0118156:	39 c1                	cmp    %eax,%ecx
f0118158:	74 28                	je     f0118182 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011815a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011815d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118160:	83 ec 0c             	sub    $0xc,%esp
f0118163:	50                   	push   %eax
f0118164:	ff 75 a8             	pushl  -0x58(%ebp)
f0118167:	68 68 cf 13 f0       	push   $0xf013cf68
f011816c:	68 9a 04 00 00       	push   $0x49a
f0118171:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118176:	e8 d9 8e fe ff       	call   f0101054 <_warn>
f011817b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011817e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118182:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118186:	74 04                	je     f011818c <test_share_chunk+0x2a5>
f0118188:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011818c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0118190:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0118197:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011819a:	c1 e0 05             	shl    $0x5,%eax
f011819d:	83 ec 08             	sub    $0x8,%esp
f01181a0:	6a 02                	push   $0x2
f01181a2:	6a 07                	push   $0x7
f01181a4:	6a 03                	push   $0x3
f01181a6:	68 07 0e 00 00       	push   $0xe07
f01181ab:	68 03 0e 00 00       	push   $0xe03
f01181b0:	6a ff                	push   $0xffffffff
f01181b2:	50                   	push   %eax
f01181b3:	68 00 00 00 40       	push   $0x40000000
f01181b8:	68 00 00 00 f0       	push   $0xf0000000
f01181bd:	ff 75 cc             	pushl  -0x34(%ebp)
f01181c0:	e8 78 28 00 00       	call   f011aa3d <CCP>
f01181c5:	83 c4 30             	add    $0x30,%esp
f01181c8:	85 c0                	test   %eax,%eax
f01181ca:	75 25                	jne    f01181f1 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01181cc:	83 ec 04             	sub    $0x4,%esp
f01181cf:	68 a0 ce 13 f0       	push   $0xf013cea0
f01181d4:	68 a3 04 00 00       	push   $0x4a3
f01181d9:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01181de:	e8 71 8e fe ff       	call   f0101054 <_warn>
f01181e3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01181e6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01181ea:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01181f1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01181f4:	89 d0                	mov    %edx,%eax
f01181f6:	01 c0                	add    %eax,%eax
f01181f8:	01 d0                	add    %edx,%eax
f01181fa:	c1 e0 02             	shl    $0x2,%eax
f01181fd:	83 ec 08             	sub    $0x8,%esp
f0118200:	6a 02                	push   $0x2
f0118202:	6a 07                	push   $0x7
f0118204:	6a 03                	push   $0x3
f0118206:	68 07 0e 00 00       	push   $0xe07
f011820b:	68 03 0e 00 00       	push   $0xe03
f0118210:	6a 02                	push   $0x2
f0118212:	50                   	push   %eax
f0118213:	68 00 00 00 40       	push   $0x40000000
f0118218:	68 00 00 00 f0       	push   $0xf0000000
f011821d:	ff 75 cc             	pushl  -0x34(%ebp)
f0118220:	e8 18 28 00 00       	call   f011aa3d <CCP>
f0118225:	83 c4 30             	add    $0x30,%esp
f0118228:	85 c0                	test   %eax,%eax
f011822a:	75 1e                	jne    f011824a <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011822c:	83 ec 04             	sub    $0x4,%esp
f011822f:	68 a0 ce 13 f0       	push   $0xf013cea0
f0118234:	68 aa 04 00 00       	push   $0x4aa
f0118239:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011823e:	e8 11 8e fe ff       	call   f0101054 <_warn>
f0118243:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118246:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011824a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011824e:	74 04                	je     f0118254 <test_share_chunk+0x36d>
f0118250:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0118254:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0118258:	b8 d0 85 9a f1       	mov    $0xf19a85d0,%eax
f011825d:	05 00 00 00 10       	add    $0x10000000,%eax
f0118262:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0118265:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118268:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f011826d:	83 ec 08             	sub    $0x8,%esp
f0118270:	6a 02                	push   $0x2
f0118272:	6a 07                	push   $0x7
f0118274:	6a 03                	push   $0x3
f0118276:	68 07 0e 00 00       	push   $0xe07
f011827b:	68 03 0e 00 00       	push   $0xe03
f0118280:	6a 02                	push   $0x2
f0118282:	50                   	push   %eax
f0118283:	68 00 00 0a 40       	push   $0x400a0000
f0118288:	68 00 00 0a f0       	push   $0xf00a0000
f011828d:	ff 75 cc             	pushl  -0x34(%ebp)
f0118290:	e8 a8 27 00 00       	call   f011aa3d <CCP>
f0118295:	83 c4 30             	add    $0x30,%esp
f0118298:	85 c0                	test   %eax,%eax
f011829a:	75 1e                	jne    f01182ba <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011829c:	83 ec 04             	sub    $0x4,%esp
f011829f:	68 a0 ce 13 f0       	push   $0xf013cea0
f01182a4:	68 b4 04 00 00       	push   $0x4b4
f01182a9:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01182ae:	e8 a1 8d fe ff       	call   f0101054 <_warn>
f01182b3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01182b6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01182ba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01182be:	74 04                	je     f01182c4 <test_share_chunk+0x3dd>
f01182c0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01182c4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01182c8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01182cc:	0f 84 a4 00 00 00    	je     f0118376 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f01182d2:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f01182d9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01182dc:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f01182df:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f01182e6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01182e9:	8a 00                	mov    (%eax),%al
f01182eb:	3c 41                	cmp    $0x41,%al
f01182ed:	75 09                	jne    f01182f8 <test_share_chunk+0x411>
f01182ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01182f2:	8a 00                	mov    (%eax),%al
f01182f4:	3c 41                	cmp    $0x41,%al
f01182f6:	74 1e                	je     f0118316 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01182f8:	83 ec 04             	sub    $0x4,%esp
f01182fb:	68 e8 ce 13 f0       	push   $0xf013cee8
f0118300:	68 c1 04 00 00       	push   $0x4c1
f0118305:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011830a:	e8 45 8d fe ff       	call   f0101054 <_warn>
f011830f:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0118312:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0118316:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011831a:	74 04                	je     f0118320 <test_share_chunk+0x439>
f011831c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0118320:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0118324:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f011832b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011832e:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0118331:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0118338:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011833b:	8a 00                	mov    (%eax),%al
f011833d:	3c 43                	cmp    $0x43,%al
f011833f:	75 09                	jne    f011834a <test_share_chunk+0x463>
f0118341:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118344:	8a 00                	mov    (%eax),%al
f0118346:	3c 43                	cmp    $0x43,%al
f0118348:	74 1e                	je     f0118368 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011834a:	83 ec 04             	sub    $0x4,%esp
f011834d:	68 e8 ce 13 f0       	push   $0xf013cee8
f0118352:	68 cc 04 00 00       	push   $0x4cc
f0118357:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011835c:	e8 f3 8c fe ff       	call   f0101054 <_warn>
f0118361:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0118364:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0118368:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011836c:	74 04                	je     f0118372 <test_share_chunk+0x48b>
f011836e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0118372:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0118376:	83 ec 0c             	sub    $0xc,%esp
f0118379:	68 f7 c4 13 f0       	push   $0xf013c4f7
f011837e:	e8 ca 97 fe ff       	call   f0101b4d <cprintf>
f0118383:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0118386:	83 ec 0c             	sub    $0xc,%esp
f0118389:	68 b8 cf 13 f0       	push   $0xf013cfb8
f011838e:	e8 ba 97 fe ff       	call   f0101b4d <cprintf>
f0118393:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118396:	e8 eb 82 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011839b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f011839e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01183a1:	89 d0                	mov    %edx,%eax
f01183a3:	c1 e0 03             	shl    $0x3,%eax
f01183a6:	01 d0                	add    %edx,%eax
f01183a8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01183af:	01 d0                	add    %edx,%eax
f01183b1:	c1 e0 03             	shl    $0x3,%eax
f01183b4:	83 ec 0c             	sub    $0xc,%esp
f01183b7:	6a 06                	push   $0x6
f01183b9:	50                   	push   %eax
f01183ba:	6a 00                	push   $0x0
f01183bc:	68 00 00 00 40       	push   $0x40000000
f01183c1:	ff 75 cc             	pushl  -0x34(%ebp)
f01183c4:	e8 26 42 ff ff       	call   f010c5ef <share_chunk>
f01183c9:	83 c4 20             	add    $0x20,%esp
f01183cc:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01183cf:	e8 b2 82 ff ff       	call   f0110686 <sys_calculate_free_frames>
f01183d4:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01183d7:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f01183db:	75 0b                	jne    f01183e8 <test_share_chunk+0x501>
f01183dd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01183e0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01183e3:	83 f8 01             	cmp    $0x1,%eax
f01183e6:	74 28                	je     f0118410 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01183e8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01183eb:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01183ee:	83 ec 0c             	sub    $0xc,%esp
f01183f1:	50                   	push   %eax
f01183f2:	ff 75 a0             	pushl  -0x60(%ebp)
f01183f5:	68 68 cf 13 f0       	push   $0xf013cf68
f01183fa:	68 e2 04 00 00       	push   $0x4e2
f01183ff:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118404:	e8 4b 8c fe ff       	call   f0101054 <_warn>
f0118409:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011840c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118410:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118414:	74 04                	je     f011841a <test_share_chunk+0x533>
f0118416:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011841a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011841e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0118425:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118428:	05 00 80 02 00       	add    $0x28000,%eax
f011842d:	c1 e0 02             	shl    $0x2,%eax
f0118430:	83 ec 08             	sub    $0x8,%esp
f0118433:	6a 02                	push   $0x2
f0118435:	6a 07                	push   $0x7
f0118437:	6a 03                	push   $0x3
f0118439:	6a 07                	push   $0x7
f011843b:	6a 07                	push   $0x7
f011843d:	6a ff                	push   $0xffffffff
f011843f:	50                   	push   %eax
f0118440:	6a 00                	push   $0x0
f0118442:	68 00 00 00 40       	push   $0x40000000
f0118447:	ff 75 cc             	pushl  -0x34(%ebp)
f011844a:	e8 ee 25 00 00       	call   f011aa3d <CCP>
f011844f:	83 c4 30             	add    $0x30,%esp
f0118452:	85 c0                	test   %eax,%eax
f0118454:	75 25                	jne    f011847b <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0118456:	83 ec 04             	sub    $0x4,%esp
f0118459:	68 a0 ce 13 f0       	push   $0xf013cea0
f011845e:	68 eb 04 00 00       	push   $0x4eb
f0118463:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118468:	e8 e7 8b fe ff       	call   f0101054 <_warn>
f011846d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118470:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0118474:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011847b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011847e:	89 d0                	mov    %edx,%eax
f0118480:	01 c0                	add    %eax,%eax
f0118482:	01 d0                	add    %edx,%eax
f0118484:	c1 e0 02             	shl    $0x2,%eax
f0118487:	83 ec 08             	sub    $0x8,%esp
f011848a:	6a 02                	push   $0x2
f011848c:	6a 07                	push   $0x7
f011848e:	6a 03                	push   $0x3
f0118490:	6a 07                	push   $0x7
f0118492:	6a 07                	push   $0x7
f0118494:	6a 03                	push   $0x3
f0118496:	50                   	push   %eax
f0118497:	6a 00                	push   $0x0
f0118499:	68 00 00 00 40       	push   $0x40000000
f011849e:	ff 75 cc             	pushl  -0x34(%ebp)
f01184a1:	e8 97 25 00 00       	call   f011aa3d <CCP>
f01184a6:	83 c4 30             	add    $0x30,%esp
f01184a9:	85 c0                	test   %eax,%eax
f01184ab:	75 1e                	jne    f01184cb <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01184ad:	83 ec 04             	sub    $0x4,%esp
f01184b0:	68 a0 ce 13 f0       	push   $0xf013cea0
f01184b5:	68 f2 04 00 00       	push   $0x4f2
f01184ba:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01184bf:	e8 90 8b fe ff       	call   f0101054 <_warn>
f01184c4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01184c7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01184cb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01184cf:	74 04                	je     f01184d5 <test_share_chunk+0x5ee>
f01184d1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01184d5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01184d9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01184dc:	89 d0                	mov    %edx,%eax
f01184de:	01 c0                	add    %eax,%eax
f01184e0:	01 d0                	add    %edx,%eax
f01184e2:	c1 e0 02             	shl    $0x2,%eax
f01184e5:	f7 d8                	neg    %eax
f01184e7:	05 00 00 0a 00       	add    $0xa0000,%eax
f01184ec:	83 ec 08             	sub    $0x8,%esp
f01184ef:	6a 02                	push   $0x2
f01184f1:	6a 07                	push   $0x7
f01184f3:	6a 03                	push   $0x3
f01184f5:	6a 07                	push   $0x7
f01184f7:	6a 07                	push   $0x7
f01184f9:	6a 02                	push   $0x2
f01184fb:	50                   	push   %eax
f01184fc:	68 00 30 00 00       	push   $0x3000
f0118501:	68 00 30 00 40       	push   $0x40003000
f0118506:	ff 75 cc             	pushl  -0x34(%ebp)
f0118509:	e8 2f 25 00 00       	call   f011aa3d <CCP>
f011850e:	83 c4 30             	add    $0x30,%esp
f0118511:	85 c0                	test   %eax,%eax
f0118513:	75 1e                	jne    f0118533 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0118515:	83 ec 04             	sub    $0x4,%esp
f0118518:	68 a0 ce 13 f0       	push   $0xf013cea0
f011851d:	68 fa 04 00 00       	push   $0x4fa
f0118522:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118527:	e8 28 8b fe ff       	call   f0101054 <_warn>
f011852c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011852f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118533:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118537:	74 04                	je     f011853d <test_share_chunk+0x656>
f0118539:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011853d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0118541:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118544:	c1 e0 02             	shl    $0x2,%eax
f0118547:	83 ec 08             	sub    $0x8,%esp
f011854a:	6a 02                	push   $0x2
f011854c:	6a 07                	push   $0x7
f011854e:	6a 03                	push   $0x3
f0118550:	6a 07                	push   $0x7
f0118552:	6a 07                	push   $0x7
f0118554:	6a 03                	push   $0x3
f0118556:	50                   	push   %eax
f0118557:	68 00 00 0a 00       	push   $0xa0000
f011855c:	68 00 00 0a 40       	push   $0x400a0000
f0118561:	ff 75 cc             	pushl  -0x34(%ebp)
f0118564:	e8 d4 24 00 00       	call   f011aa3d <CCP>
f0118569:	83 c4 30             	add    $0x30,%esp
f011856c:	85 c0                	test   %eax,%eax
f011856e:	75 1e                	jne    f011858e <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0118570:	83 ec 04             	sub    $0x4,%esp
f0118573:	68 a0 ce 13 f0       	push   $0xf013cea0
f0118578:	68 02 05 00 00       	push   $0x502
f011857d:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118582:	e8 cd 8a fe ff       	call   f0101054 <_warn>
f0118587:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011858a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011858e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118592:	74 04                	je     f0118598 <test_share_chunk+0x6b1>
f0118594:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0118598:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011859c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01185a0:	0f 84 92 00 00 00    	je     f0118638 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01185a6:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f01185ad:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01185b4:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01185bb:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01185c2:	8b 45 98             	mov    -0x68(%ebp),%eax
f01185c5:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01185c8:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f01185cf:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01185d6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01185d9:	8a 00                	mov    (%eax),%al
f01185db:	3c 41                	cmp    $0x41,%al
f01185dd:	75 2d                	jne    f011860c <test_share_chunk+0x725>
f01185df:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01185e2:	8a 00                	mov    (%eax),%al
f01185e4:	3c 41                	cmp    $0x41,%al
f01185e6:	75 24                	jne    f011860c <test_share_chunk+0x725>
f01185e8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01185eb:	8a 00                	mov    (%eax),%al
f01185ed:	3c 41                	cmp    $0x41,%al
f01185ef:	75 1b                	jne    f011860c <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01185f1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01185f4:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01185f6:	3c 44                	cmp    $0x44,%al
f01185f8:	75 12                	jne    f011860c <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01185fa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01185fd:	8a 00                	mov    (%eax),%al
f01185ff:	3c 44                	cmp    $0x44,%al
f0118601:	75 09                	jne    f011860c <test_share_chunk+0x725>
f0118603:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118606:	8a 00                	mov    (%eax),%al
f0118608:	3c 44                	cmp    $0x44,%al
f011860a:	74 1e                	je     f011862a <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011860c:	83 ec 04             	sub    $0x4,%esp
f011860f:	68 e8 ce 13 f0       	push   $0xf013cee8
f0118614:	68 14 05 00 00       	push   $0x514
f0118619:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011861e:	e8 31 8a fe ff       	call   f0101054 <_warn>
f0118623:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0118626:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011862a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011862e:	74 04                	je     f0118634 <test_share_chunk+0x74d>
f0118630:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0118634:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0118638:	83 ec 0c             	sub    $0xc,%esp
f011863b:	68 5a c5 13 f0       	push   $0xf013c55a
f0118640:	e8 08 95 fe ff       	call   f0101b4d <cprintf>
f0118645:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0118648:	83 ec 0c             	sub    $0xc,%esp
f011864b:	68 f4 cf 13 f0       	push   $0xf013cff4
f0118650:	e8 f8 94 fe ff       	call   f0101b4d <cprintf>
f0118655:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118658:	e8 29 80 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011865d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0118660:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118663:	89 d0                	mov    %edx,%eax
f0118665:	01 c0                	add    %eax,%eax
f0118667:	01 d0                	add    %edx,%eax
f0118669:	01 c0                	add    %eax,%eax
f011866b:	01 d0                	add    %edx,%eax
f011866d:	83 ec 0c             	sub    $0xc,%esp
f0118670:	6a 04                	push   $0x4
f0118672:	50                   	push   %eax
f0118673:	68 00 fc 3f 00       	push   $0x3ffc00
f0118678:	68 00 fc 09 00       	push   $0x9fc00
f011867d:	ff 75 cc             	pushl  -0x34(%ebp)
f0118680:	e8 6a 3f ff ff       	call   f010c5ef <share_chunk>
f0118685:	83 c4 20             	add    $0x20,%esp
f0118688:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011868b:	e8 f6 7f ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118690:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0118693:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0118697:	75 0b                	jne    f01186a4 <test_share_chunk+0x7bd>
f0118699:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011869c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011869f:	83 f8 01             	cmp    $0x1,%eax
f01186a2:	74 28                	je     f01186cc <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01186a4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01186a7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01186aa:	83 ec 0c             	sub    $0xc,%esp
f01186ad:	50                   	push   %eax
f01186ae:	ff 75 8c             	pushl  -0x74(%ebp)
f01186b1:	68 68 cf 13 f0       	push   $0xf013cf68
f01186b6:	68 2a 05 00 00       	push   $0x52a
f01186bb:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01186c0:	e8 8f 89 fe ff       	call   f0101054 <_warn>
f01186c5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01186c8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01186cc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01186d0:	74 04                	je     f01186d6 <test_share_chunk+0x7ef>
f01186d2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01186d6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01186da:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01186e1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01186e4:	89 d0                	mov    %edx,%eax
f01186e6:	01 c0                	add    %eax,%eax
f01186e8:	01 d0                	add    %edx,%eax
f01186ea:	c1 e0 02             	shl    $0x2,%eax
f01186ed:	83 ec 08             	sub    $0x8,%esp
f01186f0:	6a 02                	push   $0x2
f01186f2:	6a 07                	push   $0x7
f01186f4:	6a 07                	push   $0x7
f01186f6:	6a 07                	push   $0x7
f01186f8:	6a 05                	push   $0x5
f01186fa:	6a ff                	push   $0xffffffff
f01186fc:	50                   	push   %eax
f01186fd:	68 00 f0 3f 00       	push   $0x3ff000
f0118702:	68 00 f0 09 00       	push   $0x9f000
f0118707:	ff 75 cc             	pushl  -0x34(%ebp)
f011870a:	e8 2e 23 00 00       	call   f011aa3d <CCP>
f011870f:	83 c4 30             	add    $0x30,%esp
f0118712:	85 c0                	test   %eax,%eax
f0118714:	75 25                	jne    f011873b <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0118716:	83 ec 04             	sub    $0x4,%esp
f0118719:	68 a0 ce 13 f0       	push   $0xf013cea0
f011871e:	68 33 05 00 00       	push   $0x533
f0118723:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118728:	e8 27 89 fe ff       	call   f0101054 <_warn>
f011872d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118730:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0118734:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f011873b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011873f:	74 04                	je     f0118745 <test_share_chunk+0x85e>
f0118741:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0118745:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0118749:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011874c:	c1 e0 02             	shl    $0x2,%eax
f011874f:	83 ec 08             	sub    $0x8,%esp
f0118752:	6a 02                	push   $0x2
f0118754:	6a 07                	push   $0x7
f0118756:	6a 07                	push   $0x7
f0118758:	6a 07                	push   $0x7
f011875a:	6a 05                	push   $0x5
f011875c:	6a 03                	push   $0x3
f011875e:	50                   	push   %eax
f011875f:	68 00 f0 3f 00       	push   $0x3ff000
f0118764:	68 00 f0 09 00       	push   $0x9f000
f0118769:	ff 75 cc             	pushl  -0x34(%ebp)
f011876c:	e8 cc 22 00 00       	call   f011aa3d <CCP>
f0118771:	83 c4 30             	add    $0x30,%esp
f0118774:	85 c0                	test   %eax,%eax
f0118776:	75 1e                	jne    f0118796 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0118778:	83 ec 04             	sub    $0x4,%esp
f011877b:	68 a0 ce 13 f0       	push   $0xf013cea0
f0118780:	68 3c 05 00 00       	push   $0x53c
f0118785:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011878a:	e8 c5 88 fe ff       	call   f0101054 <_warn>
f011878f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118792:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118796:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011879a:	74 04                	je     f01187a0 <test_share_chunk+0x8b9>
f011879c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01187a0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01187a4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01187a7:	c1 e0 03             	shl    $0x3,%eax
f01187aa:	83 ec 08             	sub    $0x8,%esp
f01187ad:	6a 02                	push   $0x2
f01187af:	6a 07                	push   $0x7
f01187b1:	6a 07                	push   $0x7
f01187b3:	6a 07                	push   $0x7
f01187b5:	6a 05                	push   $0x5
f01187b7:	6a 04                	push   $0x4
f01187b9:	50                   	push   %eax
f01187ba:	68 00 00 40 00       	push   $0x400000
f01187bf:	68 00 00 0a 00       	push   $0xa0000
f01187c4:	ff 75 cc             	pushl  -0x34(%ebp)
f01187c7:	e8 71 22 00 00       	call   f011aa3d <CCP>
f01187cc:	83 c4 30             	add    $0x30,%esp
f01187cf:	85 c0                	test   %eax,%eax
f01187d1:	75 1e                	jne    f01187f1 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01187d3:	83 ec 04             	sub    $0x4,%esp
f01187d6:	68 a0 ce 13 f0       	push   $0xf013cea0
f01187db:	68 44 05 00 00       	push   $0x544
f01187e0:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01187e5:	e8 6a 88 fe ff       	call   f0101054 <_warn>
f01187ea:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01187ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01187f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01187f5:	74 04                	je     f01187fb <test_share_chunk+0x914>
f01187f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01187fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01187ff:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0118803:	0f 84 b2 00 00 00    	je     f01188bb <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0118809:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0118810:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0118817:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f011881e:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0118825:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f011882c:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0118833:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f011883a:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0118841:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118844:	8a 00                	mov    (%eax),%al
f0118846:	3c 44                	cmp    $0x44,%al
f0118848:	75 45                	jne    f011888f <test_share_chunk+0x9a8>
f011884a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011884d:	8a 00                	mov    (%eax),%al
f011884f:	3c 44                	cmp    $0x44,%al
f0118851:	75 3c                	jne    f011888f <test_share_chunk+0x9a8>
f0118853:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118856:	8a 00                	mov    (%eax),%al
f0118858:	3c 44                	cmp    $0x44,%al
f011885a:	75 33                	jne    f011888f <test_share_chunk+0x9a8>
f011885c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011885f:	8a 00                	mov    (%eax),%al
f0118861:	3c 44                	cmp    $0x44,%al
f0118863:	75 2a                	jne    f011888f <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0118865:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0118868:	8a 10                	mov    (%eax),%dl
f011886a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011886d:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f011886f:	38 c2                	cmp    %al,%dl
f0118871:	75 1c                	jne    f011888f <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0118873:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0118876:	8a 10                	mov    (%eax),%dl
f0118878:	8b 45 88             	mov    -0x78(%ebp),%eax
f011887b:	8a 00                	mov    (%eax),%al
f011887d:	38 c2                	cmp    %al,%dl
f011887f:	75 0e                	jne    f011888f <test_share_chunk+0x9a8>
f0118881:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0118884:	8a 10                	mov    (%eax),%dl
f0118886:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0118889:	8a 00                	mov    (%eax),%al
f011888b:	38 c2                	cmp    %al,%dl
f011888d:	74 1e                	je     f01188ad <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011888f:	83 ec 04             	sub    $0x4,%esp
f0118892:	68 e8 ce 13 f0       	push   $0xf013cee8
f0118897:	68 59 05 00 00       	push   $0x559
f011889c:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01188a1:	e8 ae 87 fe ff       	call   f0101054 <_warn>
f01188a6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01188a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01188ad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01188b1:	74 04                	je     f01188b7 <test_share_chunk+0x9d0>
f01188b3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01188b7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f01188bb:	83 ec 0c             	sub    $0xc,%esp
f01188be:	68 2c d0 13 f0       	push   $0xf013d02c
f01188c3:	e8 85 92 fe ff       	call   f0101b4d <cprintf>
f01188c8:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f01188cb:	83 ec 08             	sub    $0x8,%esp
f01188ce:	ff 75 e4             	pushl  -0x1c(%ebp)
f01188d1:	68 3c d0 13 f0       	push   $0xf013d03c
f01188d6:	e8 72 92 fe ff       	call   f0101b4d <cprintf>
f01188db:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01188de:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01188e2:	75 10                	jne    f01188f4 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01188e4:	83 ec 0c             	sub    $0xc,%esp
f01188e7:	68 6c d0 13 f0       	push   $0xf013d06c
f01188ec:	e8 5c 92 fe ff       	call   f0101b4d <cprintf>
f01188f1:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01188f4:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f01188f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01188fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01188ff:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0118902:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0118907:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011890a:	5b                   	pop    %ebx
f011890b:	5e                   	pop    %esi
f011890c:	5f                   	pop    %edi
f011890d:	5d                   	pop    %ebp
f011890e:	c3                   	ret    

f011890f <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f011890f:	55                   	push   %ebp
f0118910:	89 e5                	mov    %esp,%ebp
f0118912:	57                   	push   %edi
f0118913:	56                   	push   %esi
f0118914:	53                   	push   %ebx
f0118915:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011891b:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0118921:	bb 6c c2 13 f0       	mov    $0xf013c26c,%ebx
f0118926:	ba 0f 00 00 00       	mov    $0xf,%edx
f011892b:	89 c7                	mov    %eax,%edi
f011892d:	89 de                	mov    %ebx,%esi
f011892f:	89 d1                	mov    %edx,%ecx
f0118931:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0118933:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0118939:	b9 23 00 00 00       	mov    $0x23,%ecx
f011893e:	b0 00                	mov    $0x0,%al
f0118940:	89 d7                	mov    %edx,%edi
f0118942:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0118944:	6a 00                	push   $0x0
f0118946:	6a 0a                	push   $0xa
f0118948:	6a 14                	push   $0x14
f011894a:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0118950:	50                   	push   %eax
f0118951:	e8 3b 41 ff ff       	call   f010ca91 <env_create>
f0118956:	83 c4 10             	add    $0x10,%esp
f0118959:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011895c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011895f:	8b 40 64             	mov    0x64(%eax),%eax
f0118962:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0118965:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118968:	8b 40 68             	mov    0x68(%eax),%eax
f011896b:	89 45 90             	mov    %eax,-0x70(%ebp)
f011896e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118971:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0118974:	83 ec 0c             	sub    $0xc,%esp
f0118977:	ff 75 cc             	pushl  -0x34(%ebp)
f011897a:	e8 8a 20 00 00       	call   f011aa09 <ClearUserSpace>
f011897f:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0118982:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0118989:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0118990:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0118997:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f011899b:	83 ec 0c             	sub    $0xc,%esp
f011899e:	68 a8 d0 13 f0       	push   $0xf013d0a8
f01189a3:	e8 a5 91 fe ff       	call   f0101b4d <cprintf>
f01189a8:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f01189ab:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f01189b2:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f01189b9:	eb 03                	jmp    f01189be <test_allocate_chunk+0xaf>
f01189bb:	ff 4d e4             	decl   -0x1c(%ebp)
f01189be:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01189c5:	76 09                	jbe    f01189d0 <test_allocate_chunk+0xc1>
f01189c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01189ca:	8a 00                	mov    (%eax),%al
f01189cc:	84 c0                	test   %al,%al
f01189ce:	74 eb                	je     f01189bb <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f01189d0:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01189d7:	75 06                	jne    f01189df <test_allocate_chunk+0xd0>
f01189d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01189dc:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01189df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01189e2:	8a 00                	mov    (%eax),%al
f01189e4:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01189ea:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01189ed:	8a 00                	mov    (%eax),%al
f01189ef:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f01189f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01189f8:	8a 00                	mov    (%eax),%al
f01189fa:	0f be c0             	movsbl %al,%eax
f01189fd:	83 ec 08             	sub    $0x8,%esp
f0118a00:	50                   	push   %eax
f0118a01:	68 d2 d0 13 f0       	push   $0xf013d0d2
f0118a06:	e8 42 91 fe ff       	call   f0101b4d <cprintf>
f0118a0b:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0118a0e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118a11:	8a 00                	mov    (%eax),%al
f0118a13:	0f be c0             	movsbl %al,%eax
f0118a16:	83 ec 08             	sub    $0x8,%esp
f0118a19:	50                   	push   %eax
f0118a1a:	68 de d0 13 f0       	push   $0xf013d0de
f0118a1f:	e8 29 91 fe ff       	call   f0101b4d <cprintf>
f0118a24:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0118a27:	83 ec 08             	sub    $0x8,%esp
f0118a2a:	68 00 f0 bf ef       	push   $0xefbff000
f0118a2f:	ff 75 cc             	pushl  -0x34(%ebp)
f0118a32:	e8 b3 1f 00 00       	call   f011a9ea <GP>
f0118a37:	83 c4 10             	add    $0x10,%esp
f0118a3a:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118a3d:	e8 44 7c ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118a42:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0118a45:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118a48:	c1 e0 02             	shl    $0x2,%eax
f0118a4b:	6a 02                	push   $0x2
f0118a4d:	50                   	push   %eax
f0118a4e:	68 00 f0 bf ef       	push   $0xefbff000
f0118a53:	ff 75 cc             	pushl  -0x34(%ebp)
f0118a56:	e8 ae 3b ff ff       	call   f010c609 <allocate_chunk>
f0118a5b:	83 c4 10             	add    $0x10,%esp
f0118a5e:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0118a61:	e8 20 7c ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118a66:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0118a69:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0118a6d:	75 08                	jne    f0118a77 <test_allocate_chunk+0x168>
f0118a6f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118a72:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0118a75:	74 2a                	je     f0118aa1 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0118a77:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118a7a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118a7d:	83 ec 08             	sub    $0x8,%esp
f0118a80:	6a 00                	push   $0x0
f0118a82:	50                   	push   %eax
f0118a83:	ff 75 b0             	pushl  -0x50(%ebp)
f0118a86:	68 ec d0 13 f0       	push   $0xf013d0ec
f0118a8b:	68 99 05 00 00       	push   $0x599
f0118a90:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118a95:	e8 ba 85 fe ff       	call   f0101054 <_warn>
f0118a9a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118a9d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0118aa1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118aa5:	74 04                	je     f0118aab <test_allocate_chunk+0x19c>
f0118aa7:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0118aab:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118aaf:	e8 d2 7b ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118ab4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0118ab7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118aba:	01 c0                	add    %eax,%eax
f0118abc:	89 c1                	mov    %eax,%ecx
f0118abe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118ac1:	89 d0                	mov    %edx,%eax
f0118ac3:	c1 e0 02             	shl    $0x2,%eax
f0118ac6:	01 d0                	add    %edx,%eax
f0118ac8:	f7 d8                	neg    %eax
f0118aca:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0118acf:	6a 02                	push   $0x2
f0118ad1:	51                   	push   %ecx
f0118ad2:	50                   	push   %eax
f0118ad3:	ff 75 cc             	pushl  -0x34(%ebp)
f0118ad6:	e8 2e 3b ff ff       	call   f010c609 <allocate_chunk>
f0118adb:	83 c4 10             	add    $0x10,%esp
f0118ade:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0118ae1:	e8 a0 7b ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118ae6:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0118ae9:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0118aed:	75 08                	jne    f0118af7 <test_allocate_chunk+0x1e8>
f0118aef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118af2:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0118af5:	74 2a                	je     f0118b21 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0118af7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118afa:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118afd:	83 ec 08             	sub    $0x8,%esp
f0118b00:	6a 00                	push   $0x0
f0118b02:	50                   	push   %eax
f0118b03:	ff 75 b0             	pushl  -0x50(%ebp)
f0118b06:	68 ec d0 13 f0       	push   $0xf013d0ec
f0118b0b:	68 a7 05 00 00       	push   $0x5a7
f0118b10:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118b15:	e8 3a 85 fe ff       	call   f0101054 <_warn>
f0118b1a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118b1d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0118b21:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118b25:	74 04                	je     f0118b2b <test_allocate_chunk+0x21c>
f0118b27:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0118b2b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0118b2f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118b32:	c1 e0 02             	shl    $0x2,%eax
f0118b35:	83 ec 08             	sub    $0x8,%esp
f0118b38:	6a 03                	push   $0x3
f0118b3a:	6a 00                	push   $0x0
f0118b3c:	6a 00                	push   $0x0
f0118b3e:	68 ff 0f 00 00       	push   $0xfff
f0118b43:	ff 75 b8             	pushl  -0x48(%ebp)
f0118b46:	6a 01                	push   $0x1
f0118b48:	50                   	push   %eax
f0118b49:	68 00 f0 bf ef       	push   $0xefbff000
f0118b4e:	6a 00                	push   $0x0
f0118b50:	ff 75 cc             	pushl  -0x34(%ebp)
f0118b53:	e8 e5 1e 00 00       	call   f011aa3d <CCP>
f0118b58:	83 c4 30             	add    $0x30,%esp
f0118b5b:	85 c0                	test   %eax,%eax
f0118b5d:	75 1e                	jne    f0118b7d <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0118b5f:	83 ec 04             	sub    $0x4,%esp
f0118b62:	68 54 d1 13 f0       	push   $0xf013d154
f0118b67:	68 af 05 00 00       	push   $0x5af
f0118b6c:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118b71:	e8 de 84 fe ff       	call   f0101054 <_warn>
f0118b76:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118b79:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0118b7d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118b81:	74 04                	je     f0118b87 <test_allocate_chunk+0x278>
f0118b83:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0118b87:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0118b8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118b8e:	8a 10                	mov    (%eax),%dl
f0118b90:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0118b96:	38 c2                	cmp    %al,%dl
f0118b98:	75 0f                	jne    f0118ba9 <test_allocate_chunk+0x29a>
f0118b9a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118b9d:	8a 10                	mov    (%eax),%dl
f0118b9f:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0118ba5:	38 c2                	cmp    %al,%dl
f0118ba7:	74 1e                	je     f0118bc7 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0118ba9:	83 ec 04             	sub    $0x4,%esp
f0118bac:	68 a0 d1 13 f0       	push   $0xf013d1a0
f0118bb1:	68 b7 05 00 00       	push   $0x5b7
f0118bb6:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118bbb:	e8 94 84 fe ff       	call   f0101054 <_warn>
f0118bc0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118bc3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0118bc7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118bcb:	74 04                	je     f0118bd1 <test_allocate_chunk+0x2c2>
f0118bcd:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0118bd1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0118bd5:	83 ec 0c             	sub    $0xc,%esp
f0118bd8:	68 1d cf 13 f0       	push   $0xf013cf1d
f0118bdd:	e8 6b 8f fe ff       	call   f0101b4d <cprintf>
f0118be2:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0118be5:	83 ec 0c             	sub    $0xc,%esp
f0118be8:	68 d8 d1 13 f0       	push   $0xf013d1d8
f0118bed:	e8 5b 8f fe ff       	call   f0101b4d <cprintf>
f0118bf2:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118bf5:	e8 8c 7a ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118bfa:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0118bfd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c00:	c1 e0 05             	shl    $0x5,%eax
f0118c03:	68 02 0e 00 00       	push   $0xe02
f0118c08:	50                   	push   %eax
f0118c09:	6a 00                	push   $0x0
f0118c0b:	ff 75 cc             	pushl  -0x34(%ebp)
f0118c0e:	e8 f6 39 ff ff       	call   f010c609 <allocate_chunk>
f0118c13:	83 c4 10             	add    $0x10,%esp
f0118c16:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0118c19:	e8 68 7a ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118c1e:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0118c21:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0118c25:	75 36                	jne    f0118c5d <test_allocate_chunk+0x34e>
f0118c27:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118c2a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118c2d:	89 c1                	mov    %eax,%ecx
f0118c2f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c32:	c1 e0 05             	shl    $0x5,%eax
f0118c35:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118c38:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0118c3f:	99                   	cltd   
f0118c40:	f7 fe                	idiv   %esi
f0118c42:	89 c3                	mov    %eax,%ebx
f0118c44:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c47:	c1 e0 05             	shl    $0x5,%eax
f0118c4a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118c4d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0118c54:	99                   	cltd   
f0118c55:	f7 fe                	idiv   %esi
f0118c57:	01 d8                	add    %ebx,%eax
f0118c59:	39 c1                	cmp    %eax,%ecx
f0118c5b:	74 54                	je     f0118cb1 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0118c5d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c60:	c1 e0 05             	shl    $0x5,%eax
f0118c63:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118c66:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0118c6d:	99                   	cltd   
f0118c6e:	f7 ff                	idiv   %edi
f0118c70:	89 c1                	mov    %eax,%ecx
f0118c72:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c75:	c1 e0 05             	shl    $0x5,%eax
f0118c78:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118c7b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0118c82:	99                   	cltd   
f0118c83:	f7 fe                	idiv   %esi
f0118c85:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0118c88:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118c8b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118c8e:	83 ec 08             	sub    $0x8,%esp
f0118c91:	52                   	push   %edx
f0118c92:	50                   	push   %eax
f0118c93:	ff 75 a8             	pushl  -0x58(%ebp)
f0118c96:	68 18 d2 13 f0       	push   $0xf013d218
f0118c9b:	68 cc 05 00 00       	push   $0x5cc
f0118ca0:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118ca5:	e8 aa 83 fe ff       	call   f0101054 <_warn>
f0118caa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118cad:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0118cb1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118cb5:	74 04                	je     f0118cbb <test_allocate_chunk+0x3ac>
f0118cb7:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0118cbb:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0118cbf:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0118cc6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118cc9:	c1 e0 05             	shl    $0x5,%eax
f0118ccc:	83 ec 08             	sub    $0x8,%esp
f0118ccf:	6a 03                	push   $0x3
f0118cd1:	6a 00                	push   $0x0
f0118cd3:	6a 00                	push   $0x0
f0118cd5:	68 07 0e 00 00       	push   $0xe07
f0118cda:	68 03 0e 00 00       	push   $0xe03
f0118cdf:	6a 01                	push   $0x1
f0118ce1:	50                   	push   %eax
f0118ce2:	6a 00                	push   $0x0
f0118ce4:	6a 00                	push   $0x0
f0118ce6:	ff 75 cc             	pushl  -0x34(%ebp)
f0118ce9:	e8 4f 1d 00 00       	call   f011aa3d <CCP>
f0118cee:	83 c4 30             	add    $0x30,%esp
f0118cf1:	85 c0                	test   %eax,%eax
f0118cf3:	75 25                	jne    f0118d1a <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0118cf5:	83 ec 04             	sub    $0x4,%esp
f0118cf8:	68 54 d1 13 f0       	push   $0xf013d154
f0118cfd:	68 d5 05 00 00       	push   $0x5d5
f0118d02:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118d07:	e8 48 83 fe ff       	call   f0101054 <_warn>
f0118d0c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118d0f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0118d13:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0118d1a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118d1e:	74 04                	je     f0118d24 <test_allocate_chunk+0x415>
f0118d20:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0118d24:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0118d28:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0118d2c:	74 5a                	je     f0118d88 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0118d2e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118d31:	01 c0                	add    %eax,%eax
f0118d33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0118d36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118d39:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0118d3c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118d3f:	01 c0                	add    %eax,%eax
f0118d41:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0118d44:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118d47:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0118d4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118d4d:	8a 00                	mov    (%eax),%al
f0118d4f:	3c 4b                	cmp    $0x4b,%al
f0118d51:	75 09                	jne    f0118d5c <test_allocate_chunk+0x44d>
f0118d53:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118d56:	8a 00                	mov    (%eax),%al
f0118d58:	3c 4d                	cmp    $0x4d,%al
f0118d5a:	74 1e                	je     f0118d7a <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0118d5c:	83 ec 04             	sub    $0x4,%esp
f0118d5f:	68 a0 d1 13 f0       	push   $0xf013d1a0
f0118d64:	68 e3 05 00 00       	push   $0x5e3
f0118d69:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118d6e:	e8 e1 82 fe ff       	call   f0101054 <_warn>
f0118d73:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0118d76:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0118d7a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118d7e:	74 04                	je     f0118d84 <test_allocate_chunk+0x475>
f0118d80:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0118d84:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0118d88:	83 ec 0c             	sub    $0xc,%esp
f0118d8b:	68 f7 c4 13 f0       	push   $0xf013c4f7
f0118d90:	e8 b8 8d fe ff       	call   f0101b4d <cprintf>
f0118d95:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0118d98:	83 ec 0c             	sub    $0xc,%esp
f0118d9b:	68 78 d2 13 f0       	push   $0xf013d278
f0118da0:	e8 a8 8d fe ff       	call   f0101b4d <cprintf>
f0118da5:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118da8:	e8 d9 78 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118dad:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0118db0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118db3:	c1 e0 06             	shl    $0x6,%eax
f0118db6:	89 c2                	mov    %eax,%edx
f0118db8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118dbb:	c1 e0 05             	shl    $0x5,%eax
f0118dbe:	6a 00                	push   $0x0
f0118dc0:	52                   	push   %edx
f0118dc1:	50                   	push   %eax
f0118dc2:	ff 75 cc             	pushl  -0x34(%ebp)
f0118dc5:	e8 3f 38 ff ff       	call   f010c609 <allocate_chunk>
f0118dca:	83 c4 10             	add    $0x10,%esp
f0118dcd:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0118dd0:	e8 b1 78 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118dd5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0118dd8:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0118ddc:	75 36                	jne    f0118e14 <test_allocate_chunk+0x505>
f0118dde:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118de1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118de4:	89 c1                	mov    %eax,%ecx
f0118de6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118de9:	c1 e0 06             	shl    $0x6,%eax
f0118dec:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118def:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0118df6:	99                   	cltd   
f0118df7:	f7 ff                	idiv   %edi
f0118df9:	89 c3                	mov    %eax,%ebx
f0118dfb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118dfe:	c1 e0 06             	shl    $0x6,%eax
f0118e01:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118e04:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0118e0b:	99                   	cltd   
f0118e0c:	f7 fe                	idiv   %esi
f0118e0e:	01 d8                	add    %ebx,%eax
f0118e10:	39 c1                	cmp    %eax,%ecx
f0118e12:	74 54                	je     f0118e68 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0118e14:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118e17:	c1 e0 06             	shl    $0x6,%eax
f0118e1a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118e1d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0118e24:	99                   	cltd   
f0118e25:	f7 fb                	idiv   %ebx
f0118e27:	89 c1                	mov    %eax,%ecx
f0118e29:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118e2c:	c1 e0 06             	shl    $0x6,%eax
f0118e2f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118e32:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0118e39:	99                   	cltd   
f0118e3a:	f7 ff                	idiv   %edi
f0118e3c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0118e3f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118e42:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118e45:	83 ec 08             	sub    $0x8,%esp
f0118e48:	52                   	push   %edx
f0118e49:	50                   	push   %eax
f0118e4a:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118e4d:	68 18 d2 13 f0       	push   $0xf013d218
f0118e52:	68 f9 05 00 00       	push   $0x5f9
f0118e57:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118e5c:	e8 f3 81 fe ff       	call   f0101054 <_warn>
f0118e61:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118e64:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0118e68:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118e6c:	74 04                	je     f0118e72 <test_allocate_chunk+0x563>
f0118e6e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0118e72:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0118e76:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0118e7d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118e80:	c1 e0 06             	shl    $0x6,%eax
f0118e83:	89 c2                	mov    %eax,%edx
f0118e85:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118e88:	c1 e0 05             	shl    $0x5,%eax
f0118e8b:	83 ec 08             	sub    $0x8,%esp
f0118e8e:	6a 03                	push   $0x3
f0118e90:	6a 00                	push   $0x0
f0118e92:	6a 00                	push   $0x0
f0118e94:	68 07 0e 00 00       	push   $0xe07
f0118e99:	6a 01                	push   $0x1
f0118e9b:	6a 01                	push   $0x1
f0118e9d:	52                   	push   %edx
f0118e9e:	50                   	push   %eax
f0118e9f:	6a 00                	push   $0x0
f0118ea1:	ff 75 cc             	pushl  -0x34(%ebp)
f0118ea4:	e8 94 1b 00 00       	call   f011aa3d <CCP>
f0118ea9:	83 c4 30             	add    $0x30,%esp
f0118eac:	85 c0                	test   %eax,%eax
f0118eae:	75 25                	jne    f0118ed5 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0118eb0:	83 ec 04             	sub    $0x4,%esp
f0118eb3:	68 54 d1 13 f0       	push   $0xf013d154
f0118eb8:	68 02 06 00 00       	push   $0x602
f0118ebd:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118ec2:	e8 8d 81 fe ff       	call   f0101054 <_warn>
f0118ec7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0118eca:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0118ece:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0118ed5:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118ed9:	74 04                	je     f0118edf <test_allocate_chunk+0x5d0>
f0118edb:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0118edf:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0118ee3:	83 ec 0c             	sub    $0xc,%esp
f0118ee6:	68 5a c5 13 f0       	push   $0xf013c55a
f0118eeb:	e8 5d 8c fe ff       	call   f0101b4d <cprintf>
f0118ef0:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0118ef3:	83 ec 0c             	sub    $0xc,%esp
f0118ef6:	68 b8 d2 13 f0       	push   $0xf013d2b8
f0118efb:	e8 4d 8c fe ff       	call   f0101b4d <cprintf>
f0118f00:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0118f03:	e8 7e 77 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118f08:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0118f0b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f0e:	c1 e0 06             	shl    $0x6,%eax
f0118f11:	68 06 0e 00 00       	push   $0xe06
f0118f16:	50                   	push   %eax
f0118f17:	68 00 00 00 80       	push   $0x80000000
f0118f1c:	ff 75 cc             	pushl  -0x34(%ebp)
f0118f1f:	e8 e5 36 ff ff       	call   f010c609 <allocate_chunk>
f0118f24:	83 c4 10             	add    $0x10,%esp
f0118f27:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0118f2a:	e8 57 77 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0118f2f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0118f32:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0118f36:	75 36                	jne    f0118f6e <test_allocate_chunk+0x65f>
f0118f38:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118f3b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118f3e:	89 c1                	mov    %eax,%ecx
f0118f40:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f43:	c1 e0 06             	shl    $0x6,%eax
f0118f46:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118f49:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0118f50:	99                   	cltd   
f0118f51:	f7 fb                	idiv   %ebx
f0118f53:	89 c3                	mov    %eax,%ebx
f0118f55:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f58:	c1 e0 06             	shl    $0x6,%eax
f0118f5b:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118f5e:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0118f65:	99                   	cltd   
f0118f66:	f7 fe                	idiv   %esi
f0118f68:	01 d8                	add    %ebx,%eax
f0118f6a:	39 c1                	cmp    %eax,%ecx
f0118f6c:	74 54                	je     f0118fc2 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0118f6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f71:	c1 e0 06             	shl    $0x6,%eax
f0118f74:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118f77:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0118f7e:	99                   	cltd   
f0118f7f:	f7 ff                	idiv   %edi
f0118f81:	89 c1                	mov    %eax,%ecx
f0118f83:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f86:	c1 e0 06             	shl    $0x6,%eax
f0118f89:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118f8c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0118f93:	99                   	cltd   
f0118f94:	f7 fb                	idiv   %ebx
f0118f96:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0118f99:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118f9c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0118f9f:	83 ec 08             	sub    $0x8,%esp
f0118fa2:	52                   	push   %edx
f0118fa3:	50                   	push   %eax
f0118fa4:	ff 75 9c             	pushl  -0x64(%ebp)
f0118fa7:	68 18 d2 13 f0       	push   $0xf013d218
f0118fac:	68 18 06 00 00       	push   $0x618
f0118fb1:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0118fb6:	e8 99 80 fe ff       	call   f0101054 <_warn>
f0118fbb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118fbe:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0118fc2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0118fc6:	74 04                	je     f0118fcc <test_allocate_chunk+0x6bd>
f0118fc8:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0118fcc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0118fd0:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0118fd7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118fda:	c1 e0 06             	shl    $0x6,%eax
f0118fdd:	83 ec 08             	sub    $0x8,%esp
f0118fe0:	6a 03                	push   $0x3
f0118fe2:	6a 00                	push   $0x0
f0118fe4:	6a 00                	push   $0x0
f0118fe6:	68 07 0e 00 00       	push   $0xe07
f0118feb:	68 07 0e 00 00       	push   $0xe07
f0118ff0:	6a 01                	push   $0x1
f0118ff2:	50                   	push   %eax
f0118ff3:	68 00 00 00 80       	push   $0x80000000
f0118ff8:	6a 00                	push   $0x0
f0118ffa:	ff 75 cc             	pushl  -0x34(%ebp)
f0118ffd:	e8 3b 1a 00 00       	call   f011aa3d <CCP>
f0119002:	83 c4 30             	add    $0x30,%esp
f0119005:	85 c0                	test   %eax,%eax
f0119007:	75 25                	jne    f011902e <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0119009:	83 ec 04             	sub    $0x4,%esp
f011900c:	68 54 d1 13 f0       	push   $0xf013d154
f0119011:	68 21 06 00 00       	push   $0x621
f0119016:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011901b:	e8 34 80 fe ff       	call   f0101054 <_warn>
f0119020:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0119023:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0119027:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f011902e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0119032:	74 04                	je     f0119038 <test_allocate_chunk+0x729>
f0119034:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0119038:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011903c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0119040:	74 6f                	je     f01190b1 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0119042:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119045:	01 c0                	add    %eax,%eax
f0119047:	05 00 00 00 80       	add    $0x80000000,%eax
f011904c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011904f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119052:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0119055:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0119058:	89 d0                	mov    %edx,%eax
f011905a:	c1 e0 02             	shl    $0x2,%eax
f011905d:	01 d0                	add    %edx,%eax
f011905f:	01 c0                	add    %eax,%eax
f0119061:	01 d0                	add    %edx,%eax
f0119063:	01 c0                	add    %eax,%eax
f0119065:	05 00 00 00 80       	add    $0x80000000,%eax
f011906a:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011906d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119070:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0119073:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119076:	8a 00                	mov    (%eax),%al
f0119078:	3c 4b                	cmp    $0x4b,%al
f011907a:	75 09                	jne    f0119085 <test_allocate_chunk+0x776>
f011907c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011907f:	8a 00                	mov    (%eax),%al
f0119081:	3c 4d                	cmp    $0x4d,%al
f0119083:	74 1e                	je     f01190a3 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0119085:	83 ec 04             	sub    $0x4,%esp
f0119088:	68 a0 d1 13 f0       	push   $0xf013d1a0
f011908d:	68 2f 06 00 00       	push   $0x62f
f0119092:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119097:	e8 b8 7f fe ff       	call   f0101054 <_warn>
f011909c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011909f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01190a3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01190a7:	74 04                	je     f01190ad <test_allocate_chunk+0x79e>
f01190a9:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01190ad:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f01190b1:	83 ec 0c             	sub    $0xc,%esp
f01190b4:	68 2c d0 13 f0       	push   $0xf013d02c
f01190b9:	e8 8f 8a fe ff       	call   f0101b4d <cprintf>
f01190be:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01190c1:	83 ec 0c             	sub    $0xc,%esp
f01190c4:	68 f4 d2 13 f0       	push   $0xf013d2f4
f01190c9:	e8 7f 8a fe ff       	call   f0101b4d <cprintf>
f01190ce:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01190d1:	e8 b0 75 ff ff       	call   f0110686 <sys_calculate_free_frames>
f01190d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f01190d9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01190dc:	89 d0                	mov    %edx,%eax
f01190de:	01 c0                	add    %eax,%eax
f01190e0:	01 d0                	add    %edx,%eax
f01190e2:	01 c0                	add    %eax,%eax
f01190e4:	01 d0                	add    %edx,%eax
f01190e6:	68 04 0e 00 00       	push   $0xe04
f01190eb:	50                   	push   %eax
f01190ec:	68 00 fc 3f 40       	push   $0x403ffc00
f01190f1:	ff 75 cc             	pushl  -0x34(%ebp)
f01190f4:	e8 10 35 ff ff       	call   f010c609 <allocate_chunk>
f01190f9:	83 c4 10             	add    $0x10,%esp
f01190fc:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01190ff:	e8 82 75 ff ff       	call   f0110686 <sys_calculate_free_frames>
f0119104:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0119107:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f011910b:	75 0b                	jne    f0119118 <test_allocate_chunk+0x809>
f011910d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119110:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0119113:	83 f8 05             	cmp    $0x5,%eax
f0119116:	74 2a                	je     f0119142 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0119118:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011911b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011911e:	83 ec 08             	sub    $0x8,%esp
f0119121:	6a 05                	push   $0x5
f0119123:	50                   	push   %eax
f0119124:	ff 75 98             	pushl  -0x68(%ebp)
f0119127:	68 18 d2 13 f0       	push   $0xf013d218
f011912c:	68 46 06 00 00       	push   $0x646
f0119131:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119136:	e8 19 7f fe ff       	call   f0101054 <_warn>
f011913b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011913e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0119142:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0119146:	74 04                	je     f011914c <test_allocate_chunk+0x83d>
f0119148:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011914c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0119150:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0119157:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011915a:	89 d0                	mov    %edx,%eax
f011915c:	01 c0                	add    %eax,%eax
f011915e:	01 d0                	add    %edx,%eax
f0119160:	c1 e0 02             	shl    $0x2,%eax
f0119163:	83 ec 08             	sub    $0x8,%esp
f0119166:	6a 03                	push   $0x3
f0119168:	6a 00                	push   $0x0
f011916a:	6a 00                	push   $0x0
f011916c:	68 07 0e 00 00       	push   $0xe07
f0119171:	68 05 0e 00 00       	push   $0xe05
f0119176:	6a 01                	push   $0x1
f0119178:	50                   	push   %eax
f0119179:	68 00 f0 3f 40       	push   $0x403ff000
f011917e:	6a 00                	push   $0x0
f0119180:	ff 75 cc             	pushl  -0x34(%ebp)
f0119183:	e8 b5 18 00 00       	call   f011aa3d <CCP>
f0119188:	83 c4 30             	add    $0x30,%esp
f011918b:	85 c0                	test   %eax,%eax
f011918d:	75 25                	jne    f01191b4 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011918f:	83 ec 04             	sub    $0x4,%esp
f0119192:	68 54 d1 13 f0       	push   $0xf013d154
f0119197:	68 4f 06 00 00       	push   $0x64f
f011919c:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01191a1:	e8 ae 7e fe ff       	call   f0101054 <_warn>
f01191a6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01191a9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01191ad:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01191b4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01191b8:	74 04                	je     f01191be <test_allocate_chunk+0x8af>
f01191ba:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01191be:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01191c2:	83 ec 0c             	sub    $0xc,%esp
f01191c5:	68 2b d3 13 f0       	push   $0xf013d32b
f01191ca:	e8 7e 89 fe ff       	call   f0101b4d <cprintf>
f01191cf:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f01191d2:	83 ec 08             	sub    $0x8,%esp
f01191d5:	ff 75 e0             	pushl  -0x20(%ebp)
f01191d8:	68 3c d3 13 f0       	push   $0xf013d33c
f01191dd:	e8 6b 89 fe ff       	call   f0101b4d <cprintf>
f01191e2:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01191e5:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f01191e9:	75 10                	jne    f01191fb <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f01191eb:	83 ec 0c             	sub    $0xc,%esp
f01191ee:	68 70 d3 13 f0       	push   $0xf013d370
f01191f3:	e8 55 89 fe ff       	call   f0101b4d <cprintf>
f01191f8:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01191fb:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f0119200:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0119203:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119206:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0119209:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011920e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0119211:	5b                   	pop    %ebx
f0119212:	5e                   	pop    %esi
f0119213:	5f                   	pop    %edi
f0119214:	5d                   	pop    %ebp
f0119215:	c3                   	ret    

f0119216 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0119216:	55                   	push   %ebp
f0119217:	89 e5                	mov    %esp,%ebp
f0119219:	57                   	push   %edi
f011921a:	56                   	push   %esi
f011921b:	53                   	push   %ebx
f011921c:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0119222:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0119225:	bb 6c c2 13 f0       	mov    $0xf013c26c,%ebx
f011922a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011922f:	89 c7                	mov    %eax,%edi
f0119231:	89 de                	mov    %ebx,%esi
f0119233:	89 d1                	mov    %edx,%ecx
f0119235:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0119237:	8d 55 9d             	lea    -0x63(%ebp),%edx
f011923a:	b9 23 00 00 00       	mov    $0x23,%ecx
f011923f:	b0 00                	mov    $0x0,%al
f0119241:	89 d7                	mov    %edx,%edi
f0119243:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0119245:	6a 00                	push   $0x0
f0119247:	6a 0a                	push   $0xa
f0119249:	6a 14                	push   $0x14
f011924b:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011924e:	50                   	push   %eax
f011924f:	e8 3d 38 ff ff       	call   f010ca91 <env_create>
f0119254:	83 c4 10             	add    $0x10,%esp
f0119257:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011925a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011925d:	8b 40 64             	mov    0x64(%eax),%eax
f0119260:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0119263:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119266:	8b 40 68             	mov    0x68(%eax),%eax
f0119269:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011926c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011926f:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0119272:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0119279:	75 70 20 
f011927c:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0119283:	00 00 00 
f0119286:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0119289:	b9 03 00 00 00       	mov    $0x3,%ecx
f011928e:	b8 00 00 00 00       	mov    $0x0,%eax
f0119293:	89 d7                	mov    %edx,%edi
f0119295:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0119297:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011929a:	8b 40 10             	mov    0x10(%eax),%eax
f011929d:	83 ec 08             	sub    $0x8,%esp
f01192a0:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01192a6:	52                   	push   %edx
f01192a7:	50                   	push   %eax
f01192a8:	e8 d7 a0 00 00       	call   f0123384 <ltostr>
f01192ad:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01192b0:	83 ec 04             	sub    $0x4,%esp
f01192b3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01192b9:	50                   	push   %eax
f01192ba:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01192c0:	50                   	push   %eax
f01192c1:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01192c7:	50                   	push   %eax
f01192c8:	e8 90 a1 00 00       	call   f012345d <strcconcat>
f01192cd:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01192d0:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01192d7:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01192de:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f01192e5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f01192ec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f01192f0:	83 ec 0c             	sub    $0xc,%esp
f01192f3:	ff 75 d8             	pushl  -0x28(%ebp)
f01192f6:	e8 0e 17 00 00       	call   f011aa09 <ClearUserSpace>
f01192fb:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01192fe:	83 ec 0c             	sub    $0xc,%esp
f0119301:	68 b0 d3 13 f0       	push   $0xf013d3b0
f0119306:	e8 42 88 fe ff       	call   f0101b4d <cprintf>
f011930b:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f011930e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119311:	c1 e0 03             	shl    $0x3,%eax
f0119314:	83 ec 04             	sub    $0x4,%esp
f0119317:	50                   	push   %eax
f0119318:	6a 00                	push   $0x0
f011931a:	ff 75 d8             	pushl  -0x28(%ebp)
f011931d:	e8 35 33 ff ff       	call   f010c657 <calculate_required_frames>
f0119322:	83 c4 10             	add    $0x10,%esp
f0119325:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0119328:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011932c:	74 23                	je     f0119351 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011932e:	83 ec 0c             	sub    $0xc,%esp
f0119331:	6a 03                	push   $0x3
f0119333:	ff 75 c8             	pushl  -0x38(%ebp)
f0119336:	68 e4 d3 13 f0       	push   $0xf013d3e4
f011933b:	68 88 06 00 00       	push   $0x688
f0119340:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119345:	e8 0a 7d fe ff       	call   f0101054 <_warn>
f011934a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011934d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119351:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119355:	74 04                	je     f011935b <test_calculate_required_frames+0x145>
f0119357:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011935b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f011935f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119362:	c1 e0 02             	shl    $0x2,%eax
f0119365:	83 ec 04             	sub    $0x4,%esp
f0119368:	50                   	push   %eax
f0119369:	6a 00                	push   $0x0
f011936b:	ff 75 d8             	pushl  -0x28(%ebp)
f011936e:	e8 e4 32 ff ff       	call   f010c657 <calculate_required_frames>
f0119373:	83 c4 10             	add    $0x10,%esp
f0119376:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0119379:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0119380:	74 26                	je     f01193a8 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0119382:	83 ec 0c             	sub    $0xc,%esp
f0119385:	68 01 04 00 00       	push   $0x401
f011938a:	ff 75 c8             	pushl  -0x38(%ebp)
f011938d:	68 e4 d3 13 f0       	push   $0xf013d3e4
f0119392:	68 92 06 00 00       	push   $0x692
f0119397:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011939c:	e8 b3 7c fe ff       	call   f0101054 <_warn>
f01193a1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01193a4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01193a8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01193ac:	74 04                	je     f01193b2 <test_calculate_required_frames+0x19c>
f01193ae:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01193b2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01193b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01193b9:	c1 e0 0a             	shl    $0xa,%eax
f01193bc:	83 ec 04             	sub    $0x4,%esp
f01193bf:	50                   	push   %eax
f01193c0:	6a 00                	push   $0x0
f01193c2:	ff 75 d8             	pushl  -0x28(%ebp)
f01193c5:	e8 8d 32 ff ff       	call   f010c657 <calculate_required_frames>
f01193ca:	83 c4 10             	add    $0x10,%esp
f01193cd:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f01193d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01193d3:	c1 e0 0a             	shl    $0xa,%eax
f01193d6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01193d9:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01193e0:	99                   	cltd   
f01193e1:	f7 fb                	idiv   %ebx
f01193e3:	89 c1                	mov    %eax,%ecx
f01193e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01193e8:	c1 e0 0a             	shl    $0xa,%eax
f01193eb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01193ee:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01193f5:	99                   	cltd   
f01193f6:	f7 fe                	idiv   %esi
f01193f8:	01 c8                	add    %ecx,%eax
f01193fa:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01193fd:	74 4c                	je     f011944b <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f01193ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119402:	c1 e0 0a             	shl    $0xa,%eax
f0119405:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0119408:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011940f:	99                   	cltd   
f0119410:	f7 fb                	idiv   %ebx
f0119412:	89 c1                	mov    %eax,%ecx
f0119414:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119417:	c1 e0 0a             	shl    $0xa,%eax
f011941a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011941d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0119424:	99                   	cltd   
f0119425:	f7 fe                	idiv   %esi
f0119427:	01 c8                	add    %ecx,%eax
f0119429:	83 ec 0c             	sub    $0xc,%esp
f011942c:	50                   	push   %eax
f011942d:	ff 75 c8             	pushl  -0x38(%ebp)
f0119430:	68 e4 d3 13 f0       	push   $0xf013d3e4
f0119435:	68 9c 06 00 00       	push   $0x69c
f011943a:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011943f:	e8 10 7c fe ff       	call   f0101054 <_warn>
f0119444:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119447:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011944b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011944f:	74 04                	je     f0119455 <test_calculate_required_frames+0x23f>
f0119451:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119455:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0119459:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011945c:	89 d0                	mov    %edx,%eax
f011945e:	01 c0                	add    %eax,%eax
f0119460:	01 d0                	add    %edx,%eax
f0119462:	01 c0                	add    %eax,%eax
f0119464:	83 ec 04             	sub    $0x4,%esp
f0119467:	50                   	push   %eax
f0119468:	68 00 10 00 00       	push   $0x1000
f011946d:	ff 75 d8             	pushl  -0x28(%ebp)
f0119470:	e8 e2 31 ff ff       	call   f010c657 <calculate_required_frames>
f0119475:	83 c4 10             	add    $0x10,%esp
f0119478:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011947b:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011947f:	74 23                	je     f01194a4 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0119481:	83 ec 0c             	sub    $0xc,%esp
f0119484:	6a 03                	push   $0x3
f0119486:	ff 75 c8             	pushl  -0x38(%ebp)
f0119489:	68 e4 d3 13 f0       	push   $0xf013d3e4
f011948e:	68 a8 06 00 00       	push   $0x6a8
f0119493:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119498:	e8 b7 7b fe ff       	call   f0101054 <_warn>
f011949d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01194a0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01194a4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01194a8:	74 04                	je     f01194ae <test_calculate_required_frames+0x298>
f01194aa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01194ae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01194b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01194b5:	89 c2                	mov    %eax,%edx
f01194b7:	01 d2                	add    %edx,%edx
f01194b9:	01 d0                	add    %edx,%eax
f01194bb:	83 ec 04             	sub    $0x4,%esp
f01194be:	50                   	push   %eax
f01194bf:	68 00 18 00 00       	push   $0x1800
f01194c4:	ff 75 d8             	pushl  -0x28(%ebp)
f01194c7:	e8 8b 31 ff ff       	call   f010c657 <calculate_required_frames>
f01194cc:	83 c4 10             	add    $0x10,%esp
f01194cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01194d2:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01194d6:	74 23                	je     f01194fb <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01194d8:	83 ec 0c             	sub    $0xc,%esp
f01194db:	6a 03                	push   $0x3
f01194dd:	ff 75 c8             	pushl  -0x38(%ebp)
f01194e0:	68 e4 d3 13 f0       	push   $0xf013d3e4
f01194e5:	68 b2 06 00 00       	push   $0x6b2
f01194ea:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01194ef:	e8 60 7b fe ff       	call   f0101054 <_warn>
f01194f4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01194f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01194fb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01194ff:	74 04                	je     f0119505 <test_calculate_required_frames+0x2ef>
f0119501:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119505:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0119509:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011950c:	89 d0                	mov    %edx,%eax
f011950e:	c1 e0 02             	shl    $0x2,%eax
f0119511:	01 d0                	add    %edx,%eax
f0119513:	01 c0                	add    %eax,%eax
f0119515:	83 ec 04             	sub    $0x4,%esp
f0119518:	50                   	push   %eax
f0119519:	68 00 00 40 00       	push   $0x400000
f011951e:	ff 75 d8             	pushl  -0x28(%ebp)
f0119521:	e8 31 31 ff ff       	call   f010c657 <calculate_required_frames>
f0119526:	83 c4 10             	add    $0x10,%esp
f0119529:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f011952c:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0119533:	74 26                	je     f011955b <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0119535:	83 ec 0c             	sub    $0xc,%esp
f0119538:	68 03 0a 00 00       	push   $0xa03
f011953d:	ff 75 c8             	pushl  -0x38(%ebp)
f0119540:	68 e4 d3 13 f0       	push   $0xf013d3e4
f0119545:	68 bc 06 00 00       	push   $0x6bc
f011954a:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011954f:	e8 00 7b fe ff       	call   f0101054 <_warn>
f0119554:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119557:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011955b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011955f:	74 04                	je     f0119565 <test_calculate_required_frames+0x34f>
f0119561:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119565:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0119569:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011956c:	01 c0                	add    %eax,%eax
f011956e:	83 ec 04             	sub    $0x4,%esp
f0119571:	50                   	push   %eax
f0119572:	68 00 00 70 00       	push   $0x700000
f0119577:	ff 75 d8             	pushl  -0x28(%ebp)
f011957a:	e8 d8 30 ff ff       	call   f010c657 <calculate_required_frames>
f011957f:	83 c4 10             	add    $0x10,%esp
f0119582:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0119585:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f011958c:	74 26                	je     f01195b4 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f011958e:	83 ec 0c             	sub    $0xc,%esp
f0119591:	68 02 02 00 00       	push   $0x202
f0119596:	ff 75 c8             	pushl  -0x38(%ebp)
f0119599:	68 e4 d3 13 f0       	push   $0xf013d3e4
f011959e:	68 c8 06 00 00       	push   $0x6c8
f01195a3:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01195a8:	e8 a7 7a fe ff       	call   f0101054 <_warn>
f01195ad:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01195b0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01195b4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01195b8:	74 04                	je     f01195be <test_calculate_required_frames+0x3a8>
f01195ba:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01195be:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01195c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01195c5:	83 ec 04             	sub    $0x4,%esp
f01195c8:	50                   	push   %eax
f01195c9:	68 ff ff 3f 00       	push   $0x3fffff
f01195ce:	ff 75 d8             	pushl  -0x28(%ebp)
f01195d1:	e8 81 30 ff ff       	call   f010c657 <calculate_required_frames>
f01195d6:	83 c4 10             	add    $0x10,%esp
f01195d9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f01195dc:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01195e0:	74 23                	je     f0119605 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01195e2:	83 ec 0c             	sub    $0xc,%esp
f01195e5:	6a 04                	push   $0x4
f01195e7:	ff 75 c8             	pushl  -0x38(%ebp)
f01195ea:	68 e4 d3 13 f0       	push   $0xf013d3e4
f01195ef:	68 d2 06 00 00       	push   $0x6d2
f01195f4:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01195f9:	e8 56 7a fe ff       	call   f0101054 <_warn>
f01195fe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119601:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0119605:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119609:	74 04                	je     f011960f <test_calculate_required_frames+0x3f9>
f011960b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011960f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0119613:	83 ec 0c             	sub    $0xc,%esp
f0119616:	68 1d cf 13 f0       	push   $0xf013cf1d
f011961b:	e8 2d 85 fe ff       	call   f0101b4d <cprintf>
f0119620:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0119623:	83 ec 0c             	sub    $0xc,%esp
f0119626:	68 3c d4 13 f0       	push   $0xf013d43c
f011962b:	e8 1d 85 fe ff       	call   f0101b4d <cprintf>
f0119630:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0119633:	83 ec 04             	sub    $0x4,%esp
f0119636:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011963c:	50                   	push   %eax
f011963d:	68 d6 c2 13 f0       	push   $0xf013c2d6
f0119642:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0119648:	50                   	push   %eax
f0119649:	e8 0f 9e 00 00       	call   f012345d <strcconcat>
f011964e:	83 c4 10             	add    $0x10,%esp
f0119651:	83 ec 0c             	sub    $0xc,%esp
f0119654:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011965a:	50                   	push   %eax
f011965b:	e8 ac 87 fe ff       	call   f0101e0c <execute_command>
f0119660:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0119663:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119666:	c1 e0 03             	shl    $0x3,%eax
f0119669:	83 ec 04             	sub    $0x4,%esp
f011966c:	50                   	push   %eax
f011966d:	6a 00                	push   $0x0
f011966f:	ff 75 d8             	pushl  -0x28(%ebp)
f0119672:	e8 e0 2f ff ff       	call   f010c657 <calculate_required_frames>
f0119677:	83 c4 10             	add    $0x10,%esp
f011967a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011967d:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0119684:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119687:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011968a:	74 24                	je     f01196b0 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011968c:	83 ec 0c             	sub    $0xc,%esp
f011968f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0119692:	ff 75 c8             	pushl  -0x38(%ebp)
f0119695:	68 e4 d3 13 f0       	push   $0xf013d3e4
f011969a:	68 e6 06 00 00       	push   $0x6e6
f011969f:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01196a4:	e8 ab 79 fe ff       	call   f0101054 <_warn>
f01196a9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01196ac:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01196b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01196b4:	74 04                	je     f01196ba <test_calculate_required_frames+0x4a4>
f01196b6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01196ba:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01196be:	83 ec 04             	sub    $0x4,%esp
f01196c1:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01196c7:	50                   	push   %eax
f01196c8:	68 e3 c2 13 f0       	push   $0xf013c2e3
f01196cd:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01196d3:	50                   	push   %eax
f01196d4:	e8 84 9d 00 00       	call   f012345d <strcconcat>
f01196d9:	83 c4 10             	add    $0x10,%esp
f01196dc:	83 ec 0c             	sub    $0xc,%esp
f01196df:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01196e5:	50                   	push   %eax
f01196e6:	e8 21 87 fe ff       	call   f0101e0c <execute_command>
f01196eb:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01196ee:	83 ec 04             	sub    $0x4,%esp
f01196f1:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01196f7:	50                   	push   %eax
f01196f8:	68 70 d4 13 f0       	push   $0xf013d470
f01196fd:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0119703:	50                   	push   %eax
f0119704:	e8 54 9d 00 00       	call   f012345d <strcconcat>
f0119709:	83 c4 10             	add    $0x10,%esp
f011970c:	83 ec 0c             	sub    $0xc,%esp
f011970f:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0119715:	50                   	push   %eax
f0119716:	e8 f1 86 fe ff       	call   f0101e0c <execute_command>
f011971b:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f011971e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119721:	c1 e0 03             	shl    $0x3,%eax
f0119724:	83 ec 04             	sub    $0x4,%esp
f0119727:	50                   	push   %eax
f0119728:	6a 00                	push   $0x0
f011972a:	ff 75 d8             	pushl  -0x28(%ebp)
f011972d:	e8 25 2f ff ff       	call   f010c657 <calculate_required_frames>
f0119732:	83 c4 10             	add    $0x10,%esp
f0119735:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0119738:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f011973f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119742:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119745:	74 24                	je     f011976b <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0119747:	83 ec 0c             	sub    $0xc,%esp
f011974a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011974d:	ff 75 c8             	pushl  -0x38(%ebp)
f0119750:	68 e4 d3 13 f0       	push   $0xf013d3e4
f0119755:	68 f4 06 00 00       	push   $0x6f4
f011975a:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011975f:	e8 f0 78 fe ff       	call   f0101054 <_warn>
f0119764:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119767:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011976b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011976f:	74 04                	je     f0119775 <test_calculate_required_frames+0x55f>
f0119771:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119775:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0119779:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011977c:	c1 e0 0a             	shl    $0xa,%eax
f011977f:	83 ec 04             	sub    $0x4,%esp
f0119782:	50                   	push   %eax
f0119783:	6a 00                	push   $0x0
f0119785:	ff 75 d8             	pushl  -0x28(%ebp)
f0119788:	e8 ca 2e ff ff       	call   f010c657 <calculate_required_frames>
f011978d:	83 c4 10             	add    $0x10,%esp
f0119790:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0119793:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119796:	c1 e0 0a             	shl    $0xa,%eax
f0119799:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011979c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01197a3:	99                   	cltd   
f01197a4:	f7 fb                	idiv   %ebx
f01197a6:	89 c1                	mov    %eax,%ecx
f01197a8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01197ab:	c1 e0 0a             	shl    $0xa,%eax
f01197ae:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01197b1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01197b8:	99                   	cltd   
f01197b9:	f7 fe                	idiv   %esi
f01197bb:	01 c8                	add    %ecx,%eax
f01197bd:	83 e8 05             	sub    $0x5,%eax
f01197c0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f01197c3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01197c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01197c9:	74 24                	je     f01197ef <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01197cb:	83 ec 0c             	sub    $0xc,%esp
f01197ce:	ff 75 c4             	pushl  -0x3c(%ebp)
f01197d1:	ff 75 c8             	pushl  -0x38(%ebp)
f01197d4:	68 e4 d3 13 f0       	push   $0xf013d3e4
f01197d9:	68 ff 06 00 00       	push   $0x6ff
f01197de:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01197e3:	e8 6c 78 fe ff       	call   f0101054 <_warn>
f01197e8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01197eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01197ef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01197f3:	74 04                	je     f01197f9 <test_calculate_required_frames+0x5e3>
f01197f5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01197f9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01197fd:	83 ec 04             	sub    $0x4,%esp
f0119800:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0119806:	50                   	push   %eax
f0119807:	68 7c d4 13 f0       	push   $0xf013d47c
f011980c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0119812:	50                   	push   %eax
f0119813:	e8 45 9c 00 00       	call   f012345d <strcconcat>
f0119818:	83 c4 10             	add    $0x10,%esp
f011981b:	83 ec 0c             	sub    $0xc,%esp
f011981e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0119824:	50                   	push   %eax
f0119825:	e8 e2 85 fe ff       	call   f0101e0c <execute_command>
f011982a:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011982d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119830:	89 c2                	mov    %eax,%edx
f0119832:	01 d2                	add    %edx,%edx
f0119834:	01 d0                	add    %edx,%eax
f0119836:	83 ec 04             	sub    $0x4,%esp
f0119839:	50                   	push   %eax
f011983a:	68 00 18 00 00       	push   $0x1800
f011983f:	ff 75 d8             	pushl  -0x28(%ebp)
f0119842:	e8 10 2e ff ff       	call   f010c657 <calculate_required_frames>
f0119847:	83 c4 10             	add    $0x10,%esp
f011984a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011984d:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0119854:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119857:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011985a:	74 24                	je     f0119880 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011985c:	83 ec 0c             	sub    $0xc,%esp
f011985f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0119862:	ff 75 c8             	pushl  -0x38(%ebp)
f0119865:	68 e4 d3 13 f0       	push   $0xf013d3e4
f011986a:	68 0e 07 00 00       	push   $0x70e
f011986f:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119874:	e8 db 77 fe ff       	call   f0101054 <_warn>
f0119879:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011987c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119880:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119884:	74 04                	je     f011988a <test_calculate_required_frames+0x674>
f0119886:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011988a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011988e:	83 ec 04             	sub    $0x4,%esp
f0119891:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0119897:	50                   	push   %eax
f0119898:	68 3c c5 13 f0       	push   $0xf013c53c
f011989d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01198a3:	50                   	push   %eax
f01198a4:	e8 b4 9b 00 00       	call   f012345d <strcconcat>
f01198a9:	83 c4 10             	add    $0x10,%esp
f01198ac:	83 ec 0c             	sub    $0xc,%esp
f01198af:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01198b5:	50                   	push   %eax
f01198b6:	e8 51 85 fe ff       	call   f0101e0c <execute_command>
f01198bb:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01198be:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01198c1:	89 d0                	mov    %edx,%eax
f01198c3:	c1 e0 02             	shl    $0x2,%eax
f01198c6:	01 d0                	add    %edx,%eax
f01198c8:	01 c0                	add    %eax,%eax
f01198ca:	83 ec 04             	sub    $0x4,%esp
f01198cd:	50                   	push   %eax
f01198ce:	68 00 00 40 00       	push   $0x400000
f01198d3:	ff 75 d8             	pushl  -0x28(%ebp)
f01198d6:	e8 7c 2d ff ff       	call   f010c657 <calculate_required_frames>
f01198db:	83 c4 10             	add    $0x10,%esp
f01198de:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01198e1:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01198e8:	74 26                	je     f0119910 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01198ea:	83 ec 0c             	sub    $0xc,%esp
f01198ed:	68 03 0a 00 00       	push   $0xa03
f01198f2:	ff 75 c8             	pushl  -0x38(%ebp)
f01198f5:	68 e4 d3 13 f0       	push   $0xf013d3e4
f01198fa:	68 1a 07 00 00       	push   $0x71a
f01198ff:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119904:	e8 4b 77 fe ff       	call   f0101054 <_warn>
f0119909:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011990c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119910:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119914:	74 04                	je     f011991a <test_calculate_required_frames+0x704>
f0119916:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011991a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f011991e:	83 ec 04             	sub    $0x4,%esp
f0119921:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0119927:	50                   	push   %eax
f0119928:	68 46 c5 13 f0       	push   $0xf013c546
f011992d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0119933:	50                   	push   %eax
f0119934:	e8 24 9b 00 00       	call   f012345d <strcconcat>
f0119939:	83 c4 10             	add    $0x10,%esp
f011993c:	83 ec 0c             	sub    $0xc,%esp
f011993f:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0119945:	50                   	push   %eax
f0119946:	e8 c1 84 fe ff       	call   f0101e0c <execute_command>
f011994b:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011994e:	83 ec 04             	sub    $0x4,%esp
f0119951:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0119957:	50                   	push   %eax
f0119958:	68 84 d4 13 f0       	push   $0xf013d484
f011995d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0119963:	50                   	push   %eax
f0119964:	e8 f4 9a 00 00       	call   f012345d <strcconcat>
f0119969:	83 c4 10             	add    $0x10,%esp
f011996c:	83 ec 0c             	sub    $0xc,%esp
f011996f:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0119975:	50                   	push   %eax
f0119976:	e8 91 84 fe ff       	call   f0101e0c <execute_command>
f011997b:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011997e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119981:	01 c0                	add    %eax,%eax
f0119983:	83 ec 04             	sub    $0x4,%esp
f0119986:	50                   	push   %eax
f0119987:	68 00 00 70 00       	push   $0x700000
f011998c:	ff 75 d8             	pushl  -0x28(%ebp)
f011998f:	e8 c3 2c ff ff       	call   f010c657 <calculate_required_frames>
f0119994:	83 c4 10             	add    $0x10,%esp
f0119997:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011999a:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f01199a1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01199a4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01199a7:	74 24                	je     f01199cd <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01199a9:	83 ec 0c             	sub    $0xc,%esp
f01199ac:	ff 75 c4             	pushl  -0x3c(%ebp)
f01199af:	ff 75 c8             	pushl  -0x38(%ebp)
f01199b2:	68 e4 d3 13 f0       	push   $0xf013d3e4
f01199b7:	68 2a 07 00 00       	push   $0x72a
f01199bc:	68 d2 b7 13 f0       	push   $0xf013b7d2
f01199c1:	e8 8e 76 fe ff       	call   f0101054 <_warn>
f01199c6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01199c9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01199cd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01199d1:	74 04                	je     f01199d7 <test_calculate_required_frames+0x7c1>
f01199d3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01199d7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01199db:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01199de:	83 ec 04             	sub    $0x4,%esp
f01199e1:	50                   	push   %eax
f01199e2:	68 ff ff 3f 00       	push   $0x3fffff
f01199e7:	ff 75 d8             	pushl  -0x28(%ebp)
f01199ea:	e8 68 2c ff ff       	call   f010c657 <calculate_required_frames>
f01199ef:	83 c4 10             	add    $0x10,%esp
f01199f2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f01199f5:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f01199fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01199ff:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119a02:	74 24                	je     f0119a28 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0119a04:	83 ec 0c             	sub    $0xc,%esp
f0119a07:	ff 75 c4             	pushl  -0x3c(%ebp)
f0119a0a:	ff 75 c8             	pushl  -0x38(%ebp)
f0119a0d:	68 e4 d3 13 f0       	push   $0xf013d3e4
f0119a12:	68 35 07 00 00       	push   $0x735
f0119a17:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119a1c:	e8 33 76 fe ff       	call   f0101054 <_warn>
f0119a21:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119a24:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0119a28:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119a2c:	74 04                	je     f0119a32 <test_calculate_required_frames+0x81c>
f0119a2e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0119a32:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0119a36:	83 ec 0c             	sub    $0xc,%esp
f0119a39:	68 f7 c4 13 f0       	push   $0xf013c4f7
f0119a3e:	e8 0a 81 fe ff       	call   f0101b4d <cprintf>
f0119a43:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0119a46:	83 ec 08             	sub    $0x8,%esp
f0119a49:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119a4c:	68 90 d4 13 f0       	push   $0xf013d490
f0119a51:	e8 f7 80 fe ff       	call   f0101b4d <cprintf>
f0119a56:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0119a59:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0119a5d:	75 10                	jne    f0119a6f <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0119a5f:	83 ec 0c             	sub    $0xc,%esp
f0119a62:	68 d0 d4 13 f0       	push   $0xf013d4d0
f0119a67:	e8 e1 80 fe ff       	call   f0101b4d <cprintf>
f0119a6c:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0119a6f:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f0119a74:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0119a77:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119a7a:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0119a7d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0119a82:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0119a85:	5b                   	pop    %ebx
f0119a86:	5e                   	pop    %esi
f0119a87:	5f                   	pop    %edi
f0119a88:	5d                   	pop    %ebp
f0119a89:	c3                   	ret    

f0119a8a <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0119a8a:	55                   	push   %ebp
f0119a8b:	89 e5                	mov    %esp,%ebp
f0119a8d:	57                   	push   %edi
f0119a8e:	56                   	push   %esi
f0119a8f:	53                   	push   %ebx
f0119a90:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0119a96:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0119a99:	bb 6c c2 13 f0       	mov    $0xf013c26c,%ebx
f0119a9e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0119aa3:	89 c7                	mov    %eax,%edi
f0119aa5:	89 de                	mov    %ebx,%esi
f0119aa7:	89 d1                	mov    %edx,%ecx
f0119aa9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0119aab:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0119aae:	b9 23 00 00 00       	mov    $0x23,%ecx
f0119ab3:	b0 00                	mov    $0x0,%al
f0119ab5:	89 d7                	mov    %edx,%edi
f0119ab7:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0119ab9:	6a 00                	push   $0x0
f0119abb:	6a 0a                	push   $0xa
f0119abd:	6a 14                	push   $0x14
f0119abf:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0119ac2:	50                   	push   %eax
f0119ac3:	e8 c9 2f ff ff       	call   f010ca91 <env_create>
f0119ac8:	83 c4 10             	add    $0x10,%esp
f0119acb:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0119ace:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119ad1:	8b 40 64             	mov    0x64(%eax),%eax
f0119ad4:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0119ad7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119ada:	8b 40 68             	mov    0x68(%eax),%eax
f0119add:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0119ae0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ae3:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0119ae6:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0119aed:	75 70 20 
f0119af0:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0119af7:	00 00 00 
f0119afa:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0119afd:	b9 03 00 00 00       	mov    $0x3,%ecx
f0119b02:	b8 00 00 00 00       	mov    $0x0,%eax
f0119b07:	89 d7                	mov    %edx,%edi
f0119b09:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0119b0b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119b0e:	8b 40 10             	mov    0x10(%eax),%eax
f0119b11:	83 ec 08             	sub    $0x8,%esp
f0119b14:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0119b1a:	52                   	push   %edx
f0119b1b:	50                   	push   %eax
f0119b1c:	e8 63 98 00 00       	call   f0123384 <ltostr>
f0119b21:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0119b24:	83 ec 04             	sub    $0x4,%esp
f0119b27:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0119b2d:	50                   	push   %eax
f0119b2e:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0119b34:	50                   	push   %eax
f0119b35:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0119b3b:	50                   	push   %eax
f0119b3c:	e8 1c 99 00 00       	call   f012345d <strcconcat>
f0119b41:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0119b44:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0119b4b:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0119b52:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0119b59:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0119b5d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119b64:	00 00 00 
	uint32 num_tables = 0;
f0119b67:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119b6e:	00 00 00 
	ClearUserSpace(proc_directory);
f0119b71:	83 ec 0c             	sub    $0xc,%esp
f0119b74:	ff 75 d8             	pushl  -0x28(%ebp)
f0119b77:	e8 8d 0e 00 00       	call   f011aa09 <ClearUserSpace>
f0119b7c:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0119b7f:	83 ec 0c             	sub    $0xc,%esp
f0119b82:	68 b0 d3 13 f0       	push   $0xf013d3b0
f0119b87:	e8 c1 7f fe ff       	call   f0101b4d <cprintf>
f0119b8c:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0119b8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119b92:	c1 e0 03             	shl    $0x3,%eax
f0119b95:	89 c2                	mov    %eax,%edx
f0119b97:	83 ec 0c             	sub    $0xc,%esp
f0119b9a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119ba0:	50                   	push   %eax
f0119ba1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119ba7:	50                   	push   %eax
f0119ba8:	52                   	push   %edx
f0119ba9:	6a 00                	push   $0x0
f0119bab:	ff 75 d8             	pushl  -0x28(%ebp)
f0119bae:	e8 8a 2a ff ff       	call   f010c63d <calculate_allocated_space>
f0119bb3:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119bb6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119bbc:	85 c0                	test   %eax,%eax
f0119bbe:	74 27                	je     f0119be7 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119bc0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119bc6:	83 ec 0c             	sub    $0xc,%esp
f0119bc9:	6a 00                	push   $0x0
f0119bcb:	50                   	push   %eax
f0119bcc:	68 1c d5 13 f0       	push   $0xf013d51c
f0119bd1:	68 6a 07 00 00       	push   $0x76a
f0119bd6:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119bdb:	e8 74 74 fe ff       	call   f0101054 <_warn>
f0119be0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119be3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0119be7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119bed:	85 c0                	test   %eax,%eax
f0119bef:	74 27                	je     f0119c18 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0119bf1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119bf7:	83 ec 0c             	sub    $0xc,%esp
f0119bfa:	6a 00                	push   $0x0
f0119bfc:	50                   	push   %eax
f0119bfd:	68 7c d5 13 f0       	push   $0xf013d57c
f0119c02:	68 6f 07 00 00       	push   $0x76f
f0119c07:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119c0c:	e8 43 74 fe ff       	call   f0101054 <_warn>
f0119c11:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119c14:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119c18:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119c1c:	74 04                	je     f0119c22 <test_calculate_allocated_space+0x198>
f0119c1e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119c22:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0119c26:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119c2d:	00 00 00 
		num_pages = 0;
f0119c30:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119c37:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0119c3a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119c3d:	c1 e0 02             	shl    $0x2,%eax
f0119c40:	89 c2                	mov    %eax,%edx
f0119c42:	83 ec 0c             	sub    $0xc,%esp
f0119c45:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119c4b:	50                   	push   %eax
f0119c4c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119c52:	50                   	push   %eax
f0119c53:	52                   	push   %edx
f0119c54:	6a 00                	push   $0x0
f0119c56:	ff 75 d8             	pushl  -0x28(%ebp)
f0119c59:	e8 df 29 ff ff       	call   f010c63d <calculate_allocated_space>
f0119c5e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119c61:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119c67:	85 c0                	test   %eax,%eax
f0119c69:	74 27                	je     f0119c92 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119c6b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119c71:	83 ec 0c             	sub    $0xc,%esp
f0119c74:	6a 00                	push   $0x0
f0119c76:	50                   	push   %eax
f0119c77:	68 1c d5 13 f0       	push   $0xf013d51c
f0119c7c:	68 7b 07 00 00       	push   $0x77b
f0119c81:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119c86:	e8 c9 73 fe ff       	call   f0101054 <_warn>
f0119c8b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119c8e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0119c92:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119c98:	85 c0                	test   %eax,%eax
f0119c9a:	74 27                	je     f0119cc3 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0119c9c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119ca2:	83 ec 0c             	sub    $0xc,%esp
f0119ca5:	6a 00                	push   $0x0
f0119ca7:	50                   	push   %eax
f0119ca8:	68 7c d5 13 f0       	push   $0xf013d57c
f0119cad:	68 80 07 00 00       	push   $0x780
f0119cb2:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119cb7:	e8 98 73 fe ff       	call   f0101054 <_warn>
f0119cbc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119cbf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119cc3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119cc7:	74 04                	je     f0119ccd <test_calculate_allocated_space+0x243>
f0119cc9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119ccd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0119cd1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119cd8:	00 00 00 
		num_pages = 0;
f0119cdb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119ce2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0119ce5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119ce8:	c1 e0 0a             	shl    $0xa,%eax
f0119ceb:	89 c2                	mov    %eax,%edx
f0119ced:	83 ec 0c             	sub    $0xc,%esp
f0119cf0:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119cf6:	50                   	push   %eax
f0119cf7:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119cfd:	50                   	push   %eax
f0119cfe:	52                   	push   %edx
f0119cff:	6a 00                	push   $0x0
f0119d01:	ff 75 d8             	pushl  -0x28(%ebp)
f0119d04:	e8 34 29 ff ff       	call   f010c63d <calculate_allocated_space>
f0119d09:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119d0c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119d12:	85 c0                	test   %eax,%eax
f0119d14:	74 27                	je     f0119d3d <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119d16:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119d1c:	83 ec 0c             	sub    $0xc,%esp
f0119d1f:	6a 00                	push   $0x0
f0119d21:	50                   	push   %eax
f0119d22:	68 1c d5 13 f0       	push   $0xf013d51c
f0119d27:	68 8c 07 00 00       	push   $0x78c
f0119d2c:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119d31:	e8 1e 73 fe ff       	call   f0101054 <_warn>
f0119d36:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119d39:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0119d3d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119d43:	85 c0                	test   %eax,%eax
f0119d45:	74 27                	je     f0119d6e <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0119d47:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119d4d:	83 ec 0c             	sub    $0xc,%esp
f0119d50:	6a 00                	push   $0x0
f0119d52:	50                   	push   %eax
f0119d53:	68 7c d5 13 f0       	push   $0xf013d57c
f0119d58:	68 91 07 00 00       	push   $0x791
f0119d5d:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119d62:	e8 ed 72 fe ff       	call   f0101054 <_warn>
f0119d67:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119d6a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119d6e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119d72:	74 04                	je     f0119d78 <test_calculate_allocated_space+0x2ee>
f0119d74:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119d78:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0119d7c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119d83:	00 00 00 
		num_pages = 0;
f0119d86:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119d8d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0119d90:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0119d93:	89 d0                	mov    %edx,%eax
f0119d95:	01 c0                	add    %eax,%eax
f0119d97:	01 d0                	add    %edx,%eax
f0119d99:	01 c0                	add    %eax,%eax
f0119d9b:	05 00 10 00 00       	add    $0x1000,%eax
f0119da0:	89 c2                	mov    %eax,%edx
f0119da2:	83 ec 0c             	sub    $0xc,%esp
f0119da5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119dab:	50                   	push   %eax
f0119dac:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119db2:	50                   	push   %eax
f0119db3:	52                   	push   %edx
f0119db4:	68 00 10 00 00       	push   $0x1000
f0119db9:	ff 75 d8             	pushl  -0x28(%ebp)
f0119dbc:	e8 7c 28 ff ff       	call   f010c63d <calculate_allocated_space>
f0119dc1:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119dc4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119dca:	85 c0                	test   %eax,%eax
f0119dcc:	74 27                	je     f0119df5 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119dce:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119dd4:	83 ec 0c             	sub    $0xc,%esp
f0119dd7:	6a 00                	push   $0x0
f0119dd9:	50                   	push   %eax
f0119dda:	68 1c d5 13 f0       	push   $0xf013d51c
f0119ddf:	68 9e 07 00 00       	push   $0x79e
f0119de4:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119de9:	e8 66 72 fe ff       	call   f0101054 <_warn>
f0119dee:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119df1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0119df5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119dfb:	85 c0                	test   %eax,%eax
f0119dfd:	74 27                	je     f0119e26 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0119dff:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119e05:	83 ec 0c             	sub    $0xc,%esp
f0119e08:	6a 00                	push   $0x0
f0119e0a:	50                   	push   %eax
f0119e0b:	68 7c d5 13 f0       	push   $0xf013d57c
f0119e10:	68 a3 07 00 00       	push   $0x7a3
f0119e15:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119e1a:	e8 35 72 fe ff       	call   f0101054 <_warn>
f0119e1f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119e22:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119e26:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119e2a:	74 04                	je     f0119e30 <test_calculate_allocated_space+0x3a6>
f0119e2c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119e30:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0119e34:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119e3b:	00 00 00 
		num_pages = 0;
f0119e3e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119e45:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0119e48:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119e4b:	89 c2                	mov    %eax,%edx
f0119e4d:	01 d2                	add    %edx,%edx
f0119e4f:	01 d0                	add    %edx,%eax
f0119e51:	05 00 18 00 00       	add    $0x1800,%eax
f0119e56:	89 c2                	mov    %eax,%edx
f0119e58:	83 ec 0c             	sub    $0xc,%esp
f0119e5b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119e61:	50                   	push   %eax
f0119e62:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119e68:	50                   	push   %eax
f0119e69:	52                   	push   %edx
f0119e6a:	68 00 18 00 00       	push   $0x1800
f0119e6f:	ff 75 d8             	pushl  -0x28(%ebp)
f0119e72:	e8 c6 27 ff ff       	call   f010c63d <calculate_allocated_space>
f0119e77:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119e7a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119e80:	85 c0                	test   %eax,%eax
f0119e82:	74 27                	je     f0119eab <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119e84:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119e8a:	83 ec 0c             	sub    $0xc,%esp
f0119e8d:	6a 00                	push   $0x0
f0119e8f:	50                   	push   %eax
f0119e90:	68 1c d5 13 f0       	push   $0xf013d51c
f0119e95:	68 af 07 00 00       	push   $0x7af
f0119e9a:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119e9f:	e8 b0 71 fe ff       	call   f0101054 <_warn>
f0119ea4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119ea7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0119eab:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119eb1:	85 c0                	test   %eax,%eax
f0119eb3:	74 27                	je     f0119edc <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0119eb5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119ebb:	83 ec 0c             	sub    $0xc,%esp
f0119ebe:	6a 00                	push   $0x0
f0119ec0:	50                   	push   %eax
f0119ec1:	68 7c d5 13 f0       	push   $0xf013d57c
f0119ec6:	68 b4 07 00 00       	push   $0x7b4
f0119ecb:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119ed0:	e8 7f 71 fe ff       	call   f0101054 <_warn>
f0119ed5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119ed8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119edc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119ee0:	74 04                	je     f0119ee6 <test_calculate_allocated_space+0x45c>
f0119ee2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119ee6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0119eea:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119ef1:	00 00 00 
		num_pages = 0;
f0119ef4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119efb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0119efe:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0119f01:	89 d0                	mov    %edx,%eax
f0119f03:	c1 e0 02             	shl    $0x2,%eax
f0119f06:	01 d0                	add    %edx,%eax
f0119f08:	01 c0                	add    %eax,%eax
f0119f0a:	05 00 00 40 00       	add    $0x400000,%eax
f0119f0f:	89 c2                	mov    %eax,%edx
f0119f11:	83 ec 0c             	sub    $0xc,%esp
f0119f14:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119f1a:	50                   	push   %eax
f0119f1b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119f21:	50                   	push   %eax
f0119f22:	52                   	push   %edx
f0119f23:	68 00 00 40 00       	push   $0x400000
f0119f28:	ff 75 d8             	pushl  -0x28(%ebp)
f0119f2b:	e8 0d 27 ff ff       	call   f010c63d <calculate_allocated_space>
f0119f30:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119f33:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119f39:	85 c0                	test   %eax,%eax
f0119f3b:	74 27                	je     f0119f64 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119f3d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119f43:	83 ec 0c             	sub    $0xc,%esp
f0119f46:	6a 00                	push   $0x0
f0119f48:	50                   	push   %eax
f0119f49:	68 1c d5 13 f0       	push   $0xf013d51c
f0119f4e:	68 c0 07 00 00       	push   $0x7c0
f0119f53:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119f58:	e8 f7 70 fe ff       	call   f0101054 <_warn>
f0119f5d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119f60:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0119f64:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119f6a:	85 c0                	test   %eax,%eax
f0119f6c:	74 27                	je     f0119f95 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0119f6e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119f74:	83 ec 0c             	sub    $0xc,%esp
f0119f77:	6a 00                	push   $0x0
f0119f79:	50                   	push   %eax
f0119f7a:	68 7c d5 13 f0       	push   $0xf013d57c
f0119f7f:	68 c5 07 00 00       	push   $0x7c5
f0119f84:	68 d2 b7 13 f0       	push   $0xf013b7d2
f0119f89:	e8 c6 70 fe ff       	call   f0101054 <_warn>
f0119f8e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0119f91:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0119f95:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0119f99:	74 04                	je     f0119f9f <test_calculate_allocated_space+0x515>
f0119f9b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0119f9f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0119fa3:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0119faa:	00 00 00 
		num_pages = 0;
f0119fad:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0119fb4:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0119fb7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119fba:	05 00 00 38 00       	add    $0x380000,%eax
f0119fbf:	01 c0                	add    %eax,%eax
f0119fc1:	89 c2                	mov    %eax,%edx
f0119fc3:	83 ec 0c             	sub    $0xc,%esp
f0119fc6:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0119fcc:	50                   	push   %eax
f0119fcd:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0119fd3:	50                   	push   %eax
f0119fd4:	52                   	push   %edx
f0119fd5:	68 00 00 70 00       	push   $0x700000
f0119fda:	ff 75 d8             	pushl  -0x28(%ebp)
f0119fdd:	e8 5b 26 ff ff       	call   f010c63d <calculate_allocated_space>
f0119fe2:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0119fe5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119feb:	85 c0                	test   %eax,%eax
f0119fed:	74 27                	je     f011a016 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0119fef:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0119ff5:	83 ec 0c             	sub    $0xc,%esp
f0119ff8:	6a 00                	push   $0x0
f0119ffa:	50                   	push   %eax
f0119ffb:	68 1c d5 13 f0       	push   $0xf013d51c
f011a000:	68 d2 07 00 00       	push   $0x7d2
f011a005:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a00a:	e8 45 70 fe ff       	call   f0101054 <_warn>
f011a00f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a012:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011a016:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a01c:	85 c0                	test   %eax,%eax
f011a01e:	74 27                	je     f011a047 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011a020:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a026:	83 ec 0c             	sub    $0xc,%esp
f011a029:	6a 00                	push   $0x0
f011a02b:	50                   	push   %eax
f011a02c:	68 7c d5 13 f0       	push   $0xf013d57c
f011a031:	68 d7 07 00 00       	push   $0x7d7
f011a036:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a03b:	e8 14 70 fe ff       	call   f0101054 <_warn>
f011a040:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a043:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011a047:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a04b:	74 04                	je     f011a051 <test_calculate_allocated_space+0x5c7>
f011a04d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011a051:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f011a055:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a05c:	00 00 00 
		num_pages = 0;
f011a05f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a066:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011a069:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a06c:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011a071:	89 c2                	mov    %eax,%edx
f011a073:	83 ec 0c             	sub    $0xc,%esp
f011a076:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a07c:	50                   	push   %eax
f011a07d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a083:	50                   	push   %eax
f011a084:	52                   	push   %edx
f011a085:	68 ff ff 3f 00       	push   $0x3fffff
f011a08a:	ff 75 d8             	pushl  -0x28(%ebp)
f011a08d:	e8 ab 25 ff ff       	call   f010c63d <calculate_allocated_space>
f011a092:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011a095:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a09b:	85 c0                	test   %eax,%eax
f011a09d:	74 27                	je     f011a0c6 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011a09f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a0a5:	83 ec 0c             	sub    $0xc,%esp
f011a0a8:	6a 00                	push   $0x0
f011a0aa:	50                   	push   %eax
f011a0ab:	68 1c d5 13 f0       	push   $0xf013d51c
f011a0b0:	68 e3 07 00 00       	push   $0x7e3
f011a0b5:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a0ba:	e8 95 6f fe ff       	call   f0101054 <_warn>
f011a0bf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a0c2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011a0c6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a0cc:	85 c0                	test   %eax,%eax
f011a0ce:	74 27                	je     f011a0f7 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011a0d0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a0d6:	83 ec 0c             	sub    $0xc,%esp
f011a0d9:	6a 00                	push   $0x0
f011a0db:	50                   	push   %eax
f011a0dc:	68 7c d5 13 f0       	push   $0xf013d57c
f011a0e1:	68 e8 07 00 00       	push   $0x7e8
f011a0e6:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a0eb:	e8 64 6f fe ff       	call   f0101054 <_warn>
f011a0f0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a0f3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011a0f7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a0fb:	74 04                	je     f011a101 <test_calculate_allocated_space+0x677>
f011a0fd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011a101:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011a105:	83 ec 0c             	sub    $0xc,%esp
f011a108:	68 1d cf 13 f0       	push   $0xf013cf1d
f011a10d:	e8 3b 7a fe ff       	call   f0101b4d <cprintf>
f011a112:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011a115:	83 ec 0c             	sub    $0xc,%esp
f011a118:	68 3c d4 13 f0       	push   $0xf013d43c
f011a11d:	e8 2b 7a fe ff       	call   f0101b4d <cprintf>
f011a122:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011a125:	83 ec 04             	sub    $0x4,%esp
f011a128:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f011a12e:	50                   	push   %eax
f011a12f:	68 d6 c2 13 f0       	push   $0xf013c2d6
f011a134:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a13a:	50                   	push   %eax
f011a13b:	e8 1d 93 00 00       	call   f012345d <strcconcat>
f011a140:	83 c4 10             	add    $0x10,%esp
f011a143:	83 ec 0c             	sub    $0xc,%esp
f011a146:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f011a14c:	50                   	push   %eax
f011a14d:	e8 ba 7c fe ff       	call   f0101e0c <execute_command>
f011a152:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f011a155:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a15c:	00 00 00 
		num_pages = 0;
f011a15f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a166:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f011a169:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a16c:	c1 e0 03             	shl    $0x3,%eax
f011a16f:	89 c2                	mov    %eax,%edx
f011a171:	83 ec 0c             	sub    $0xc,%esp
f011a174:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a17a:	50                   	push   %eax
f011a17b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a181:	50                   	push   %eax
f011a182:	52                   	push   %edx
f011a183:	6a 00                	push   $0x0
f011a185:	ff 75 d8             	pushl  -0x28(%ebp)
f011a188:	e8 b0 24 ff ff       	call   f010c63d <calculate_allocated_space>
f011a18d:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011a190:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f011a197:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a19e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a1a4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a1a7:	74 28                	je     f011a1d1 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a1a9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a1af:	83 ec 0c             	sub    $0xc,%esp
f011a1b2:	ff 75 c8             	pushl  -0x38(%ebp)
f011a1b5:	50                   	push   %eax
f011a1b6:	68 1c d5 13 f0       	push   $0xf013d51c
f011a1bb:	68 ff 07 00 00       	push   $0x7ff
f011a1c0:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a1c5:	e8 8a 6e fe ff       	call   f0101054 <_warn>
f011a1ca:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a1cd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a1d1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a1d7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a1da:	74 28                	je     f011a204 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a1dc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a1e2:	83 ec 0c             	sub    $0xc,%esp
f011a1e5:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a1e8:	50                   	push   %eax
f011a1e9:	68 7c d5 13 f0       	push   $0xf013d57c
f011a1ee:	68 04 08 00 00       	push   $0x804
f011a1f3:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a1f8:	e8 57 6e fe ff       	call   f0101054 <_warn>
f011a1fd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a200:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011a204:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a208:	74 04                	je     f011a20e <test_calculate_allocated_space+0x784>
f011a20a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011a20e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f011a212:	83 ec 04             	sub    $0x4,%esp
f011a215:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011a21b:	50                   	push   %eax
f011a21c:	68 e3 c2 13 f0       	push   $0xf013c2e3
f011a221:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a227:	50                   	push   %eax
f011a228:	e8 30 92 00 00       	call   f012345d <strcconcat>
f011a22d:	83 c4 10             	add    $0x10,%esp
f011a230:	83 ec 0c             	sub    $0xc,%esp
f011a233:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011a239:	50                   	push   %eax
f011a23a:	e8 cd 7b fe ff       	call   f0101e0c <execute_command>
f011a23f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011a242:	83 ec 04             	sub    $0x4,%esp
f011a245:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011a24b:	50                   	push   %eax
f011a24c:	68 70 d4 13 f0       	push   $0xf013d470
f011a251:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a257:	50                   	push   %eax
f011a258:	e8 00 92 00 00       	call   f012345d <strcconcat>
f011a25d:	83 c4 10             	add    $0x10,%esp
f011a260:	83 ec 0c             	sub    $0xc,%esp
f011a263:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011a269:	50                   	push   %eax
f011a26a:	e8 9d 7b fe ff       	call   f0101e0c <execute_command>
f011a26f:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f011a272:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a279:	00 00 00 
		num_pages = 0;
f011a27c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a283:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f011a286:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011a289:	c1 e0 03             	shl    $0x3,%eax
f011a28c:	89 c2                	mov    %eax,%edx
f011a28e:	83 ec 0c             	sub    $0xc,%esp
f011a291:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a297:	50                   	push   %eax
f011a298:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a29e:	50                   	push   %eax
f011a29f:	52                   	push   %edx
f011a2a0:	6a 00                	push   $0x0
f011a2a2:	ff 75 d8             	pushl  -0x28(%ebp)
f011a2a5:	e8 93 23 ff ff       	call   f010c63d <calculate_allocated_space>
f011a2aa:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011a2ad:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f011a2b4:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a2bb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a2c1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a2c4:	74 28                	je     f011a2ee <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a2c6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a2cc:	83 ec 0c             	sub    $0xc,%esp
f011a2cf:	ff 75 c8             	pushl  -0x38(%ebp)
f011a2d2:	50                   	push   %eax
f011a2d3:	68 1c d5 13 f0       	push   $0xf013d51c
f011a2d8:	68 15 08 00 00       	push   $0x815
f011a2dd:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a2e2:	e8 6d 6d fe ff       	call   f0101054 <_warn>
f011a2e7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a2ea:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a2ee:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a2f4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a2f7:	74 28                	je     f011a321 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a2f9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a2ff:	83 ec 0c             	sub    $0xc,%esp
f011a302:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a305:	50                   	push   %eax
f011a306:	68 7c d5 13 f0       	push   $0xf013d57c
f011a30b:	68 1a 08 00 00       	push   $0x81a
f011a310:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a315:	e8 3a 6d fe ff       	call   f0101054 <_warn>
f011a31a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a31d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011a321:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a325:	74 04                	je     f011a32b <test_calculate_allocated_space+0x8a1>
f011a327:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011a32b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f011a32f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a336:	00 00 00 
		num_pages = 0;
f011a339:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a340:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011a343:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011a346:	c1 e0 0a             	shl    $0xa,%eax
f011a349:	89 c2                	mov    %eax,%edx
f011a34b:	83 ec 0c             	sub    $0xc,%esp
f011a34e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a354:	50                   	push   %eax
f011a355:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a35b:	50                   	push   %eax
f011a35c:	52                   	push   %edx
f011a35d:	6a 00                	push   $0x0
f011a35f:	ff 75 d8             	pushl  -0x28(%ebp)
f011a362:	e8 d6 22 ff ff       	call   f010c63d <calculate_allocated_space>
f011a367:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f011a36a:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f011a371:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a378:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a37e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a381:	74 28                	je     f011a3ab <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a383:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a389:	83 ec 0c             	sub    $0xc,%esp
f011a38c:	ff 75 c8             	pushl  -0x38(%ebp)
f011a38f:	50                   	push   %eax
f011a390:	68 1c d5 13 f0       	push   $0xf013d51c
f011a395:	68 28 08 00 00       	push   $0x828
f011a39a:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a39f:	e8 b0 6c fe ff       	call   f0101054 <_warn>
f011a3a4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a3a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a3ab:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a3b1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3b4:	74 28                	je     f011a3de <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a3b6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a3bc:	83 ec 0c             	sub    $0xc,%esp
f011a3bf:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a3c2:	50                   	push   %eax
f011a3c3:	68 7c d5 13 f0       	push   $0xf013d57c
f011a3c8:	68 2d 08 00 00       	push   $0x82d
f011a3cd:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a3d2:	e8 7d 6c fe ff       	call   f0101054 <_warn>
f011a3d7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a3da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011a3de:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a3e2:	74 04                	je     f011a3e8 <test_calculate_allocated_space+0x95e>
f011a3e4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011a3e8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f011a3ec:	83 ec 04             	sub    $0x4,%esp
f011a3ef:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011a3f5:	50                   	push   %eax
f011a3f6:	68 7c d4 13 f0       	push   $0xf013d47c
f011a3fb:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a401:	50                   	push   %eax
f011a402:	e8 56 90 00 00       	call   f012345d <strcconcat>
f011a407:	83 c4 10             	add    $0x10,%esp
f011a40a:	83 ec 0c             	sub    $0xc,%esp
f011a40d:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011a413:	50                   	push   %eax
f011a414:	e8 f3 79 fe ff       	call   f0101e0c <execute_command>
f011a419:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f011a41c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a423:	00 00 00 
		num_pages = 0;
f011a426:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a42d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011a430:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a433:	89 c2                	mov    %eax,%edx
f011a435:	01 d2                	add    %edx,%edx
f011a437:	01 d0                	add    %edx,%eax
f011a439:	05 00 18 00 00       	add    $0x1800,%eax
f011a43e:	89 c2                	mov    %eax,%edx
f011a440:	83 ec 0c             	sub    $0xc,%esp
f011a443:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a449:	50                   	push   %eax
f011a44a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a450:	50                   	push   %eax
f011a451:	52                   	push   %edx
f011a452:	68 00 18 00 00       	push   $0x1800
f011a457:	ff 75 d8             	pushl  -0x28(%ebp)
f011a45a:	e8 de 21 ff ff       	call   f010c63d <calculate_allocated_space>
f011a45f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011a462:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011a469:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a470:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a476:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a479:	74 28                	je     f011a4a3 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a47b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a481:	83 ec 0c             	sub    $0xc,%esp
f011a484:	ff 75 c8             	pushl  -0x38(%ebp)
f011a487:	50                   	push   %eax
f011a488:	68 1c d5 13 f0       	push   $0xf013d51c
f011a48d:	68 3e 08 00 00       	push   $0x83e
f011a492:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a497:	e8 b8 6b fe ff       	call   f0101054 <_warn>
f011a49c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a49f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a4a3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a4a9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4ac:	74 28                	je     f011a4d6 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a4ae:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a4b4:	83 ec 0c             	sub    $0xc,%esp
f011a4b7:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a4ba:	50                   	push   %eax
f011a4bb:	68 7c d5 13 f0       	push   $0xf013d57c
f011a4c0:	68 43 08 00 00       	push   $0x843
f011a4c5:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a4ca:	e8 85 6b fe ff       	call   f0101054 <_warn>
f011a4cf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a4d2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011a4d6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a4da:	74 04                	je     f011a4e0 <test_calculate_allocated_space+0xa56>
f011a4dc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011a4e0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011a4e4:	83 ec 04             	sub    $0x4,%esp
f011a4e7:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011a4ed:	50                   	push   %eax
f011a4ee:	68 3c c5 13 f0       	push   $0xf013c53c
f011a4f3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a4f9:	50                   	push   %eax
f011a4fa:	e8 5e 8f 00 00       	call   f012345d <strcconcat>
f011a4ff:	83 c4 10             	add    $0x10,%esp
f011a502:	83 ec 0c             	sub    $0xc,%esp
f011a505:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011a50b:	50                   	push   %eax
f011a50c:	e8 fb 78 fe ff       	call   f0101e0c <execute_command>
f011a511:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f011a514:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a51b:	00 00 00 
		num_pages = 0;
f011a51e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a525:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f011a528:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011a52b:	89 d0                	mov    %edx,%eax
f011a52d:	c1 e0 02             	shl    $0x2,%eax
f011a530:	01 d0                	add    %edx,%eax
f011a532:	01 c0                	add    %eax,%eax
f011a534:	05 00 00 40 00       	add    $0x400000,%eax
f011a539:	89 c2                	mov    %eax,%edx
f011a53b:	83 ec 0c             	sub    $0xc,%esp
f011a53e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a544:	50                   	push   %eax
f011a545:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a54b:	50                   	push   %eax
f011a54c:	52                   	push   %edx
f011a54d:	68 00 00 40 00       	push   $0x400000
f011a552:	ff 75 d8             	pushl  -0x28(%ebp)
f011a555:	e8 e3 20 ff ff       	call   f010c63d <calculate_allocated_space>
f011a55a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011a55d:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011a564:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a56b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a571:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a574:	74 28                	je     f011a59e <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a576:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a57c:	83 ec 0c             	sub    $0xc,%esp
f011a57f:	ff 75 c8             	pushl  -0x38(%ebp)
f011a582:	50                   	push   %eax
f011a583:	68 1c d5 13 f0       	push   $0xf013d51c
f011a588:	68 53 08 00 00       	push   $0x853
f011a58d:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a592:	e8 bd 6a fe ff       	call   f0101054 <_warn>
f011a597:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a59a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a59e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a5a4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5a7:	74 28                	je     f011a5d1 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a5a9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a5af:	83 ec 0c             	sub    $0xc,%esp
f011a5b2:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a5b5:	50                   	push   %eax
f011a5b6:	68 7c d5 13 f0       	push   $0xf013d57c
f011a5bb:	68 58 08 00 00       	push   $0x858
f011a5c0:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a5c5:	e8 8a 6a fe ff       	call   f0101054 <_warn>
f011a5ca:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a5cd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011a5d1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a5d5:	74 04                	je     f011a5db <test_calculate_allocated_space+0xb51>
f011a5d7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011a5db:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f011a5df:	83 ec 04             	sub    $0x4,%esp
f011a5e2:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011a5e8:	50                   	push   %eax
f011a5e9:	68 46 c5 13 f0       	push   $0xf013c546
f011a5ee:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a5f4:	50                   	push   %eax
f011a5f5:	e8 63 8e 00 00       	call   f012345d <strcconcat>
f011a5fa:	83 c4 10             	add    $0x10,%esp
f011a5fd:	83 ec 0c             	sub    $0xc,%esp
f011a600:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011a606:	50                   	push   %eax
f011a607:	e8 00 78 fe ff       	call   f0101e0c <execute_command>
f011a60c:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011a60f:	83 ec 04             	sub    $0x4,%esp
f011a612:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011a618:	50                   	push   %eax
f011a619:	68 84 d4 13 f0       	push   $0xf013d484
f011a61e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011a624:	50                   	push   %eax
f011a625:	e8 33 8e 00 00       	call   f012345d <strcconcat>
f011a62a:	83 c4 10             	add    $0x10,%esp
f011a62d:	83 ec 0c             	sub    $0xc,%esp
f011a630:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011a636:	50                   	push   %eax
f011a637:	e8 d0 77 fe ff       	call   f0101e0c <execute_command>
f011a63c:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f011a63f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a646:	00 00 00 
		num_pages = 0;
f011a649:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a650:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011a653:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011a656:	05 00 00 38 00       	add    $0x380000,%eax
f011a65b:	01 c0                	add    %eax,%eax
f011a65d:	89 c2                	mov    %eax,%edx
f011a65f:	83 ec 0c             	sub    $0xc,%esp
f011a662:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a668:	50                   	push   %eax
f011a669:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a66f:	50                   	push   %eax
f011a670:	52                   	push   %edx
f011a671:	68 00 00 70 00       	push   $0x700000
f011a676:	ff 75 d8             	pushl  -0x28(%ebp)
f011a679:	e8 bf 1f ff ff       	call   f010c63d <calculate_allocated_space>
f011a67e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011a681:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f011a688:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a68f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a695:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a698:	74 28                	je     f011a6c2 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a69a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a6a0:	83 ec 0c             	sub    $0xc,%esp
f011a6a3:	ff 75 c8             	pushl  -0x38(%ebp)
f011a6a6:	50                   	push   %eax
f011a6a7:	68 1c d5 13 f0       	push   $0xf013d51c
f011a6ac:	68 6a 08 00 00       	push   $0x86a
f011a6b1:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a6b6:	e8 99 69 fe ff       	call   f0101054 <_warn>
f011a6bb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a6be:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a6c2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a6c8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6cb:	74 28                	je     f011a6f5 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a6cd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a6d3:	83 ec 0c             	sub    $0xc,%esp
f011a6d6:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a6d9:	50                   	push   %eax
f011a6da:	68 7c d5 13 f0       	push   $0xf013d57c
f011a6df:	68 6f 08 00 00       	push   $0x86f
f011a6e4:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a6e9:	e8 66 69 fe ff       	call   f0101054 <_warn>
f011a6ee:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a6f1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011a6f5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a6f9:	74 04                	je     f011a6ff <test_calculate_allocated_space+0xc75>
f011a6fb:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011a6ff:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f011a703:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011a70a:	00 00 00 
		num_pages = 0;
f011a70d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011a714:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011a717:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a71a:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011a71f:	89 c2                	mov    %eax,%edx
f011a721:	83 ec 0c             	sub    $0xc,%esp
f011a724:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011a72a:	50                   	push   %eax
f011a72b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011a731:	50                   	push   %eax
f011a732:	52                   	push   %edx
f011a733:	68 ff ff 3f 00       	push   $0x3fffff
f011a738:	ff 75 d8             	pushl  -0x28(%ebp)
f011a73b:	e8 fd 1e ff ff       	call   f010c63d <calculate_allocated_space>
f011a740:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011a743:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f011a74a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011a751:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a757:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011a75a:	74 28                	je     f011a784 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011a75c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011a762:	83 ec 0c             	sub    $0xc,%esp
f011a765:	ff 75 c8             	pushl  -0x38(%ebp)
f011a768:	50                   	push   %eax
f011a769:	68 1c d5 13 f0       	push   $0xf013d51c
f011a76e:	68 7d 08 00 00       	push   $0x87d
f011a773:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a778:	e8 d7 68 fe ff       	call   f0101054 <_warn>
f011a77d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a780:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011a784:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a78a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a78d:	74 28                	je     f011a7b7 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011a78f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a795:	83 ec 0c             	sub    $0xc,%esp
f011a798:	ff 75 c4             	pushl  -0x3c(%ebp)
f011a79b:	50                   	push   %eax
f011a79c:	68 7c d5 13 f0       	push   $0xf013d57c
f011a7a1:	68 82 08 00 00       	push   $0x882
f011a7a6:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a7ab:	e8 a4 68 fe ff       	call   f0101054 <_warn>
f011a7b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011a7b3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011a7b7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011a7bb:	74 04                	je     f011a7c1 <test_calculate_allocated_space+0xd37>
f011a7bd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011a7c1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011a7c5:	83 ec 0c             	sub    $0xc,%esp
f011a7c8:	68 f7 c4 13 f0       	push   $0xf013c4f7
f011a7cd:	e8 7b 73 fe ff       	call   f0101b4d <cprintf>
f011a7d2:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011a7d5:	83 ec 08             	sub    $0x8,%esp
f011a7d8:	ff 75 e4             	pushl  -0x1c(%ebp)
f011a7db:	68 d8 d5 13 f0       	push   $0xf013d5d8
f011a7e0:	e8 68 73 fe ff       	call   f0101b4d <cprintf>
f011a7e5:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011a7e8:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011a7ec:	75 10                	jne    f011a7fe <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f011a7ee:	83 ec 0c             	sub    $0xc,%esp
f011a7f1:	68 18 d6 13 f0       	push   $0xf013d618
f011a7f6:	e8 52 73 fe ff       	call   f0101b4d <cprintf>
f011a7fb:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011a7fe:	a1 80 54 96 f1       	mov    0xf1965480,%eax
f011a803:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011a806:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a809:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011a80c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011a811:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011a814:	5b                   	pop    %ebx
f011a815:	5e                   	pop    %esi
f011a816:	5f                   	pop    %edi
f011a817:	5d                   	pop    %ebp
f011a818:	c3                   	ret    

f011a819 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f011a819:	55                   	push   %ebp
f011a81a:	89 e5                	mov    %esp,%ebp
f011a81c:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f011a81f:	8b 45 10             	mov    0x10(%ebp),%eax
f011a822:	ba 01 00 00 00       	mov    $0x1,%edx
f011a827:	88 c1                	mov    %al,%cl
f011a829:	d3 e2                	shl    %cl,%edx
f011a82b:	89 d0                	mov    %edx,%eax
f011a82d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011a830:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a833:	c1 e8 16             	shr    $0x16,%eax
f011a836:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a83d:	8b 45 08             	mov    0x8(%ebp),%eax
f011a840:	01 d0                	add    %edx,%eax
f011a842:	8b 00                	mov    (%eax),%eax
f011a844:	83 e0 01             	and    $0x1,%eax
f011a847:	85 c0                	test   %eax,%eax
f011a849:	75 07                	jne    f011a852 <CB+0x39>
f011a84b:	b8 00 00 00 00       	mov    $0x0,%eax
f011a850:	eb 76                	jmp    f011a8c8 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011a852:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a855:	c1 e8 16             	shr    $0x16,%eax
f011a858:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a85f:	8b 45 08             	mov    0x8(%ebp),%eax
f011a862:	01 d0                	add    %edx,%eax
f011a864:	8b 00                	mov    (%eax),%eax
f011a866:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a86b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a871:	c1 e8 0c             	shr    $0xc,%eax
f011a874:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a877:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f011a87c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011a87f:	72 17                	jb     f011a898 <CB+0x7f>
f011a881:	ff 75 f0             	pushl  -0x10(%ebp)
f011a884:	68 64 d6 13 f0       	push   $0xf013d664
f011a889:	68 9d 08 00 00       	push   $0x89d
f011a88e:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a893:	e8 17 66 fe ff       	call   f0100eaf <_panic>
f011a898:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a89b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a8a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f011a8a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a8a6:	c1 e8 0c             	shr    $0xc,%eax
f011a8a9:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a8ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a8b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a8b8:	01 d0                	add    %edx,%eax
f011a8ba:	8b 00                	mov    (%eax),%eax
f011a8bc:	23 45 f4             	and    -0xc(%ebp),%eax
f011a8bf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a8c2:	0f 94 c0             	sete   %al
f011a8c5:	0f b6 c0             	movzbl %al,%eax
}
f011a8c8:	c9                   	leave  
f011a8c9:	c3                   	ret    

f011a8ca <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011a8ca:	55                   	push   %ebp
f011a8cb:	89 e5                	mov    %esp,%ebp
f011a8cd:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011a8d0:	68 93 d6 13 f0       	push   $0xf013d693
f011a8d5:	68 a2 d6 13 f0       	push   $0xf013d6a2
f011a8da:	68 a2 08 00 00       	push   $0x8a2
f011a8df:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a8e4:	e8 c6 65 fe ff       	call   f0100eaf <_panic>

f011a8e9 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f011a8e9:	55                   	push   %ebp
f011a8ea:	89 e5                	mov    %esp,%ebp
f011a8ec:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011a8ef:	68 93 d6 13 f0       	push   $0xf013d693
f011a8f4:	68 a2 d6 13 f0       	push   $0xf013d6a2
f011a8f9:	68 ac 08 00 00       	push   $0x8ac
f011a8fe:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a903:	e8 a7 65 fe ff       	call   f0100eaf <_panic>

f011a908 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f011a908:	55                   	push   %ebp
f011a909:	89 e5                	mov    %esp,%ebp
f011a90b:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011a90e:	68 93 d6 13 f0       	push   $0xf013d693
f011a913:	68 a2 d6 13 f0       	push   $0xf013d6a2
f011a918:	68 bb 08 00 00       	push   $0x8bb
f011a91d:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a922:	e8 88 65 fe ff       	call   f0100eaf <_panic>

f011a927 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return (table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF) + (va & 0xFFF);
}

int CE(uint32 *_d, uint32 va)
{
f011a927:	55                   	push   %ebp
f011a928:	89 e5                	mov    %esp,%ebp
f011a92a:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011a92d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a930:	c1 e8 16             	shr    $0x16,%eax
f011a933:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a93a:	8b 45 08             	mov    0x8(%ebp),%eax
f011a93d:	01 d0                	add    %edx,%eax
f011a93f:	8b 00                	mov    (%eax),%eax
f011a941:	83 e0 01             	and    $0x1,%eax
f011a944:	85 c0                	test   %eax,%eax
f011a946:	75 07                	jne    f011a94f <CE+0x28>
f011a948:	b8 00 00 00 00       	mov    $0x0,%eax
f011a94d:	eb 7a                	jmp    f011a9c9 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011a94f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a952:	c1 e8 16             	shr    $0x16,%eax
f011a955:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a95c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a95f:	01 d0                	add    %edx,%eax
f011a961:	8b 00                	mov    (%eax),%eax
f011a963:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a968:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011a96b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a96e:	c1 e8 0c             	shr    $0xc,%eax
f011a971:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a974:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f011a979:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f011a97c:	72 17                	jb     f011a995 <CE+0x6e>
f011a97e:	ff 75 f4             	pushl  -0xc(%ebp)
f011a981:	68 64 d6 13 f0       	push   $0xf013d664
f011a986:	68 c4 08 00 00       	push   $0x8c4
f011a98b:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a990:	e8 1a 65 fe ff       	call   f0100eaf <_panic>
f011a995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a998:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a99d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f011a9a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a9a3:	c1 e8 0c             	shr    $0xc,%eax
f011a9a6:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a9ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a9b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a9b5:	01 d0                	add    %edx,%eax
f011a9b7:	8b 00                	mov    (%eax),%eax
f011a9b9:	85 c0                	test   %eax,%eax
f011a9bb:	74 07                	je     f011a9c4 <CE+0x9d>
f011a9bd:	b8 00 00 00 00       	mov    $0x0,%eax
f011a9c2:	eb 05                	jmp    f011a9c9 <CE+0xa2>
	return 1;
f011a9c4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011a9c9:	c9                   	leave  
f011a9ca:	c3                   	ret    

f011a9cb <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f011a9cb:	55                   	push   %ebp
f011a9cc:	89 e5                	mov    %esp,%ebp
f011a9ce:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011a9d1:	68 93 d6 13 f0       	push   $0xf013d693
f011a9d6:	68 a2 d6 13 f0       	push   $0xf013d6a2
f011a9db:	68 cb 08 00 00       	push   $0x8cb
f011a9e0:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011a9e5:	e8 c5 64 fe ff       	call   f0100eaf <_panic>

f011a9ea <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f011a9ea:	55                   	push   %ebp
f011a9eb:	89 e5                	mov    %esp,%ebp
f011a9ed:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011a9f0:	68 93 d6 13 f0       	push   $0xf013d693
f011a9f5:	68 a2 d6 13 f0       	push   $0xf013d6a2
f011a9fa:	68 db 08 00 00       	push   $0x8db
f011a9ff:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011aa04:	e8 a6 64 fe ff       	call   f0100eaf <_panic>

f011aa09 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f011aa09:	55                   	push   %ebp
f011aa0a:	89 e5                	mov    %esp,%ebp
f011aa0c:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f011aa0f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011aa16:	eb 18                	jmp    f011aa30 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f011aa18:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011aa1b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011aa22:	8b 45 08             	mov    0x8(%ebp),%eax
f011aa25:	01 d0                	add    %edx,%eax
f011aa27:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f011aa2d:	ff 45 fc             	incl   -0x4(%ebp)
f011aa30:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011aa33:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f011aa38:	76 de                	jbe    f011aa18 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f011aa3a:	90                   	nop
f011aa3b:	c9                   	leave  
f011aa3c:	c3                   	ret    

f011aa3d <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f011aa3d:	55                   	push   %ebp
f011aa3e:	89 e5                	mov    %esp,%ebp
f011aa40:	83 ec 38             	sub    $0x38,%esp
f011aa43:	8b 45 2c             	mov    0x2c(%ebp),%eax
f011aa46:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f011aa49:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa4c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011aa51:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f011aa54:	8b 45 10             	mov    0x10(%ebp),%eax
f011aa57:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011aa5c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011aa5f:	e9 ea 01 00 00       	jmp    f011ac4e <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f011aa64:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011aa68:	74 44                	je     f011aaae <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f011aa6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa6d:	83 ec 04             	sub    $0x4,%esp
f011aa70:	8d 55 dc             	lea    -0x24(%ebp),%edx
f011aa73:	52                   	push   %edx
f011aa74:	50                   	push   %eax
f011aa75:	ff 75 08             	pushl  0x8(%ebp)
f011aa78:	e8 6d f1 fe ff       	call   f0109bea <get_frame_info>
f011aa7d:	83 c4 10             	add    $0x10,%esp
f011aa80:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f011aa83:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011aa86:	85 c0                	test   %eax,%eax
f011aa88:	75 24                	jne    f011aaae <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f011aa8a:	83 ec 04             	sub    $0x4,%esp
f011aa8d:	68 b8 d6 13 f0       	push   $0xf013d6b8
f011aa92:	68 f8 08 00 00       	push   $0x8f8
f011aa97:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011aa9c:	e8 b3 65 fe ff       	call   f0101054 <_warn>
f011aaa1:	83 c4 10             	add    $0x10,%esp
				return 0;
f011aaa4:	b8 00 00 00 00       	mov    $0x0,%eax
f011aaa9:	e9 b6 01 00 00       	jmp    f011ac64 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f011aaae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011aab1:	83 ec 04             	sub    $0x4,%esp
f011aab4:	8d 55 d8             	lea    -0x28(%ebp),%edx
f011aab7:	52                   	push   %edx
f011aab8:	50                   	push   %eax
f011aab9:	ff 75 08             	pushl  0x8(%ebp)
f011aabc:	e8 29 f1 fe ff       	call   f0109bea <get_frame_info>
f011aac1:	83 c4 10             	add    $0x10,%esp
f011aac4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f011aac7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011aaca:	85 c0                	test   %eax,%eax
f011aacc:	75 24                	jne    f011aaf2 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f011aace:	83 ec 04             	sub    $0x4,%esp
f011aad1:	68 e4 d6 13 f0       	push   $0xf013d6e4
f011aad6:	68 ff 08 00 00       	push   $0x8ff
f011aadb:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011aae0:	e8 6f 65 fe ff       	call   f0101054 <_warn>
f011aae5:	83 c4 10             	add    $0x10,%esp
			return 0;
f011aae8:	b8 00 00 00 00       	mov    $0x0,%eax
f011aaed:	e9 72 01 00 00       	jmp    f011ac64 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f011aaf2:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011aaf6:	75 70                	jne    f011ab68 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011aaf8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011aafb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aafe:	c1 ea 0c             	shr    $0xc,%edx
f011ab01:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011ab07:	c1 e2 02             	shl    $0x2,%edx
f011ab0a:	01 d0                	add    %edx,%eax
f011ab0c:	8b 00                	mov    (%eax),%eax
f011ab0e:	c1 e8 0c             	shr    $0xc,%eax
f011ab11:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f011ab14:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ab17:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ab1a:	c1 ea 0c             	shr    $0xc,%edx
f011ab1d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011ab23:	c1 e2 02             	shl    $0x2,%edx
f011ab26:	01 d0                	add    %edx,%eax
f011ab28:	8b 00                	mov    (%eax),%eax
f011ab2a:	c1 e8 0c             	shr    $0xc,%eax
f011ab2d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f011ab30:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ab33:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011ab36:	74 30                	je     f011ab68 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f011ab38:	83 ec 04             	sub    $0x4,%esp
f011ab3b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ab3e:	ff 75 e8             	pushl  -0x18(%ebp)
f011ab41:	ff 75 f0             	pushl  -0x10(%ebp)
f011ab44:	ff 75 f4             	pushl  -0xc(%ebp)
f011ab47:	68 10 d7 13 f0       	push   $0xf013d710
f011ab4c:	68 09 09 00 00       	push   $0x909
f011ab51:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011ab56:	e8 f9 64 fe ff       	call   f0101054 <_warn>
f011ab5b:	83 c4 20             	add    $0x20,%esp
				return 0;
f011ab5e:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab63:	e9 fc 00 00 00       	jmp    f011ac64 <CCP+0x227>
			}
		}
		if (ref != -1)
f011ab68:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f011ab6c:	74 52                	je     f011abc0 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f011ab6e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ab72:	74 0e                	je     f011ab82 <CCP+0x145>
f011ab74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ab77:	8b 40 08             	mov    0x8(%eax),%eax
f011ab7a:	0f b7 c0             	movzwl %ax,%eax
f011ab7d:	3b 45 18             	cmp    0x18(%ebp),%eax
f011ab80:	74 3e                	je     f011abc0 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f011ab82:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ab86:	74 0b                	je     f011ab93 <CCP+0x156>
f011ab88:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ab8b:	8b 40 08             	mov    0x8(%eax),%eax
f011ab8e:	0f b7 c0             	movzwl %ax,%eax
f011ab91:	eb 05                	jmp    f011ab98 <CCP+0x15b>
f011ab93:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab98:	83 ec 0c             	sub    $0xc,%esp
f011ab9b:	50                   	push   %eax
f011ab9c:	ff 75 f0             	pushl  -0x10(%ebp)
f011ab9f:	68 6c d7 13 f0       	push   $0xf013d76c
f011aba4:	68 11 09 00 00       	push   $0x911
f011aba9:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011abae:	e8 a1 64 fe ff       	call   f0101054 <_warn>
f011abb3:	83 c4 20             	add    $0x20,%esp
				return 0;
f011abb6:	b8 00 00 00 00       	mov    $0x0,%eax
f011abbb:	e9 a4 00 00 00       	jmp    f011ac64 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f011abc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011abc3:	ff 75 20             	pushl  0x20(%ebp)
f011abc6:	ff 75 1c             	pushl  0x1c(%ebp)
f011abc9:	50                   	push   %eax
f011abca:	ff 75 08             	pushl  0x8(%ebp)
f011abcd:	e8 17 fd ff ff       	call   f011a8e9 <CPs>
f011abd2:	83 c4 10             	add    $0x10,%esp
f011abd5:	85 c0                	test   %eax,%eax
f011abd7:	7f 21                	jg     f011abfa <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f011abd9:	83 ec 04             	sub    $0x4,%esp
f011abdc:	68 dc d7 13 f0       	push   $0xf013d7dc
f011abe1:	68 17 09 00 00       	push   $0x917
f011abe6:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011abeb:	e8 64 64 fe ff       	call   f0101054 <_warn>
f011abf0:	83 c4 10             	add    $0x10,%esp
			return 0;
f011abf3:	b8 00 00 00 00       	mov    $0x0,%eax
f011abf8:	eb 6a                	jmp    f011ac64 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f011abfa:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011abfe:	74 3a                	je     f011ac3a <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f011ac00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ac03:	ff 75 28             	pushl  0x28(%ebp)
f011ac06:	ff 75 24             	pushl  0x24(%ebp)
f011ac09:	50                   	push   %eax
f011ac0a:	ff 75 08             	pushl  0x8(%ebp)
f011ac0d:	e8 d7 fc ff ff       	call   f011a8e9 <CPs>
f011ac12:	83 c4 10             	add    $0x10,%esp
f011ac15:	85 c0                	test   %eax,%eax
f011ac17:	7f 21                	jg     f011ac3a <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f011ac19:	83 ec 04             	sub    $0x4,%esp
f011ac1c:	68 24 d8 13 f0       	push   $0xf013d824
f011ac21:	68 1e 09 00 00       	push   $0x91e
f011ac26:	68 d2 b7 13 f0       	push   $0xf013b7d2
f011ac2b:	e8 24 64 fe ff       	call   f0101054 <_warn>
f011ac30:	83 c4 10             	add    $0x10,%esp
				return 0;
f011ac33:	b8 00 00 00 00       	mov    $0x0,%eax
f011ac38:	eb 2a                	jmp    f011ac64 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f011ac3a:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011ac3e:	74 07                	je     f011ac47 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f011ac40:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011ac47:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f011ac4e:	8b 55 10             	mov    0x10(%ebp),%edx
f011ac51:	8b 45 14             	mov    0x14(%ebp),%eax
f011ac54:	01 d0                	add    %edx,%eax
f011ac56:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011ac59:	0f 87 05 fe ff ff    	ja     f011aa64 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f011ac5f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011ac64:	c9                   	leave  
f011ac65:	c3                   	ret    

f011ac66 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f011ac66:	55                   	push   %ebp
f011ac67:	89 e5                	mov    %esp,%ebp
f011ac69:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f011ac6c:	83 ec 04             	sub    $0x4,%esp
f011ac6f:	68 64 d8 13 f0       	push   $0xf013d864
f011ac74:	6a 0e                	push   $0xe
f011ac76:	68 74 d8 13 f0       	push   $0xf013d874
f011ac7b:	e8 2f 62 fe ff       	call   f0100eaf <_panic>

f011ac80 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f011ac80:	55                   	push   %ebp
f011ac81:	89 e5                	mov    %esp,%ebp
f011ac83:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f011ac86:	83 ec 04             	sub    $0x4,%esp
f011ac89:	68 64 d8 13 f0       	push   $0xf013d864
f011ac8e:	68 d7 00 00 00       	push   $0xd7
f011ac93:	68 74 d8 13 f0       	push   $0xf013d874
f011ac98:	e8 12 62 fe ff       	call   f0100eaf <_panic>

f011ac9d <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f011ac9d:	55                   	push   %ebp
f011ac9e:	89 e5                	mov    %esp,%ebp
f011aca0:	a1 64 50 96 f1       	mov    0xf1965064,%eax
f011aca5:	5d                   	pop    %ebp
f011aca6:	c3                   	ret    

f011aca7 <test_kmalloc>:
int test_fast_BF();
int test_fast_WF();
int test_fast_CF();

int test_kmalloc(uint32 ALLOC_TYPE)
{
f011aca7:	55                   	push   %ebp
f011aca8:	89 e5                	mov    %esp,%ebp
f011acaa:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f011acad:	e8 eb ff ff ff       	call   f011ac9d <get_kheap_strategy>
f011acb2:	83 f8 01             	cmp    $0x1,%eax
f011acb5:	75 34                	jne    f011aceb <test_kmalloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011acb7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011acbb:	75 0a                	jne    f011acc7 <test_kmalloc+0x20>
			test_kmalloc_FF_page();
f011acbd:	e8 a0 11 00 00       	call   f011be62 <test_kmalloc_FF_page>
f011acc2:	e9 f3 00 00 00       	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011acc7:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011accb:	75 0a                	jne    f011acd7 <test_kmalloc+0x30>
			test_kmalloc_FF_block();
f011accd:	e8 d2 14 00 00       	call   f011c1a4 <test_kmalloc_FF_block>
f011acd2:	e9 e3 00 00 00       	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011acd7:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011acdb:	0f 85 d9 00 00 00    	jne    f011adba <test_kmalloc+0x113>
			test_kmalloc_FF_both();
f011ace1:	e8 00 1b 00 00       	call   f011c7e6 <test_kmalloc_FF_both>
f011ace6:	e9 cf 00 00 00       	jmp    f011adba <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011aceb:	e8 ad ff ff ff       	call   f011ac9d <get_kheap_strategy>
f011acf0:	83 f8 02             	cmp    $0x2,%eax
f011acf3:	75 34                	jne    f011ad29 <test_kmalloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011acf5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011acf9:	75 0a                	jne    f011ad05 <test_kmalloc+0x5e>
			test_kmalloc_BF_page();
f011acfb:	e8 9c 11 00 00       	call   f011be9c <test_kmalloc_BF_page>
f011ad00:	e9 b5 00 00 00       	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ad05:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ad09:	75 0a                	jne    f011ad15 <test_kmalloc+0x6e>
			test_kmalloc_BF_block();
f011ad0b:	e8 ce 14 00 00       	call   f011c1de <test_kmalloc_BF_block>
f011ad10:	e9 a5 00 00 00       	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011ad15:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011ad19:	0f 85 9b 00 00 00    	jne    f011adba <test_kmalloc+0x113>
			test_kmalloc_BF_both();
f011ad1f:	e8 fc 1a 00 00       	call   f011c820 <test_kmalloc_BF_both>
f011ad24:	e9 91 00 00 00       	jmp    f011adba <test_kmalloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011ad29:	e8 6f ff ff ff       	call   f011ac9d <get_kheap_strategy>
f011ad2e:	83 f8 03             	cmp    $0x3,%eax
f011ad31:	75 27                	jne    f011ad5a <test_kmalloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011ad33:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ad37:	75 07                	jne    f011ad40 <test_kmalloc+0x99>
			test_kmalloc_NF_page();
f011ad39:	e8 41 11 00 00       	call   f011be7f <test_kmalloc_NF_page>
f011ad3e:	eb 7a                	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ad40:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ad44:	75 07                	jne    f011ad4d <test_kmalloc+0xa6>
			test_kmalloc_NF_block();
f011ad46:	e8 76 14 00 00       	call   f011c1c1 <test_kmalloc_NF_block>
f011ad4b:	eb 6d                	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011ad4d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011ad51:	75 67                	jne    f011adba <test_kmalloc+0x113>
			test_kmalloc_NF_both();
f011ad53:	e8 ab 1a 00 00       	call   f011c803 <test_kmalloc_NF_both>
f011ad58:	eb 60                	jmp    f011adba <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f011ad5a:	e8 3e ff ff ff       	call   f011ac9d <get_kheap_strategy>
f011ad5f:	83 f8 04             	cmp    $0x4,%eax
f011ad62:	75 27                	jne    f011ad8b <test_kmalloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011ad64:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ad68:	75 07                	jne    f011ad71 <test_kmalloc+0xca>
			test_kmalloc_WF_page();
f011ad6a:	e8 4a 11 00 00       	call   f011beb9 <test_kmalloc_WF_page>
f011ad6f:	eb 49                	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ad71:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ad75:	75 07                	jne    f011ad7e <test_kmalloc+0xd7>
			test_kmalloc_WF_block();
f011ad77:	e8 7f 14 00 00       	call   f011c1fb <test_kmalloc_WF_block>
f011ad7c:	eb 3c                	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011ad7e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011ad82:	75 36                	jne    f011adba <test_kmalloc+0x113>
			test_kmalloc_WF_both();
f011ad84:	e8 b4 1a 00 00       	call   f011c83d <test_kmalloc_WF_both>
f011ad89:	eb 2f                	jmp    f011adba <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f011ad8b:	e8 0d ff ff ff       	call   f011ac9d <get_kheap_strategy>
f011ad90:	83 f8 05             	cmp    $0x5,%eax
f011ad93:	75 25                	jne    f011adba <test_kmalloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011ad95:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ad99:	75 07                	jne    f011ada2 <test_kmalloc+0xfb>
			test_kmalloc_CF_page();
f011ad9b:	e8 36 11 00 00       	call   f011bed6 <test_kmalloc_CF_page>
f011ada0:	eb 18                	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ada2:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ada6:	75 07                	jne    f011adaf <test_kmalloc+0x108>
			test_kmalloc_CF_block();
f011ada8:	e8 6b 14 00 00       	call   f011c218 <test_kmalloc_CF_block>
f011adad:	eb 0b                	jmp    f011adba <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011adaf:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011adb3:	75 05                	jne    f011adba <test_kmalloc+0x113>
			test_kmalloc_CF_both();
f011adb5:	e8 a0 1a 00 00       	call   f011c85a <test_kmalloc_CF_both>
	}
	return 0;
f011adba:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011adbf:	c9                   	leave  
f011adc0:	c3                   	ret    

f011adc1 <test_kfree>:

int test_kfree(uint32 ALLOC_TYPE)
{
f011adc1:	55                   	push   %ebp
f011adc2:	89 e5                	mov    %esp,%ebp
f011adc4:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f011adc7:	e8 d1 fe ff ff       	call   f011ac9d <get_kheap_strategy>
f011adcc:	83 f8 01             	cmp    $0x1,%eax
f011adcf:	75 34                	jne    f011ae05 <test_kfree+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011add1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011add5:	75 0a                	jne    f011ade1 <test_kfree+0x20>
			test_kfree_FF_page();
f011add7:	e8 9b 1a 00 00       	call   f011c877 <test_kfree_FF_page>
f011addc:	e9 f3 00 00 00       	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ade1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ade5:	75 0a                	jne    f011adf1 <test_kfree+0x30>
			test_kfree_FF_block();
f011ade7:	e8 b3 25 00 00       	call   f011d39f <test_kfree_FF_block>
f011adec:	e9 e3 00 00 00       	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011adf1:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011adf5:	0f 85 d9 00 00 00    	jne    f011aed4 <test_kfree+0x113>
			test_kfree_FF_both();
f011adfb:	e8 60 2d 00 00       	call   f011db60 <test_kfree_FF_both>
f011ae00:	e9 cf 00 00 00       	jmp    f011aed4 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011ae05:	e8 93 fe ff ff       	call   f011ac9d <get_kheap_strategy>
f011ae0a:	83 f8 02             	cmp    $0x2,%eax
f011ae0d:	75 34                	jne    f011ae43 <test_kfree+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011ae0f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ae13:	75 0a                	jne    f011ae1f <test_kfree+0x5e>
			test_kfree_BF_page();
f011ae15:	e8 97 1a 00 00       	call   f011c8b1 <test_kfree_BF_page>
f011ae1a:	e9 b5 00 00 00       	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ae1f:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ae23:	75 0a                	jne    f011ae2f <test_kfree+0x6e>
			test_kfree_BF_block();
f011ae25:	e8 af 25 00 00       	call   f011d3d9 <test_kfree_BF_block>
f011ae2a:	e9 a5 00 00 00       	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011ae2f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011ae33:	0f 85 9b 00 00 00    	jne    f011aed4 <test_kfree+0x113>
			test_kfree_BF_both();
f011ae39:	e8 5c 2d 00 00       	call   f011db9a <test_kfree_BF_both>
f011ae3e:	e9 91 00 00 00       	jmp    f011aed4 <test_kfree+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011ae43:	e8 55 fe ff ff       	call   f011ac9d <get_kheap_strategy>
f011ae48:	83 f8 03             	cmp    $0x3,%eax
f011ae4b:	75 27                	jne    f011ae74 <test_kfree+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011ae4d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ae51:	75 07                	jne    f011ae5a <test_kfree+0x99>
			test_kfree_NF_page();
f011ae53:	e8 3c 1a 00 00       	call   f011c894 <test_kfree_NF_page>
f011ae58:	eb 7a                	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ae5a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ae5e:	75 07                	jne    f011ae67 <test_kfree+0xa6>
			test_kfree_NF_block();
f011ae60:	e8 57 25 00 00       	call   f011d3bc <test_kfree_NF_block>
f011ae65:	eb 6d                	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011ae67:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011ae6b:	75 67                	jne    f011aed4 <test_kfree+0x113>
			test_kfree_NF_both();
f011ae6d:	e8 0b 2d 00 00       	call   f011db7d <test_kfree_NF_both>
f011ae72:	eb 60                	jmp    f011aed4 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f011ae74:	e8 24 fe ff ff       	call   f011ac9d <get_kheap_strategy>
f011ae79:	83 f8 04             	cmp    $0x4,%eax
f011ae7c:	75 27                	jne    f011aea5 <test_kfree+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011ae7e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ae82:	75 07                	jne    f011ae8b <test_kfree+0xca>
			test_kfree_WF_page();
f011ae84:	e8 45 1a 00 00       	call   f011c8ce <test_kfree_WF_page>
f011ae89:	eb 49                	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011ae8b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011ae8f:	75 07                	jne    f011ae98 <test_kfree+0xd7>
			test_kfree_WF_block();
f011ae91:	e8 60 25 00 00       	call   f011d3f6 <test_kfree_WF_block>
f011ae96:	eb 3c                	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011ae98:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011ae9c:	75 36                	jne    f011aed4 <test_kfree+0x113>
			test_kfree_WF_both();
f011ae9e:	e8 14 2d 00 00       	call   f011dbb7 <test_kfree_WF_both>
f011aea3:	eb 2f                	jmp    f011aed4 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f011aea5:	e8 f3 fd ff ff       	call   f011ac9d <get_kheap_strategy>
f011aeaa:	83 f8 05             	cmp    $0x5,%eax
f011aead:	75 25                	jne    f011aed4 <test_kfree+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011aeaf:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011aeb3:	75 07                	jne    f011aebc <test_kfree+0xfb>
			test_kfree_CF_page();
f011aeb5:	e8 31 1a 00 00       	call   f011c8eb <test_kfree_CF_page>
f011aeba:	eb 18                	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011aebc:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011aec0:	75 07                	jne    f011aec9 <test_kfree+0x108>
			test_kfree_CF_block();
f011aec2:	e8 4c 25 00 00       	call   f011d413 <test_kfree_CF_block>
f011aec7:	eb 0b                	jmp    f011aed4 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011aec9:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011aecd:	75 05                	jne    f011aed4 <test_kfree+0x113>
			test_kfree_CF_both();
f011aecf:	e8 00 2d 00 00       	call   f011dbd4 <test_kfree_CF_both>
	}
	return 0;
f011aed4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011aed9:	c9                   	leave  
f011aeda:	c3                   	ret    

f011aedb <test_krealloc>:
int test_krealloc(uint32 ALLOC_TYPE)
{
f011aedb:	55                   	push   %ebp
f011aedc:	89 e5                	mov    %esp,%ebp
f011aede:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f011aee1:	e8 b7 fd ff ff       	call   f011ac9d <get_kheap_strategy>
f011aee6:	83 f8 01             	cmp    $0x1,%eax
f011aee9:	75 34                	jne    f011af1f <test_krealloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011aeeb:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011aeef:	75 0a                	jne    f011aefb <test_krealloc+0x20>
			test_krealloc_FF_page();
f011aef1:	e8 af 46 00 00       	call   f011f5a5 <test_krealloc_FF_page>
f011aef6:	e9 f3 00 00 00       	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011aefb:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011aeff:	75 0a                	jne    f011af0b <test_krealloc+0x30>
			test_krealloc_FF_block();
f011af01:	e8 30 47 00 00       	call   f011f636 <test_krealloc_FF_block>
f011af06:	e9 e3 00 00 00       	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011af0b:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011af0f:	0f 85 d9 00 00 00    	jne    f011afee <test_krealloc+0x113>
			test_krealloc_FF_both();
f011af15:	e8 ad 47 00 00       	call   f011f6c7 <test_krealloc_FF_both>
f011af1a:	e9 cf 00 00 00       	jmp    f011afee <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011af1f:	e8 79 fd ff ff       	call   f011ac9d <get_kheap_strategy>
f011af24:	83 f8 02             	cmp    $0x2,%eax
f011af27:	75 34                	jne    f011af5d <test_krealloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011af29:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011af2d:	75 0a                	jne    f011af39 <test_krealloc+0x5e>
			test_krealloc_BF_page();
f011af2f:	e8 ab 46 00 00       	call   f011f5df <test_krealloc_BF_page>
f011af34:	e9 b5 00 00 00       	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011af39:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011af3d:	75 0a                	jne    f011af49 <test_krealloc+0x6e>
			test_krealloc_BF_block();
f011af3f:	e8 2c 47 00 00       	call   f011f670 <test_krealloc_BF_block>
f011af44:	e9 a5 00 00 00       	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011af49:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011af4d:	0f 85 9b 00 00 00    	jne    f011afee <test_krealloc+0x113>
			test_krealloc_BF_both();
f011af53:	e8 a9 47 00 00       	call   f011f701 <test_krealloc_BF_both>
f011af58:	e9 91 00 00 00       	jmp    f011afee <test_krealloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011af5d:	e8 3b fd ff ff       	call   f011ac9d <get_kheap_strategy>
f011af62:	83 f8 03             	cmp    $0x3,%eax
f011af65:	75 27                	jne    f011af8e <test_krealloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011af67:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011af6b:	75 07                	jne    f011af74 <test_krealloc+0x99>
			test_krealloc_NF_page();
f011af6d:	e8 50 46 00 00       	call   f011f5c2 <test_krealloc_NF_page>
f011af72:	eb 7a                	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011af74:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011af78:	75 07                	jne    f011af81 <test_krealloc+0xa6>
			test_krealloc_NF_block();
f011af7a:	e8 d4 46 00 00       	call   f011f653 <test_krealloc_NF_block>
f011af7f:	eb 6d                	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011af81:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011af85:	75 67                	jne    f011afee <test_krealloc+0x113>
			test_krealloc_NF_both();
f011af87:	e8 58 47 00 00       	call   f011f6e4 <test_krealloc_NF_both>
f011af8c:	eb 60                	jmp    f011afee <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f011af8e:	e8 0a fd ff ff       	call   f011ac9d <get_kheap_strategy>
f011af93:	83 f8 04             	cmp    $0x4,%eax
f011af96:	75 27                	jne    f011afbf <test_krealloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011af98:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011af9c:	75 07                	jne    f011afa5 <test_krealloc+0xca>
			test_krealloc_WF_page();
f011af9e:	e8 59 46 00 00       	call   f011f5fc <test_krealloc_WF_page>
f011afa3:	eb 49                	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011afa5:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011afa9:	75 07                	jne    f011afb2 <test_krealloc+0xd7>
			test_krealloc_WF_block();
f011afab:	e8 dd 46 00 00       	call   f011f68d <test_krealloc_WF_block>
f011afb0:	eb 3c                	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011afb2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011afb6:	75 36                	jne    f011afee <test_krealloc+0x113>
			test_krealloc_WF_both();
f011afb8:	e8 61 47 00 00       	call   f011f71e <test_krealloc_WF_both>
f011afbd:	eb 2f                	jmp    f011afee <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f011afbf:	e8 d9 fc ff ff       	call   f011ac9d <get_kheap_strategy>
f011afc4:	83 f8 05             	cmp    $0x5,%eax
f011afc7:	75 25                	jne    f011afee <test_krealloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011afc9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011afcd:	75 07                	jne    f011afd6 <test_krealloc+0xfb>
			test_krealloc_CF_page();
f011afcf:	e8 45 46 00 00       	call   f011f619 <test_krealloc_CF_page>
f011afd4:	eb 18                	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011afd6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011afda:	75 07                	jne    f011afe3 <test_krealloc+0x108>
			test_krealloc_CF_block();
f011afdc:	e8 c9 46 00 00       	call   f011f6aa <test_krealloc_CF_block>
f011afe1:	eb 0b                	jmp    f011afee <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011afe3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011afe7:	75 05                	jne    f011afee <test_krealloc+0x113>
			test_krealloc_CF_both();
f011afe9:	e8 4d 47 00 00       	call   f011f73b <test_krealloc_CF_both>
	}
	return 0;
f011afee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011aff3:	c9                   	leave  
f011aff4:	c3                   	ret    

f011aff5 <test_fast_page_alloc>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fast_page_alloc()
{
f011aff5:	55                   	push   %ebp
f011aff6:	89 e5                	mov    %esp,%ebp
f011aff8:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f011affb:	e8 9d fc ff ff       	call   f011ac9d <get_kheap_strategy>
f011b000:	83 f8 01             	cmp    $0x1,%eax
f011b003:	75 07                	jne    f011b00c <test_fast_page_alloc+0x17>
	{
		test_fast_FF();
f011b005:	e8 4e 47 00 00       	call   f011f758 <test_fast_FF>
f011b00a:	eb 42                	jmp    f011b04e <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011b00c:	e8 8c fc ff ff       	call   f011ac9d <get_kheap_strategy>
f011b011:	83 f8 03             	cmp    $0x3,%eax
f011b014:	75 07                	jne    f011b01d <test_fast_page_alloc+0x28>
	{
		test_fast_NF();
f011b016:	e8 5a 47 00 00       	call   f011f775 <test_fast_NF>
f011b01b:	eb 31                	jmp    f011b04e <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011b01d:	e8 7b fc ff ff       	call   f011ac9d <get_kheap_strategy>
f011b022:	83 f8 02             	cmp    $0x2,%eax
f011b025:	75 07                	jne    f011b02e <test_fast_page_alloc+0x39>
	{
		test_fast_BF();
f011b027:	e8 66 47 00 00       	call   f011f792 <test_fast_BF>
f011b02c:	eb 20                	jmp    f011b04e <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f011b02e:	e8 6a fc ff ff       	call   f011ac9d <get_kheap_strategy>
f011b033:	83 f8 04             	cmp    $0x4,%eax
f011b036:	75 07                	jne    f011b03f <test_fast_page_alloc+0x4a>
	{
		test_fast_WF();
f011b038:	e8 72 47 00 00       	call   f011f7af <test_fast_WF>
f011b03d:	eb 0f                	jmp    f011b04e <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f011b03f:	e8 59 fc ff ff       	call   f011ac9d <get_kheap_strategy>
f011b044:	83 f8 05             	cmp    $0x5,%eax
f011b047:	75 05                	jne    f011b04e <test_fast_page_alloc+0x59>
	{
		test_fast_CF();
f011b049:	e8 7e 47 00 00       	call   f011f7cc <test_fast_CF>
	}
	return 0;
f011b04e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b053:	c9                   	leave  
f011b054:	c3                   	ret    

f011b055 <allocSpaceInPageAlloc>:
void* ptr_allocations[MAX_NUM_OF_ALLOCS] = {0};
int lastIndices[MAX_NUM_OF_ALLOCS] = {0};
uint32 requestedSizes[MAX_NUM_OF_ALLOCS] = {0};
uint32 totalRequestedSize ;
bool allocSpaceInPageAlloc(int allocIndex, uint32 size, bool fill)
{
f011b055:	55                   	push   %ebp
f011b056:	89 e5                	mov    %esp,%ebp
f011b058:	53                   	push   %ebx
f011b059:	83 ec 24             	sub    $0x24,%esp
	int correct = 1;
f011b05c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int freeFrames = (int)sys_calculate_free_frames() ;
f011b063:	e8 1e 56 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011b068:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b06b:	e8 c3 a8 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011b070:	89 45 e8             	mov    %eax,-0x18(%ebp)
	requestedSizes[allocIndex] = size ;
f011b073:	8b 45 08             	mov    0x8(%ebp),%eax
f011b076:	8b 55 0c             	mov    0xc(%ebp),%edx
f011b079:	89 14 85 20 ca 94 f0 	mov    %edx,-0xf6b35e0(,%eax,4)
	uint32 expectedNumOfFrames = ROUNDUP(requestedSizes[allocIndex], PAGE_SIZE) / PAGE_SIZE ;
f011b080:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f011b087:	8b 45 08             	mov    0x8(%ebp),%eax
f011b08a:	8b 14 85 20 ca 94 f0 	mov    -0xf6b35e0(,%eax,4),%edx
f011b091:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b094:	01 d0                	add    %edx,%eax
f011b096:	48                   	dec    %eax
f011b097:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011b09a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b09d:	ba 00 00 00 00       	mov    $0x0,%edx
f011b0a2:	f7 75 e4             	divl   -0x1c(%ebp)
f011b0a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b0a8:	29 d0                	sub    %edx,%eax
f011b0aa:	c1 e8 0c             	shr    $0xc,%eax
f011b0ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
	{
		ptr_allocations[allocIndex] = kmalloc(requestedSizes[allocIndex]);
f011b0b0:	8b 45 08             	mov    0x8(%ebp),%eax
f011b0b3:	8b 04 85 20 ca 94 f0 	mov    -0xf6b35e0(,%eax,4),%eax
f011b0ba:	83 ec 0c             	sub    $0xc,%esp
f011b0bd:	50                   	push   %eax
f011b0be:	e8 0f fe fe ff       	call   f010aed2 <kmalloc>
f011b0c3:	83 c4 10             	add    $0x10,%esp
f011b0c6:	89 c2                	mov    %eax,%edx
f011b0c8:	8b 45 08             	mov    0x8(%ebp),%eax
f011b0cb:	89 14 85 60 c9 94 f0 	mov    %edx,-0xf6b36a0(,%eax,4)
	}
	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", allocIndex); }
f011b0d2:	e8 5c a8 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011b0d7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b0da:	74 1c                	je     f011b0f8 <allocSpaceInPageAlloc+0xa3>
f011b0dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b0e3:	83 ec 04             	sub    $0x4,%esp
f011b0e6:	ff 75 08             	pushl  0x8(%ebp)
f011b0e9:	68 90 d8 13 f0       	push   $0xf013d890
f011b0ee:	6a 0c                	push   $0xc
f011b0f0:	e8 88 6a fe ff       	call   f0101b7d <cprintf_colored>
f011b0f5:	83 c4 10             	add    $0x10,%esp
	if ((freeFrames - sys_calculate_free_frames()) < expectedNumOfFrames) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.2 Wrong allocation: pages are not loaded successfully into memory\n", allocIndex); }
f011b0f8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011b0fb:	e8 86 55 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011b100:	29 c3                	sub    %eax,%ebx
f011b102:	89 d8                	mov    %ebx,%eax
f011b104:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b107:	73 1c                	jae    f011b125 <allocSpaceInPageAlloc+0xd0>
f011b109:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b110:	83 ec 04             	sub    $0x4,%esp
f011b113:	ff 75 08             	pushl  0x8(%ebp)
f011b116:	68 00 d9 13 f0       	push   $0xf013d900
f011b11b:	6a 0c                	push   $0xc
f011b11d:	e8 5b 6a fe ff       	call   f0101b7d <cprintf_colored>
f011b122:	83 c4 10             	add    $0x10,%esp
	lastIndices[allocIndex] = (size)/sizeof(char) - 1;
f011b125:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b128:	48                   	dec    %eax
f011b129:	89 c2                	mov    %eax,%edx
f011b12b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b12e:	89 14 85 c0 c9 94 f0 	mov    %edx,-0xf6b3640(,%eax,4)
	if (fill)
f011b135:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b139:	74 35                	je     f011b170 <allocSpaceInPageAlloc+0x11b>
	{
		char* ptr = (char*)ptr_allocations[allocIndex];
f011b13b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b13e:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b145:	89 45 d8             	mov    %eax,-0x28(%ebp)
		for (int i = 0; i < lastIndices[allocIndex]; ++i)
f011b148:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b14f:	eb 10                	jmp    f011b161 <allocSpaceInPageAlloc+0x10c>
		{
			ptr[i] = allocIndex ;
f011b151:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b154:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b157:	01 d0                	add    %edx,%eax
f011b159:	8b 55 08             	mov    0x8(%ebp),%edx
f011b15c:	88 10                	mov    %dl,(%eax)
	if ((freeFrames - sys_calculate_free_frames()) < expectedNumOfFrames) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.2 Wrong allocation: pages are not loaded successfully into memory\n", allocIndex); }
	lastIndices[allocIndex] = (size)/sizeof(char) - 1;
	if (fill)
	{
		char* ptr = (char*)ptr_allocations[allocIndex];
		for (int i = 0; i < lastIndices[allocIndex]; ++i)
f011b15e:	ff 45 f0             	incl   -0x10(%ebp)
f011b161:	8b 45 08             	mov    0x8(%ebp),%eax
f011b164:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011b16b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b16e:	7f e1                	jg     f011b151 <allocSpaceInPageAlloc+0xfc>
		{
			ptr[i] = allocIndex ;
		}
	}
	return correct;
f011b170:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f011b173:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011b176:	c9                   	leave  
f011b177:	c3                   	ret    

f011b178 <freeSpaceInPageAlloc>:

bool freeSpaceInPageAlloc(int allocIndex)
{
f011b178:	55                   	push   %ebp
f011b179:	89 e5                	mov    %esp,%ebp
f011b17b:	83 ec 28             	sub    $0x28,%esp
	int correct = 1;
f011b17e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int freeFrames = (int)sys_calculate_free_frames() ;
f011b185:	e8 fc 54 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011b18a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b18d:	e8 a1 a7 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011b192:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 expectedNumOfFrames = ROUNDUP(requestedSizes[allocIndex], PAGE_SIZE) / PAGE_SIZE ;
f011b195:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f011b19c:	8b 45 08             	mov    0x8(%ebp),%eax
f011b19f:	8b 14 85 20 ca 94 f0 	mov    -0xf6b35e0(,%eax,4),%edx
f011b1a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b1a9:	01 d0                	add    %edx,%eax
f011b1ab:	48                   	dec    %eax
f011b1ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b1af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b1b2:	ba 00 00 00 00       	mov    $0x0,%edx
f011b1b7:	f7 75 e8             	divl   -0x18(%ebp)
f011b1ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b1bd:	29 d0                	sub    %edx,%eax
f011b1bf:	c1 e8 0c             	shr    $0xc,%eax
f011b1c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	{
		kfree(ptr_allocations[allocIndex]);
f011b1c5:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1c8:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b1cf:	83 ec 0c             	sub    $0xc,%esp
f011b1d2:	50                   	push   %eax
f011b1d3:	e8 7b 00 ff ff       	call   f010b253 <kfree>
f011b1d8:	83 c4 10             	add    $0x10,%esp
	}
	if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("%d.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", allocIndex); }
f011b1db:	e8 53 a7 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011b1e0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b1e3:	74 1a                	je     f011b1ff <freeSpaceInPageAlloc+0x87>
f011b1e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b1ec:	83 ec 08             	sub    $0x8,%esp
f011b1ef:	ff 75 08             	pushl  0x8(%ebp)
f011b1f2:	68 90 d8 13 f0       	push   $0xf013d890
f011b1f7:	e8 51 69 fe ff       	call   f0101b4d <cprintf>
f011b1fc:	83 c4 10             	add    $0x10,%esp
	if ((sys_calculate_free_frames() - freeFrames) < expectedNumOfFrames) { correct = 0; cprintf("$d.2 Wrong kfree: pages in memory are not freed correctly\n", allocIndex); }
f011b1ff:	e8 82 54 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011b204:	89 c2                	mov    %eax,%edx
f011b206:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b209:	29 c2                	sub    %eax,%edx
f011b20b:	89 d0                	mov    %edx,%eax
f011b20d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011b210:	73 1a                	jae    f011b22c <freeSpaceInPageAlloc+0xb4>
f011b212:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b219:	83 ec 08             	sub    $0x8,%esp
f011b21c:	ff 75 08             	pushl  0x8(%ebp)
f011b21f:	68 48 d9 13 f0       	push   $0xf013d948
f011b224:	e8 24 69 fe ff       	call   f0101b4d <cprintf>
f011b229:	83 c4 10             	add    $0x10,%esp
	return correct;
f011b22c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011b22f:	c9                   	leave  
f011b230:	c3                   	ret    

f011b231 <initial_page_allocations>:
int initial_page_allocations()
{
f011b231:	55                   	push   %ebp
f011b232:	89 e5                	mov    %esp,%ebp
f011b234:	57                   	push   %edi
f011b235:	81 ec 04 01 00 00    	sub    $0x104,%esp
	 * WE COMPARE THE DIFF IN FREE FRAMES BY "AT LEAST" RULE
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/
	uint32 expectedVA = ACTUAL_PAGE_ALLOC_START;
f011b23b:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames, allocIndex ;
	uint32 size = 0;
f011b242:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	char* ptr;
	int sums[20] = {0};
f011b249:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f011b24f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b254:	b8 00 00 00 00       	mov    $0x0,%eax
f011b259:	89 d7                	mov    %edx,%edi
f011b25b:	f3 ab                	rep stos %eax,%es:(%edi)
	totalRequestedSize = 0;
f011b25d:	c7 05 80 79 9a f1 00 	movl   $0x0,0xf19a7980
f011b264:	00 00 00 

	int eval = 0;
f011b267:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct ;

	correct = 1;
f011b26e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Create some areas in PAGE allocators
	cprintf_colored(TEXT_cyan,"\n	1.1 Create some areas in PAGE allocators\n");
f011b275:	83 ec 08             	sub    $0x8,%esp
f011b278:	68 84 d9 13 f0       	push   $0xf013d984
f011b27d:	6a 03                	push   $0x3
f011b27f:	e8 f9 68 fe ff       	call   f0101b7d <cprintf_colored>
f011b284:	83 c4 10             	add    $0x10,%esp
	{
		//4 MB
		allocIndex = 0;
f011b287:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b28e:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f011b295:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b298:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b29b:	01 d0                	add    %edx,%eax
f011b29d:	48                   	dec    %eax
f011b29e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011b2a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b2a4:	ba 00 00 00 00       	mov    $0x0,%edx
f011b2a9:	f7 75 e0             	divl   -0x20(%ebp)
f011b2ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b2af:	29 d0                	sub    %edx,%eax
f011b2b1:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 4*Mega - kilo;
f011b2b4:	c7 45 e8 00 fc 3f 00 	movl   $0x3ffc00,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b2bb:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f011b2c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b2c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b2c8:	01 d0                	add    %edx,%eax
f011b2ca:	48                   	dec    %eax
f011b2cb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b2ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011b2d1:	ba 00 00 00 00       	mov    $0x0,%edx
f011b2d6:	f7 75 d8             	divl   -0x28(%ebp)
f011b2d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011b2dc:	29 d0                	sub    %edx,%eax
f011b2de:	89 c2                	mov    %eax,%edx
f011b2e0:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b2e5:	01 d0                	add    %edx,%eax
f011b2e7:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b2ec:	83 ec 04             	sub    $0x4,%esp
f011b2ef:	6a 01                	push   $0x1
f011b2f1:	ff 75 e8             	pushl  -0x18(%ebp)
f011b2f4:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b2f7:	e8 59 fd ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b2fc:	83 c4 10             	add    $0x10,%esp
f011b2ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b302:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b305:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b30c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b30f:	74 2a                	je     f011b33b <initial_page_allocations+0x10a>
f011b311:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b318:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b31b:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b322:	83 ec 0c             	sub    $0xc,%esp
f011b325:	50                   	push   %eax
f011b326:	ff 75 ec             	pushl  -0x14(%ebp)
f011b329:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b32c:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b331:	6a 0c                	push   $0xc
f011b333:	e8 45 68 fe ff       	call   f0101b7d <cprintf_colored>
f011b338:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b33b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b33f:	74 04                	je     f011b345 <initial_page_allocations+0x114>
f011b341:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b345:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//3 MB
		allocIndex = 1;
f011b34c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b353:	c7 45 d0 00 10 00 00 	movl   $0x1000,-0x30(%ebp)
f011b35a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b35d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b360:	01 d0                	add    %edx,%eax
f011b362:	48                   	dec    %eax
f011b363:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b366:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b369:	ba 00 00 00 00       	mov    $0x0,%edx
f011b36e:	f7 75 d0             	divl   -0x30(%ebp)
f011b371:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b374:	29 d0                	sub    %edx,%eax
f011b376:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 3*Mega - kilo;
f011b379:	c7 45 e8 00 fc 2f 00 	movl   $0x2ffc00,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b380:	c7 45 c8 00 10 00 00 	movl   $0x1000,-0x38(%ebp)
f011b387:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b38a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b38d:	01 d0                	add    %edx,%eax
f011b38f:	48                   	dec    %eax
f011b390:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011b393:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b396:	ba 00 00 00 00       	mov    $0x0,%edx
f011b39b:	f7 75 c8             	divl   -0x38(%ebp)
f011b39e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b3a1:	29 d0                	sub    %edx,%eax
f011b3a3:	89 c2                	mov    %eax,%edx
f011b3a5:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b3aa:	01 d0                	add    %edx,%eax
f011b3ac:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b3b1:	83 ec 04             	sub    $0x4,%esp
f011b3b4:	6a 01                	push   $0x1
f011b3b6:	ff 75 e8             	pushl  -0x18(%ebp)
f011b3b9:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b3bc:	e8 94 fc ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b3c1:	83 c4 10             	add    $0x10,%esp
f011b3c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b3c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b3ca:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b3d1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b3d4:	74 2a                	je     f011b400 <initial_page_allocations+0x1cf>
f011b3d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b3dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b3e0:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b3e7:	83 ec 0c             	sub    $0xc,%esp
f011b3ea:	50                   	push   %eax
f011b3eb:	ff 75 ec             	pushl  -0x14(%ebp)
f011b3ee:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b3f1:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b3f6:	6a 0c                	push   $0xc
f011b3f8:	e8 80 67 fe ff       	call   f0101b7d <cprintf_colored>
f011b3fd:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b400:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b404:	74 04                	je     f011b40a <initial_page_allocations+0x1d9>
f011b406:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b40a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//2 MB
		allocIndex = 2;
f011b411:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b418:	c7 45 c0 00 10 00 00 	movl   $0x1000,-0x40(%ebp)
f011b41f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b422:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b425:	01 d0                	add    %edx,%eax
f011b427:	48                   	dec    %eax
f011b428:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011b42b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b42e:	ba 00 00 00 00       	mov    $0x0,%edx
f011b433:	f7 75 c0             	divl   -0x40(%ebp)
f011b436:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b439:	29 d0                	sub    %edx,%eax
f011b43b:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 2*Mega ;
f011b43e:	c7 45 e8 00 00 20 00 	movl   $0x200000,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b445:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f011b44c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b44f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011b452:	01 d0                	add    %edx,%eax
f011b454:	48                   	dec    %eax
f011b455:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f011b458:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011b45b:	ba 00 00 00 00       	mov    $0x0,%edx
f011b460:	f7 75 b8             	divl   -0x48(%ebp)
f011b463:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011b466:	29 d0                	sub    %edx,%eax
f011b468:	89 c2                	mov    %eax,%edx
f011b46a:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b46f:	01 d0                	add    %edx,%eax
f011b471:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b476:	83 ec 04             	sub    $0x4,%esp
f011b479:	6a 01                	push   $0x1
f011b47b:	ff 75 e8             	pushl  -0x18(%ebp)
f011b47e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b481:	e8 cf fb ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b486:	83 c4 10             	add    $0x10,%esp
f011b489:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b48c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b48f:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b496:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b499:	74 2a                	je     f011b4c5 <initial_page_allocations+0x294>
f011b49b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b4a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b4a5:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b4ac:	83 ec 0c             	sub    $0xc,%esp
f011b4af:	50                   	push   %eax
f011b4b0:	ff 75 ec             	pushl  -0x14(%ebp)
f011b4b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b4b6:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b4bb:	6a 0c                	push   $0xc
f011b4bd:	e8 bb 66 fe ff       	call   f0101b7d <cprintf_colored>
f011b4c2:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b4c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b4c9:	74 04                	je     f011b4cf <initial_page_allocations+0x29e>
f011b4cb:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b4cf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//4 MB
		allocIndex = 3;
f011b4d6:	c7 45 e4 03 00 00 00 	movl   $0x3,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b4dd:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f011b4e4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b4e7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011b4ea:	01 d0                	add    %edx,%eax
f011b4ec:	48                   	dec    %eax
f011b4ed:	89 45 ac             	mov    %eax,-0x54(%ebp)
f011b4f0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011b4f3:	ba 00 00 00 00       	mov    $0x0,%edx
f011b4f8:	f7 75 b0             	divl   -0x50(%ebp)
f011b4fb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011b4fe:	29 d0                	sub    %edx,%eax
f011b500:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 4*Mega - kilo;
f011b503:	c7 45 e8 00 fc 3f 00 	movl   $0x3ffc00,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b50a:	c7 45 a8 00 10 00 00 	movl   $0x1000,-0x58(%ebp)
f011b511:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b514:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b517:	01 d0                	add    %edx,%eax
f011b519:	48                   	dec    %eax
f011b51a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f011b51d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b520:	ba 00 00 00 00       	mov    $0x0,%edx
f011b525:	f7 75 a8             	divl   -0x58(%ebp)
f011b528:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b52b:	29 d0                	sub    %edx,%eax
f011b52d:	89 c2                	mov    %eax,%edx
f011b52f:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b534:	01 d0                	add    %edx,%eax
f011b536:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b53b:	83 ec 04             	sub    $0x4,%esp
f011b53e:	6a 01                	push   $0x1
f011b540:	ff 75 e8             	pushl  -0x18(%ebp)
f011b543:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b546:	e8 0a fb ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b54b:	83 c4 10             	add    $0x10,%esp
f011b54e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b551:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b554:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b55b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b55e:	74 2a                	je     f011b58a <initial_page_allocations+0x359>
f011b560:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b567:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b56a:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b571:	83 ec 0c             	sub    $0xc,%esp
f011b574:	50                   	push   %eax
f011b575:	ff 75 ec             	pushl  -0x14(%ebp)
f011b578:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b57b:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b580:	6a 0c                	push   $0xc
f011b582:	e8 f6 65 fe ff       	call   f0101b7d <cprintf_colored>
f011b587:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b58a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b58e:	74 04                	je     f011b594 <initial_page_allocations+0x363>
f011b590:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b594:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//1 MB
		allocIndex = 4;
f011b59b:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b5a2:	c7 45 a0 00 10 00 00 	movl   $0x1000,-0x60(%ebp)
f011b5a9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b5ac:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b5af:	01 d0                	add    %edx,%eax
f011b5b1:	48                   	dec    %eax
f011b5b2:	89 45 9c             	mov    %eax,-0x64(%ebp)
f011b5b5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b5b8:	ba 00 00 00 00       	mov    $0x0,%edx
f011b5bd:	f7 75 a0             	divl   -0x60(%ebp)
f011b5c0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b5c3:	29 d0                	sub    %edx,%eax
f011b5c5:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 1*Mega - 3*kilo;
f011b5c8:	c7 45 e8 00 f4 0f 00 	movl   $0xff400,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b5cf:	c7 45 98 00 10 00 00 	movl   $0x1000,-0x68(%ebp)
f011b5d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b5d9:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b5dc:	01 d0                	add    %edx,%eax
f011b5de:	48                   	dec    %eax
f011b5df:	89 45 94             	mov    %eax,-0x6c(%ebp)
f011b5e2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b5e5:	ba 00 00 00 00       	mov    $0x0,%edx
f011b5ea:	f7 75 98             	divl   -0x68(%ebp)
f011b5ed:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b5f0:	29 d0                	sub    %edx,%eax
f011b5f2:	89 c2                	mov    %eax,%edx
f011b5f4:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b5f9:	01 d0                	add    %edx,%eax
f011b5fb:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b600:	83 ec 04             	sub    $0x4,%esp
f011b603:	6a 01                	push   $0x1
f011b605:	ff 75 e8             	pushl  -0x18(%ebp)
f011b608:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b60b:	e8 45 fa ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b610:	83 c4 10             	add    $0x10,%esp
f011b613:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b616:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b619:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b620:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b623:	74 2a                	je     f011b64f <initial_page_allocations+0x41e>
f011b625:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b62c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b62f:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b636:	83 ec 0c             	sub    $0xc,%esp
f011b639:	50                   	push   %eax
f011b63a:	ff 75 ec             	pushl  -0x14(%ebp)
f011b63d:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b640:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b645:	6a 0c                	push   $0xc
f011b647:	e8 31 65 fe ff       	call   f0101b7d <cprintf_colored>
f011b64c:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b64f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b653:	74 04                	je     f011b659 <initial_page_allocations+0x428>
f011b655:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b659:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//1 MB
		allocIndex = 5;
f011b660:	c7 45 e4 05 00 00 00 	movl   $0x5,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b667:	c7 45 90 00 10 00 00 	movl   $0x1000,-0x70(%ebp)
f011b66e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b671:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b674:	01 d0                	add    %edx,%eax
f011b676:	48                   	dec    %eax
f011b677:	89 45 8c             	mov    %eax,-0x74(%ebp)
f011b67a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011b67d:	ba 00 00 00 00       	mov    $0x0,%edx
f011b682:	f7 75 90             	divl   -0x70(%ebp)
f011b685:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011b688:	29 d0                	sub    %edx,%eax
f011b68a:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 1*Mega - 2*kilo;
f011b68d:	c7 45 e8 00 f8 0f 00 	movl   $0xff800,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b694:	c7 45 88 00 10 00 00 	movl   $0x1000,-0x78(%ebp)
f011b69b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b69e:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b6a1:	01 d0                	add    %edx,%eax
f011b6a3:	48                   	dec    %eax
f011b6a4:	89 45 84             	mov    %eax,-0x7c(%ebp)
f011b6a7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011b6aa:	ba 00 00 00 00       	mov    $0x0,%edx
f011b6af:	f7 75 88             	divl   -0x78(%ebp)
f011b6b2:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011b6b5:	29 d0                	sub    %edx,%eax
f011b6b7:	89 c2                	mov    %eax,%edx
f011b6b9:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b6be:	01 d0                	add    %edx,%eax
f011b6c0:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b6c5:	83 ec 04             	sub    $0x4,%esp
f011b6c8:	6a 01                	push   $0x1
f011b6ca:	ff 75 e8             	pushl  -0x18(%ebp)
f011b6cd:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b6d0:	e8 80 f9 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b6d5:	83 c4 10             	add    $0x10,%esp
f011b6d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b6db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b6de:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b6e5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b6e8:	74 2a                	je     f011b714 <initial_page_allocations+0x4e3>
f011b6ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b6f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b6f4:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b6fb:	83 ec 0c             	sub    $0xc,%esp
f011b6fe:	50                   	push   %eax
f011b6ff:	ff 75 ec             	pushl  -0x14(%ebp)
f011b702:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b705:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b70a:	6a 0c                	push   $0xc
f011b70c:	e8 6c 64 fe ff       	call   f0101b7d <cprintf_colored>
f011b711:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b714:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b718:	74 04                	je     f011b71e <initial_page_allocations+0x4ed>
f011b71a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b71e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//1 MB
		allocIndex = 6;
f011b725:	c7 45 e4 06 00 00 00 	movl   $0x6,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b72c:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f011b733:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b736:	8b 45 80             	mov    -0x80(%ebp),%eax
f011b739:	01 d0                	add    %edx,%eax
f011b73b:	48                   	dec    %eax
f011b73c:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f011b742:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b748:	ba 00 00 00 00       	mov    $0x0,%edx
f011b74d:	f7 75 80             	divl   -0x80(%ebp)
f011b750:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b756:	29 d0                	sub    %edx,%eax
f011b758:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 1*Mega - 1*kilo;
f011b75b:	c7 45 e8 00 fc 0f 00 	movl   $0xffc00,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b762:	c7 85 78 ff ff ff 00 	movl   $0x1000,-0x88(%ebp)
f011b769:	10 00 00 
f011b76c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b76f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b775:	01 d0                	add    %edx,%eax
f011b777:	48                   	dec    %eax
f011b778:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f011b77e:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011b784:	ba 00 00 00 00       	mov    $0x0,%edx
f011b789:	f7 b5 78 ff ff ff    	divl   -0x88(%ebp)
f011b78f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011b795:	29 d0                	sub    %edx,%eax
f011b797:	89 c2                	mov    %eax,%edx
f011b799:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b79e:	01 d0                	add    %edx,%eax
f011b7a0:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b7a5:	83 ec 04             	sub    $0x4,%esp
f011b7a8:	6a 01                	push   $0x1
f011b7aa:	ff 75 e8             	pushl  -0x18(%ebp)
f011b7ad:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b7b0:	e8 a0 f8 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b7b5:	83 c4 10             	add    $0x10,%esp
f011b7b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b7bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b7be:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b7c5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b7c8:	74 2a                	je     f011b7f4 <initial_page_allocations+0x5c3>
f011b7ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b7d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b7d4:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b7db:	83 ec 0c             	sub    $0xc,%esp
f011b7de:	50                   	push   %eax
f011b7df:	ff 75 ec             	pushl  -0x14(%ebp)
f011b7e2:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b7e5:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b7ea:	6a 0c                	push   $0xc
f011b7ec:	e8 8c 63 fe ff       	call   f0101b7d <cprintf_colored>
f011b7f1:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b7f4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b7f8:	74 04                	je     f011b7fe <initial_page_allocations+0x5cd>
f011b7fa:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b7fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//2 MB
		allocIndex = 7;
f011b805:	c7 45 e4 07 00 00 00 	movl   $0x7,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b80c:	c7 85 70 ff ff ff 00 	movl   $0x1000,-0x90(%ebp)
f011b813:	10 00 00 
f011b816:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b819:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011b81f:	01 d0                	add    %edx,%eax
f011b821:	48                   	dec    %eax
f011b822:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
f011b828:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b82e:	ba 00 00 00 00       	mov    $0x0,%edx
f011b833:	f7 b5 70 ff ff ff    	divl   -0x90(%ebp)
f011b839:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b83f:	29 d0                	sub    %edx,%eax
f011b841:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 2*Mega ;
f011b844:	c7 45 e8 00 00 20 00 	movl   $0x200000,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b84b:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f011b852:	10 00 00 
f011b855:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b858:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011b85e:	01 d0                	add    %edx,%eax
f011b860:	48                   	dec    %eax
f011b861:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f011b867:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011b86d:	ba 00 00 00 00       	mov    $0x0,%edx
f011b872:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f011b878:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011b87e:	29 d0                	sub    %edx,%eax
f011b880:	89 c2                	mov    %eax,%edx
f011b882:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b887:	01 d0                	add    %edx,%eax
f011b889:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b88e:	83 ec 04             	sub    $0x4,%esp
f011b891:	6a 01                	push   $0x1
f011b893:	ff 75 e8             	pushl  -0x18(%ebp)
f011b896:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b899:	e8 b7 f7 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b89e:	83 c4 10             	add    $0x10,%esp
f011b8a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b8a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b8a7:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b8ae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b8b1:	74 2a                	je     f011b8dd <initial_page_allocations+0x6ac>
f011b8b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b8ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b8bd:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b8c4:	83 ec 0c             	sub    $0xc,%esp
f011b8c7:	50                   	push   %eax
f011b8c8:	ff 75 ec             	pushl  -0x14(%ebp)
f011b8cb:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b8ce:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b8d3:	6a 0c                	push   $0xc
f011b8d5:	e8 a3 62 fe ff       	call   f0101b7d <cprintf_colored>
f011b8da:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b8dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b8e1:	74 04                	je     f011b8e7 <initial_page_allocations+0x6b6>
f011b8e3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b8e7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

		//2 MB
		allocIndex = 8;
f011b8ee:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
		expectedVA += ROUNDUP(size, PAGE_SIZE);
f011b8f5:	c7 85 60 ff ff ff 00 	movl   $0x1000,-0xa0(%ebp)
f011b8fc:	10 00 00 
f011b8ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b902:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011b908:	01 d0                	add    %edx,%eax
f011b90a:	48                   	dec    %eax
f011b90b:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
f011b911:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011b917:	ba 00 00 00 00       	mov    $0x0,%edx
f011b91c:	f7 b5 60 ff ff ff    	divl   -0xa0(%ebp)
f011b922:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011b928:	29 d0                	sub    %edx,%eax
f011b92a:	01 45 ec             	add    %eax,-0x14(%ebp)
		size = 2*Mega ;
f011b92d:	c7 45 e8 00 00 20 00 	movl   $0x200000,-0x18(%ebp)
		totalRequestedSize += ROUNDUP(size, PAGE_SIZE);
f011b934:	c7 85 58 ff ff ff 00 	movl   $0x1000,-0xa8(%ebp)
f011b93b:	10 00 00 
f011b93e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b941:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011b947:	01 d0                	add    %edx,%eax
f011b949:	48                   	dec    %eax
f011b94a:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
f011b950:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011b956:	ba 00 00 00 00       	mov    $0x0,%edx
f011b95b:	f7 b5 58 ff ff ff    	divl   -0xa8(%ebp)
f011b961:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011b967:	29 d0                	sub    %edx,%eax
f011b969:	89 c2                	mov    %eax,%edx
f011b96b:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011b970:	01 d0                	add    %edx,%eax
f011b972:	a3 80 79 9a f1       	mov    %eax,0xf19a7980
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011b977:	83 ec 04             	sub    $0x4,%esp
f011b97a:	6a 01                	push   $0x1
f011b97c:	ff 75 e8             	pushl  -0x18(%ebp)
f011b97f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b982:	e8 ce f6 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011b987:	83 c4 10             	add    $0x10,%esp
f011b98a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011b98d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b990:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b997:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b99a:	74 2a                	je     f011b9c6 <initial_page_allocations+0x795>
f011b99c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b9a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011b9a6:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011b9ad:	83 ec 0c             	sub    $0xc,%esp
f011b9b0:	50                   	push   %eax
f011b9b1:	ff 75 ec             	pushl  -0x14(%ebp)
f011b9b4:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b9b7:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011b9bc:	6a 0c                	push   $0xc
f011b9be:	e8 ba 61 fe ff       	call   f0101b7d <cprintf_colored>
f011b9c3:	83 c4 20             	add    $0x20,%esp
		if (correct) eval += 10;
f011b9c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b9ca:	74 04                	je     f011b9d0 <initial_page_allocations+0x79f>
f011b9cc:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
		correct = 1;
f011b9d0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	}
	//Insufficient space
	cprintf_colored(TEXT_cyan,"\n	1.2 Insufficient Space\n");
f011b9d7:	83 ec 08             	sub    $0x8,%esp
f011b9da:	68 00 da 13 f0       	push   $0xf013da00
f011b9df:	6a 03                	push   $0x3
f011b9e1:	e8 97 61 fe ff       	call   f0101b7d <cprintf_colored>
f011b9e6:	83 c4 10             	add    $0x10,%esp
	{
		allocIndex = 9;
f011b9e9:	c7 45 e4 09 00 00 00 	movl   $0x9,-0x1c(%ebp)
		expectedVA = 0;
f011b9f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b9f7:	e8 8a 4c ff ff       	call   f0110686 <sys_calculate_free_frames>
f011b9fc:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ba02:	e8 2c 9f fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ba07:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_PAGE_ALLOC_START) - (4*Mega+3*Mega+2*Mega+4*Mega+3*Mega+2*Mega+2*Mega) ;
f011ba0d:	c7 85 48 ff ff ff 00 	movl   $0x6bfe000,-0xb8(%ebp)
f011ba14:	e0 bf 06 
		ptr_allocations[allocIndex] = kmalloc(restOfKHeap+1);
f011ba17:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011ba1d:	40                   	inc    %eax
f011ba1e:	83 ec 0c             	sub    $0xc,%esp
f011ba21:	50                   	push   %eax
f011ba22:	e8 ab f4 fe ff       	call   f010aed2 <kmalloc>
f011ba27:	83 c4 10             	add    $0x10,%esp
f011ba2a:	89 c2                	mov    %eax,%edx
f011ba2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ba2f:	89 14 85 60 c9 94 f0 	mov    %edx,-0xf6b36a0(,%eax,4)
		if (ptr_allocations[allocIndex] != NULL) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.1 Allocating insufficient space: should return NULL\n", allocIndex); }
f011ba36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ba39:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011ba40:	85 c0                	test   %eax,%eax
f011ba42:	74 1c                	je     f011ba60 <initial_page_allocations+0x82f>
f011ba44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba4b:	83 ec 04             	sub    $0x4,%esp
f011ba4e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ba51:	68 1c da 13 f0       	push   $0xf013da1c
f011ba56:	6a 0c                	push   $0xc
f011ba58:	e8 20 61 fe ff       	call   f0101b7d <cprintf_colored>
f011ba5d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", allocIndex); }
f011ba60:	e8 ce 9e fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ba65:	3b 85 4c ff ff ff    	cmp    -0xb4(%ebp),%eax
f011ba6b:	74 1c                	je     f011ba89 <initial_page_allocations+0x858>
f011ba6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba74:	83 ec 04             	sub    $0x4,%esp
f011ba77:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ba7a:	68 54 da 13 f0       	push   $0xf013da54
f011ba7f:	6a 0c                	push   $0xc
f011ba81:	e8 f7 60 fe ff       	call   f0101b7d <cprintf_colored>
f011ba86:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong allocation: pages are not loaded successfully into memory\n", allocIndex); }
f011ba89:	e8 f8 4b ff ff       	call   f0110686 <sys_calculate_free_frames>
f011ba8e:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f011ba94:	74 1c                	je     f011bab2 <initial_page_allocations+0x881>
f011ba96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba9d:	83 ec 04             	sub    $0x4,%esp
f011baa0:	ff 75 e4             	pushl  -0x1c(%ebp)
f011baa3:	68 c4 da 13 f0       	push   $0xf013dac4
f011baa8:	6a 0c                	push   $0xc
f011baaa:	e8 ce 60 fe ff       	call   f0101b7d <cprintf_colored>
f011baaf:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011bab2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bab6:	74 04                	je     f011babc <initial_page_allocations+0x88b>
f011bab8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	return eval;
f011babc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011babf:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011bac2:	c9                   	leave  
f011bac3:	c3                   	ret    

f011bac4 <initial_block_allocations>:
#define numOfLevels (LOG2_MAX_SIZE - LOG2_MIN_SIZE + 1)
int numOfAllocBlocksPerSize[numOfLevels] = {0};
int numOfAllocPages = 0;

int initial_block_allocations()
{
f011bac4:	55                   	push   %ebp
f011bac5:	89 e5                	mov    %esp,%ebp
f011bac7:	53                   	push   %ebx
f011bac8:	83 ec 64             	sub    $0x64,%esp
	memset(numOfAllocBlocksPerSize, 0, numOfLevels * sizeof(int)) ;
f011bacb:	83 ec 04             	sub    $0x4,%esp
f011bace:	6a 24                	push   $0x24
f011bad0:	6a 00                	push   $0x0
f011bad2:	68 80 ca 94 f1       	push   $0xf194ca80
f011bad7:	e8 41 75 00 00       	call   f012301d <memset>
f011badc:	83 c4 10             	add    $0x10,%esp
	numOfAllocPages = 0;
f011badf:	c7 05 a4 ca 94 f1 00 	movl   $0x0,0xf194caa4
f011bae6:	00 00 00 

	int eval = 0;
f011bae9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct = 1;
f011baf0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)


	int freeFramesBefore = sys_calculate_free_frames();
f011baf7:	e8 8a 4b ff ff       	call   f0110686 <sys_calculate_free_frames>
f011bafc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	void *va ;
	//====================================================================//
	/*1: Check initial allocations (two blocks should be allocated at start-up 16B & 8B)*/
	cprintf_colored(TEXT_cyan, "\n	1.1: Check initial BLOCK allocations (two blocks should be allocated at start-up 16B & 8B)\n\n") ;
f011baff:	83 ec 08             	sub    $0x8,%esp
f011bb02:	68 0c db 13 f0       	push   $0xf013db0c
f011bb07:	6a 03                	push   $0x3
f011bb09:	e8 6f 60 fe ff       	call   f0101b7d <cprintf_colored>
f011bb0e:	83 c4 10             	add    $0x10,%esp
	uint32 numOfRemain8 = PAGE_SIZE / 8 - 1;
f011bb11:	c7 45 c0 ff 01 00 00 	movl   $0x1ff,-0x40(%ebp)
	uint32 numOfRemain16 = PAGE_SIZE / 16 - 1;
f011bb18:	c7 45 bc ff 00 00 00 	movl   $0xff,-0x44(%ebp)
	if (LIST_SIZE(&freeBlockLists[0]) != numOfRemain8 || LIST_SIZE(&freeBlockLists[1]) != numOfRemain16)
f011bb1f:	a1 ec 52 96 f1       	mov    0xf19652ec,%eax
f011bb24:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f011bb27:	75 0a                	jne    f011bb33 <initial_block_allocations+0x6f>
f011bb29:	a1 fc 52 96 f1       	mov    0xf19652fc,%eax
f011bb2e:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011bb31:	74 19                	je     f011bb4c <initial_block_allocations+0x88>
	{
		is_correct = 0;
f011bb33:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf_colored(TEXT_TESTERR_CLR, "initial allocation #1: unexpected list size! check boot-time allocation\n");
f011bb3a:	83 ec 08             	sub    $0x8,%esp
f011bb3d:	68 6c db 13 f0       	push   $0xf013db6c
f011bb42:	6a 0c                	push   $0xc
f011bb44:	e8 34 60 fe ff       	call   f0101b7d <cprintf_colored>
f011bb49:	83 c4 10             	add    $0x10,%esp
	}
	numOfAllocBlocksPerSize[0]++ ;
f011bb4c:	a1 80 ca 94 f1       	mov    0xf194ca80,%eax
f011bb51:	40                   	inc    %eax
f011bb52:	a3 80 ca 94 f1       	mov    %eax,0xf194ca80
	numOfAllocBlocksPerSize[1]++ ;
f011bb57:	a1 84 ca 94 f1       	mov    0xf194ca84,%eax
f011bb5c:	40                   	inc    %eax
f011bb5d:	a3 84 ca 94 f1       	mov    %eax,0xf194ca84
	//====================================================================//
	/*2: Allocate set of blocks for each possible block size */
	cprintf_colored(TEXT_cyan, "	1.2: Allocate set of blocks for each possible block size \n\n") ;
f011bb62:	83 ec 08             	sub    $0x8,%esp
f011bb65:	68 b8 db 13 f0       	push   $0xf013dbb8
f011bb6a:	6a 03                	push   $0x3
f011bb6c:	e8 0c 60 fe ff       	call   f0101b7d <cprintf_colored>
f011bb71:	83 c4 10             	add    $0x10,%esp
	int curSize = 1<<LOG2_MIN_SIZE ;
f011bb74:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
	int curIndex = 0;
f011bb7b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int numOfBlksAtCurSize = 0;
f011bb82:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
	int maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011bb89:	b8 00 10 00 00       	mov    $0x1000,%eax
f011bb8e:	99                   	cltd   
f011bb8f:	f7 7d ec             	idivl  -0x14(%ebp)
f011bb92:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 currentVA = KERNEL_HEAP_START;
f011bb95:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
	int freeFrames = (int)sys_calculate_free_frames() ;
f011bb9c:	e8 e5 4a ff ff       	call   f0110686 <sys_calculate_free_frames>
f011bba1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	int freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bba4:	e8 8a 9d fe ff       	call   f0105933 <pf_calculate_free_frames>
f011bba9:	89 45 b0             	mov    %eax,-0x50(%ebp)

	for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011bbac:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
f011bbb3:	e9 3e 01 00 00       	jmp    f011bcf6 <initial_block_allocations+0x232>
	{
		//allocate a new block with the curSize
		{
			va = alloc_block(s);
f011bbb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bbbb:	83 ec 0c             	sub    $0xc,%esp
f011bbbe:	50                   	push   %eax
f011bbbf:	e8 c3 80 00 00       	call   f0123c87 <alloc_block>
f011bbc4:	83 c4 10             	add    $0x10,%esp
f011bbc7:	89 45 ac             	mov    %eax,-0x54(%ebp)
			startBlockVAs[s] = va;
f011bbca:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bbcd:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011bbd0:	89 14 85 80 ca 94 f0 	mov    %edx,-0xf6b3580(,%eax,4)
		}

		//fill the entire block
		for (int i = 0; i < curSize/2; ++i)
f011bbd7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011bbde:	eb 1a                	jmp    f011bbfa <initial_block_allocations+0x136>
		{
			startBlockVAs[s][i] = s;
f011bbe0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bbe3:	8b 14 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%edx
f011bbea:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bbed:	01 c0                	add    %eax,%eax
f011bbef:	01 c2                	add    %eax,%edx
f011bbf1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bbf4:	66 89 02             	mov    %ax,(%edx)
			va = alloc_block(s);
			startBlockVAs[s] = va;
		}

		//fill the entire block
		for (int i = 0; i < curSize/2; ++i)
f011bbf7:	ff 45 d8             	incl   -0x28(%ebp)
f011bbfa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011bbfd:	89 c2                	mov    %eax,%edx
f011bbff:	c1 ea 1f             	shr    $0x1f,%edx
f011bc02:	01 d0                	add    %edx,%eax
f011bc04:	d1 f8                	sar    %eax
f011bc06:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011bc09:	7f d5                	jg     f011bbe0 <initial_block_allocations+0x11c>
		{
			startBlockVAs[s][i] = s;
		}

		numOfAllocBlocksPerSize[curIndex]++ ;
f011bc0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bc0e:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011bc15:	8d 50 01             	lea    0x1(%eax),%edx
f011bc18:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bc1b:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)

		uint32 expectedVA = currentVA ;
f011bc22:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011bc25:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//special cases for the 8B & 16B blocks since they are allocated during the boot-time
		if (curSize == 8) expectedVA = KERNEL_HEAP_START + PAGE_SIZE;
f011bc28:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011bc2c:	75 07                	jne    f011bc35 <initial_block_allocations+0x171>
f011bc2e:	c7 45 d4 00 10 00 f6 	movl   $0xf6001000,-0x2c(%ebp)
		if (curSize == 16) expectedVA = KERNEL_HEAP_START ;
f011bc35:	83 7d ec 10          	cmpl   $0x10,-0x14(%ebp)
f011bc39:	75 07                	jne    f011bc42 <initial_block_allocations+0x17e>
f011bc3b:	c7 45 d4 00 00 00 f6 	movl   $0xf6000000,-0x2c(%ebp)
		if (is_correct && ROUNDDOWN((uint32)va, PAGE_SIZE) != expectedVA)
f011bc42:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bc46:	74 41                	je     f011bc89 <initial_block_allocations+0x1c5>
f011bc48:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011bc4b:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011bc4e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011bc51:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bc56:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011bc59:	74 2e                	je     f011bc89 <initial_block_allocations+0x1c5>
		{
			is_correct = 0;
f011bc5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf_colored(TEXT_TESTERR_CLR, "initial allocation #2.%d: WRONG! VA is not correct. Expected VA = %x, Actual VA = %x\n", s, expectedVA, ROUNDDOWN((uint32)va, PAGE_SIZE));
f011bc62:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011bc65:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f011bc68:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011bc6b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bc70:	83 ec 0c             	sub    $0xc,%esp
f011bc73:	50                   	push   %eax
f011bc74:	ff 75 d4             	pushl  -0x2c(%ebp)
f011bc77:	ff 75 dc             	pushl  -0x24(%ebp)
f011bc7a:	68 f8 db 13 f0       	push   $0xf013dbf8
f011bc7f:	6a 0c                	push   $0xc
f011bc81:	e8 f7 5e fe ff       	call   f0101b7d <cprintf_colored>
f011bc86:	83 c4 20             	add    $0x20,%esp
		}
		if (s == curSize)
f011bc89:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bc8c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011bc8f:	75 3c                	jne    f011bccd <initial_block_allocations+0x209>
		{
			if (is_correct)	eval += 5;
f011bc91:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bc95:	74 04                	je     f011bc9b <initial_block_allocations+0x1d7>
f011bc97:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)

			//Reinitialize
			{
				curSize <<= 1;
f011bc9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011bc9e:	01 c0                	add    %eax,%eax
f011bca0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				curIndex++;
f011bca3:	ff 45 e8             	incl   -0x18(%ebp)
				currentVA += PAGE_SIZE;
f011bca6:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
				numOfAllocPages++;
f011bcad:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011bcb2:	40                   	inc    %eax
f011bcb3:	a3 a4 ca 94 f1       	mov    %eax,0xf194caa4
				maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011bcb8:	b8 00 10 00 00       	mov    $0x1000,%eax
f011bcbd:	99                   	cltd   
f011bcbe:	f7 7d ec             	idivl  -0x14(%ebp)
f011bcc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				is_correct = 1;
f011bcc4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
f011bccb:	eb 26                	jmp    f011bcf3 <initial_block_allocations+0x22f>
			}
		}
		else if (numOfAllocBlocksPerSize[curIndex] % maxNumOfBlksAtCurPage == 0)
f011bccd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bcd0:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011bcd7:	99                   	cltd   
f011bcd8:	f7 7d e4             	idivl  -0x1c(%ebp)
f011bcdb:	89 d0                	mov    %edx,%eax
f011bcdd:	85 c0                	test   %eax,%eax
f011bcdf:	75 12                	jne    f011bcf3 <initial_block_allocations+0x22f>
		{
			currentVA += PAGE_SIZE;
f011bce1:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
			numOfAllocPages++;
f011bce8:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011bced:	40                   	inc    %eax
f011bcee:	a3 a4 ca 94 f1       	mov    %eax,0xf194caa4
	int maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
	uint32 currentVA = KERNEL_HEAP_START;
	int freeFrames = (int)sys_calculate_free_frames() ;
	int freeDiskFrames = (int)pf_calculate_free_frames() ;

	for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011bcf3:	ff 45 dc             	incl   -0x24(%ebp)
f011bcf6:	81 7d dc 00 08 00 00 	cmpl   $0x800,-0x24(%ebp)
f011bcfd:	0f 8e b5 fe ff ff    	jle    f011bbb8 <initial_block_allocations+0xf4>
		}
	}

	//====================================================================//
	/*3: Check content of each block */
	cprintf_colored(TEXT_cyan, "	1.3: Check content of each block \n\n") ;
f011bd03:	83 ec 08             	sub    $0x8,%esp
f011bd06:	68 50 dc 13 f0       	push   $0xf013dc50
f011bd0b:	6a 03                	push   $0x3
f011bd0d:	e8 6b 5e fe ff       	call   f0101b7d <cprintf_colored>
f011bd12:	83 c4 10             	add    $0x10,%esp
	curSize = 1<<LOG2_MIN_SIZE ;
f011bd15:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
	is_correct = 1;
f011bd1c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011bd23:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
f011bd2a:	e9 97 00 00 00       	jmp    f011bdc6 <initial_block_allocations+0x302>
	{
		//check the content of the current block
		int sum = 0;
f011bd2f:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
		for (int i = 0; i < curSize/2; ++i)
f011bd36:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011bd3d:	eb 1b                	jmp    f011bd5a <initial_block_allocations+0x296>
		{
			sum += startBlockVAs[s][i] ;
f011bd3f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bd42:	8b 14 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%edx
f011bd49:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011bd4c:	01 c0                	add    %eax,%eax
f011bd4e:	01 d0                	add    %edx,%eax
f011bd50:	66 8b 00             	mov    (%eax),%ax
f011bd53:	98                   	cwtl   
f011bd54:	01 45 cc             	add    %eax,-0x34(%ebp)
	is_correct = 1;
	for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
	{
		//check the content of the current block
		int sum = 0;
		for (int i = 0; i < curSize/2; ++i)
f011bd57:	ff 45 c8             	incl   -0x38(%ebp)
f011bd5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011bd5d:	89 c2                	mov    %eax,%edx
f011bd5f:	c1 ea 1f             	shr    $0x1f,%edx
f011bd62:	01 d0                	add    %edx,%eax
f011bd64:	d1 f8                	sar    %eax
f011bd66:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011bd69:	7f d4                	jg     f011bd3f <initial_block_allocations+0x27b>
		{
			sum += startBlockVAs[s][i] ;
		}
		if (is_correct && sum != s * curSize/2)
f011bd6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bd6f:	74 31                	je     f011bda2 <initial_block_allocations+0x2de>
f011bd71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bd74:	0f af 45 ec          	imul   -0x14(%ebp),%eax
f011bd78:	89 c2                	mov    %eax,%edx
f011bd7a:	c1 ea 1f             	shr    $0x1f,%edx
f011bd7d:	01 d0                	add    %edx,%eax
f011bd7f:	d1 f8                	sar    %eax
f011bd81:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011bd84:	74 1c                	je     f011bda2 <initial_block_allocations+0x2de>
		{ is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d wrong content\n", s); }
f011bd86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd8d:	83 ec 04             	sub    $0x4,%esp
f011bd90:	ff 75 d0             	pushl  -0x30(%ebp)
f011bd93:	68 75 dc 13 f0       	push   $0xf013dc75
f011bd98:	6a 0c                	push   $0xc
f011bd9a:	e8 de 5d fe ff       	call   f0101b7d <cprintf_colored>
f011bd9f:	83 c4 10             	add    $0x10,%esp

		if (s == curSize)
f011bda2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bda5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011bda8:	75 19                	jne    f011bdc3 <initial_block_allocations+0x2ff>
		{
			if (is_correct)	eval += 5;
f011bdaa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bdae:	74 04                	je     f011bdb4 <initial_block_allocations+0x2f0>
f011bdb0:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)

			//Reinitialize
			{
				curSize <<= 1;
f011bdb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011bdb7:	01 c0                	add    %eax,%eax
f011bdb9:	89 45 ec             	mov    %eax,-0x14(%ebp)
				is_correct = 1;
f011bdbc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//====================================================================//
	/*3: Check content of each block */
	cprintf_colored(TEXT_cyan, "	1.3: Check content of each block \n\n") ;
	curSize = 1<<LOG2_MIN_SIZE ;
	is_correct = 1;
	for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011bdc3:	ff 45 d0             	incl   -0x30(%ebp)
f011bdc6:	81 7d d0 00 08 00 00 	cmpl   $0x800,-0x30(%ebp)
f011bdcd:	0f 8e 5c ff ff ff    	jle    f011bd2f <initial_block_allocations+0x26b>
		}
	}

	//====================================================================//
	/*4: Check number of allocated pages */
	cprintf_colored(TEXT_cyan, "	1.4: Check number of allocated pages \n\n") ;
f011bdd3:	83 ec 08             	sub    $0x8,%esp
f011bdd6:	68 88 dc 13 f0       	push   $0xf013dc88
f011bddb:	6a 03                	push   $0x3
f011bddd:	e8 9b 5d fe ff       	call   f0101b7d <cprintf_colored>
f011bde2:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011bde5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bdec:	e8 42 9b fe ff       	call   f0105933 <pf_calculate_free_frames>
f011bdf1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bdf4:	74 19                	je     f011be0f <initial_block_allocations+0x34b>
f011bdf6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bdfd:	83 ec 08             	sub    $0x8,%esp
f011be00:	68 b4 dc 13 f0       	push   $0xf013dcb4
f011be05:	6a 0c                	push   $0xc
f011be07:	e8 71 5d fe ff       	call   f0101b7d <cprintf_colored>
f011be0c:	83 c4 10             	add    $0x10,%esp
	//exclude the 1st two pages that are allocated to 16B & 8B during boot-time
	if ((freeFrames - sys_calculate_free_frames()) != numOfAllocPages - 2) { is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Wrong allocation: invalid number of allocated pages! Expected = %d, Actual = %d\n", numOfAllocPages,freeFrames - sys_calculate_free_frames()); }
f011be0f:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f011be12:	e8 6f 48 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011be17:	29 c3                	sub    %eax,%ebx
f011be19:	89 da                	mov    %ebx,%edx
f011be1b:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011be20:	83 e8 02             	sub    $0x2,%eax
f011be23:	39 c2                	cmp    %eax,%edx
f011be25:	74 29                	je     f011be50 <initial_block_allocations+0x38c>
f011be27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be2e:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f011be31:	e8 50 48 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011be36:	29 c3                	sub    %eax,%ebx
f011be38:	89 da                	mov    %ebx,%edx
f011be3a:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011be3f:	52                   	push   %edx
f011be40:	50                   	push   %eax
f011be41:	68 20 dd 13 f0       	push   $0xf013dd20
f011be46:	6a 0c                	push   $0xc
f011be48:	e8 30 5d fe ff       	call   f0101b7d <cprintf_colored>
f011be4d:	83 c4 10             	add    $0x10,%esp
	if (is_correct)	eval += 10;
f011be50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011be54:	74 04                	je     f011be5a <initial_block_allocations+0x396>
f011be56:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	return eval;
f011be5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011be5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011be60:	c9                   	leave  
f011be61:	c3                   	ret    

f011be62 <test_kmalloc_FF_page>:

/**********************************************************************************************/
/********************************** KMALLOC TESTING AREA **************************************/
/**********************************************************************************************/
int test_kmalloc_FF_page()
{
f011be62:	55                   	push   %ebp
f011be63:	89 e5                	mov    %esp,%ebp
f011be65:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011be68:	83 ec 04             	sub    $0x4,%esp
f011be6b:	68 71 dd 13 f0       	push   $0xf013dd71
f011be70:	68 54 02 00 00       	push   $0x254
f011be75:	68 8a dd 13 f0       	push   $0xf013dd8a
f011be7a:	e8 30 50 fe ff       	call   f0100eaf <_panic>

f011be7f <test_kmalloc_NF_page>:
}
int test_kmalloc_NF_page()
{
f011be7f:	55                   	push   %ebp
f011be80:	89 e5                	mov    %esp,%ebp
f011be82:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011be85:	83 ec 04             	sub    $0x4,%esp
f011be88:	68 71 dd 13 f0       	push   $0xf013dd71
f011be8d:	68 58 02 00 00       	push   $0x258
f011be92:	68 8a dd 13 f0       	push   $0xf013dd8a
f011be97:	e8 13 50 fe ff       	call   f0100eaf <_panic>

f011be9c <test_kmalloc_BF_page>:
}
int test_kmalloc_BF_page()
{
f011be9c:	55                   	push   %ebp
f011be9d:	89 e5                	mov    %esp,%ebp
f011be9f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011bea2:	83 ec 04             	sub    $0x4,%esp
f011bea5:	68 71 dd 13 f0       	push   $0xf013dd71
f011beaa:	68 5c 02 00 00       	push   $0x25c
f011beaf:	68 8a dd 13 f0       	push   $0xf013dd8a
f011beb4:	e8 f6 4f fe ff       	call   f0100eaf <_panic>

f011beb9 <test_kmalloc_WF_page>:
}
int test_kmalloc_WF_page()
{
f011beb9:	55                   	push   %ebp
f011beba:	89 e5                	mov    %esp,%ebp
f011bebc:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011bebf:	83 ec 04             	sub    $0x4,%esp
f011bec2:	68 71 dd 13 f0       	push   $0xf013dd71
f011bec7:	68 60 02 00 00       	push   $0x260
f011becc:	68 8a dd 13 f0       	push   $0xf013dd8a
f011bed1:	e8 d9 4f fe ff       	call   f0100eaf <_panic>

f011bed6 <test_kmalloc_CF_page>:
}

int test_kmalloc_CF_page()
{
f011bed6:	55                   	push   %ebp
f011bed7:	89 e5                	mov    %esp,%ebp
f011bed9:	57                   	push   %edi
f011beda:	81 ec 94 00 00 00    	sub    $0x94,%esp
	 * WE COMPARE THE DIFF IN FREE FRAMES BY "AT LEAST" RULE
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011bee0:	83 ec 08             	sub    $0x8,%esp
f011bee3:	68 a4 dd 13 f0       	push   $0xf013dda4
f011bee8:	6a 0e                	push   $0xe
f011beea:	e8 8e 5c fe ff       	call   f0101b7d <cprintf_colored>
f011beef:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011bef2:	83 ec 08             	sub    $0x8,%esp
f011bef5:	68 d4 dd 13 f0       	push   $0xf013ddd4
f011befa:	6a 0e                	push   $0xe
f011befc:	e8 7c 5c fe ff       	call   f0101b7d <cprintf_colored>
f011bf01:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011bf04:	83 ec 08             	sub    $0x8,%esp
f011bf07:	68 a4 dd 13 f0       	push   $0xf013dda4
f011bf0c:	6a 0e                	push   $0xe
f011bf0e:	e8 6a 5c fe ff       	call   f0101b7d <cprintf_colored>
f011bf13:	83 c4 10             	add    $0x10,%esp

	//1. Alloc some spaces
	int eval = 0;
f011bf16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	cprintf_colored(TEXT_cyan,"\n1. Alloc some spaces [70%]\n");
f011bf1d:	83 ec 08             	sub    $0x8,%esp
f011bf20:	68 2d de 13 f0       	push   $0xf013de2d
f011bf25:	6a 03                	push   $0x3
f011bf27:	e8 51 5c fe ff       	call   f0101b7d <cprintf_colored>
f011bf2c:	83 c4 10             	add    $0x10,%esp
	{
		eval = initial_page_allocations();
f011bf2f:	e8 fd f2 ff ff       	call   f011b231 <initial_page_allocations>
f011bf34:	89 45 f4             	mov    %eax,-0xc(%ebp)
		eval = eval * 70 / 100; //rescale
f011bf37:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011bf3a:	89 d0                	mov    %edx,%eax
f011bf3c:	c1 e0 02             	shl    $0x2,%eax
f011bf3f:	01 d0                	add    %edx,%eax
f011bf41:	01 c0                	add    %eax,%eax
f011bf43:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011bf4a:	89 d1                	mov    %edx,%ecx
f011bf4c:	29 c1                	sub    %eax,%ecx
f011bf4e:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011bf53:	f7 e9                	imul   %ecx
f011bf55:	c1 fa 05             	sar    $0x5,%edx
f011bf58:	89 c8                	mov    %ecx,%eax
f011bf5a:	c1 f8 1f             	sar    $0x1f,%eax
f011bf5d:	29 c2                	sub    %eax,%edx
f011bf5f:	89 d0                	mov    %edx,%eax
f011bf61:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//2. Check BREAK
	int correct = 1;
f011bf64:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	cprintf_colored(TEXT_cyan,"\n2. Check Page Allocator BREAK [10%]\n");
f011bf6b:	83 ec 08             	sub    $0x8,%esp
f011bf6e:	68 4c de 13 f0       	push   $0xf013de4c
f011bf73:	6a 03                	push   $0x3
f011bf75:	e8 03 5c fe ff       	call   f0101b7d <cprintf_colored>
f011bf7a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 allocSizes = 0;
f011bf7d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		for (int i = 0; i < 9; ++i)
f011bf84:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011bf8b:	eb 30                	jmp    f011bfbd <test_kmalloc_CF_page+0xe7>
		{
			allocSizes += ROUNDUP(requestedSizes[i], PAGE_SIZE);
f011bf8d:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f011bf94:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf97:	8b 14 85 20 ca 94 f0 	mov    -0xf6b35e0(,%eax,4),%edx
f011bf9e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bfa1:	01 d0                	add    %edx,%eax
f011bfa3:	48                   	dec    %eax
f011bfa4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011bfa7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011bfaa:	ba 00 00 00 00       	mov    $0x0,%edx
f011bfaf:	f7 75 d8             	divl   -0x28(%ebp)
f011bfb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011bfb5:	29 d0                	sub    %edx,%eax
f011bfb7:	01 45 ec             	add    %eax,-0x14(%ebp)
	//2. Check BREAK
	int correct = 1;
	cprintf_colored(TEXT_cyan,"\n2. Check Page Allocator BREAK [10%]\n");
	{
		uint32 allocSizes = 0;
		for (int i = 0; i < 9; ++i)
f011bfba:	ff 45 e8             	incl   -0x18(%ebp)
f011bfbd:	83 7d e8 08          	cmpl   $0x8,-0x18(%ebp)
f011bfc1:	7e ca                	jle    f011bf8d <test_kmalloc_CF_page+0xb7>
		{
			allocSizes += ROUNDUP(requestedSizes[i], PAGE_SIZE);
		}
		uint32 expectedVA = ACTUAL_PAGE_ALLOC_START + allocSizes;
f011bfc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011bfc6:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011bfcb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if(kheapPageAllocBreak != expectedVA) {correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"BREAK value is not correct! Expected = %x, Actual = %x\n", expectedVA, kheapPageAllocBreak);}
f011bfce:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011bfd3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011bfd6:	74 1f                	je     f011bff7 <test_kmalloc_CF_page+0x121>
f011bfd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bfdf:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011bfe4:	50                   	push   %eax
f011bfe5:	ff 75 d0             	pushl  -0x30(%ebp)
f011bfe8:	68 74 de 13 f0       	push   $0xf013de74
f011bfed:	6a 0c                	push   $0xc
f011bfef:	e8 89 5b fe ff       	call   f0101b7d <cprintf_colored>
f011bff4:	83 c4 10             	add    $0x10,%esp
	}
	if (correct) eval += 10;
f011bff7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bffb:	74 04                	je     f011c001 <test_kmalloc_CF_page+0x12b>
f011bffd:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	correct = 1;
f011c001:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//3. Check Permissions
	cprintf_colored(TEXT_cyan,"\n3. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f011c008:	83 ec 08             	sub    $0x8,%esp
f011c00b:	68 ac de 13 f0       	push   $0xf013deac
f011c010:	6a 03                	push   $0x3
f011c012:	e8 66 5b fe ff       	call   f0101b7d <cprintf_colored>
f011c017:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[8] + 2*Mega ;
f011c01a:	a1 80 c9 94 f0       	mov    0xf094c980,%eax
f011c01f:	05 00 00 20 00       	add    $0x200000,%eax
f011c024:	89 45 cc             	mov    %eax,-0x34(%ebp)
		uint32 va;
		for (va = ACTUAL_PAGE_ALLOC_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011c027:	c7 45 e4 00 10 00 f8 	movl   $0xf8001000,-0x1c(%ebp)
f011c02e:	eb 6c                	jmp    f011c09c <test_kmalloc_CF_page+0x1c6>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f011c030:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011c035:	83 ec 04             	sub    $0x4,%esp
f011c038:	8d 95 70 ff ff ff    	lea    -0x90(%ebp),%edx
f011c03e:	52                   	push   %edx
f011c03f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c042:	50                   	push   %eax
f011c043:	e8 1f d8 fe ff       	call   f0109867 <get_page_table>
f011c048:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011c04b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c051:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011c054:	c1 ea 0c             	shr    $0xc,%edx
f011c057:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c05d:	c1 e2 02             	shl    $0x2,%edx
f011c060:	01 d0                	add    %edx,%eax
f011c062:	8b 00                	mov    (%eax),%eax
f011c064:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c069:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011c06c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c06f:	83 e0 04             	and    $0x4,%eax
f011c072:	85 c0                	test   %eax,%eax
f011c074:	74 1f                	je     f011c095 <test_kmalloc_CF_page+0x1bf>
			{
				if (correct)
f011c076:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c07a:	74 19                	je     f011c095 <test_kmalloc_CF_page+0x1bf>
				{
					correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011c07c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c083:	83 ec 08             	sub    $0x8,%esp
f011c086:	68 f0 de 13 f0       	push   $0xf013def0
f011c08b:	6a 0c                	push   $0xc
f011c08d:	e8 eb 5a fe ff       	call   f0101b7d <cprintf_colored>
f011c092:	83 c4 10             	add    $0x10,%esp
	//3. Check Permissions
	cprintf_colored(TEXT_cyan,"\n3. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[8] + 2*Mega ;
		uint32 va;
		for (va = ACTUAL_PAGE_ALLOC_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011c095:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f011c09c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c09f:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c0a2:	72 8c                	jb     f011c030 <test_kmalloc_CF_page+0x15a>
					correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct) eval += 10;
f011c0a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c0a8:	74 04                	je     f011c0ae <test_kmalloc_CF_page+0x1d8>
f011c0aa:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	correct = 1;
f011c0ae:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//4. Check Content
	uint32 sums[MAX_NUM_OF_ALLOCS] = {0};
f011c0b5:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f011c0bb:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c0c0:	b8 00 00 00 00       	mov    $0x0,%eax
f011c0c5:	89 d7                	mov    %edx,%edi
f011c0c7:	f3 ab                	rep stos %eax,%es:(%edi)
	cprintf_colored(TEXT_cyan,"\n4. Check Content [10%]\n");
f011c0c9:	83 ec 08             	sub    $0x8,%esp
f011c0cc:	68 3b df 13 f0       	push   $0xf013df3b
f011c0d1:	6a 03                	push   $0x3
f011c0d3:	e8 a5 5a fe ff       	call   f0101b7d <cprintf_colored>
f011c0d8:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < 9; ++i)
f011c0db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0e2:	e9 83 00 00 00       	jmp    f011c16a <test_kmalloc_CF_page+0x294>
		{
			char* ptr = (char*)ptr_allocations[i];
f011c0e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c0ea:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011c0f1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			for (int j = 0; j < lastIndices[i]; ++j)
f011c0f4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011c0fb:	eb 26                	jmp    f011c123 <test_kmalloc_CF_page+0x24d>
			{
				sums[i] += ptr[j] ;
f011c0fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c100:	8b 94 85 74 ff ff ff 	mov    -0x8c(%ebp,%eax,4),%edx
f011c107:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011c10a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c10d:	01 c8                	add    %ecx,%eax
f011c10f:	8a 00                	mov    (%eax),%al
f011c111:	0f be c0             	movsbl %al,%eax
f011c114:	01 c2                	add    %eax,%edx
f011c116:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c119:	89 94 85 74 ff ff ff 	mov    %edx,-0x8c(%ebp,%eax,4)
	cprintf_colored(TEXT_cyan,"\n4. Check Content [10%]\n");
	{
		for (int i = 0; i < 9; ++i)
		{
			char* ptr = (char*)ptr_allocations[i];
			for (int j = 0; j < lastIndices[i]; ++j)
f011c120:	ff 45 dc             	incl   -0x24(%ebp)
f011c123:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c126:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011c12d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011c130:	7f cb                	jg     f011c0fd <test_kmalloc_CF_page+0x227>
			{
				sums[i] += ptr[j] ;
			}
			if (sums[i] != i*lastIndices[i])	{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"invalid content\n"); }
f011c132:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c135:	8b 94 85 74 ff ff ff 	mov    -0x8c(%ebp,%eax,4),%edx
f011c13c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c13f:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011c146:	0f af 45 e0          	imul   -0x20(%ebp),%eax
f011c14a:	39 c2                	cmp    %eax,%edx
f011c14c:	74 19                	je     f011c167 <test_kmalloc_CF_page+0x291>
f011c14e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c155:	83 ec 08             	sub    $0x8,%esp
f011c158:	68 54 df 13 f0       	push   $0xf013df54
f011c15d:	6a 0c                	push   $0xc
f011c15f:	e8 19 5a fe ff       	call   f0101b7d <cprintf_colored>
f011c164:	83 c4 10             	add    $0x10,%esp

	//4. Check Content
	uint32 sums[MAX_NUM_OF_ALLOCS] = {0};
	cprintf_colored(TEXT_cyan,"\n4. Check Content [10%]\n");
	{
		for (int i = 0; i < 9; ++i)
f011c167:	ff 45 e0             	incl   -0x20(%ebp)
f011c16a:	83 7d e0 08          	cmpl   $0x8,-0x20(%ebp)
f011c16e:	0f 8e 73 ff ff ff    	jle    f011c0e7 <test_kmalloc_CF_page+0x211>
				sums[i] += ptr[j] ;
			}
			if (sums[i] != i*lastIndices[i])	{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"invalid content\n"); }
		}
	}
	if (correct) eval += 10;
f011c174:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c178:	74 04                	je     f011c17e <test_kmalloc_CF_page+0x2a8>
f011c17a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	correct = 1;
f011c17e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	cprintf_colored(TEXT_light_green,"\nTest kmalloc Page Alloc Completed. Evaluation = %d%\n", eval);
f011c185:	83 ec 04             	sub    $0x4,%esp
f011c188:	ff 75 f4             	pushl  -0xc(%ebp)
f011c18b:	68 68 df 13 f0       	push   $0xf013df68
f011c190:	6a 0a                	push   $0xa
f011c192:	e8 e6 59 fe ff       	call   f0101b7d <cprintf_colored>
f011c197:	83 c4 10             	add    $0x10,%esp
	return 0;
f011c19a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011c19f:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011c1a2:	c9                   	leave  
f011c1a3:	c3                   	ret    

f011c1a4 <test_kmalloc_FF_block>:

int test_kmalloc_FF_block()
{
f011c1a4:	55                   	push   %ebp
f011c1a5:	89 e5                	mov    %esp,%ebp
f011c1a7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c1aa:	83 ec 04             	sub    $0x4,%esp
f011c1ad:	68 71 dd 13 f0       	push   $0xf013dd71
f011c1b2:	68 b3 02 00 00       	push   $0x2b3
f011c1b7:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c1bc:	e8 ee 4c fe ff       	call   f0100eaf <_panic>

f011c1c1 <test_kmalloc_NF_block>:
}
int test_kmalloc_NF_block()
{
f011c1c1:	55                   	push   %ebp
f011c1c2:	89 e5                	mov    %esp,%ebp
f011c1c4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c1c7:	83 ec 04             	sub    $0x4,%esp
f011c1ca:	68 71 dd 13 f0       	push   $0xf013dd71
f011c1cf:	68 b7 02 00 00       	push   $0x2b7
f011c1d4:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c1d9:	e8 d1 4c fe ff       	call   f0100eaf <_panic>

f011c1de <test_kmalloc_BF_block>:
}
int test_kmalloc_BF_block()
{
f011c1de:	55                   	push   %ebp
f011c1df:	89 e5                	mov    %esp,%ebp
f011c1e1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c1e4:	83 ec 04             	sub    $0x4,%esp
f011c1e7:	68 71 dd 13 f0       	push   $0xf013dd71
f011c1ec:	68 bb 02 00 00       	push   $0x2bb
f011c1f1:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c1f6:	e8 b4 4c fe ff       	call   f0100eaf <_panic>

f011c1fb <test_kmalloc_WF_block>:
}
int test_kmalloc_WF_block()
{
f011c1fb:	55                   	push   %ebp
f011c1fc:	89 e5                	mov    %esp,%ebp
f011c1fe:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c201:	83 ec 04             	sub    $0x4,%esp
f011c204:	68 71 dd 13 f0       	push   $0xf013dd71
f011c209:	68 bf 02 00 00       	push   $0x2bf
f011c20e:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c213:	e8 97 4c fe ff       	call   f0100eaf <_panic>

f011c218 <test_kmalloc_CF_block>:
}
int test_kmalloc_CF_block()
{
f011c218:	55                   	push   %ebp
f011c219:	89 e5                	mov    %esp,%ebp
f011c21b:	57                   	push   %edi
f011c21c:	53                   	push   %ebx
f011c21d:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011c223:	83 ec 08             	sub    $0x8,%esp
f011c226:	68 a4 dd 13 f0       	push   $0xf013dda4
f011c22b:	6a 0e                	push   $0xe
f011c22d:	e8 4b 59 fe ff       	call   f0101b7d <cprintf_colored>
f011c232:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c235:	83 ec 08             	sub    $0x8,%esp
f011c238:	68 d4 dd 13 f0       	push   $0xf013ddd4
f011c23d:	6a 0e                	push   $0xe
f011c23f:	e8 39 59 fe ff       	call   f0101b7d <cprintf_colored>
f011c244:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011c247:	83 ec 08             	sub    $0x8,%esp
f011c24a:	68 a4 dd 13 f0       	push   $0xf013dda4
f011c24f:	6a 0e                	push   $0xe
f011c251:	e8 27 59 fe ff       	call   f0101b7d <cprintf_colored>
f011c256:	83 c4 10             	add    $0x10,%esp

	//1. Alloc some spaces
	int eval = 0;
f011c259:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	cprintf_colored(TEXT_cyan,"1. Alloc some spaces [50%]\n");
f011c260:	83 ec 08             	sub    $0x8,%esp
f011c263:	68 9e df 13 f0       	push   $0xf013df9e
f011c268:	6a 03                	push   $0x3
f011c26a:	e8 0e 59 fe ff       	call   f0101b7d <cprintf_colored>
f011c26f:	83 c4 10             	add    $0x10,%esp
	{
		eval = initial_block_allocations();
f011c272:	e8 4d f8 ff ff       	call   f011bac4 <initial_block_allocations>
f011c277:	89 45 f4             	mov    %eax,-0xc(%ebp)
		eval = eval * 50 / 100; //rescale
f011c27a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c27d:	89 d0                	mov    %edx,%eax
f011c27f:	c1 e0 02             	shl    $0x2,%eax
f011c282:	01 d0                	add    %edx,%eax
f011c284:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011c28b:	01 d0                	add    %edx,%eax
f011c28d:	01 c0                	add    %eax,%eax
f011c28f:	89 c1                	mov    %eax,%ecx
f011c291:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011c296:	f7 e9                	imul   %ecx
f011c298:	c1 fa 05             	sar    $0x5,%edx
f011c29b:	89 c8                	mov    %ecx,%eax
f011c29d:	c1 f8 1f             	sar    $0x1f,%eax
f011c2a0:	29 c2                	sub    %eax,%edx
f011c2a2:	89 d0                	mov    %edx,%eax
f011c2a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	//2. Fill-up the remaining pages using the 2KB block
	void *va;
	int is_correct;
	cprintf_colored(TEXT_cyan,"2. Fill-up the remaining pages using the 2KB block [15%]\n");
f011c2a7:	83 ec 08             	sub    $0x8,%esp
f011c2aa:	68 bc df 13 f0       	push   $0xf013dfbc
f011c2af:	6a 03                	push   $0x3
f011c2b1:	e8 c7 58 fe ff       	call   f0101b7d <cprintf_colored>
f011c2b6:	83 c4 10             	add    $0x10,%esp
	{
		is_correct = 1;
f011c2b9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int freeFrames = (int)sys_calculate_free_frames() ;
f011c2c0:	e8 c1 43 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011c2c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
		int freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c2c8:	e8 66 96 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011c2cd:	89 45 c8             	mov    %eax,-0x38(%ebp)
		int requiredNumOf2KBBlks = (DYN_ALLOC_MAX_SIZE/PAGE_SIZE - numOfAllocPages) * 2;
f011c2d0:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011c2d5:	ba 00 20 00 00       	mov    $0x2000,%edx
f011c2da:	29 c2                	sub    %eax,%edx
f011c2dc:	89 d0                	mov    %edx,%eax
f011c2de:	01 c0                	add    %eax,%eax
f011c2e0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		int curIndex = numOfLevels - 1;
f011c2e3:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
		uint32 currentVA = KERNEL_HEAP_START + numOfAllocPages*PAGE_SIZE ;
f011c2ea:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011c2ef:	c1 e0 0c             	shl    $0xc,%eax
f011c2f2:	2d 00 00 00 0a       	sub    $0xa000000,%eax
f011c2f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for (int i = 1; i <= requiredNumOf2KBBlks; ++i)
f011c2fa:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
f011c301:	e9 96 00 00 00       	jmp    f011c39c <test_kmalloc_CF_block+0x184>
		{
			//allocate a new block with the curSize
			{
				va = alloc_block(DYN_ALLOC_MAX_BLOCK_SIZE);
f011c306:	83 ec 0c             	sub    $0xc,%esp
f011c309:	68 00 08 00 00       	push   $0x800
f011c30e:	e8 74 79 00 00       	call   f0123c87 <alloc_block>
f011c313:	83 c4 10             	add    $0x10,%esp
f011c316:	89 45 bc             	mov    %eax,-0x44(%ebp)
			}

			numOfAllocBlocksPerSize[curIndex]++ ;
f011c319:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c31c:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011c323:	8d 50 01             	lea    0x1(%eax),%edx
f011c326:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c329:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)

			uint32 expectedVA = currentVA ;
f011c330:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c333:	89 45 b8             	mov    %eax,-0x48(%ebp)
			if (is_correct && ROUNDDOWN((uint32)va, PAGE_SIZE) != expectedVA)
f011c336:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c33a:	74 41                	je     f011c37d <test_kmalloc_CF_block+0x165>
f011c33c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c33f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f011c342:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c345:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c34a:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c34d:	74 2e                	je     f011c37d <test_kmalloc_CF_block+0x165>
			{
				is_correct = 0;
f011c34f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #5.%d: WRONG! VA is not correct. Expected VA = %x, Actual VA = %x\n", i, expectedVA, ROUNDDOWN((uint32)va, PAGE_SIZE));
f011c356:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c359:	89 45 b0             	mov    %eax,-0x50(%ebp)
f011c35c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011c35f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c364:	83 ec 0c             	sub    $0xc,%esp
f011c367:	50                   	push   %eax
f011c368:	ff 75 b8             	pushl  -0x48(%ebp)
f011c36b:	ff 75 e8             	pushl  -0x18(%ebp)
f011c36e:	68 f8 df 13 f0       	push   $0xf013dff8
f011c373:	6a 0c                	push   $0xc
f011c375:	e8 03 58 fe ff       	call   f0101b7d <cprintf_colored>
f011c37a:	83 c4 20             	add    $0x20,%esp
			}
			if (i%2 == 0)
f011c37d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011c380:	83 e0 01             	and    $0x1,%eax
f011c383:	85 c0                	test   %eax,%eax
f011c385:	75 12                	jne    f011c399 <test_kmalloc_CF_block+0x181>
			{
				numOfAllocPages++;
f011c387:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011c38c:	40                   	inc    %eax
f011c38d:	a3 a4 ca 94 f1       	mov    %eax,0xf194caa4
				currentVA += PAGE_SIZE;
f011c392:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
		int freeFrames = (int)sys_calculate_free_frames() ;
		int freeDiskFrames = (int)pf_calculate_free_frames() ;
		int requiredNumOf2KBBlks = (DYN_ALLOC_MAX_SIZE/PAGE_SIZE - numOfAllocPages) * 2;
		int curIndex = numOfLevels - 1;
		uint32 currentVA = KERNEL_HEAP_START + numOfAllocPages*PAGE_SIZE ;
		for (int i = 1; i <= requiredNumOf2KBBlks; ++i)
f011c399:	ff 45 e8             	incl   -0x18(%ebp)
f011c39c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011c39f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c3a2:	0f 8e 5e ff ff ff    	jle    f011c306 <test_kmalloc_CF_block+0xee>
			{
				numOfAllocPages++;
				currentVA += PAGE_SIZE;
			}
		}
		int expectedNumOfAllocPages = requiredNumOf2KBBlks / 2;
f011c3a8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c3ab:	89 c2                	mov    %eax,%edx
f011c3ad:	c1 ea 1f             	shr    $0x1f,%edx
f011c3b0:	01 d0                	add    %edx,%eax
f011c3b2:	d1 f8                	sar    %eax
f011c3b4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c3b7:	e8 77 95 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011c3bc:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011c3bf:	74 19                	je     f011c3da <test_kmalloc_CF_block+0x1c2>
f011c3c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c3c8:	83 ec 08             	sub    $0x8,%esp
f011c3cb:	68 b4 dc 13 f0       	push   $0xf013dcb4
f011c3d0:	6a 0c                	push   $0xc
f011c3d2:	e8 a6 57 fe ff       	call   f0101b7d <cprintf_colored>
f011c3d7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != expectedNumOfAllocPages) { is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Wrong allocation: invalid number of allocated pages! Expected = %d, Actual = %d\n", expectedNumOfAllocPages, freeFrames - sys_calculate_free_frames()); }
f011c3da:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f011c3dd:	e8 a4 42 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011c3e2:	29 c3                	sub    %eax,%ebx
f011c3e4:	89 da                	mov    %ebx,%edx
f011c3e6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011c3e9:	39 c2                	cmp    %eax,%edx
f011c3eb:	74 26                	je     f011c413 <test_kmalloc_CF_block+0x1fb>
f011c3ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c3f4:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f011c3f7:	e8 8a 42 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011c3fc:	29 c3                	sub    %eax,%ebx
f011c3fe:	89 d8                	mov    %ebx,%eax
f011c400:	50                   	push   %eax
f011c401:	ff 75 ac             	pushl  -0x54(%ebp)
f011c404:	68 20 dd 13 f0       	push   $0xf013dd20
f011c409:	6a 0c                	push   $0xc
f011c40b:	e8 6d 57 fe ff       	call   f0101b7d <cprintf_colored>
f011c410:	83 c4 10             	add    $0x10,%esp

		if (is_correct) eval += 15;
f011c413:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c417:	74 04                	je     f011c41d <test_kmalloc_CF_block+0x205>
f011c419:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
		is_correct = 1;
f011c41d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}

	//3. Allocate blocks of same size that consume remaining free blocks at all levels
	cprintf_colored(TEXT_cyan,"\n3. Allocate blocks of same size that consume remaining free blocks at all levels [25%]\n") ;
f011c424:	83 ec 08             	sub    $0x8,%esp
f011c427:	68 48 e0 13 f0       	push   $0xf013e048
f011c42c:	6a 03                	push   $0x3
f011c42e:	e8 4a 57 fe ff       	call   f0101b7d <cprintf_colored>
f011c433:	83 c4 10             	add    $0x10,%esp
	{
		is_correct = 1;
f011c436:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		//calculate expected number of free blocks at all levels
		int curSize = DYN_ALLOC_MIN_BLOCK_SIZE;
f011c43d:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
		int numOfRemFreeBlks[numOfLevels] = {0};
f011c444:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f011c44a:	b9 09 00 00 00       	mov    $0x9,%ecx
f011c44f:	b8 00 00 00 00       	mov    $0x0,%eax
f011c454:	89 d7                	mov    %edx,%edi
f011c456:	f3 ab                	rep stos %eax,%es:(%edi)
		uint32 expectedPageIndex[numOfLevels] = {0};
f011c458:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f011c45e:	b9 09 00 00 00       	mov    $0x9,%ecx
f011c463:	b8 00 00 00 00       	mov    $0x0,%eax
f011c468:	89 d7                	mov    %edx,%edi
f011c46a:	f3 ab                	rep stos %eax,%es:(%edi)
		uint32 prevAllocPages = 0;
f011c46c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		int freeFrames = (int)sys_calculate_free_frames() ;
f011c473:	e8 0e 42 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011c478:	89 45 a8             	mov    %eax,-0x58(%ebp)
		int freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c47b:	e8 b3 94 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011c480:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		for (int i = 0; i < numOfLevels; ++i)
f011c483:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011c48a:	e9 c7 00 00 00       	jmp    f011c556 <test_kmalloc_CF_block+0x33e>
		{
			int numOfAllocBlks = numOfAllocBlocksPerSize[i] ;
f011c48f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c492:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011c499:	89 45 a0             	mov    %eax,-0x60(%ebp)
			int expectedNumOfBlksPerPage = PAGE_SIZE / curSize;
f011c49c:	b8 00 10 00 00       	mov    $0x1000,%eax
f011c4a1:	99                   	cltd   
f011c4a2:	f7 7d e4             	idivl  -0x1c(%ebp)
f011c4a5:	89 45 9c             	mov    %eax,-0x64(%ebp)
			if (numOfAllocBlks % expectedNumOfBlksPerPage != 0)
f011c4a8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4ab:	99                   	cltd   
f011c4ac:	f7 7d 9c             	idivl  -0x64(%ebp)
f011c4af:	89 d0                	mov    %edx,%eax
f011c4b1:	85 c0                	test   %eax,%eax
f011c4b3:	74 70                	je     f011c525 <test_kmalloc_CF_block+0x30d>
			{
				numOfRemFreeBlks[i] = expectedNumOfBlksPerPage - (numOfAllocBlks % expectedNumOfBlksPerPage) ;
f011c4b5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4b8:	99                   	cltd   
f011c4b9:	f7 7d 9c             	idivl  -0x64(%ebp)
f011c4bc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011c4bf:	29 d0                	sub    %edx,%eax
f011c4c1:	89 c2                	mov    %eax,%edx
f011c4c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c4c6:	89 94 85 34 ff ff ff 	mov    %edx,-0xcc(%ebp,%eax,4)
				//Special cases for 16B & 8B blocks due to their allocation at the boot-time
				if (i == 0) //8B Block is in the 2nd page
f011c4cd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011c4d1:	75 10                	jne    f011c4e3 <test_kmalloc_CF_block+0x2cb>
				{
					expectedPageIndex[i] = 1;
f011c4d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c4d6:	c7 84 85 58 ff ff ff 	movl   $0x1,-0xa8(%ebp,%eax,4)
f011c4dd:	01 00 00 00 
f011c4e1:	eb 2e                	jmp    f011c511 <test_kmalloc_CF_block+0x2f9>
				}
				else if (i == 1) //16B Block is in the 1st page
f011c4e3:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f011c4e7:	75 10                	jne    f011c4f9 <test_kmalloc_CF_block+0x2e1>
				{
					expectedPageIndex[i] = 0 ;
f011c4e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c4ec:	c7 84 85 58 ff ff ff 	movl   $0x0,-0xa8(%ebp,%eax,4)
f011c4f3:	00 00 00 00 
f011c4f7:	eb 18                	jmp    f011c511 <test_kmalloc_CF_block+0x2f9>
				}
				else
				{
					expectedPageIndex[i] = (prevAllocPages + numOfAllocBlks / expectedNumOfBlksPerPage) ;
f011c4f9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4fc:	99                   	cltd   
f011c4fd:	f7 7d 9c             	idivl  -0x64(%ebp)
f011c500:	89 c2                	mov    %eax,%edx
f011c502:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c505:	01 c2                	add    %eax,%edx
f011c507:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c50a:	89 94 85 58 ff ff ff 	mov    %edx,-0xa8(%ebp,%eax,4)
				}
				prevAllocPages += numOfAllocBlks / expectedNumOfBlksPerPage + 1;
f011c511:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c514:	99                   	cltd   
f011c515:	f7 7d 9c             	idivl  -0x64(%ebp)
f011c518:	89 c2                	mov    %eax,%edx
f011c51a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c51d:	01 d0                	add    %edx,%eax
f011c51f:	40                   	inc    %eax
f011c520:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011c523:	eb 26                	jmp    f011c54b <test_kmalloc_CF_block+0x333>
			}
			else
			{
				numOfRemFreeBlks[i] = 0;
f011c525:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c528:	c7 84 85 34 ff ff ff 	movl   $0x0,-0xcc(%ebp,%eax,4)
f011c52f:	00 00 00 00 
				expectedPageIndex[i] = 0;
f011c533:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c536:	c7 84 85 58 ff ff ff 	movl   $0x0,-0xa8(%ebp,%eax,4)
f011c53d:	00 00 00 00 
				prevAllocPages += numOfAllocBlks / expectedNumOfBlksPerPage;
f011c541:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c544:	99                   	cltd   
f011c545:	f7 7d 9c             	idivl  -0x64(%ebp)
f011c548:	01 45 e0             	add    %eax,-0x20(%ebp)
			}
			curSize *= 2 ;
f011c54b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c54e:	01 c0                	add    %eax,%eax
f011c550:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 expectedPageIndex[numOfLevels] = {0};
		uint32 prevAllocPages = 0;
		int freeFrames = (int)sys_calculate_free_frames() ;
		int freeDiskFrames = (int)pf_calculate_free_frames() ;

		for (int i = 0; i < numOfLevels; ++i)
f011c553:	ff 45 dc             	incl   -0x24(%ebp)
f011c556:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
f011c55a:	0f 8e 2f ff ff ff    	jle    f011c48f <test_kmalloc_CF_block+0x277>
			}
			curSize *= 2 ;
		}

		//Allocate a number of blocks of same size to consume all the remaining free blocks
		int blkSize = 1<<LOG2_MIN_SIZE ;
f011c560:	c7 45 98 08 00 00 00 	movl   $0x8,-0x68(%ebp)
		for (int i = 0; i < numOfLevels; ++i)
f011c567:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011c56e:	e9 2d 01 00 00       	jmp    f011c6a0 <test_kmalloc_CF_block+0x488>
		{
			uint32 expectedVA = KERNEL_HEAP_START + expectedPageIndex[i] * PAGE_SIZE;
f011c573:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c576:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
f011c57d:	05 00 60 0f 00       	add    $0xf6000,%eax
f011c582:	c1 e0 0c             	shl    $0xc,%eax
f011c585:	89 45 94             	mov    %eax,-0x6c(%ebp)
			//cprintf( "Level#%d: num of remaining free blocks = %d\n", i, numOfRemFreeBlks[i]);
			for (int j = 0; j < numOfRemFreeBlks[i]; ++j)
f011c588:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011c58f:	eb 7a                	jmp    f011c60b <test_kmalloc_CF_block+0x3f3>
			{
				va = alloc_block(blkSize);
f011c591:	8b 45 98             	mov    -0x68(%ebp),%eax
f011c594:	83 ec 0c             	sub    $0xc,%esp
f011c597:	50                   	push   %eax
f011c598:	e8 ea 76 00 00       	call   f0123c87 <alloc_block>
f011c59d:	83 c4 10             	add    $0x10,%esp
f011c5a0:	89 45 bc             	mov    %eax,-0x44(%ebp)
				int *tmpVal = va ;
f011c5a3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c5a6:	89 45 90             	mov    %eax,-0x70(%ebp)
				*tmpVal = 353 ;
f011c5a9:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c5ac:	c7 00 61 01 00 00    	movl   $0x161,(%eax)
				if (ROUNDDOWN((uint32)va, PAGE_SIZE) != expectedVA)
f011c5b2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c5b5:	89 45 8c             	mov    %eax,-0x74(%ebp)
f011c5b8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011c5bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c5c0:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011c5c3:	74 1e                	je     f011c5e3 <test_kmalloc_CF_block+0x3cb>
				{
					is_correct = 0;
f011c5c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #6.1: WRONG! VA is not correct (i = %d, j = %d)\n", i, j);
f011c5cc:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c5cf:	ff 75 d8             	pushl  -0x28(%ebp)
f011c5d2:	68 a4 e0 13 f0       	push   $0xf013e0a4
f011c5d7:	6a 0c                	push   $0xc
f011c5d9:	e8 9f 55 fe ff       	call   f0101b7d <cprintf_colored>
f011c5de:	83 c4 10             	add    $0x10,%esp
					break;
f011c5e1:	eb 3b                	jmp    f011c61e <test_kmalloc_CF_block+0x406>
				}
				if (*tmpVal != 353)
f011c5e3:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c5e6:	8b 00                	mov    (%eax),%eax
f011c5e8:	3d 61 01 00 00       	cmp    $0x161,%eax
f011c5ed:	74 19                	je     f011c608 <test_kmalloc_CF_block+0x3f0>
				{
					is_correct = 0;
f011c5ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #6.2: wrong stored value in the allocated block\n");
f011c5f6:	83 ec 08             	sub    $0x8,%esp
f011c5f9:	68 e4 e0 13 f0       	push   $0xf013e0e4
f011c5fe:	6a 0c                	push   $0xc
f011c600:	e8 78 55 fe ff       	call   f0101b7d <cprintf_colored>
f011c605:	83 c4 10             	add    $0x10,%esp
		int blkSize = 1<<LOG2_MIN_SIZE ;
		for (int i = 0; i < numOfLevels; ++i)
		{
			uint32 expectedVA = KERNEL_HEAP_START + expectedPageIndex[i] * PAGE_SIZE;
			//cprintf( "Level#%d: num of remaining free blocks = %d\n", i, numOfRemFreeBlks[i]);
			for (int j = 0; j < numOfRemFreeBlks[i]; ++j)
f011c608:	ff 45 d4             	incl   -0x2c(%ebp)
f011c60b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c60e:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
f011c615:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011c618:	0f 8f 73 ff ff ff    	jg     f011c591 <test_kmalloc_CF_block+0x379>
					is_correct = 0;
					cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #6.2: wrong stored value in the allocated block\n");
				}
			}

			if (numOfRemFreeBlks[i] > 0)
f011c61e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c621:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
f011c628:	85 c0                	test   %eax,%eax
f011c62a:	7e 71                	jle    f011c69d <test_kmalloc_CF_block+0x485>
			{
				if (LIST_SIZE(&freeBlockLists[i]) != 0)
f011c62c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c62f:	c1 e0 04             	shl    $0x4,%eax
f011c632:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f011c637:	8b 00                	mov    (%eax),%eax
f011c639:	85 c0                	test   %eax,%eax
f011c63b:	74 1c                	je     f011c659 <test_kmalloc_CF_block+0x441>
				{
					is_correct = 0;
f011c63d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #6.3: WRONG! there's still free blocks at level %d while not expected to\n", i);
f011c644:	83 ec 04             	sub    $0x4,%esp
f011c647:	ff 75 d8             	pushl  -0x28(%ebp)
f011c64a:	68 24 e1 13 f0       	push   $0xf013e124
f011c64f:	6a 0c                	push   $0xc
f011c651:	e8 27 55 fe ff       	call   f0101b7d <cprintf_colored>
f011c656:	83 c4 10             	add    $0x10,%esp
				}
				if (pageBlockInfoArr[expectedPageIndex[i]].num_of_free_blocks != 0)
f011c659:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c65c:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
f011c663:	89 d0                	mov    %edx,%eax
f011c665:	01 c0                	add    %eax,%eax
f011c667:	01 d0                	add    %edx,%eax
f011c669:	c1 e0 02             	shl    $0x2,%eax
f011c66c:	05 6a d0 94 f1       	add    $0xf194d06a,%eax
f011c671:	66 8b 00             	mov    (%eax),%ax
f011c674:	66 85 c0             	test   %ax,%ax
f011c677:	74 24                	je     f011c69d <test_kmalloc_CF_block+0x485>
				{
					is_correct = 0;
f011c679:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #6.4: WRONG! there's still free blocks at page %d while not expected to\n", expectedPageIndex[i]);
f011c680:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c683:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
f011c68a:	83 ec 04             	sub    $0x4,%esp
f011c68d:	50                   	push   %eax
f011c68e:	68 7c e1 13 f0       	push   $0xf013e17c
f011c693:	6a 0c                	push   $0xc
f011c695:	e8 e3 54 fe ff       	call   f0101b7d <cprintf_colored>
f011c69a:	83 c4 10             	add    $0x10,%esp
			curSize *= 2 ;
		}

		//Allocate a number of blocks of same size to consume all the remaining free blocks
		int blkSize = 1<<LOG2_MIN_SIZE ;
		for (int i = 0; i < numOfLevels; ++i)
f011c69d:	ff 45 d8             	incl   -0x28(%ebp)
f011c6a0:	83 7d d8 08          	cmpl   $0x8,-0x28(%ebp)
f011c6a4:	0f 8e c9 fe ff ff    	jle    f011c573 <test_kmalloc_CF_block+0x35b>
					is_correct = 0;
					cprintf_colored(TEXT_TESTERR_CLR, "Block Alloc #6.4: WRONG! there's still free blocks at page %d while not expected to\n", expectedPageIndex[i]);
				}
			}
		}
		int expectedNumOfAllocPages = 0;
f011c6aa:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Block Alloc #6.5: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c6b1:	e8 7d 92 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011c6b6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011c6b9:	74 19                	je     f011c6d4 <test_kmalloc_CF_block+0x4bc>
f011c6bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c6c2:	83 ec 08             	sub    $0x8,%esp
f011c6c5:	68 d4 e1 13 f0       	push   $0xf013e1d4
f011c6ca:	6a 0c                	push   $0xc
f011c6cc:	e8 ac 54 fe ff       	call   f0101b7d <cprintf_colored>
f011c6d1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != expectedNumOfAllocPages) { is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Block Alloc #6.6: Wrong allocation: invalid number of allocated pages! Expected = %d, Actual = %d\n", expectedNumOfAllocPages, freeFrames - sys_calculate_free_frames()); }
f011c6d4:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011c6d7:	e8 aa 3f ff ff       	call   f0110686 <sys_calculate_free_frames>
f011c6dc:	29 c3                	sub    %eax,%ebx
f011c6de:	89 da                	mov    %ebx,%edx
f011c6e0:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c6e3:	39 c2                	cmp    %eax,%edx
f011c6e5:	74 26                	je     f011c70d <test_kmalloc_CF_block+0x4f5>
f011c6e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c6ee:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011c6f1:	e8 90 3f ff ff       	call   f0110686 <sys_calculate_free_frames>
f011c6f6:	29 c3                	sub    %eax,%ebx
f011c6f8:	89 d8                	mov    %ebx,%eax
f011c6fa:	50                   	push   %eax
f011c6fb:	ff 75 88             	pushl  -0x78(%ebp)
f011c6fe:	68 50 e2 13 f0       	push   $0xf013e250
f011c703:	6a 0c                	push   $0xc
f011c705:	e8 73 54 fe ff       	call   f0101b7d <cprintf_colored>
f011c70a:	83 c4 10             	add    $0x10,%esp

		if (is_correct) eval += 25;
f011c70d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c711:	74 04                	je     f011c717 <test_kmalloc_CF_block+0x4ff>
f011c713:	83 45 f4 19          	addl   $0x19,-0xc(%ebp)
		is_correct = 1;
f011c717:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}

	//4. Check Permissions
	cprintf_colored(TEXT_cyan,"\n4. Check permissions of allocated spaces in BLOCK ALLOCATOR [10%]\n");
f011c71e:	83 ec 08             	sub    $0x8,%esp
f011c721:	68 b4 e2 13 f0       	push   $0xf013e2b4
f011c726:	6a 03                	push   $0x3
f011c728:	e8 50 54 fe ff       	call   f0101b7d <cprintf_colored>
f011c72d:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[8] + 2*Mega ;
f011c730:	a1 80 c9 94 f0       	mov    0xf094c980,%eax
f011c735:	05 00 00 20 00       	add    $0x200000,%eax
f011c73a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		uint32 va;
		for (va = KERNEL_HEAP_START; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va+=PAGE_SIZE)
f011c73d:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011c744:	eb 6c                	jmp    f011c7b2 <test_kmalloc_CF_block+0x59a>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f011c746:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011c74b:	83 ec 04             	sub    $0x4,%esp
f011c74e:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
f011c754:	52                   	push   %edx
f011c755:	ff 75 d0             	pushl  -0x30(%ebp)
f011c758:	50                   	push   %eax
f011c759:	e8 09 d1 fe ff       	call   f0109867 <get_page_table>
f011c75e:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011c761:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c767:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c76a:	c1 ea 0c             	shr    $0xc,%edx
f011c76d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c773:	c1 e2 02             	shl    $0x2,%edx
f011c776:	01 d0                	add    %edx,%eax
f011c778:	8b 00                	mov    (%eax),%eax
f011c77a:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c77f:	89 45 80             	mov    %eax,-0x80(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011c782:	8b 45 80             	mov    -0x80(%ebp),%eax
f011c785:	83 e0 04             	and    $0x4,%eax
f011c788:	85 c0                	test   %eax,%eax
f011c78a:	74 1f                	je     f011c7ab <test_kmalloc_CF_block+0x593>
			{
				if (is_correct)
f011c78c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c790:	74 19                	je     f011c7ab <test_kmalloc_CF_block+0x593>
				{
					is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Block Alloc #7: Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011c792:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c799:	83 ec 08             	sub    $0x8,%esp
f011c79c:	68 f8 e2 13 f0       	push   $0xf013e2f8
f011c7a1:	6a 0c                	push   $0xc
f011c7a3:	e8 d5 53 fe ff       	call   f0101b7d <cprintf_colored>
f011c7a8:	83 c4 10             	add    $0x10,%esp
	//4. Check Permissions
	cprintf_colored(TEXT_cyan,"\n4. Check permissions of allocated spaces in BLOCK ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[8] + 2*Mega ;
		uint32 va;
		for (va = KERNEL_HEAP_START; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va+=PAGE_SIZE)
f011c7ab:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
f011c7b2:	81 7d d0 ff ff ff f7 	cmpl   $0xf7ffffff,-0x30(%ebp)
f011c7b9:	76 8b                	jbe    f011c746 <test_kmalloc_CF_block+0x52e>
					is_correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"Block Alloc #7: Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (is_correct) eval += 10;
f011c7bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011c7bf:	74 04                	je     f011c7c5 <test_kmalloc_CF_block+0x5ad>
f011c7c1:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf_colored(TEXT_light_green,"\nTest kmalloc Block Alloc Completed. Evaluation = %d%\n", eval);
f011c7c5:	83 ec 04             	sub    $0x4,%esp
f011c7c8:	ff 75 f4             	pushl  -0xc(%ebp)
f011c7cb:	68 54 e3 13 f0       	push   $0xf013e354
f011c7d0:	6a 0a                	push   $0xa
f011c7d2:	e8 a6 53 fe ff       	call   f0101b7d <cprintf_colored>
f011c7d7:	83 c4 10             	add    $0x10,%esp
	return 0;
f011c7da:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011c7df:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011c7e2:	5b                   	pop    %ebx
f011c7e3:	5f                   	pop    %edi
f011c7e4:	5d                   	pop    %ebp
f011c7e5:	c3                   	ret    

f011c7e6 <test_kmalloc_FF_both>:

int test_kmalloc_FF_both()
{
f011c7e6:	55                   	push   %ebp
f011c7e7:	89 e5                	mov    %esp,%ebp
f011c7e9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c7ec:	83 ec 04             	sub    $0x4,%esp
f011c7ef:	68 71 dd 13 f0       	push   $0xf013dd71
f011c7f4:	68 6a 03 00 00       	push   $0x36a
f011c7f9:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c7fe:	e8 ac 46 fe ff       	call   f0100eaf <_panic>

f011c803 <test_kmalloc_NF_both>:
}
int test_kmalloc_NF_both()
{
f011c803:	55                   	push   %ebp
f011c804:	89 e5                	mov    %esp,%ebp
f011c806:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c809:	83 ec 04             	sub    $0x4,%esp
f011c80c:	68 71 dd 13 f0       	push   $0xf013dd71
f011c811:	68 6e 03 00 00       	push   $0x36e
f011c816:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c81b:	e8 8f 46 fe ff       	call   f0100eaf <_panic>

f011c820 <test_kmalloc_BF_both>:
}
int test_kmalloc_BF_both()
{
f011c820:	55                   	push   %ebp
f011c821:	89 e5                	mov    %esp,%ebp
f011c823:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c826:	83 ec 04             	sub    $0x4,%esp
f011c829:	68 71 dd 13 f0       	push   $0xf013dd71
f011c82e:	68 72 03 00 00       	push   $0x372
f011c833:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c838:	e8 72 46 fe ff       	call   f0100eaf <_panic>

f011c83d <test_kmalloc_WF_both>:
}
int test_kmalloc_WF_both()
{
f011c83d:	55                   	push   %ebp
f011c83e:	89 e5                	mov    %esp,%ebp
f011c840:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c843:	83 ec 04             	sub    $0x4,%esp
f011c846:	68 71 dd 13 f0       	push   $0xf013dd71
f011c84b:	68 76 03 00 00       	push   $0x376
f011c850:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c855:	e8 55 46 fe ff       	call   f0100eaf <_panic>

f011c85a <test_kmalloc_CF_both>:
}
int test_kmalloc_CF_both()
{
f011c85a:	55                   	push   %ebp
f011c85b:	89 e5                	mov    %esp,%ebp
f011c85d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c860:	83 ec 04             	sub    $0x4,%esp
f011c863:	68 71 dd 13 f0       	push   $0xf013dd71
f011c868:	68 7a 03 00 00       	push   $0x37a
f011c86d:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c872:	e8 38 46 fe ff       	call   f0100eaf <_panic>

f011c877 <test_kfree_FF_page>:

/**********************************************************************************************/
/*********************************** KFREE TESTING AREA ***************************************/
/**********************************************************************************************/
int test_kfree_FF_page()
{
f011c877:	55                   	push   %ebp
f011c878:	89 e5                	mov    %esp,%ebp
f011c87a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c87d:	83 ec 04             	sub    $0x4,%esp
f011c880:	68 71 dd 13 f0       	push   $0xf013dd71
f011c885:	68 82 03 00 00       	push   $0x382
f011c88a:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c88f:	e8 1b 46 fe ff       	call   f0100eaf <_panic>

f011c894 <test_kfree_NF_page>:
}
int test_kfree_NF_page()
{
f011c894:	55                   	push   %ebp
f011c895:	89 e5                	mov    %esp,%ebp
f011c897:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c89a:	83 ec 04             	sub    $0x4,%esp
f011c89d:	68 71 dd 13 f0       	push   $0xf013dd71
f011c8a2:	68 86 03 00 00       	push   $0x386
f011c8a7:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c8ac:	e8 fe 45 fe ff       	call   f0100eaf <_panic>

f011c8b1 <test_kfree_BF_page>:
}
int test_kfree_BF_page()
{
f011c8b1:	55                   	push   %ebp
f011c8b2:	89 e5                	mov    %esp,%ebp
f011c8b4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c8b7:	83 ec 04             	sub    $0x4,%esp
f011c8ba:	68 71 dd 13 f0       	push   $0xf013dd71
f011c8bf:	68 8a 03 00 00       	push   $0x38a
f011c8c4:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c8c9:	e8 e1 45 fe ff       	call   f0100eaf <_panic>

f011c8ce <test_kfree_WF_page>:
}
int test_kfree_WF_page()
{
f011c8ce:	55                   	push   %ebp
f011c8cf:	89 e5                	mov    %esp,%ebp
f011c8d1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011c8d4:	83 ec 04             	sub    $0x4,%esp
f011c8d7:	68 71 dd 13 f0       	push   $0xf013dd71
f011c8dc:	68 8e 03 00 00       	push   $0x38e
f011c8e1:	68 8a dd 13 f0       	push   $0xf013dd8a
f011c8e6:	e8 c4 45 fe ff       	call   f0100eaf <_panic>

f011c8eb <test_kfree_CF_page>:
}
int test_kfree_CF_page()
{
f011c8eb:	55                   	push   %ebp
f011c8ec:	89 e5                	mov    %esp,%ebp
f011c8ee:	57                   	push   %edi
f011c8ef:	81 ec c4 00 00 00    	sub    $0xc4,%esp
	 * WE COMPARE THE DIFF IN FREE FRAMES BY "AT LEAST" RULE
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011c8f5:	83 ec 08             	sub    $0x8,%esp
f011c8f8:	68 a4 dd 13 f0       	push   $0xf013dda4
f011c8fd:	6a 0e                	push   $0xe
f011c8ff:	e8 79 52 fe ff       	call   f0101b7d <cprintf_colored>
f011c904:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c907:	83 ec 08             	sub    $0x8,%esp
f011c90a:	68 d4 dd 13 f0       	push   $0xf013ddd4
f011c90f:	6a 0e                	push   $0xe
f011c911:	e8 67 52 fe ff       	call   f0101b7d <cprintf_colored>
f011c916:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011c919:	83 ec 08             	sub    $0x8,%esp
f011c91c:	68 a4 dd 13 f0       	push   $0xf013dda4
f011c921:	6a 0e                	push   $0xe
f011c923:	e8 55 52 fe ff       	call   f0101b7d <cprintf_colored>
f011c928:	83 c4 10             	add    $0x10,%esp

	//1. Alloc some spaces in PAGE allocator
	int correct = 1;
f011c92b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int eval;
	cprintf_colored(TEXT_cyan,"\n1. Alloc some spaces in PAGE allocator\n");
f011c932:	83 ec 08             	sub    $0x8,%esp
f011c935:	68 8c e3 13 f0       	push   $0xf013e38c
f011c93a:	6a 03                	push   $0x3
f011c93c:	e8 3c 52 fe ff       	call   f0101b7d <cprintf_colored>
f011c941:	83 c4 10             	add    $0x10,%esp
	{
		eval = initial_page_allocations();
f011c944:	e8 e8 e8 ff ff       	call   f011b231 <initial_page_allocations>
f011c949:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (eval != 100)
f011c94c:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
f011c950:	74 1c                	je     f011c96e <test_kfree_CF_page+0x83>
		{
			cprintf_colored(TEXT_TESTERR_CLR,"initial allocations are not correct!\nplease make sure the the kmalloc test is correct before testing the kfree\n");
f011c952:	83 ec 08             	sub    $0x8,%esp
f011c955:	68 b8 e3 13 f0       	push   $0xf013e3b8
f011c95a:	6a 0c                	push   $0xc
f011c95c:	e8 1c 52 fe ff       	call   f0101b7d <cprintf_colored>
f011c961:	83 c4 10             	add    $0x10,%esp
			return 0;
f011c964:	b8 00 00 00 00       	mov    $0x0,%eax
f011c969:	e9 2c 0a 00 00       	jmp    f011d39a <test_kfree_CF_page+0xaaf>
		}
	}
	eval = 0;
f011c96e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	//2. Free some allocations to create initial holes
	cprintf_colored(TEXT_cyan,"\n2. Free some allocations to create initial holes [5%]\n");
f011c975:	83 ec 08             	sub    $0x8,%esp
f011c978:	68 28 e4 13 f0       	push   $0xf013e428
f011c97d:	6a 03                	push   $0x3
f011c97f:	e8 f9 51 fe ff       	call   f0101b7d <cprintf_colored>
f011c984:	83 c4 10             	add    $0x10,%esp
	correct = 1;
f011c987:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		//3 MB Hole
		correct = freeSpaceInPageAlloc(1);
f011c98e:	83 ec 0c             	sub    $0xc,%esp
f011c991:	6a 01                	push   $0x1
f011c993:	e8 e0 e7 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011c998:	83 c4 10             	add    $0x10,%esp
f011c99b:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//2nd 4 MB Hole
		correct = freeSpaceInPageAlloc(3);
f011c99e:	83 ec 0c             	sub    $0xc,%esp
f011c9a1:	6a 03                	push   $0x3
f011c9a3:	e8 d0 e7 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011c9a8:	83 c4 10             	add    $0x10,%esp
f011c9ab:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//2nd 1 MB Hole
		correct = freeSpaceInPageAlloc(5);
f011c9ae:	83 ec 0c             	sub    $0xc,%esp
f011c9b1:	6a 05                	push   $0x5
f011c9b3:	e8 c0 e7 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011c9b8:	83 c4 10             	add    $0x10,%esp
f011c9bb:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//2nd 2 MB Hole
		correct = freeSpaceInPageAlloc(7);
f011c9be:	83 ec 0c             	sub    $0xc,%esp
f011c9c1:	6a 07                	push   $0x7
f011c9c3:	e8 b0 e7 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011c9c8:	83 c4 10             	add    $0x10,%esp
f011c9cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	if (correct) eval += 5;
f011c9ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011c9d2:	74 04                	je     f011c9d8 <test_kfree_CF_page+0xed>
f011c9d4:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)
	correct = 1;
f011c9d8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//3. Check content of un-freed spaces
	uint32 sums[MAX_NUM_OF_ALLOCS] = {0};
f011c9df:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f011c9e5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c9ea:	b8 00 00 00 00       	mov    $0x0,%eax
f011c9ef:	89 d7                	mov    %edx,%edi
f011c9f1:	f3 ab                	rep stos %eax,%es:(%edi)
	cprintf_colored(TEXT_cyan,"\n3. Check content of un-freed spaces [5%]\n");
f011c9f3:	83 ec 08             	sub    $0x8,%esp
f011c9f6:	68 60 e4 13 f0       	push   $0xf013e460
f011c9fb:	6a 03                	push   $0x3
f011c9fd:	e8 7b 51 fe ff       	call   f0101b7d <cprintf_colored>
f011ca02:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < 9; ++i)
f011ca05:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ca0c:	e9 ae 00 00 00       	jmp    f011cabf <test_kfree_CF_page+0x1d4>
		{
			//skip the freed spaces
			if (i == 1 || i == 3 || i == 5 || i == 7)
f011ca11:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
f011ca15:	0f 84 a0 00 00 00    	je     f011cabb <test_kfree_CF_page+0x1d0>
f011ca1b:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
f011ca1f:	0f 84 96 00 00 00    	je     f011cabb <test_kfree_CF_page+0x1d0>
f011ca25:	83 7d ec 05          	cmpl   $0x5,-0x14(%ebp)
f011ca29:	0f 84 8c 00 00 00    	je     f011cabb <test_kfree_CF_page+0x1d0>
f011ca2f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011ca33:	0f 84 82 00 00 00    	je     f011cabb <test_kfree_CF_page+0x1d0>
				continue;
			char* ptr = (char*)ptr_allocations[i];
f011ca39:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca3c:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011ca43:	89 45 cc             	mov    %eax,-0x34(%ebp)
			for (int j = 0; j < lastIndices[i]; ++j)
f011ca46:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011ca4d:	eb 26                	jmp    f011ca75 <test_kfree_CF_page+0x18a>
			{
				sums[i] += ptr[j] ;
f011ca4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca52:	8b 94 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%edx
f011ca59:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f011ca5c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ca5f:	01 c8                	add    %ecx,%eax
f011ca61:	8a 00                	mov    (%eax),%al
f011ca63:	0f be c0             	movsbl %al,%eax
f011ca66:	01 c2                	add    %eax,%edx
f011ca68:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca6b:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
		{
			//skip the freed spaces
			if (i == 1 || i == 3 || i == 5 || i == 7)
				continue;
			char* ptr = (char*)ptr_allocations[i];
			for (int j = 0; j < lastIndices[i]; ++j)
f011ca72:	ff 45 e8             	incl   -0x18(%ebp)
f011ca75:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca78:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011ca7f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ca82:	7f cb                	jg     f011ca4f <test_kfree_CF_page+0x164>
			{
				sums[i] += ptr[j] ;
			}
			if (sums[i] != i*lastIndices[i])	{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"invalid content\n"); }
f011ca84:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca87:	8b 94 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%edx
f011ca8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca91:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011ca98:	0f af 45 ec          	imul   -0x14(%ebp),%eax
f011ca9c:	39 c2                	cmp    %eax,%edx
f011ca9e:	74 1c                	je     f011cabc <test_kfree_CF_page+0x1d1>
f011caa0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011caa7:	83 ec 08             	sub    $0x8,%esp
f011caaa:	68 54 df 13 f0       	push   $0xf013df54
f011caaf:	6a 0c                	push   $0xc
f011cab1:	e8 c7 50 fe ff       	call   f0101b7d <cprintf_colored>
f011cab6:	83 c4 10             	add    $0x10,%esp
f011cab9:	eb 01                	jmp    f011cabc <test_kfree_CF_page+0x1d1>
	{
		for (int i = 0; i < 9; ++i)
		{
			//skip the freed spaces
			if (i == 1 || i == 3 || i == 5 || i == 7)
				continue;
f011cabb:	90                   	nop

	//3. Check content of un-freed spaces
	uint32 sums[MAX_NUM_OF_ALLOCS] = {0};
	cprintf_colored(TEXT_cyan,"\n3. Check content of un-freed spaces [5%]\n");
	{
		for (int i = 0; i < 9; ++i)
f011cabc:	ff 45 ec             	incl   -0x14(%ebp)
f011cabf:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011cac3:	0f 8e 48 ff ff ff    	jle    f011ca11 <test_kfree_CF_page+0x126>
				sums[i] += ptr[j] ;
			}
			if (sums[i] != i*lastIndices[i])	{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"invalid content\n"); }
		}
	}
	if (correct) eval += 5;
f011cac9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011cacd:	74 04                	je     f011cad3 <test_kfree_CF_page+0x1e8>
f011cacf:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)
	correct = 1;
f011cad3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//4. Check BREAK
	correct = 1;
f011cada:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	uint32 expectedBreak = 0;
f011cae1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	cprintf_colored(TEXT_cyan,"\n4. Check BREAK [5%]\n");
f011cae8:	83 ec 08             	sub    $0x8,%esp
f011caeb:	68 8b e4 13 f0       	push   $0xf013e48b
f011caf0:	6a 03                	push   $0x3
f011caf2:	e8 86 50 fe ff       	call   f0101b7d <cprintf_colored>
f011caf7:	83 c4 10             	add    $0x10,%esp
	{
		uint32 allocSizes = 0;
f011cafa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		for (int i = 0; i < 9; ++i)
f011cb01:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb08:	eb 30                	jmp    f011cb3a <test_kfree_CF_page+0x24f>
		{
			allocSizes += ROUNDUP(requestedSizes[i], PAGE_SIZE);
f011cb0a:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f011cb11:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011cb14:	8b 14 85 20 ca 94 f0 	mov    -0xf6b35e0(,%eax,4),%edx
f011cb1b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011cb1e:	01 d0                	add    %edx,%eax
f011cb20:	48                   	dec    %eax
f011cb21:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011cb24:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cb27:	ba 00 00 00 00       	mov    $0x0,%edx
f011cb2c:	f7 75 c4             	divl   -0x3c(%ebp)
f011cb2f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cb32:	29 d0                	sub    %edx,%eax
f011cb34:	01 45 e4             	add    %eax,-0x1c(%ebp)
	correct = 1;
	uint32 expectedBreak = 0;
	cprintf_colored(TEXT_cyan,"\n4. Check BREAK [5%]\n");
	{
		uint32 allocSizes = 0;
		for (int i = 0; i < 9; ++i)
f011cb37:	ff 45 e0             	incl   -0x20(%ebp)
f011cb3a:	83 7d e0 08          	cmpl   $0x8,-0x20(%ebp)
f011cb3e:	7e ca                	jle    f011cb0a <test_kfree_CF_page+0x21f>
		{
			allocSizes += ROUNDUP(requestedSizes[i], PAGE_SIZE);
		}
		expectedBreak = ACTUAL_PAGE_ALLOC_START + allocSizes;
f011cb40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cb43:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011cb48:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if(kheapPageAllocBreak != expectedBreak) {correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"BREAK value is not correct! Expected = %x, Actual = %x\n", expectedBreak, kheapPageAllocBreak);}
f011cb4b:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011cb50:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011cb53:	74 1f                	je     f011cb74 <test_kfree_CF_page+0x289>
f011cb55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cb5c:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011cb61:	50                   	push   %eax
f011cb62:	ff 75 c8             	pushl  -0x38(%ebp)
f011cb65:	68 74 de 13 f0       	push   $0xf013de74
f011cb6a:	6a 0c                	push   $0xc
f011cb6c:	e8 0c 50 fe ff       	call   f0101b7d <cprintf_colored>
f011cb71:	83 c4 10             	add    $0x10,%esp
	}
	if (correct) eval += 5;
f011cb74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011cb78:	74 04                	je     f011cb7e <test_kfree_CF_page+0x293>
f011cb7a:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)
	correct = 1;
f011cb7e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//5. Allocate after kfree [Test CUSTOM FIT]
	uint32 allocIndex,expectedVA, size = 0;
f011cb85:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
	cprintf_colored(TEXT_cyan,"\n5. Allocate after kfree [Test CUSTOM FIT] [30%]\n");
f011cb8c:	83 ec 08             	sub    $0x8,%esp
f011cb8f:	68 a4 e4 13 f0       	push   $0xf013e4a4
f011cb94:	6a 03                	push   $0x3
f011cb96:	e8 e2 4f fe ff       	call   f0101b7d <cprintf_colored>
f011cb9b:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB [EXACT FIT in 1MB Hole (alloc#5)]
		allocIndex = 10;
f011cb9e:	c7 45 b8 0a 00 00 00 	movl   $0xa,-0x48(%ebp)
		size = 1*Mega - kilo;
f011cba5:	c7 45 bc 00 fc 0f 00 	movl   $0xffc00,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011cbac:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cbaf:	83 ec 04             	sub    $0x4,%esp
f011cbb2:	6a 01                	push   $0x1
f011cbb4:	ff 75 bc             	pushl  -0x44(%ebp)
f011cbb7:	50                   	push   %eax
f011cbb8:	e8 98 e4 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011cbbd:	83 c4 10             	add    $0x10,%esp
f011cbc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[5] ; //Address of 1MB Hole
f011cbc3:	a1 74 c9 94 f0       	mov    0xf094c974,%eax
f011cbc8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011cbcb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cbce:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cbd5:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cbd8:	74 2a                	je     f011cc04 <test_kfree_CF_page+0x319>
f011cbda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cbe1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cbe4:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cbeb:	83 ec 0c             	sub    $0xc,%esp
f011cbee:	50                   	push   %eax
f011cbef:	ff 75 b4             	pushl  -0x4c(%ebp)
f011cbf2:	ff 75 b8             	pushl  -0x48(%ebp)
f011cbf5:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011cbfa:	6a 0c                	push   $0xc
f011cbfc:	e8 7c 4f fe ff       	call   f0101b7d <cprintf_colored>
f011cc01:	83 c4 20             	add    $0x20,%esp

		//1MB + 4KB [WORST FIT in 4MB Hole (alloc#3)]
		allocIndex = 11;
f011cc04:	c7 45 b8 0b 00 00 00 	movl   $0xb,-0x48(%ebp)
		size = 1*Mega + 4*kilo;
f011cc0b:	c7 45 bc 00 10 10 00 	movl   $0x101000,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011cc12:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cc15:	83 ec 04             	sub    $0x4,%esp
f011cc18:	6a 01                	push   $0x1
f011cc1a:	ff 75 bc             	pushl  -0x44(%ebp)
f011cc1d:	50                   	push   %eax
f011cc1e:	e8 32 e4 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011cc23:	83 c4 10             	add    $0x10,%esp
f011cc26:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[3] ; //Address of 4MB Hole
f011cc29:	a1 6c c9 94 f0       	mov    0xf094c96c,%eax
f011cc2e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011cc31:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cc34:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cc3b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cc3e:	74 2a                	je     f011cc6a <test_kfree_CF_page+0x37f>
f011cc40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cc47:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cc4a:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cc51:	83 ec 0c             	sub    $0xc,%esp
f011cc54:	50                   	push   %eax
f011cc55:	ff 75 b4             	pushl  -0x4c(%ebp)
f011cc58:	ff 75 b8             	pushl  -0x48(%ebp)
f011cc5b:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011cc60:	6a 0c                	push   $0xc
f011cc62:	e8 16 4f fe ff       	call   f0101b7d <cprintf_colored>
f011cc67:	83 c4 20             	add    $0x20,%esp

		//3MB - 4KB [EXACT FIT in remaining area of 4MB Hole (alloc#3)]
		allocIndex = 12;
f011cc6a:	c7 45 b8 0c 00 00 00 	movl   $0xc,-0x48(%ebp)
		size = 3*Mega - 4*kilo;
f011cc71:	c7 45 bc 00 f0 2f 00 	movl   $0x2ff000,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011cc78:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cc7b:	83 ec 04             	sub    $0x4,%esp
f011cc7e:	6a 01                	push   $0x1
f011cc80:	ff 75 bc             	pushl  -0x44(%ebp)
f011cc83:	50                   	push   %eax
f011cc84:	e8 cc e3 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011cc89:	83 c4 10             	add    $0x10,%esp
f011cc8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[3] + 1*Mega + 4*kilo; //1MB.4KB after the Start Address of 4MB Hole
f011cc8f:	a1 6c c9 94 f0       	mov    0xf094c96c,%eax
f011cc94:	05 00 10 10 00       	add    $0x101000,%eax
f011cc99:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011cc9c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cc9f:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cca6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cca9:	74 2a                	je     f011ccd5 <test_kfree_CF_page+0x3ea>
f011ccab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ccb2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ccb5:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011ccbc:	83 ec 0c             	sub    $0xc,%esp
f011ccbf:	50                   	push   %eax
f011ccc0:	ff 75 b4             	pushl  -0x4c(%ebp)
f011ccc3:	ff 75 b8             	pushl  -0x48(%ebp)
f011ccc6:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011cccb:	6a 0c                	push   $0xc
f011cccd:	e8 ab 4e fe ff       	call   f0101b7d <cprintf_colored>
f011ccd2:	83 c4 20             	add    $0x20,%esp

		//1.5 MB [WORST FIT in 3MB Hole (alloc#1)]
		allocIndex = 13;
f011ccd5:	c7 45 b8 0d 00 00 00 	movl   $0xd,-0x48(%ebp)
		size = 1*Mega + Mega/2;
f011ccdc:	c7 45 bc 00 00 18 00 	movl   $0x180000,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011cce3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cce6:	83 ec 04             	sub    $0x4,%esp
f011cce9:	6a 01                	push   $0x1
f011cceb:	ff 75 bc             	pushl  -0x44(%ebp)
f011ccee:	50                   	push   %eax
f011ccef:	e8 61 e3 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011ccf4:	83 c4 10             	add    $0x10,%esp
f011ccf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[1] ; //Address of 3MB Hole
f011ccfa:	a1 64 c9 94 f0       	mov    0xf094c964,%eax
f011ccff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011cd02:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cd05:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cd0c:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cd0f:	74 2a                	je     f011cd3b <test_kfree_CF_page+0x450>
f011cd11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cd18:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cd1b:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cd22:	83 ec 0c             	sub    $0xc,%esp
f011cd25:	50                   	push   %eax
f011cd26:	ff 75 b4             	pushl  -0x4c(%ebp)
f011cd29:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd2c:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011cd31:	6a 0c                	push   $0xc
f011cd33:	e8 45 4e fe ff       	call   f0101b7d <cprintf_colored>
f011cd38:	83 c4 20             	add    $0x20,%esp

		//2.5 MB [EXTEND THE BREAK]
		allocIndex = 14;
f011cd3b:	c7 45 b8 0e 00 00 00 	movl   $0xe,-0x48(%ebp)
		size = 2*Mega + Mega/2;
f011cd42:	c7 45 bc 00 00 28 00 	movl   $0x280000,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011cd49:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cd4c:	83 ec 04             	sub    $0x4,%esp
f011cd4f:	6a 01                	push   $0x1
f011cd51:	ff 75 bc             	pushl  -0x44(%ebp)
f011cd54:	50                   	push   %eax
f011cd55:	e8 fb e2 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011cd5a:	83 c4 10             	add    $0x10,%esp
f011cd5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = expectedBreak ;
f011cd60:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cd63:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedBreak += ROUNDUP(size, PAGE_SIZE);
f011cd66:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f011cd6d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f011cd70:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011cd73:	01 d0                	add    %edx,%eax
f011cd75:	48                   	dec    %eax
f011cd76:	89 45 ac             	mov    %eax,-0x54(%ebp)
f011cd79:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011cd7c:	ba 00 00 00 00       	mov    $0x0,%edx
f011cd81:	f7 75 b0             	divl   -0x50(%ebp)
f011cd84:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011cd87:	29 d0                	sub    %edx,%eax
f011cd89:	01 45 c8             	add    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011cd8c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cd8f:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cd96:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cd99:	74 2a                	je     f011cdc5 <test_kfree_CF_page+0x4da>
f011cd9b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cda2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cda5:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cdac:	83 ec 0c             	sub    $0xc,%esp
f011cdaf:	50                   	push   %eax
f011cdb0:	ff 75 b4             	pushl  -0x4c(%ebp)
f011cdb3:	ff 75 b8             	pushl  -0x48(%ebp)
f011cdb6:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011cdbb:	6a 0c                	push   $0xc
f011cdbd:	e8 bb 4d fe ff       	call   f0101b7d <cprintf_colored>
f011cdc2:	83 c4 20             	add    $0x20,%esp
		if(kheapPageAllocBreak != expectedBreak) {correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"BREAK value is not correct! Expected = %x, Actual = %x\n", expectedBreak, kheapPageAllocBreak);}
f011cdc5:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011cdca:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011cdcd:	74 1f                	je     f011cdee <test_kfree_CF_page+0x503>
f011cdcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cdd6:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011cddb:	50                   	push   %eax
f011cddc:	ff 75 c8             	pushl  -0x38(%ebp)
f011cddf:	68 74 de 13 f0       	push   $0xf013de74
f011cde4:	6a 0c                	push   $0xc
f011cde6:	e8 92 4d fe ff       	call   f0101b7d <cprintf_colored>
f011cdeb:	83 c4 10             	add    $0x10,%esp

		//Insufficient space
		allocIndex = 15;
f011cdee:	c7 45 b8 0f 00 00 00 	movl   $0xf,-0x48(%ebp)
		expectedVA = 0;
f011cdf5:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
		int freeFrames = (int)sys_calculate_free_frames() ;
f011cdfc:	e8 85 38 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011ce01:	89 45 a8             	mov    %eax,-0x58(%ebp)
		int freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ce04:	e8 2a 8b fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ce09:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_PAGE_ALLOC_START) - expectedBreak ;
f011ce0c:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f011ce11:	2b 45 c8             	sub    -0x38(%ebp),%eax
f011ce14:	89 45 a0             	mov    %eax,-0x60(%ebp)
		ptr_allocations[allocIndex] = kmalloc(restOfKHeap+1);
f011ce17:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ce1a:	40                   	inc    %eax
f011ce1b:	83 ec 0c             	sub    $0xc,%esp
f011ce1e:	50                   	push   %eax
f011ce1f:	e8 ae e0 fe ff       	call   f010aed2 <kmalloc>
f011ce24:	83 c4 10             	add    $0x10,%esp
f011ce27:	89 c2                	mov    %eax,%edx
f011ce29:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ce2c:	89 14 85 60 c9 94 f0 	mov    %edx,-0xf6b36a0(,%eax,4)
		if (ptr_allocations[allocIndex] != NULL) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.1 Allocating insufficient space: should return NULL\n", allocIndex); }
f011ce33:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ce36:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011ce3d:	85 c0                	test   %eax,%eax
f011ce3f:	74 1c                	je     f011ce5d <test_kfree_CF_page+0x572>
f011ce41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ce48:	83 ec 04             	sub    $0x4,%esp
f011ce4b:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce4e:	68 1c da 13 f0       	push   $0xf013da1c
f011ce53:	6a 0c                	push   $0xc
f011ce55:	e8 23 4d fe ff       	call   f0101b7d <cprintf_colored>
f011ce5a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", allocIndex); }
f011ce5d:	e8 d1 8a fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ce62:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ce65:	74 1c                	je     f011ce83 <test_kfree_CF_page+0x598>
f011ce67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ce6e:	83 ec 04             	sub    $0x4,%esp
f011ce71:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce74:	68 54 da 13 f0       	push   $0xf013da54
f011ce79:	6a 0c                	push   $0xc
f011ce7b:	e8 fd 4c fe ff       	call   f0101b7d <cprintf_colored>
f011ce80:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong allocation: pages are not loaded successfully into memory\n", allocIndex); }
f011ce83:	e8 fe 37 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011ce88:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f011ce8b:	74 1c                	je     f011cea9 <test_kfree_CF_page+0x5be>
f011ce8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ce94:	83 ec 04             	sub    $0x4,%esp
f011ce97:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce9a:	68 c4 da 13 f0       	push   $0xf013dac4
f011ce9f:	6a 0c                	push   $0xc
f011cea1:	e8 d7 4c fe ff       	call   f0101b7d <cprintf_colored>
f011cea6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct) eval+=30;
f011cea9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011cead:	74 04                	je     f011ceb3 <test_kfree_CF_page+0x5c8>
f011ceaf:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)
	correct = 1;
f011ceb3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//6. Check content of newly allocated  spaces
	cprintf_colored(TEXT_cyan,"\n6. Check content of newly allocated spaces [5%]\n");
f011ceba:	83 ec 08             	sub    $0x8,%esp
f011cebd:	68 d8 e4 13 f0       	push   $0xf013e4d8
f011cec2:	6a 03                	push   $0x3
f011cec4:	e8 b4 4c fe ff       	call   f0101b7d <cprintf_colored>
f011cec9:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 10; i < 15; ++i)
f011cecc:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
f011ced3:	e9 83 00 00 00       	jmp    f011cf5b <test_kfree_CF_page+0x670>
		{
			char* ptr = (char*)ptr_allocations[i];
f011ced8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cedb:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011cee2:	89 45 9c             	mov    %eax,-0x64(%ebp)
			for (int j = 0; j < lastIndices[i]; ++j)
f011cee5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011ceec:	eb 26                	jmp    f011cf14 <test_kfree_CF_page+0x629>
			{
				sums[i] += ptr[j] ;
f011ceee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cef1:	8b 94 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%edx
f011cef8:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011cefb:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011cefe:	01 c8                	add    %ecx,%eax
f011cf00:	8a 00                	mov    (%eax),%al
f011cf02:	0f be c0             	movsbl %al,%eax
f011cf05:	01 c2                	add    %eax,%edx
f011cf07:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cf0a:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
	cprintf_colored(TEXT_cyan,"\n6. Check content of newly allocated spaces [5%]\n");
	{
		for (int i = 10; i < 15; ++i)
		{
			char* ptr = (char*)ptr_allocations[i];
			for (int j = 0; j < lastIndices[i]; ++j)
f011cf11:	ff 45 d8             	incl   -0x28(%ebp)
f011cf14:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cf17:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011cf1e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011cf21:	7f cb                	jg     f011ceee <test_kfree_CF_page+0x603>
			{
				sums[i] += ptr[j] ;
			}
			if (sums[i] != i*lastIndices[i])	{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"invalid content\n"); }
f011cf23:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cf26:	8b 94 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%edx
f011cf2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cf30:	8b 04 85 c0 c9 94 f0 	mov    -0xf6b3640(,%eax,4),%eax
f011cf37:	0f af 45 dc          	imul   -0x24(%ebp),%eax
f011cf3b:	39 c2                	cmp    %eax,%edx
f011cf3d:	74 19                	je     f011cf58 <test_kfree_CF_page+0x66d>
f011cf3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cf46:	83 ec 08             	sub    $0x8,%esp
f011cf49:	68 54 df 13 f0       	push   $0xf013df54
f011cf4e:	6a 0c                	push   $0xc
f011cf50:	e8 28 4c fe ff       	call   f0101b7d <cprintf_colored>
f011cf55:	83 c4 10             	add    $0x10,%esp
	correct = 1;

	//6. Check content of newly allocated  spaces
	cprintf_colored(TEXT_cyan,"\n6. Check content of newly allocated spaces [5%]\n");
	{
		for (int i = 10; i < 15; ++i)
f011cf58:	ff 45 dc             	incl   -0x24(%ebp)
f011cf5b:	83 7d dc 0e          	cmpl   $0xe,-0x24(%ebp)
f011cf5f:	0f 8e 73 ff ff ff    	jle    f011ced8 <test_kfree_CF_page+0x5ed>
				sums[i] += ptr[j] ;
			}
			if (sums[i] != i*lastIndices[i])	{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"invalid content\n"); }
		}
	}
	if (correct) eval += 5;
f011cf65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011cf69:	74 04                	je     f011cf6f <test_kfree_CF_page+0x684>
f011cf6b:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)
	correct = 1;
f011cf6f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//7. Free some allocations to create MERGED holes
	correct = 1;
f011cf76:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	cprintf_colored(TEXT_cyan,"\n7. Free some allocations to create MERGED holes [10%]\n");
f011cf7d:	83 ec 08             	sub    $0x8,%esp
f011cf80:	68 0c e5 13 f0       	push   $0xf013e50c
f011cf85:	6a 03                	push   $0x3
f011cf87:	e8 f1 4b fe ff       	call   f0101b7d <cprintf_colored>
f011cf8c:	83 c4 10             	add    $0x10,%esp
	{
		//Free new 3MB allocation inside the 4MB Hole
		correct = freeSpaceInPageAlloc(12);
f011cf8f:	83 ec 0c             	sub    $0xc,%esp
f011cf92:	6a 0c                	push   $0xc
f011cf94:	e8 df e1 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011cf99:	83 c4 10             	add    $0x10,%esp
f011cf9c:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//Free new 1MB allocation at the beginning of the 4MB Hole (should be MERGED with next 3MB) => 4MB HOLE
		correct = freeSpaceInPageAlloc(11);
f011cf9f:	83 ec 0c             	sub    $0xc,%esp
f011cfa2:	6a 0b                	push   $0xb
f011cfa4:	e8 cf e1 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011cfa9:	83 c4 10             	add    $0x10,%esp
f011cfac:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//Free new 1MB allocation at the beginning of the 3MB Hole (should be MERGED with next 1.5MB) => 3MB HOLE
		correct = freeSpaceInPageAlloc(13);
f011cfaf:	83 ec 0c             	sub    $0xc,%esp
f011cfb2:	6a 0d                	push   $0xd
f011cfb4:	e8 bf e1 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011cfb9:	83 c4 10             	add    $0x10,%esp
f011cfbc:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//Free new 1MB allocation at the 1MB Hole (NO MERGED)
		correct = freeSpaceInPageAlloc(10);
f011cfbf:	83 ec 0c             	sub    $0xc,%esp
f011cfc2:	6a 0a                	push   $0xa
f011cfc4:	e8 af e1 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011cfc9:	83 c4 10             	add    $0x10,%esp
f011cfcc:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//Free original 3rd 1MB allocation (should be MERGED with next 2MB hole and the prev 1MB hole) => 4MB HOLE
		correct = freeSpaceInPageAlloc(6);
f011cfcf:	83 ec 0c             	sub    $0xc,%esp
f011cfd2:	6a 06                	push   $0x6
f011cfd4:	e8 9f e1 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011cfd9:	83 c4 10             	add    $0x10,%esp
f011cfdc:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//Free original last 2MB allocation (should be MERGED with the prev 4MB created hole) => 6MB HOLE
		correct = freeSpaceInPageAlloc(8);
f011cfdf:	83 ec 0c             	sub    $0xc,%esp
f011cfe2:	6a 08                	push   $0x8
f011cfe4:	e8 8f e1 ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011cfe9:	83 c4 10             	add    $0x10,%esp
f011cfec:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	if (correct) eval += 10;
f011cfef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011cff3:	74 04                	je     f011cff9 <test_kfree_CF_page+0x70e>
f011cff5:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)
	correct = 1;
f011cff9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//8. Allocate after kfree [Test CUSTOM FIT in MERGED FREE SPACES]
	cprintf_colored(TEXT_cyan,"\n8. Allocate after kfree [Test CUSTOM FIT in MERGED FREE SPACES] [20%]\n");
f011d000:	83 ec 08             	sub    $0x8,%esp
f011d003:	68 44 e5 13 f0       	push   $0xf013e544
f011d008:	6a 03                	push   $0x3
f011d00a:	e8 6e 4b fe ff       	call   f0101b7d <cprintf_colored>
f011d00f:	83 c4 10             	add    $0x10,%esp
	{
		//3 MB [EXACT FIT in 3MB Hole]
		allocIndex = 16;
f011d012:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%ebp)
		size = 3*Mega - kilo;
f011d019:	c7 45 bc 00 fc 2f 00 	movl   $0x2ffc00,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011d020:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d023:	83 ec 04             	sub    $0x4,%esp
f011d026:	6a 01                	push   $0x1
f011d028:	ff 75 bc             	pushl  -0x44(%ebp)
f011d02b:	50                   	push   %eax
f011d02c:	e8 24 e0 ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011d031:	83 c4 10             	add    $0x10,%esp
f011d034:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[1] ; //Address of 3MB Hole
f011d037:	a1 64 c9 94 f0       	mov    0xf094c964,%eax
f011d03c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011d03f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d042:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d049:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d04c:	74 2a                	je     f011d078 <test_kfree_CF_page+0x78d>
f011d04e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d055:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d058:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d05f:	83 ec 0c             	sub    $0xc,%esp
f011d062:	50                   	push   %eax
f011d063:	ff 75 b4             	pushl  -0x4c(%ebp)
f011d066:	ff 75 b8             	pushl  -0x48(%ebp)
f011d069:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011d06e:	6a 0c                	push   $0xc
f011d070:	e8 08 4b fe ff       	call   f0101b7d <cprintf_colored>
f011d075:	83 c4 20             	add    $0x20,%esp

		//3 MB [WORST FIT in 6MB Hole]
		allocIndex = 17;
f011d078:	c7 45 b8 11 00 00 00 	movl   $0x11,-0x48(%ebp)
		size = 3*Mega - kilo;
f011d07f:	c7 45 bc 00 fc 2f 00 	movl   $0x2ffc00,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011d086:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d089:	83 ec 04             	sub    $0x4,%esp
f011d08c:	6a 01                	push   $0x1
f011d08e:	ff 75 bc             	pushl  -0x44(%ebp)
f011d091:	50                   	push   %eax
f011d092:	e8 be df ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011d097:	83 c4 10             	add    $0x10,%esp
f011d09a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[5] ; //Address of 6MB Hole
f011d09d:	a1 74 c9 94 f0       	mov    0xf094c974,%eax
f011d0a2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011d0a5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d0a8:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d0af:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d0b2:	74 2a                	je     f011d0de <test_kfree_CF_page+0x7f3>
f011d0b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d0bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d0be:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d0c5:	83 ec 0c             	sub    $0xc,%esp
f011d0c8:	50                   	push   %eax
f011d0c9:	ff 75 b4             	pushl  -0x4c(%ebp)
f011d0cc:	ff 75 b8             	pushl  -0x48(%ebp)
f011d0cf:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011d0d4:	6a 0c                	push   $0xc
f011d0d6:	e8 a2 4a fe ff       	call   f0101b7d <cprintf_colored>
f011d0db:	83 c4 20             	add    $0x20,%esp

		//3MB - 4KB [WORST FIT in 4MB Hole]
		allocIndex = 18;
f011d0de:	c7 45 b8 12 00 00 00 	movl   $0x12,-0x48(%ebp)
		size = 3*Mega - 4*kilo;
f011d0e5:	c7 45 bc 00 f0 2f 00 	movl   $0x2ff000,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011d0ec:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d0ef:	83 ec 04             	sub    $0x4,%esp
f011d0f2:	6a 01                	push   $0x1
f011d0f4:	ff 75 bc             	pushl  -0x44(%ebp)
f011d0f7:	50                   	push   %eax
f011d0f8:	e8 58 df ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011d0fd:	83 c4 10             	add    $0x10,%esp
f011d100:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[3] ; //Address of 4MB Hole
f011d103:	a1 6c c9 94 f0       	mov    0xf094c96c,%eax
f011d108:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011d10b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d10e:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d115:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d118:	74 2a                	je     f011d144 <test_kfree_CF_page+0x859>
f011d11a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d121:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d124:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d12b:	83 ec 0c             	sub    $0xc,%esp
f011d12e:	50                   	push   %eax
f011d12f:	ff 75 b4             	pushl  -0x4c(%ebp)
f011d132:	ff 75 b8             	pushl  -0x48(%ebp)
f011d135:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011d13a:	6a 0c                	push   $0xc
f011d13c:	e8 3c 4a fe ff       	call   f0101b7d <cprintf_colored>
f011d141:	83 c4 20             	add    $0x20,%esp

		//3 MB [EXACT FIT in remaining of 6MB Hole]
		allocIndex = 19;
f011d144:	c7 45 b8 13 00 00 00 	movl   $0x13,-0x48(%ebp)
		size = 3*Mega;
f011d14b:	c7 45 bc 00 00 30 00 	movl   $0x300000,-0x44(%ebp)
		correct = allocSpaceInPageAlloc(allocIndex, size, 1);
f011d152:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d155:	83 ec 04             	sub    $0x4,%esp
f011d158:	6a 01                	push   $0x1
f011d15a:	ff 75 bc             	pushl  -0x44(%ebp)
f011d15d:	50                   	push   %eax
f011d15e:	e8 f2 de ff ff       	call   f011b055 <allocSpaceInPageAlloc>
f011d163:	83 c4 10             	add    $0x10,%esp
f011d166:	89 45 f4             	mov    %eax,-0xc(%ebp)
		expectedVA = (uint32)ptr_allocations[5] + 3*Mega ; //3MB after the start address of 6MB Hole
f011d169:	a1 74 c9 94 f0       	mov    0xf094c974,%eax
f011d16e:	05 00 00 30 00       	add    $0x300000,%eax
f011d173:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[allocIndex] != (expectedVA)) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"%d.3 Wrong start address for the allocated space... Expected = %x, Actual = %x\n", allocIndex, expectedVA, ptr_allocations[allocIndex]); }
f011d176:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d179:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d180:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d183:	74 2a                	je     f011d1af <test_kfree_CF_page+0x8c4>
f011d185:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d18c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d18f:	8b 04 85 60 c9 94 f0 	mov    -0xf6b36a0(,%eax,4),%eax
f011d196:	83 ec 0c             	sub    $0xc,%esp
f011d199:	50                   	push   %eax
f011d19a:	ff 75 b4             	pushl  -0x4c(%ebp)
f011d19d:	ff 75 b8             	pushl  -0x48(%ebp)
f011d1a0:	68 b0 d9 13 f0       	push   $0xf013d9b0
f011d1a5:	6a 0c                	push   $0xc
f011d1a7:	e8 d1 49 fe ff       	call   f0101b7d <cprintf_colored>
f011d1ac:	83 c4 20             	add    $0x20,%esp
	}
	if (correct) eval += 20;
f011d1af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d1b3:	74 04                	je     f011d1b9 <test_kfree_CF_page+0x8ce>
f011d1b5:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)
	correct = 1;
f011d1b9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//9. Free last allocations to move-down the BREAK
	correct = 1;
f011d1c0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	cprintf_colored(TEXT_cyan,"\n9. Free last allocations to move-down the BREAK [10%]\n");
f011d1c7:	83 ec 08             	sub    $0x8,%esp
f011d1ca:	68 8c e5 13 f0       	push   $0xf013e58c
f011d1cf:	6a 03                	push   $0x3
f011d1d1:	e8 a7 49 fe ff       	call   f0101b7d <cprintf_colored>
f011d1d6:	83 c4 10             	add    $0x10,%esp
	{
		//Free last allocated 3MB
		correct = freeSpaceInPageAlloc(19);
f011d1d9:	83 ec 0c             	sub    $0xc,%esp
f011d1dc:	6a 13                	push   $0x13
f011d1de:	e8 95 df ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011d1e3:	83 c4 10             	add    $0x10,%esp
f011d1e6:	89 45 f4             	mov    %eax,-0xc(%ebp)

		//Free 2.5MB allocation (should be merged with prev 3MB and the break should be moved-down)
		correct = freeSpaceInPageAlloc(14);
f011d1e9:	83 ec 0c             	sub    $0xc,%esp
f011d1ec:	6a 0e                	push   $0xe
f011d1ee:	e8 85 df ff ff       	call   f011b178 <freeSpaceInPageAlloc>
f011d1f3:	83 c4 10             	add    $0x10,%esp
f011d1f6:	89 45 f4             	mov    %eax,-0xc(%ebp)

		expectedBreak = expectedBreak - (5*Mega + Mega/2) ;
f011d1f9:	81 6d c8 00 00 58 00 	subl   $0x580000,-0x38(%ebp)
		if(kheapPageAllocBreak != expectedBreak) {correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"BREAK value is not correct! Expected = %x, Actual = %x\n", expectedBreak, kheapPageAllocBreak);}
f011d200:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011d205:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011d208:	74 1f                	je     f011d229 <test_kfree_CF_page+0x93e>
f011d20a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d211:	a1 b0 51 96 f1       	mov    0xf19651b0,%eax
f011d216:	50                   	push   %eax
f011d217:	ff 75 c8             	pushl  -0x38(%ebp)
f011d21a:	68 74 de 13 f0       	push   $0xf013de74
f011d21f:	6a 0c                	push   $0xc
f011d221:	e8 57 49 fe ff       	call   f0101b7d <cprintf_colored>
f011d226:	83 c4 10             	add    $0x10,%esp
	}
	if (correct) eval += 10;
f011d229:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d22d:	74 04                	je     f011d233 <test_kfree_CF_page+0x948>
f011d22f:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)
	correct = 1;
f011d233:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	//Check memory access of FREED area in PAGE allocator
	char* ptr;
	cprintf_colored(TEXT_cyan,"\n10. Check memory access of FREED area in PAGE allocator [5%]\n");
f011d23a:	83 ec 08             	sub    $0x8,%esp
f011d23d:	68 c4 e5 13 f0       	push   $0xf013e5c4
f011d242:	6a 03                	push   $0x3
f011d244:	e8 34 49 fe ff       	call   f0101b7d <cprintf_colored>
f011d249:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011d24c:	83 ec 0c             	sub    $0xc,%esp
f011d24f:	6a 03                	push   $0x3
f011d251:	e8 1d 3b ff ff       	call   f0110d73 <sys_bypassPageFault>
f011d256:	83 c4 10             	add    $0x10,%esp

		ptr = (char *) ptr_allocations[18] + requestedSizes[18]; //begin of free 1MB after the 3rd 3MB allocation
f011d259:	8b 15 a8 c9 94 f0    	mov    0xf094c9a8,%edx
f011d25f:	a1 68 ca 94 f0       	mov    0xf094ca68,%eax
f011d264:	01 d0                	add    %edx,%eax
f011d266:	89 45 98             	mov    %eax,-0x68(%ebp)
		ptr[0] = 10;
f011d269:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d26c:	c6 00 0a             	movb   $0xa,(%eax)
		//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
		if (sys_rcr2() != (uint32)&(ptr[0]))
f011d26f:	e8 ed 3a ff ff       	call   f0110d61 <sys_rcr2>
f011d274:	89 c2                	mov    %eax,%edx
f011d276:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d279:	39 c2                	cmp    %eax,%edx
f011d27b:	74 19                	je     f011d296 <test_kfree_CF_page+0x9ab>
		{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"10 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011d27d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d284:	83 ec 08             	sub    $0x8,%esp
f011d287:	68 04 e6 13 f0       	push   $0xf013e604
f011d28c:	6a 0c                	push   $0xc
f011d28e:	e8 ea 48 fe ff       	call   f0101b7d <cprintf_colored>
f011d293:	83 c4 10             	add    $0x10,%esp
		ptr[1*Mega-1] = 10;
f011d296:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d299:	05 ff ff 0f 00       	add    $0xfffff,%eax
f011d29e:	c6 00 0a             	movb   $0xa,(%eax)
		if (sys_rcr2() != (uint32)&(ptr[1*Mega-1]))
f011d2a1:	e8 bb 3a ff ff       	call   f0110d61 <sys_rcr2>
f011d2a6:	8b 55 98             	mov    -0x68(%ebp),%edx
f011d2a9:	81 c2 ff ff 0f 00    	add    $0xfffff,%edx
f011d2af:	39 d0                	cmp    %edx,%eax
f011d2b1:	74 19                	je     f011d2cc <test_kfree_CF_page+0x9e1>
		{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"10 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011d2b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d2ba:	83 ec 08             	sub    $0x8,%esp
f011d2bd:	68 04 e6 13 f0       	push   $0xf013e604
f011d2c2:	6a 0c                	push   $0xc
f011d2c4:	e8 b4 48 fe ff       	call   f0101b7d <cprintf_colored>
f011d2c9:	83 c4 10             	add    $0x10,%esp

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011d2cc:	83 ec 0c             	sub    $0xc,%esp
f011d2cf:	6a 00                	push   $0x0
f011d2d1:	e8 9d 3a ff ff       	call   f0110d73 <sys_bypassPageFault>
f011d2d6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct) eval += 5;
f011d2d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d2dd:	74 04                	je     f011d2e3 <test_kfree_CF_page+0x9f8>
f011d2df:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)
	correct = 1;
f011d2e3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)

	correct = 1 ;
f011d2ea:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	//11. Check page tables
	cprintf_colored(TEXT_cyan,"\n11. check page tables [5%]\n");
f011d2f1:	83 ec 08             	sub    $0x8,%esp
f011d2f4:	68 4d e6 13 f0       	push   $0xf013e64d
f011d2f9:	6a 03                	push   $0x3
f011d2fb:	e8 7d 48 fe ff       	call   f0101b7d <cprintf_colored>
f011d300:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011d303:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011d30a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011d311:	eb 4e                	jmp    f011d361 <test_kfree_CF_page+0xa76>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011d313:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d316:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011d31b:	83 ec 04             	sub    $0x4,%esp
f011d31e:	8d 8d 44 ff ff ff    	lea    -0xbc(%ebp),%ecx
f011d324:	51                   	push   %ecx
f011d325:	52                   	push   %edx
f011d326:	50                   	push   %eax
f011d327:	e8 3b c5 fe ff       	call   f0109867 <get_page_table>
f011d32c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011d32f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011d335:	85 c0                	test   %eax,%eax
f011d337:	75 1d                	jne    f011d356 <test_kfree_CF_page+0xa6b>
			{
				if (correct)
f011d339:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d33d:	74 17                	je     f011d356 <test_kfree_CF_page+0xa6b>
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011d33f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d346:	83 ec 0c             	sub    $0xc,%esp
f011d349:	68 6c e6 13 f0       	push   $0xf013e66c
f011d34e:	e8 fa 47 fe ff       	call   f0101b4d <cprintf>
f011d353:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//11. Check page tables
	cprintf_colored(TEXT_cyan,"\n11. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011d356:	81 45 d0 00 00 40 00 	addl   $0x400000,-0x30(%ebp)
f011d35d:	83 55 d4 00          	adcl   $0x0,-0x2c(%ebp)
f011d361:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d365:	78 ac                	js     f011d313 <test_kfree_CF_page+0xa28>
f011d367:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d36b:	7f 09                	jg     f011d376 <test_kfree_CF_page+0xa8b>
f011d36d:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f011d374:	76 9d                	jbe    f011d313 <test_kfree_CF_page+0xa28>
				if (correct)
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011d376:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d37a:	74 04                	je     f011d380 <test_kfree_CF_page+0xa95>
f011d37c:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf_colored(TEXT_light_green,"\nTest kfree & CUSTOM FIT Page Alloc Completed. Evaluation = %d%\n", eval);
f011d380:	83 ec 04             	sub    $0x4,%esp
f011d383:	ff 75 f0             	pushl  -0x10(%ebp)
f011d386:	68 d4 e6 13 f0       	push   $0xf013e6d4
f011d38b:	6a 0a                	push   $0xa
f011d38d:	e8 eb 47 fe ff       	call   f0101b7d <cprintf_colored>
f011d392:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d395:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d39a:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011d39d:	c9                   	leave  
f011d39e:	c3                   	ret    

f011d39f <test_kfree_FF_block>:

int test_kfree_FF_block()
{
f011d39f:	55                   	push   %ebp
f011d3a0:	89 e5                	mov    %esp,%ebp
f011d3a2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011d3a5:	83 ec 04             	sub    $0x4,%esp
f011d3a8:	68 71 dd 13 f0       	push   $0xf013dd71
f011d3ad:	68 a1 04 00 00       	push   $0x4a1
f011d3b2:	68 8a dd 13 f0       	push   $0xf013dd8a
f011d3b7:	e8 f3 3a fe ff       	call   f0100eaf <_panic>

f011d3bc <test_kfree_NF_block>:
}
int test_kfree_NF_block()
{
f011d3bc:	55                   	push   %ebp
f011d3bd:	89 e5                	mov    %esp,%ebp
f011d3bf:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011d3c2:	83 ec 04             	sub    $0x4,%esp
f011d3c5:	68 71 dd 13 f0       	push   $0xf013dd71
f011d3ca:	68 a5 04 00 00       	push   $0x4a5
f011d3cf:	68 8a dd 13 f0       	push   $0xf013dd8a
f011d3d4:	e8 d6 3a fe ff       	call   f0100eaf <_panic>

f011d3d9 <test_kfree_BF_block>:
}
int test_kfree_BF_block()
{
f011d3d9:	55                   	push   %ebp
f011d3da:	89 e5                	mov    %esp,%ebp
f011d3dc:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011d3df:	83 ec 04             	sub    $0x4,%esp
f011d3e2:	68 71 dd 13 f0       	push   $0xf013dd71
f011d3e7:	68 a9 04 00 00       	push   $0x4a9
f011d3ec:	68 8a dd 13 f0       	push   $0xf013dd8a
f011d3f1:	e8 b9 3a fe ff       	call   f0100eaf <_panic>

f011d3f6 <test_kfree_WF_block>:
}
int test_kfree_WF_block()
{
f011d3f6:	55                   	push   %ebp
f011d3f7:	89 e5                	mov    %esp,%ebp
f011d3f9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011d3fc:	83 ec 04             	sub    $0x4,%esp
f011d3ff:	68 71 dd 13 f0       	push   $0xf013dd71
f011d404:	68 ad 04 00 00       	push   $0x4ad
f011d409:	68 8a dd 13 f0       	push   $0xf013dd8a
f011d40e:	e8 9c 3a fe ff       	call   f0100eaf <_panic>

f011d413 <test_kfree_CF_block>:
}
int test_kfree_CF_block()
{
f011d413:	55                   	push   %ebp
f011d414:	89 e5                	mov    %esp,%ebp
f011d416:	81 ec a8 00 00 00    	sub    $0xa8,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011d41c:	83 ec 08             	sub    $0x8,%esp
f011d41f:	68 a4 dd 13 f0       	push   $0xf013dda4
f011d424:	6a 0e                	push   $0xe
f011d426:	e8 52 47 fe ff       	call   f0101b7d <cprintf_colored>
f011d42b:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011d42e:	83 ec 08             	sub    $0x8,%esp
f011d431:	68 d4 dd 13 f0       	push   $0xf013ddd4
f011d436:	6a 0e                	push   $0xe
f011d438:	e8 40 47 fe ff       	call   f0101b7d <cprintf_colored>
f011d43d:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011d440:	83 ec 08             	sub    $0x8,%esp
f011d443:	68 a4 dd 13 f0       	push   $0xf013dda4
f011d448:	6a 0e                	push   $0xe
f011d44a:	e8 2e 47 fe ff       	call   f0101b7d <cprintf_colored>
f011d44f:	83 c4 10             	add    $0x10,%esp

	int origFreeFrames = (int)sys_calculate_free_frames();
f011d452:	e8 2f 32 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d457:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int eval ;
	//1. Alloc some blocks at each possible block size
	cprintf_colored(TEXT_cyan,"\n1. Alloc some blocks at each possible block size\n");
f011d45a:	83 ec 08             	sub    $0x8,%esp
f011d45d:	68 18 e7 13 f0       	push   $0xf013e718
f011d462:	6a 03                	push   $0x3
f011d464:	e8 14 47 fe ff       	call   f0101b7d <cprintf_colored>
f011d469:	83 c4 10             	add    $0x10,%esp
	{
		eval = initial_block_allocations();
f011d46c:	e8 53 e6 ff ff       	call   f011bac4 <initial_block_allocations>
f011d471:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (eval != 100)
f011d474:	83 7d f4 64          	cmpl   $0x64,-0xc(%ebp)
f011d478:	74 1c                	je     f011d496 <test_kfree_CF_block+0x83>
		{
			cprintf_colored(TEXT_TESTERR_CLR,"initial allocations are not correct!\nplease make sure the the kmalloc test is correct before testing the kfree\n");
f011d47a:	83 ec 08             	sub    $0x8,%esp
f011d47d:	68 b8 e3 13 f0       	push   $0xf013e3b8
f011d482:	6a 0c                	push   $0xc
f011d484:	e8 f4 46 fe ff       	call   f0101b7d <cprintf_colored>
f011d489:	83 c4 10             	add    $0x10,%esp
			return 0;
f011d48c:	b8 00 00 00 00       	mov    $0x0,%eax
f011d491:	e9 c8 06 00 00       	jmp    f011db5e <test_kfree_CF_block+0x74b>
		}
	}
	eval = 0;
f011d496:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int is_correct ;
	int curSize, idx, nextSize, nextIdx, nextS, maxNumOfBlksAtCurPage;

	//2. Free some blocks WITHOUT freeing their pages
	cprintf_colored(TEXT_cyan,"\n2. Free some blocks WITHOUT freeing their pages [15%]\n");
f011d49d:	83 ec 08             	sub    $0x8,%esp
f011d4a0:	68 4c e7 13 f0       	push   $0xf013e74c
f011d4a5:	6a 03                	push   $0x3
f011d4a7:	e8 d1 46 fe ff       	call   f0101b7d <cprintf_colored>
f011d4ac:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011d4af:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//At each level that consume ONLY 1 page, free all its blocks (except 1)
		curSize = 1<<LOG2_MIN_SIZE ;
f011d4b6:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
		maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011d4bd:	b8 00 10 00 00       	mov    $0x1000,%eax
f011d4c2:	99                   	cltd   
f011d4c3:	f7 7d ec             	idivl  -0x14(%ebp)
f011d4c6:	89 45 d8             	mov    %eax,-0x28(%ebp)
		idx = 0;
f011d4c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
f011d4d0:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f011d4d7:	e8 aa 31 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d4dc:	89 45 98             	mov    %eax,-0x68(%ebp)
		nextSize = 0;
f011d4df:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		nextIdx = 0;
f011d4e6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d4ed:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
f011d4f4:	eb 79                	jmp    f011d56f <test_kfree_CF_block+0x15c>
		{
			//Skip removing the last block at the current size
			if (s == curSize)
f011d4f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d4f9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d4fc:	75 3e                	jne    f011d53c <test_kfree_CF_block+0x129>
			{
				//Reinitialize
				{
					curSize <<= 1;
f011d4fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d501:	01 c0                	add    %eax,%eax
f011d503:	89 45 ec             	mov    %eax,-0x14(%ebp)
					idx++ ;
f011d506:	ff 45 e8             	incl   -0x18(%ebp)
					maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011d509:	b8 00 10 00 00       	mov    $0x1000,%eax
f011d50e:	99                   	cltd   
f011d50f:	f7 7d ec             	idivl  -0x14(%ebp)
f011d512:	89 45 d8             	mov    %eax,-0x28(%ebp)
				}
				//Stop the loop if the # allocation at current size exceed one page
				if (numOfAllocBlocksPerSize[idx] / maxNumOfBlksAtCurPage > 0)
f011d515:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d518:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011d51f:	99                   	cltd   
f011d520:	f7 7d d8             	idivl  -0x28(%ebp)
f011d523:	85 c0                	test   %eax,%eax
f011d525:	7e 44                	jle    f011d56b <test_kfree_CF_block+0x158>
				{
					nextSize = curSize;
f011d527:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d52a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					nextIdx = idx ;
f011d52d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d530:	89 45 e0             	mov    %eax,-0x20(%ebp)
					nextS = s + 1;
f011d533:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d536:	40                   	inc    %eax
f011d537:	89 45 dc             	mov    %eax,-0x24(%ebp)
					break;
f011d53a:	eb 40                	jmp    f011d57c <test_kfree_CF_block+0x169>
				}
			}

			//Free the current block
			{
				free_block(startBlockVAs[s]);
f011d53c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d53f:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011d546:	83 ec 0c             	sub    $0xc,%esp
f011d549:	50                   	push   %eax
f011d54a:	e8 92 6c 00 00       	call   f01241e1 <free_block>
f011d54f:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011d552:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d555:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011d55c:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d55f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d562:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
f011d569:	eb 01                	jmp    f011d56c <test_kfree_CF_block+0x159>
					nextS = s + 1;
					break;
				}
				else
				{
					continue;
f011d56b:	90                   	nop
		maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
		idx = 0;
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
		nextSize = 0;
		nextIdx = 0;
		for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d56c:	ff 45 d4             	incl   -0x2c(%ebp)
f011d56f:	81 7d d4 00 08 00 00 	cmpl   $0x800,-0x2c(%ebp)
f011d576:	0f 8e 7a ff ff ff    	jle    f011d4f6 <test_kfree_CF_block+0xe3>
				numOfAllocBlocksPerSize[idx]--;
			}
		}
		//Check # free frames (should not be changed)
		{
			freeFramesAfter = sys_calculate_free_frames();
f011d57c:	e8 05 31 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d581:	89 45 9c             	mov    %eax,-0x64(%ebp)
			if (freeFramesAfter != freeFramesBefore)
f011d584:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011d587:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011d58a:	74 1f                	je     f011d5ab <test_kfree_CF_block+0x198>
			{
				is_correct = 0;
f011d58c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #2: WRONG! number of allocated frames is not as expected. Actual: %d, Expected: %d\n",freeFramesBefore - freeFramesAfter , 0);
f011d593:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d596:	2b 45 9c             	sub    -0x64(%ebp),%eax
f011d599:	6a 00                	push   $0x0
f011d59b:	50                   	push   %eax
f011d59c:	68 84 e7 13 f0       	push   $0xf013e784
f011d5a1:	6a 0c                	push   $0xc
f011d5a3:	e8 d5 45 fe ff       	call   f0101b7d <cprintf_colored>
f011d5a8:	83 c4 10             	add    $0x10,%esp
			}
		}
	}
	if (is_correct) eval += 15;
f011d5ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d5af:	74 04                	je     f011d5b5 <test_kfree_CF_block+0x1a2>
f011d5b1:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	//3. Allocate same blocks after free with diff. content (pages should NOT be allocated)
	cprintf_colored(TEXT_cyan,"\n3. Allocate same blocks after free with diff. content (pages should NOT be allocated) [15%]\n");
f011d5b5:	83 ec 08             	sub    $0x8,%esp
f011d5b8:	68 ec e7 13 f0       	push   $0xf013e7ec
f011d5bd:	6a 03                	push   $0x3
f011d5bf:	e8 b9 45 fe ff       	call   f0101b7d <cprintf_colored>
f011d5c4:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011d5c7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		curSize = 1<<LOG2_MIN_SIZE ;
f011d5ce:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
		idx = 0;
f011d5d5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		void *va;
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
f011d5dc:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
f011d5e3:	e8 9e 30 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d5e8:	89 45 90             	mov    %eax,-0x70(%ebp)
		for (int s = 1; s < nextS; ++s)
f011d5eb:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
f011d5f2:	e9 84 00 00 00       	jmp    f011d67b <test_kfree_CF_block+0x268>
		{
			//Skip the last block at the current size
			if (s == curSize)
f011d5f7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d5fa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d5fd:	75 0d                	jne    f011d60c <test_kfree_CF_block+0x1f9>
			{
				//Reinitialize
				{
					curSize <<= 1;
f011d5ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d602:	01 c0                	add    %eax,%eax
f011d604:	89 45 ec             	mov    %eax,-0x14(%ebp)
					idx++ ;
f011d607:	ff 45 e8             	incl   -0x18(%ebp)
				}
				continue;
f011d60a:	eb 6c                	jmp    f011d678 <test_kfree_CF_block+0x265>
			}
			//allocate a new block with the curSize
			{
				va = alloc_block(s);
f011d60c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d60f:	83 ec 0c             	sub    $0xc,%esp
f011d612:	50                   	push   %eax
f011d613:	e8 6f 66 00 00       	call   f0123c87 <alloc_block>
f011d618:	83 c4 10             	add    $0x10,%esp
f011d61b:	89 45 8c             	mov    %eax,-0x74(%ebp)
				startBlockVAs[s] = va;
f011d61e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d621:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011d624:	89 14 85 80 ca 94 f0 	mov    %edx,-0xf6b3580(,%eax,4)
				numOfAllocBlocksPerSize[idx]++ ;
f011d62b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d62e:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011d635:	8d 50 01             	lea    0x1(%eax),%edx
f011d638:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d63b:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			}
			//fill the entire block with different content
			for (int i = 0; i < curSize/2; ++i)
f011d642:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f011d649:	eb 1c                	jmp    f011d667 <test_kfree_CF_block+0x254>
			{
				startBlockVAs[s][i] = s * 2;
f011d64b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d64e:	8b 14 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%edx
f011d655:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d658:	01 c0                	add    %eax,%eax
f011d65a:	01 c2                	add    %eax,%edx
f011d65c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d65f:	d1 e0                	shl    %eax
f011d661:	66 89 02             	mov    %ax,(%edx)
				va = alloc_block(s);
				startBlockVAs[s] = va;
				numOfAllocBlocksPerSize[idx]++ ;
			}
			//fill the entire block with different content
			for (int i = 0; i < curSize/2; ++i)
f011d664:	ff 45 cc             	incl   -0x34(%ebp)
f011d667:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d66a:	89 c2                	mov    %eax,%edx
f011d66c:	c1 ea 1f             	shr    $0x1f,%edx
f011d66f:	01 d0                	add    %edx,%eax
f011d671:	d1 f8                	sar    %eax
f011d673:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d676:	7f d3                	jg     f011d64b <test_kfree_CF_block+0x238>
	{
		curSize = 1<<LOG2_MIN_SIZE ;
		idx = 0;
		void *va;
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
		for (int s = 1; s < nextS; ++s)
f011d678:	ff 45 d0             	incl   -0x30(%ebp)
f011d67b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d67e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d681:	0f 8c 70 ff ff ff    	jl     f011d5f7 <test_kfree_CF_block+0x1e4>
				startBlockVAs[s][i] = s * 2;
			}
		}
		//Check # free frames (should not be changed)
		{
			freeFramesAfter = sys_calculate_free_frames();
f011d687:	e8 fa 2f ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d68c:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (freeFramesAfter != freeFramesBefore)
f011d68f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d692:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d695:	74 1f                	je     f011d6b6 <test_kfree_CF_block+0x2a3>
			{
				is_correct = 0;
f011d697:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #3: WRONG! number of allocated frames is not as expected. Actual: %d, Expected: %d\n",freeFramesBefore - freeFramesAfter , 0);
f011d69e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d6a1:	2b 45 94             	sub    -0x6c(%ebp),%eax
f011d6a4:	6a 00                	push   $0x0
f011d6a6:	50                   	push   %eax
f011d6a7:	68 4c e8 13 f0       	push   $0xf013e84c
f011d6ac:	6a 0c                	push   $0xc
f011d6ae:	e8 ca 44 fe ff       	call   f0101b7d <cprintf_colored>
f011d6b3:	83 c4 10             	add    $0x10,%esp
			}
		}
	}
	if (is_correct) eval += 15;
f011d6b6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d6ba:	74 04                	je     f011d6c0 <test_kfree_CF_block+0x2ad>
f011d6bc:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	//4. Free some blocks WITH freeing their pages
	cprintf_colored(TEXT_cyan,"\n4. Free some blocks WITH freeing their pages [15%]\n");
f011d6c0:	83 ec 08             	sub    $0x8,%esp
f011d6c3:	68 b4 e8 13 f0       	push   $0xf013e8b4
f011d6c8:	6a 03                	push   $0x3
f011d6ca:	e8 ae 44 fe ff       	call   f0101b7d <cprintf_colored>
f011d6cf:	83 c4 10             	add    $0x10,%esp
	int expectedNumOfRemovedPages = 0;
f011d6d2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	is_correct = 1;
f011d6d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		curSize = nextSize ;
f011d6e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d6e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011d6e6:	b8 00 10 00 00       	mov    $0x1000,%eax
f011d6eb:	99                   	cltd   
f011d6ec:	f7 7d ec             	idivl  -0x14(%ebp)
f011d6ef:	89 45 d8             	mov    %eax,-0x28(%ebp)
		idx = nextIdx;
f011d6f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d6f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
f011d6f8:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
f011d6ff:	e8 82 2f ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d704:	89 45 84             	mov    %eax,-0x7c(%ebp)
		for (int s = nextS; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d707:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d70a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011d70d:	eb 6b                	jmp    f011d77a <test_kfree_CF_block+0x367>
		{
			//Free the current block
			{
				free_block(startBlockVAs[s]);
f011d70f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d712:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011d719:	83 ec 0c             	sub    $0xc,%esp
f011d71c:	50                   	push   %eax
f011d71d:	e8 bf 6a 00 00       	call   f01241e1 <free_block>
f011d722:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011d725:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d728:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011d72f:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d732:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d735:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			}
			//Update for next size
			if (s == curSize)
f011d73c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d73f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d742:	75 1c                	jne    f011d760 <test_kfree_CF_block+0x34d>
			{
				//Reinitialize
				curSize <<= 1;
f011d744:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d747:	01 c0                	add    %eax,%eax
f011d749:	89 45 ec             	mov    %eax,-0x14(%ebp)
				idx++ ;
f011d74c:	ff 45 e8             	incl   -0x18(%ebp)
				maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011d74f:	b8 00 10 00 00       	mov    $0x1000,%eax
f011d754:	99                   	cltd   
f011d755:	f7 7d ec             	idivl  -0x14(%ebp)
f011d758:	89 45 d8             	mov    %eax,-0x28(%ebp)
				expectedNumOfRemovedPages++;
f011d75b:	ff 45 c8             	incl   -0x38(%ebp)
f011d75e:	eb 17                	jmp    f011d777 <test_kfree_CF_block+0x364>
			}
			else if (numOfAllocBlocksPerSize[idx] % maxNumOfBlksAtCurPage == 0)
f011d760:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d763:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011d76a:	99                   	cltd   
f011d76b:	f7 7d d8             	idivl  -0x28(%ebp)
f011d76e:	89 d0                	mov    %edx,%eax
f011d770:	85 c0                	test   %eax,%eax
f011d772:	75 03                	jne    f011d777 <test_kfree_CF_block+0x364>
			{
				expectedNumOfRemovedPages++;
f011d774:	ff 45 c8             	incl   -0x38(%ebp)
	{
		curSize = nextSize ;
		maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
		idx = nextIdx;
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
		for (int s = nextS; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d777:	ff 45 c4             	incl   -0x3c(%ebp)
f011d77a:	81 7d c4 00 08 00 00 	cmpl   $0x800,-0x3c(%ebp)
f011d781:	7e 8c                	jle    f011d70f <test_kfree_CF_block+0x2fc>
				expectedNumOfRemovedPages++;
			}
		}
		//Check # free frames (should be changed)
		{
			freeFramesAfter = sys_calculate_free_frames();
f011d783:	e8 fe 2e ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d788:	89 45 88             	mov    %eax,-0x78(%ebp)
			if (freeFramesAfter - freeFramesBefore != expectedNumOfRemovedPages)
f011d78b:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d78e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011d791:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011d794:	74 20                	je     f011d7b6 <test_kfree_CF_block+0x3a3>
			{
				is_correct = 0;
f011d796:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #4: WRONG! number of free frames is not as expected. Actual: %d, Expected: %d\n",freeFramesAfter - freeFramesBefore, expectedNumOfRemovedPages);
f011d79d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d7a0:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011d7a3:	ff 75 c8             	pushl  -0x38(%ebp)
f011d7a6:	50                   	push   %eax
f011d7a7:	68 ec e8 13 f0       	push   $0xf013e8ec
f011d7ac:	6a 0c                	push   $0xc
f011d7ae:	e8 ca 43 fe ff       	call   f0101b7d <cprintf_colored>
f011d7b3:	83 c4 10             	add    $0x10,%esp
			}
		}
	}
	if (is_correct) eval += 15;
f011d7b6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d7ba:	74 04                	je     f011d7c0 <test_kfree_CF_block+0x3ad>
f011d7bc:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	//5. Allocate same blocks after free with diff. content (pages should be allocated)
	cprintf_colored(TEXT_cyan,"\n5. Allocate same blocks after free with diff. content (pages should be allocated) [15%]\n");
f011d7c0:	83 ec 08             	sub    $0x8,%esp
f011d7c3:	68 4c e9 13 f0       	push   $0xf013e94c
f011d7c8:	6a 03                	push   $0x3
f011d7ca:	e8 ae 43 fe ff       	call   f0101b7d <cprintf_colored>
f011d7cf:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011d7d2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		curSize = nextSize ;
f011d7d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d7dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
f011d7df:	b8 00 10 00 00       	mov    $0x1000,%eax
f011d7e4:	99                   	cltd   
f011d7e5:	f7 7d ec             	idivl  -0x14(%ebp)
f011d7e8:	89 45 d8             	mov    %eax,-0x28(%ebp)
		idx = nextIdx;
f011d7eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d7ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
f011d7f1:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
f011d7f8:	e8 89 2e ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d7fd:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		void* va;
		for (int s = nextS; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d803:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d806:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011d809:	e9 88 00 00 00       	jmp    f011d896 <test_kfree_CF_block+0x483>
		{
			//allocate a new block with the curSize
			{
				va = alloc_block(s);
f011d80e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d811:	83 ec 0c             	sub    $0xc,%esp
f011d814:	50                   	push   %eax
f011d815:	e8 6d 64 00 00       	call   f0123c87 <alloc_block>
f011d81a:	83 c4 10             	add    $0x10,%esp
f011d81d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				startBlockVAs[s] = va;
f011d823:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d826:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011d82c:	89 14 85 80 ca 94 f0 	mov    %edx,-0xf6b3580(,%eax,4)
				numOfAllocBlocksPerSize[idx]++ ;
f011d833:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d836:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011d83d:	8d 50 01             	lea    0x1(%eax),%edx
f011d840:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d843:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			}
			//fill the entire block with different content
			for (int i = 0; i < curSize/2; ++i)
f011d84a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011d851:	eb 1c                	jmp    f011d86f <test_kfree_CF_block+0x45c>
			{
				startBlockVAs[s][i] = s * 2;
f011d853:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d856:	8b 14 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%edx
f011d85d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011d860:	01 c0                	add    %eax,%eax
f011d862:	01 c2                	add    %eax,%edx
f011d864:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d867:	d1 e0                	shl    %eax
f011d869:	66 89 02             	mov    %ax,(%edx)
				va = alloc_block(s);
				startBlockVAs[s] = va;
				numOfAllocBlocksPerSize[idx]++ ;
			}
			//fill the entire block with different content
			for (int i = 0; i < curSize/2; ++i)
f011d86c:	ff 45 bc             	incl   -0x44(%ebp)
f011d86f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d872:	89 c2                	mov    %eax,%edx
f011d874:	c1 ea 1f             	shr    $0x1f,%edx
f011d877:	01 d0                	add    %edx,%eax
f011d879:	d1 f8                	sar    %eax
f011d87b:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011d87e:	7f d3                	jg     f011d853 <test_kfree_CF_block+0x440>
			{
				startBlockVAs[s][i] = s * 2;
			}
			if (s == curSize)
f011d880:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d883:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d886:	75 0b                	jne    f011d893 <test_kfree_CF_block+0x480>
			{
				//Reinitialize
				curSize <<= 1;
f011d888:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d88b:	01 c0                	add    %eax,%eax
f011d88d:	89 45 ec             	mov    %eax,-0x14(%ebp)
				idx++ ;
f011d890:	ff 45 e8             	incl   -0x18(%ebp)
		curSize = nextSize ;
		maxNumOfBlksAtCurPage = PAGE_SIZE / curSize;
		idx = nextIdx;
		int freeFramesAfter = 0, freeFramesBefore = sys_calculate_free_frames();
		void* va;
		for (int s = nextS; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d893:	ff 45 c0             	incl   -0x40(%ebp)
f011d896:	81 7d c0 00 08 00 00 	cmpl   $0x800,-0x40(%ebp)
f011d89d:	0f 8e 6b ff ff ff    	jle    f011d80e <test_kfree_CF_block+0x3fb>
			}

		}
		//Check # free frames (should be changed)
		{
			freeFramesAfter = sys_calculate_free_frames();
f011d8a3:	e8 de 2d ff ff       	call   f0110686 <sys_calculate_free_frames>
f011d8a8:	89 45 80             	mov    %eax,-0x80(%ebp)
			if (freeFramesBefore - freeFramesAfter != expectedNumOfRemovedPages)
f011d8ab:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d8b1:	2b 45 80             	sub    -0x80(%ebp),%eax
f011d8b4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011d8b7:	74 23                	je     f011d8dc <test_kfree_CF_block+0x4c9>
			{
				is_correct = 0;
f011d8b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #5: WRONG! number of allocated frames is not as expected. Actual: %d, Expected: %d\n", freeFramesBefore - freeFramesAfter, expectedNumOfRemovedPages);
f011d8c0:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d8c6:	2b 45 80             	sub    -0x80(%ebp),%eax
f011d8c9:	ff 75 c8             	pushl  -0x38(%ebp)
f011d8cc:	50                   	push   %eax
f011d8cd:	68 a8 e9 13 f0       	push   $0xf013e9a8
f011d8d2:	6a 0c                	push   $0xc
f011d8d4:	e8 a4 42 fe ff       	call   f0101b7d <cprintf_colored>
f011d8d9:	83 c4 10             	add    $0x10,%esp
			}
		}
	}
	if (is_correct) eval += 15;
f011d8dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d8e0:	74 04                	je     f011d8e6 <test_kfree_CF_block+0x4d3>
f011d8e2:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	//6. Check content of all blocks
	cprintf_colored(TEXT_cyan,"\n6. Check content of all blocks [20%]\n");
f011d8e6:	83 ec 08             	sub    $0x8,%esp
f011d8e9:	68 10 ea 13 f0       	push   $0xf013ea10
f011d8ee:	6a 03                	push   $0x3
f011d8f0:	e8 88 42 fe ff       	call   f0101b7d <cprintf_colored>
f011d8f5:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011d8f8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		curSize = 1<<LOG2_MIN_SIZE ;
f011d8ff:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
		idx = 0;
f011d906:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		void *va;
		int mult ;
		for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d90d:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
f011d914:	e9 d6 00 00 00       	jmp    f011d9ef <test_kfree_CF_block+0x5dc>
		{
			//Only last block at the current size has its original values
			mult = s >= nextS? 2 : s == curSize ? 1 : 2;
f011d919:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d91c:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d91f:	7d 16                	jge    f011d937 <test_kfree_CF_block+0x524>
f011d921:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d924:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d927:	75 07                	jne    f011d930 <test_kfree_CF_block+0x51d>
f011d929:	b8 01 00 00 00       	mov    $0x1,%eax
f011d92e:	eb 0c                	jmp    f011d93c <test_kfree_CF_block+0x529>
f011d930:	b8 02 00 00 00       	mov    $0x2,%eax
f011d935:	eb 05                	jmp    f011d93c <test_kfree_CF_block+0x529>
f011d937:	b8 02 00 00 00       	mov    $0x2,%eax
f011d93c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)

			//check the content of the current block
			int sum = 0;
f011d942:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
			for (int i = 0; i < curSize/2; ++i)
f011d949:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f011d950:	eb 1b                	jmp    f011d96d <test_kfree_CF_block+0x55a>
			{
				sum += startBlockVAs[s][i] ;
f011d952:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d955:	8b 14 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%edx
f011d95c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011d95f:	01 c0                	add    %eax,%eax
f011d961:	01 d0                	add    %edx,%eax
f011d963:	66 8b 00             	mov    (%eax),%ax
f011d966:	98                   	cwtl   
f011d967:	01 45 b4             	add    %eax,-0x4c(%ebp)
			//Only last block at the current size has its original values
			mult = s >= nextS? 2 : s == curSize ? 1 : 2;

			//check the content of the current block
			int sum = 0;
			for (int i = 0; i < curSize/2; ++i)
f011d96a:	ff 45 b0             	incl   -0x50(%ebp)
f011d96d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d970:	89 c2                	mov    %eax,%edx
f011d972:	c1 ea 1f             	shr    $0x1f,%edx
f011d975:	01 d0                	add    %edx,%eax
f011d977:	d1 f8                	sar    %eax
f011d979:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d97c:	7f d4                	jg     f011d952 <test_kfree_CF_block+0x53f>
			{
				sum += startBlockVAs[s][i] ;
			}
			if (is_correct && sum != mult * s * curSize/2)
f011d97e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d982:	74 55                	je     f011d9d9 <test_kfree_CF_block+0x5c6>
f011d984:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011d98a:	0f af 45 b8          	imul   -0x48(%ebp),%eax
f011d98e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
f011d992:	89 c2                	mov    %eax,%edx
f011d994:	c1 ea 1f             	shr    $0x1f,%edx
f011d997:	01 d0                	add    %edx,%eax
f011d999:	d1 f8                	sar    %eax
f011d99b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d99e:	74 39                	je     f011d9d9 <test_kfree_CF_block+0x5c6>
			{
				is_correct = 0;
f011d9a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR,"Free Block Alloc #6: wrong content at block size %d. Expected = %d, Actual = %d\n", s, mult * s * curSize/2, sum);
f011d9a7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011d9ad:	0f af 45 b8          	imul   -0x48(%ebp),%eax
f011d9b1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
f011d9b5:	89 c2                	mov    %eax,%edx
f011d9b7:	c1 ea 1f             	shr    $0x1f,%edx
f011d9ba:	01 d0                	add    %edx,%eax
f011d9bc:	d1 f8                	sar    %eax
f011d9be:	83 ec 0c             	sub    $0xc,%esp
f011d9c1:	ff 75 b4             	pushl  -0x4c(%ebp)
f011d9c4:	50                   	push   %eax
f011d9c5:	ff 75 b8             	pushl  -0x48(%ebp)
f011d9c8:	68 38 ea 13 f0       	push   $0xf013ea38
f011d9cd:	6a 0c                	push   $0xc
f011d9cf:	e8 a9 41 fe ff       	call   f0101b7d <cprintf_colored>
f011d9d4:	83 c4 20             	add    $0x20,%esp
				break;
f011d9d7:	eb 23                	jmp    f011d9fc <test_kfree_CF_block+0x5e9>
			}

			if (s == curSize)
f011d9d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d9dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d9df:	75 0b                	jne    f011d9ec <test_kfree_CF_block+0x5d9>
			{
				curSize <<= 1;
f011d9e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d9e4:	01 c0                	add    %eax,%eax
f011d9e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
				idx++ ;
f011d9e9:	ff 45 e8             	incl   -0x18(%ebp)
	{
		curSize = 1<<LOG2_MIN_SIZE ;
		idx = 0;
		void *va;
		int mult ;
		for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011d9ec:	ff 45 b8             	incl   -0x48(%ebp)
f011d9ef:	81 7d b8 00 08 00 00 	cmpl   $0x800,-0x48(%ebp)
f011d9f6:	0f 8e 1d ff ff ff    	jle    f011d919 <test_kfree_CF_block+0x506>
				curSize <<= 1;
				idx++ ;
			}
		}
	}
	if (is_correct) eval += 20;
f011d9fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011da00:	74 04                	je     f011da06 <test_kfree_CF_block+0x5f3>
f011da02:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	//7. Free all blocks
	cprintf_colored(TEXT_cyan,"\n7. Free all blocks [20%]\n");
f011da06:	83 ec 08             	sub    $0x8,%esp
f011da09:	68 89 ea 13 f0       	push   $0xf013ea89
f011da0e:	6a 03                	push   $0x3
f011da10:	e8 68 41 fe ff       	call   f0101b7d <cprintf_colored>
f011da15:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011da18:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		int freeFramesAfter = 0 ;
f011da1f:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
f011da26:	00 00 00 
		int expectedNumOfRemovedPages = numOfAllocPages;
f011da29:	a1 a4 ca 94 f1       	mov    0xf194caa4,%eax
f011da2e:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
		for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011da34:	c7 45 ac 01 00 00 00 	movl   $0x1,-0x54(%ebp)
f011da3b:	eb 30                	jmp    f011da6d <test_kfree_CF_block+0x65a>
		{
			//Free the current block
			{
				free_block(startBlockVAs[s]);
f011da3d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011da40:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011da47:	83 ec 0c             	sub    $0xc,%esp
f011da4a:	50                   	push   %eax
f011da4b:	e8 91 67 00 00       	call   f01241e1 <free_block>
f011da50:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011da53:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011da56:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011da5d:	8d 50 ff             	lea    -0x1(%eax),%edx
f011da60:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011da63:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
	cprintf_colored(TEXT_cyan,"\n7. Free all blocks [20%]\n");
	is_correct = 1;
	{
		int freeFramesAfter = 0 ;
		int expectedNumOfRemovedPages = numOfAllocPages;
		for (int s = 1; s <= DYN_ALLOC_MAX_BLOCK_SIZE; ++s)
f011da6a:	ff 45 ac             	incl   -0x54(%ebp)
f011da6d:	81 7d ac 00 08 00 00 	cmpl   $0x800,-0x54(%ebp)
f011da74:	7e c7                	jle    f011da3d <test_kfree_CF_block+0x62a>
				numOfAllocBlocksPerSize[idx]--;
			}
		}
		//Check # free frames (should be restored to the original value before allocations)
		{
			freeFramesAfter = sys_calculate_free_frames();
f011da76:	e8 0b 2c ff ff       	call   f0110686 <sys_calculate_free_frames>
f011da7b:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (origFreeFrames - freeFramesAfter != 0)
f011da81:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011da84:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011da8a:	74 22                	je     f011daae <test_kfree_CF_block+0x69b>
			{
				is_correct = 0;
f011da8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #7: WRONG! number of free frames is not restored correctly. Actual: %d, Expected: %d\n",origFreeFrames - freeFramesAfter, 0);
f011da93:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011da96:	2b 85 70 ff ff ff    	sub    -0x90(%ebp),%eax
f011da9c:	6a 00                	push   $0x0
f011da9e:	50                   	push   %eax
f011da9f:	68 a4 ea 13 f0       	push   $0xf013eaa4
f011daa4:	6a 0c                	push   $0xc
f011daa6:	e8 d2 40 fe ff       	call   f0101b7d <cprintf_colored>
f011daab:	83 c4 10             	add    $0x10,%esp
			}
		}
		//Check free block lists
		{
			int expectedNumOfFreeBlocks8 = PAGE_SIZE / 8 - 1; //since initial alloc of 8B at boot-time
f011daae:	c7 85 68 ff ff ff ff 	movl   $0x1ff,-0x98(%ebp)
f011dab5:	01 00 00 
			int expectedNumOfFreeBlocks16 = PAGE_SIZE / 16 - 1; //since initial alloc of 16B at boot-time
f011dab8:	c7 85 64 ff ff ff ff 	movl   $0xff,-0x9c(%ebp)
f011dabf:	00 00 00 
			int expectedNumOfFreeBlocks ;
			for (int i = 0; i < numOfLevels; ++i)
f011dac2:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
f011dac9:	eb 69                	jmp    f011db34 <test_kfree_CF_block+0x721>
			{
				expectedNumOfFreeBlocks = 0;
f011dacb:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
				if (i == 0) expectedNumOfFreeBlocks = expectedNumOfFreeBlocks8;
f011dad2:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f011dad6:	75 09                	jne    f011dae1 <test_kfree_CF_block+0x6ce>
f011dad8:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011dade:	89 45 a8             	mov    %eax,-0x58(%ebp)
				if (i == 1) expectedNumOfFreeBlocks = expectedNumOfFreeBlocks16;
f011dae1:	83 7d a4 01          	cmpl   $0x1,-0x5c(%ebp)
f011dae5:	75 09                	jne    f011daf0 <test_kfree_CF_block+0x6dd>
f011dae7:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011daed:	89 45 a8             	mov    %eax,-0x58(%ebp)

				if (LIST_SIZE(&freeBlockLists[i]) != expectedNumOfFreeBlocks)
f011daf0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011daf3:	c1 e0 04             	shl    $0x4,%eax
f011daf6:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f011dafb:	8b 10                	mov    (%eax),%edx
f011dafd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011db00:	39 c2                	cmp    %eax,%edx
f011db02:	74 2d                	je     f011db31 <test_kfree_CF_block+0x71e>
				{
					is_correct = 0;
f011db04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #7: WRONG! number of free blocks at level %d is not correct. Actual: %d, Expected: %d\n", i, LIST_SIZE(&freeBlockLists[i]), expectedNumOfFreeBlocks);
f011db0b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011db0e:	c1 e0 04             	shl    $0x4,%eax
f011db11:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f011db16:	8b 00                	mov    (%eax),%eax
f011db18:	83 ec 0c             	sub    $0xc,%esp
f011db1b:	ff 75 a8             	pushl  -0x58(%ebp)
f011db1e:	50                   	push   %eax
f011db1f:	ff 75 a4             	pushl  -0x5c(%ebp)
f011db22:	68 0c eb 13 f0       	push   $0xf013eb0c
f011db27:	6a 0c                	push   $0xc
f011db29:	e8 4f 40 fe ff       	call   f0101b7d <cprintf_colored>
f011db2e:	83 c4 20             	add    $0x20,%esp
		//Check free block lists
		{
			int expectedNumOfFreeBlocks8 = PAGE_SIZE / 8 - 1; //since initial alloc of 8B at boot-time
			int expectedNumOfFreeBlocks16 = PAGE_SIZE / 16 - 1; //since initial alloc of 16B at boot-time
			int expectedNumOfFreeBlocks ;
			for (int i = 0; i < numOfLevels; ++i)
f011db31:	ff 45 a4             	incl   -0x5c(%ebp)
f011db34:	83 7d a4 08          	cmpl   $0x8,-0x5c(%ebp)
f011db38:	7e 91                	jle    f011dacb <test_kfree_CF_block+0x6b8>
					cprintf_colored(TEXT_TESTERR_CLR, "Free Block Alloc #7: WRONG! number of free blocks at level %d is not correct. Actual: %d, Expected: %d\n", i, LIST_SIZE(&freeBlockLists[i]), expectedNumOfFreeBlocks);
				}
			}
		}
	}
	if (is_correct) eval += 20;
f011db3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011db3e:	74 04                	je     f011db44 <test_kfree_CF_block+0x731>
f011db40:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf_colored(TEXT_light_green,"\nTest kfree Block Alloc Completed. Evaluation = %d%\n", eval);
f011db44:	83 ec 04             	sub    $0x4,%esp
f011db47:	ff 75 f4             	pushl  -0xc(%ebp)
f011db4a:	68 74 eb 13 f0       	push   $0xf013eb74
f011db4f:	6a 0a                	push   $0xa
f011db51:	e8 27 40 fe ff       	call   f0101b7d <cprintf_colored>
f011db56:	83 c4 10             	add    $0x10,%esp
	return 0;
f011db59:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011db5e:	c9                   	leave  
f011db5f:	c3                   	ret    

f011db60 <test_kfree_FF_both>:

int test_kfree_FF_both()
{
f011db60:	55                   	push   %ebp
f011db61:	89 e5                	mov    %esp,%ebp
f011db63:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011db66:	83 ec 04             	sub    $0x4,%esp
f011db69:	68 71 dd 13 f0       	push   $0xf013dd71
f011db6e:	68 d0 05 00 00       	push   $0x5d0
f011db73:	68 8a dd 13 f0       	push   $0xf013dd8a
f011db78:	e8 32 33 fe ff       	call   f0100eaf <_panic>

f011db7d <test_kfree_NF_both>:
}
int test_kfree_NF_both()
{
f011db7d:	55                   	push   %ebp
f011db7e:	89 e5                	mov    %esp,%ebp
f011db80:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011db83:	83 ec 04             	sub    $0x4,%esp
f011db86:	68 71 dd 13 f0       	push   $0xf013dd71
f011db8b:	68 d4 05 00 00       	push   $0x5d4
f011db90:	68 8a dd 13 f0       	push   $0xf013dd8a
f011db95:	e8 15 33 fe ff       	call   f0100eaf <_panic>

f011db9a <test_kfree_BF_both>:
}
int test_kfree_BF_both()
{
f011db9a:	55                   	push   %ebp
f011db9b:	89 e5                	mov    %esp,%ebp
f011db9d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011dba0:	83 ec 04             	sub    $0x4,%esp
f011dba3:	68 71 dd 13 f0       	push   $0xf013dd71
f011dba8:	68 d8 05 00 00       	push   $0x5d8
f011dbad:	68 8a dd 13 f0       	push   $0xf013dd8a
f011dbb2:	e8 f8 32 fe ff       	call   f0100eaf <_panic>

f011dbb7 <test_kfree_WF_both>:
}
int test_kfree_WF_both()
{
f011dbb7:	55                   	push   %ebp
f011dbb8:	89 e5                	mov    %esp,%ebp
f011dbba:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011dbbd:	83 ec 04             	sub    $0x4,%esp
f011dbc0:	68 71 dd 13 f0       	push   $0xf013dd71
f011dbc5:	68 dc 05 00 00       	push   $0x5dc
f011dbca:	68 8a dd 13 f0       	push   $0xf013dd8a
f011dbcf:	e8 db 32 fe ff       	call   f0100eaf <_panic>

f011dbd4 <test_kfree_CF_both>:
}
int test_kfree_CF_both()
{
f011dbd4:	55                   	push   %ebp
f011dbd5:	89 e5                	mov    %esp,%ebp
f011dbd7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011dbda:	83 ec 04             	sub    $0x4,%esp
f011dbdd:	68 71 dd 13 f0       	push   $0xf013dd71
f011dbe2:	68 e0 05 00 00       	push   $0x5e0
f011dbe7:	68 8a dd 13 f0       	push   $0xf013dd8a
f011dbec:	e8 be 32 fe ff       	call   f0100eaf <_panic>

f011dbf1 <isVAInsideFreedAreas>:

/**********************************************************************************************/
/****************************** ADDRESS CONVERSION TEST AREA **********************************/
/**********************************************************************************************/
inline bool isVAInsideFreedAreas(uint32 va, uint32 *startOfFreedAreas, uint32 *endOfFreedAreas, int numOfFreedAreas)
{
f011dbf1:	55                   	push   %ebp
f011dbf2:	89 e5                	mov    %esp,%ebp
f011dbf4:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < numOfFreedAreas; ++i)
f011dbf7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011dbfe:	eb 36                	jmp    f011dc36 <isVAInsideFreedAreas+0x45>
	{
		if (va >= startOfFreedAreas[i] && va <= endOfFreedAreas[i])
f011dc00:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011dc03:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dc0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011dc0d:	01 d0                	add    %edx,%eax
f011dc0f:	8b 00                	mov    (%eax),%eax
f011dc11:	3b 45 08             	cmp    0x8(%ebp),%eax
f011dc14:	77 1d                	ja     f011dc33 <isVAInsideFreedAreas+0x42>
f011dc16:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011dc19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dc20:	8b 45 10             	mov    0x10(%ebp),%eax
f011dc23:	01 d0                	add    %edx,%eax
f011dc25:	8b 00                	mov    (%eax),%eax
f011dc27:	3b 45 08             	cmp    0x8(%ebp),%eax
f011dc2a:	72 07                	jb     f011dc33 <isVAInsideFreedAreas+0x42>
			return 1;
f011dc2c:	b8 01 00 00 00       	mov    $0x1,%eax
f011dc31:	eb 10                	jmp    f011dc43 <isVAInsideFreedAreas+0x52>
/**********************************************************************************************/
/****************************** ADDRESS CONVERSION TEST AREA **********************************/
/**********************************************************************************************/
inline bool isVAInsideFreedAreas(uint32 va, uint32 *startOfFreedAreas, uint32 *endOfFreedAreas, int numOfFreedAreas)
{
	for (int i = 0; i < numOfFreedAreas; ++i)
f011dc33:	ff 45 fc             	incl   -0x4(%ebp)
f011dc36:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011dc39:	3b 45 14             	cmp    0x14(%ebp),%eax
f011dc3c:	7c c2                	jl     f011dc00 <isVAInsideFreedAreas+0xf>
	{
		if (va >= startOfFreedAreas[i] && va <= endOfFreedAreas[i])
			return 1;
	}
	return 0;
f011dc3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011dc43:	c9                   	leave  
f011dc44:	c3                   	ret    

f011dc45 <test_kheap_phys_addr>:
uint32 allPAs[(128*Mega)/PAGE_SIZE] ;

int test_kheap_phys_addr()
{
f011dc45:	55                   	push   %ebp
f011dc46:	89 e5                	mov    %esp,%ebp
f011dc48:	57                   	push   %edi
f011dc49:	53                   	push   %ebx
f011dc4a:	81 ec 30 01 00 00    	sub    $0x130,%esp
	 * WE COMPARE THE DIFF IN FREE FRAMES BY "AT LEAST" RULE
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011dc50:	83 ec 08             	sub    $0x8,%esp
f011dc53:	68 a4 dd 13 f0       	push   $0xf013dda4
f011dc58:	6a 0e                	push   $0xe
f011dc5a:	e8 1e 3f fe ff       	call   f0101b7d <cprintf_colored>
f011dc5f:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011dc62:	83 ec 08             	sub    $0x8,%esp
f011dc65:	68 d4 dd 13 f0       	push   $0xf013ddd4
f011dc6a:	6a 0e                	push   $0xe
f011dc6c:	e8 0c 3f fe ff       	call   f0101b7d <cprintf_colored>
f011dc71:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011dc74:	83 ec 08             	sub    $0x8,%esp
f011dc77:	68 a4 dd 13 f0       	push   $0xf013dda4
f011dc7c:	6a 0e                	push   $0xe
f011dc7e:	e8 fa 3e fe ff       	call   f0101b7d <cprintf_colored>
f011dc83:	83 c4 10             	add    $0x10,%esp

	//1. Alloc some spaces in both allocators
	int correct = 1;
f011dc86:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int eval;
	cprintf_colored(TEXT_cyan,"\n1. Alloc some spaces in both allocators\n");
f011dc8d:	83 ec 08             	sub    $0x8,%esp
f011dc90:	68 ac eb 13 f0       	push   $0xf013ebac
f011dc95:	6a 03                	push   $0x3
f011dc97:	e8 e1 3e fe ff       	call   f0101b7d <cprintf_colored>
f011dc9c:	83 c4 10             	add    $0x10,%esp
	{
		eval = initial_block_allocations();
f011dc9f:	e8 20 de ff ff       	call   f011bac4 <initial_block_allocations>
f011dca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		eval += initial_page_allocations();
f011dca7:	e8 85 d5 ff ff       	call   f011b231 <initial_page_allocations>
f011dcac:	01 45 f0             	add    %eax,-0x10(%ebp)
		if (eval != 200)
f011dcaf:	81 7d f0 c8 00 00 00 	cmpl   $0xc8,-0x10(%ebp)
f011dcb6:	74 1c                	je     f011dcd4 <test_kheap_phys_addr+0x8f>
		{
			cprintf_colored(TEXT_TESTERR_CLR,"initial allocations are not correct!\nplease make sure the the kmalloc test is correct before testing the kheap_phys_addr\n");
f011dcb8:	83 ec 08             	sub    $0x8,%esp
f011dcbb:	68 d8 eb 13 f0       	push   $0xf013ebd8
f011dcc0:	6a 0c                	push   $0xc
f011dcc2:	e8 b6 3e fe ff       	call   f0101b7d <cprintf_colored>
f011dcc7:	83 c4 10             	add    $0x10,%esp
			return 0;
f011dcca:	b8 00 00 00 00       	mov    $0x0,%eax
f011dccf:	e9 c1 0c 00 00       	jmp    f011e995 <test_kheap_phys_addr+0xd50>
		}
	}
	eval = 0;
f011dcd4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	//2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only
	cprintf_colored(TEXT_cyan,"\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [20%]\n");
f011dcdb:	83 ec 08             	sub    $0x8,%esp
f011dcde:	68 54 ec 13 f0       	push   $0xf013ec54
f011dce3:	6a 03                	push   $0x3
f011dce5:	e8 93 3e fe ff       	call   f0101b7d <cprintf_colored>
f011dcea:	83 c4 10             	add    $0x10,%esp
	correct = 1;
f011dced:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va;
		uint32 offset = 353;
f011dcf4:	c7 45 ac 61 01 00 00 	movl   $0x161,-0x54(%ebp)
		uint32 startVA = ACTUAL_PAGE_ALLOC_START + offset;
f011dcfb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011dcfe:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011dd03:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
f011dd06:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011dd0b:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011dd10:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		int i = 0;
f011dd13:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011dd1a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011dd1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011dd20:	eb 25                	jmp    f011dd47 <test_kheap_phys_addr+0x102>
		{
			allPAs[i++] = kheap_physical_address(va);
f011dd22:	8b 5d e8             	mov    -0x18(%ebp),%ebx
f011dd25:	8d 43 01             	lea    0x1(%ebx),%eax
f011dd28:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011dd2b:	83 ec 0c             	sub    $0xc,%esp
f011dd2e:	ff 75 ec             	pushl  -0x14(%ebp)
f011dd31:	e8 56 d7 fe ff       	call   f010b48c <kheap_physical_address>
f011dd36:	83 c4 10             	add    $0x10,%esp
f011dd39:	89 04 9d 80 79 98 f1 	mov    %eax,-0xe678680(,%ebx,4)
		uint32 va;
		uint32 offset = 353;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START + offset;
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
		int i = 0;
		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011dd40:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011dd47:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dd4a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dd4d:	72 d3                	jb     f011dd22 <test_kheap_phys_addr+0xdd>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011dd4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dd52:	89 45 a0             	mov    %eax,-0x60(%ebp)
		i = 0;
f011dd55:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011dd5c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011dd5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011dd62:	e9 c7 00 00 00       	jmp    f011de2e <test_kheap_phys_addr+0x1e9>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011dd67:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011dd6c:	83 ec 04             	sub    $0x4,%esp
f011dd6f:	8d 95 e4 fe ff ff    	lea    -0x11c(%ebp),%edx
f011dd75:	52                   	push   %edx
f011dd76:	ff 75 ec             	pushl  -0x14(%ebp)
f011dd79:	50                   	push   %eax
f011dd7a:	e8 e8 ba fe ff       	call   f0109867 <get_page_table>
f011dd7f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011dd82:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011dd88:	85 c0                	test   %eax,%eax
f011dd8a:	75 1e                	jne    f011ddaa <test_kheap_phys_addr+0x165>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011dd8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011dd93:	83 ec 04             	sub    $0x4,%esp
f011dd96:	68 a0 ec 13 f0       	push   $0xf013eca0
f011dd9b:	68 20 06 00 00       	push   $0x620
f011dda0:	68 8a dd 13 f0       	push   $0xf013dd8a
f011dda5:	e8 05 31 fe ff       	call   f0100eaf <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011ddaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ddad:	c1 e8 0c             	shr    $0xc,%eax
f011ddb0:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ddb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ddb8:	eb 5b                	jmp    f011de15 <test_kheap_phys_addr+0x1d0>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011ddba:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011ddc0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011ddc3:	c1 e2 02             	shl    $0x2,%edx
f011ddc6:	01 d0                	add    %edx,%eax
f011ddc8:	8b 00                	mov    (%eax),%eax
f011ddca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ddcf:	89 c2                	mov    %eax,%edx
f011ddd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ddd4:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ddd9:	01 c2                	add    %eax,%edx
f011dddb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ddde:	8b 04 85 80 79 98 f1 	mov    -0xe678680(,%eax,4),%eax
f011dde5:	39 c2                	cmp    %eax,%edx
f011dde7:	74 1f                	je     f011de08 <test_kheap_phys_addr+0x1c3>
				{
					if (correct)
f011dde9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011dded:	74 19                	je     f011de08 <test_kheap_phys_addr+0x1c3>
					{
						//cprintf_colored(TEXT_TESTERR_CLR,"\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
						correct = 0;
f011ddef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
						cprintf_colored(TEXT_TESTERR_CLR,"2.2 Wrong kheap_physical_address\n");
f011ddf6:	83 ec 08             	sub    $0x8,%esp
f011ddf9:	68 00 ed 13 f0       	push   $0xf013ed00
f011ddfe:	6a 0c                	push   $0xc
f011de00:	e8 78 3d fe ff       	call   f0101b7d <cprintf_colored>
f011de05:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011de08:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011de0f:	ff 45 e4             	incl   -0x1c(%ebp)
f011de12:	ff 45 e8             	incl   -0x18(%ebp)
f011de15:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de18:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011de1b:	7d 11                	jge    f011de2e <test_kheap_phys_addr+0x1e9>
f011de1d:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011de24:	7f 08                	jg     f011de2e <test_kheap_phys_addr+0x1e9>
f011de26:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011de29:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011de2c:	72 8c                	jb     f011ddba <test_kheap_phys_addr+0x175>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011de2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011de31:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011de34:	0f 82 2d ff ff ff    	jb     f011dd67 <test_kheap_phys_addr+0x122>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011de3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011de3e:	74 04                	je     f011de44 <test_kheap_phys_addr+0x1ff>
f011de40:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	//3. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc only
	cprintf_colored(TEXT_cyan,"\n3. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc only [20%]\n");
f011de44:	83 ec 08             	sub    $0x8,%esp
f011de47:	68 24 ed 13 f0       	push   $0xf013ed24
f011de4c:	6a 03                	push   $0x3
f011de4e:	e8 2a 3d fe ff       	call   f0101b7d <cprintf_colored>
f011de53:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011de56:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		int i;
		uint32 va, pa;
		for (i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011de5d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f011de64:	e9 b2 00 00 00       	jmp    f011df1b <test_kheap_phys_addr+0x2d6>
		{
			va = (uint32)startBlockVAs[i];
f011de69:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011de6c:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011de73:	89 45 9c             	mov    %eax,-0x64(%ebp)
			pa = kheap_physical_address(va);
f011de76:	83 ec 0c             	sub    $0xc,%esp
f011de79:	ff 75 9c             	pushl  -0x64(%ebp)
f011de7c:	e8 0b d6 fe ff       	call   f010b48c <kheap_physical_address>
f011de81:	83 c4 10             	add    $0x10,%esp
f011de84:	89 45 98             	mov    %eax,-0x68(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011de87:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011de8c:	83 ec 04             	sub    $0x4,%esp
f011de8f:	8d 95 e0 fe ff ff    	lea    -0x120(%ebp),%edx
f011de95:	52                   	push   %edx
f011de96:	ff 75 9c             	pushl  -0x64(%ebp)
f011de99:	50                   	push   %eax
f011de9a:	e8 c8 b9 fe ff       	call   f0109867 <get_page_table>
f011de9f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011dea2:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011dea8:	85 c0                	test   %eax,%eax
f011deaa:	75 1e                	jne    f011deca <test_kheap_phys_addr+0x285>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011deac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011deb3:	83 ec 04             	sub    $0x4,%esp
f011deb6:	68 70 ed 13 f0       	push   $0xf013ed70
f011debb:	68 40 06 00 00       	push   $0x640
f011dec0:	68 8a dd 13 f0       	push   $0xf013dd8a
f011dec5:	e8 e5 2f fe ff       	call   f0100eaf <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011deca:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011ded0:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011ded3:	c1 ea 0c             	shr    $0xc,%edx
f011ded6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011dedc:	c1 e2 02             	shl    $0x2,%edx
f011dedf:	01 d0                	add    %edx,%eax
f011dee1:	8b 00                	mov    (%eax),%eax
f011dee3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011dee8:	89 c2                	mov    %eax,%edx
f011deea:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011deed:	25 ff 0f 00 00       	and    $0xfff,%eax
f011def2:	01 d0                	add    %edx,%eax
f011def4:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011def7:	74 1f                	je     f011df18 <test_kheap_phys_addr+0x2d3>
			{
				//cprintf_colored(TEXT_TESTERR_CLR,"\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011def9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011defd:	74 19                	je     f011df18 <test_kheap_phys_addr+0x2d3>
				{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"3.2 Wrong kheap_physical_address\n"); }
f011deff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011df06:	83 ec 08             	sub    $0x8,%esp
f011df09:	68 d0 ed 13 f0       	push   $0xf013edd0
f011df0e:	6a 0c                	push   $0xc
f011df10:	e8 68 3c fe ff       	call   f0101b7d <cprintf_colored>
f011df15:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_cyan,"\n3. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc only [20%]\n");
	correct = 1 ;
	{
		int i;
		uint32 va, pa;
		for (i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011df18:	ff 45 e0             	incl   -0x20(%ebp)
f011df1b:	81 7d e0 00 08 00 00 	cmpl   $0x800,-0x20(%ebp)
f011df22:	0f 8e 41 ff ff ff    	jle    f011de69 <test_kheap_phys_addr+0x224>
				if (correct)
				{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011df28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011df2c:	74 04                	je     f011df32 <test_kheap_phys_addr+0x2ed>
f011df2e:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	//4. kfree some of the allocated spaces in both allocators
	cprintf_colored(TEXT_cyan,"\n4. kfree some of the allocated spaces in both allocators\n");
f011df32:	83 ec 08             	sub    $0x8,%esp
f011df35:	68 f4 ed 13 f0       	push   $0xf013edf4
f011df3a:	6a 03                	push   $0x3
f011df3c:	e8 3c 3c fe ff       	call   f0101b7d <cprintf_colored>
f011df41:	83 c4 10             	add    $0x10,%esp
	uint32 startOfFreedAreas[3] = {0};
f011df44:	8d 95 04 ff ff ff    	lea    -0xfc(%ebp),%edx
f011df4a:	b9 03 00 00 00       	mov    $0x3,%ecx
f011df4f:	b8 00 00 00 00       	mov    $0x0,%eax
f011df54:	89 d7                	mov    %edx,%edi
f011df56:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 endOfFreedAreas[3] = {0};
f011df58:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f011df5e:	b9 03 00 00 00       	mov    $0x3,%ecx
f011df63:	b8 00 00 00 00       	mov    $0x0,%eax
f011df68:	89 d7                	mov    %edx,%edi
f011df6a:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 startOfFreedBlocks[2] = {0};
f011df6c:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
f011df73:	00 00 00 
f011df76:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
f011df7d:	00 00 00 
	uint32 endOfFreedBlocks[2] = {0};
f011df80:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
f011df87:	00 00 00 
f011df8a:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
f011df91:	00 00 00 

	{
		//[PAGE ALLOCATOR]
		{
			uint32 startVA = BLOCK_ALLOC_LIMIT + PAGE_SIZE;
f011df94:	c7 45 94 00 10 00 f8 	movl   $0xf8001000,-0x6c(%ebp)

			//kfree 1st 4 MB
			int freeFrames = sys_calculate_free_frames() ;
f011df9b:	e8 e6 26 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011dfa0:	89 45 90             	mov    %eax,-0x70(%ebp)
			int freeDiskFrames = pf_calculate_free_frames() ;
f011dfa3:	e8 8b 79 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011dfa8:	89 45 8c             	mov    %eax,-0x74(%ebp)
			kfree(ptr_allocations[0]);
f011dfab:	a1 60 c9 94 f0       	mov    0xf094c960,%eax
f011dfb0:	83 ec 0c             	sub    $0xc,%esp
f011dfb3:	50                   	push   %eax
f011dfb4:	e8 9a d2 fe ff       	call   f010b253 <kfree>
f011dfb9:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dfbc:	e8 72 79 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011dfc1:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011dfc4:	74 19                	je     f011dfdf <test_kheap_phys_addr+0x39a>
f011dfc6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011dfcd:	83 ec 08             	sub    $0x8,%esp
f011dfd0:	68 30 ee 13 f0       	push   $0xf013ee30
f011dfd5:	6a 0c                	push   $0xc
f011dfd7:	e8 a1 3b fe ff       	call   f0101b7d <cprintf_colored>
f011dfdc:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < ROUNDUP(requestedSizes[0], PAGE_SIZE)/PAGE_SIZE ) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011dfdf:	e8 a2 26 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011dfe4:	89 c2                	mov    %eax,%edx
f011dfe6:	8b 45 90             	mov    -0x70(%ebp),%eax
f011dfe9:	89 d1                	mov    %edx,%ecx
f011dfeb:	29 c1                	sub    %eax,%ecx
f011dfed:	c7 45 88 00 10 00 00 	movl   $0x1000,-0x78(%ebp)
f011dff4:	8b 15 20 ca 94 f0    	mov    0xf094ca20,%edx
f011dffa:	8b 45 88             	mov    -0x78(%ebp),%eax
f011dffd:	01 d0                	add    %edx,%eax
f011dfff:	48                   	dec    %eax
f011e000:	89 45 84             	mov    %eax,-0x7c(%ebp)
f011e003:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011e006:	ba 00 00 00 00       	mov    $0x0,%edx
f011e00b:	f7 75 88             	divl   -0x78(%ebp)
f011e00e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011e011:	29 d0                	sub    %edx,%eax
f011e013:	c1 e8 0c             	shr    $0xc,%eax
f011e016:	39 c1                	cmp    %eax,%ecx
f011e018:	73 19                	jae    f011e033 <test_kheap_phys_addr+0x3ee>
f011e01a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e021:	83 ec 08             	sub    $0x8,%esp
f011e024:	68 a0 ee 13 f0       	push   $0xf013eea0
f011e029:	6a 0c                	push   $0xc
f011e02b:	e8 4d 3b fe ff       	call   f0101b7d <cprintf_colored>
f011e030:	83 c4 10             	add    $0x10,%esp
			startOfFreedAreas[0] = startVA ;
f011e033:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011e036:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
			endOfFreedAreas[0] = startOfFreedAreas[0] + ROUNDUP(requestedSizes[0], PAGE_SIZE) - 1;
f011e03c:	8b 8d 04 ff ff ff    	mov    -0xfc(%ebp),%ecx
f011e042:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f011e049:	8b 15 20 ca 94 f0    	mov    0xf094ca20,%edx
f011e04f:	8b 45 80             	mov    -0x80(%ebp),%eax
f011e052:	01 d0                	add    %edx,%eax
f011e054:	48                   	dec    %eax
f011e055:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f011e05b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011e061:	ba 00 00 00 00       	mov    $0x0,%edx
f011e066:	f7 75 80             	divl   -0x80(%ebp)
f011e069:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011e06f:	29 d0                	sub    %edx,%eax
f011e071:	01 c8                	add    %ecx,%eax
f011e073:	48                   	dec    %eax
f011e074:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)

			//kfree 1st 2 MB
			freeFrames = sys_calculate_free_frames() ;
f011e07a:	e8 07 26 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011e07f:	89 45 90             	mov    %eax,-0x70(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e082:	e8 ac 78 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011e087:	89 45 8c             	mov    %eax,-0x74(%ebp)
			kfree(ptr_allocations[2]);
f011e08a:	a1 68 c9 94 f0       	mov    0xf094c968,%eax
f011e08f:	83 ec 0c             	sub    $0xc,%esp
f011e092:	50                   	push   %eax
f011e093:	e8 bb d1 fe ff       	call   f010b253 <kfree>
f011e098:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e09b:	e8 93 78 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011e0a0:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011e0a3:	74 19                	je     f011e0be <test_kheap_phys_addr+0x479>
f011e0a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e0ac:	83 ec 08             	sub    $0x8,%esp
f011e0af:	68 dc ee 13 f0       	push   $0xf013eedc
f011e0b4:	6a 0c                	push   $0xc
f011e0b6:	e8 c2 3a fe ff       	call   f0101b7d <cprintf_colored>
f011e0bb:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < ROUNDUP(requestedSizes[2], PAGE_SIZE)/PAGE_SIZE) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011e0be:	e8 c3 25 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011e0c3:	89 c2                	mov    %eax,%edx
f011e0c5:	8b 45 90             	mov    -0x70(%ebp),%eax
f011e0c8:	89 d1                	mov    %edx,%ecx
f011e0ca:	29 c1                	sub    %eax,%ecx
f011e0cc:	c7 85 78 ff ff ff 00 	movl   $0x1000,-0x88(%ebp)
f011e0d3:	10 00 00 
f011e0d6:	8b 15 28 ca 94 f0    	mov    0xf094ca28,%edx
f011e0dc:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e0e2:	01 d0                	add    %edx,%eax
f011e0e4:	48                   	dec    %eax
f011e0e5:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f011e0eb:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011e0f1:	ba 00 00 00 00       	mov    $0x0,%edx
f011e0f6:	f7 b5 78 ff ff ff    	divl   -0x88(%ebp)
f011e0fc:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011e102:	29 d0                	sub    %edx,%eax
f011e104:	c1 e8 0c             	shr    $0xc,%eax
f011e107:	39 c1                	cmp    %eax,%ecx
f011e109:	73 19                	jae    f011e124 <test_kheap_phys_addr+0x4df>
f011e10b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e112:	83 ec 08             	sub    $0x8,%esp
f011e115:	68 4c ef 13 f0       	push   $0xf013ef4c
f011e11a:	6a 0c                	push   $0xc
f011e11c:	e8 5c 3a fe ff       	call   f0101b7d <cprintf_colored>
f011e121:	83 c4 10             	add    $0x10,%esp
			startOfFreedAreas[1] = startVA + ROUNDUP(requestedSizes[0], PAGE_SIZE) + ROUNDUP(requestedSizes[1], PAGE_SIZE) ;
f011e124:	c7 85 70 ff ff ff 00 	movl   $0x1000,-0x90(%ebp)
f011e12b:	10 00 00 
f011e12e:	8b 15 20 ca 94 f0    	mov    0xf094ca20,%edx
f011e134:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e13a:	01 d0                	add    %edx,%eax
f011e13c:	48                   	dec    %eax
f011e13d:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
f011e143:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011e149:	ba 00 00 00 00       	mov    $0x0,%edx
f011e14e:	f7 b5 70 ff ff ff    	divl   -0x90(%ebp)
f011e154:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011e15a:	29 d0                	sub    %edx,%eax
f011e15c:	89 c2                	mov    %eax,%edx
f011e15e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011e161:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011e164:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f011e16b:	10 00 00 
f011e16e:	8b 15 24 ca 94 f0    	mov    0xf094ca24,%edx
f011e174:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011e17a:	01 d0                	add    %edx,%eax
f011e17c:	48                   	dec    %eax
f011e17d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f011e183:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011e189:	ba 00 00 00 00       	mov    $0x0,%edx
f011e18e:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f011e194:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011e19a:	29 d0                	sub    %edx,%eax
f011e19c:	01 c8                	add    %ecx,%eax
f011e19e:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
			endOfFreedAreas[1] = startOfFreedAreas[1] + ROUNDUP(requestedSizes[2], PAGE_SIZE) - 1;
f011e1a4:	8b 8d 08 ff ff ff    	mov    -0xf8(%ebp),%ecx
f011e1aa:	c7 85 60 ff ff ff 00 	movl   $0x1000,-0xa0(%ebp)
f011e1b1:	10 00 00 
f011e1b4:	8b 15 28 ca 94 f0    	mov    0xf094ca28,%edx
f011e1ba:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011e1c0:	01 d0                	add    %edx,%eax
f011e1c2:	48                   	dec    %eax
f011e1c3:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
f011e1c9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011e1cf:	ba 00 00 00 00       	mov    $0x0,%edx
f011e1d4:	f7 b5 60 ff ff ff    	divl   -0xa0(%ebp)
f011e1da:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011e1e0:	29 d0                	sub    %edx,%eax
f011e1e2:	01 c8                	add    %ecx,%eax
f011e1e4:	48                   	dec    %eax
f011e1e5:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)

			//kfree 1st 1 MB
			freeFrames = sys_calculate_free_frames() ;
f011e1eb:	e8 96 24 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011e1f0:	89 45 90             	mov    %eax,-0x70(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e1f3:	e8 3b 77 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011e1f8:	89 45 8c             	mov    %eax,-0x74(%ebp)
			kfree(ptr_allocations[4]);
f011e1fb:	a1 70 c9 94 f0       	mov    0xf094c970,%eax
f011e200:	83 ec 0c             	sub    $0xc,%esp
f011e203:	50                   	push   %eax
f011e204:	e8 4a d0 fe ff       	call   f010b253 <kfree>
f011e209:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e20c:	e8 22 77 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011e211:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011e214:	74 19                	je     f011e22f <test_kheap_phys_addr+0x5ea>
f011e216:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e21d:	83 ec 08             	sub    $0x8,%esp
f011e220:	68 dc ee 13 f0       	push   $0xf013eedc
f011e225:	6a 0c                	push   $0xc
f011e227:	e8 51 39 fe ff       	call   f0101b7d <cprintf_colored>
f011e22c:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < ROUNDUP(requestedSizes[4], PAGE_SIZE)/PAGE_SIZE) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011e22f:	e8 52 24 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011e234:	89 c2                	mov    %eax,%edx
f011e236:	8b 45 90             	mov    -0x70(%ebp),%eax
f011e239:	89 d1                	mov    %edx,%ecx
f011e23b:	29 c1                	sub    %eax,%ecx
f011e23d:	c7 85 58 ff ff ff 00 	movl   $0x1000,-0xa8(%ebp)
f011e244:	10 00 00 
f011e247:	8b 15 30 ca 94 f0    	mov    0xf094ca30,%edx
f011e24d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011e253:	01 d0                	add    %edx,%eax
f011e255:	48                   	dec    %eax
f011e256:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
f011e25c:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011e262:	ba 00 00 00 00       	mov    $0x0,%edx
f011e267:	f7 b5 58 ff ff ff    	divl   -0xa8(%ebp)
f011e26d:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011e273:	29 d0                	sub    %edx,%eax
f011e275:	c1 e8 0c             	shr    $0xc,%eax
f011e278:	39 c1                	cmp    %eax,%ecx
f011e27a:	73 19                	jae    f011e295 <test_kheap_phys_addr+0x650>
f011e27c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e283:	83 ec 08             	sub    $0x8,%esp
f011e286:	68 4c ef 13 f0       	push   $0xf013ef4c
f011e28b:	6a 0c                	push   $0xc
f011e28d:	e8 eb 38 fe ff       	call   f0101b7d <cprintf_colored>
f011e292:	83 c4 10             	add    $0x10,%esp
			startOfFreedAreas[2] = startOfFreedAreas[1] + ROUNDUP(requestedSizes[2], PAGE_SIZE)+ ROUNDUP(requestedSizes[3], PAGE_SIZE) ;
f011e295:	8b 8d 08 ff ff ff    	mov    -0xf8(%ebp),%ecx
f011e29b:	c7 85 50 ff ff ff 00 	movl   $0x1000,-0xb0(%ebp)
f011e2a2:	10 00 00 
f011e2a5:	8b 15 28 ca 94 f0    	mov    0xf094ca28,%edx
f011e2ab:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011e2b1:	01 d0                	add    %edx,%eax
f011e2b3:	48                   	dec    %eax
f011e2b4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
f011e2ba:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011e2c0:	ba 00 00 00 00       	mov    $0x0,%edx
f011e2c5:	f7 b5 50 ff ff ff    	divl   -0xb0(%ebp)
f011e2cb:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011e2d1:	29 d0                	sub    %edx,%eax
f011e2d3:	01 c1                	add    %eax,%ecx
f011e2d5:	c7 85 48 ff ff ff 00 	movl   $0x1000,-0xb8(%ebp)
f011e2dc:	10 00 00 
f011e2df:	8b 15 2c ca 94 f0    	mov    0xf094ca2c,%edx
f011e2e5:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011e2eb:	01 d0                	add    %edx,%eax
f011e2ed:	48                   	dec    %eax
f011e2ee:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
f011e2f4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011e2fa:	ba 00 00 00 00       	mov    $0x0,%edx
f011e2ff:	f7 b5 48 ff ff ff    	divl   -0xb8(%ebp)
f011e305:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011e30b:	29 d0                	sub    %edx,%eax
f011e30d:	01 c8                	add    %ecx,%eax
f011e30f:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
			endOfFreedAreas[2] = startOfFreedAreas[2] + ROUNDUP(requestedSizes[4], PAGE_SIZE) - 1 ;
f011e315:	8b 8d 0c ff ff ff    	mov    -0xf4(%ebp),%ecx
f011e31b:	c7 85 40 ff ff ff 00 	movl   $0x1000,-0xc0(%ebp)
f011e322:	10 00 00 
f011e325:	8b 15 30 ca 94 f0    	mov    0xf094ca30,%edx
f011e32b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011e331:	01 d0                	add    %edx,%eax
f011e333:	48                   	dec    %eax
f011e334:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
f011e33a:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011e340:	ba 00 00 00 00       	mov    $0x0,%edx
f011e345:	f7 b5 40 ff ff ff    	divl   -0xc0(%ebp)
f011e34b:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011e351:	29 d0                	sub    %edx,%eax
f011e353:	01 c8                	add    %ecx,%eax
f011e355:	48                   	dec    %eax
f011e356:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
		}
		//[BLOCK ALLOCATOR]
		int idx;
		{
			//kfree 8B blocks (except one block of boot-time)
			idx = 0;
f011e35c:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f011e363:	00 00 00 
			for (int s = 1; s <= 8; ++s)
f011e366:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
f011e36d:	eb 36                	jmp    f011e3a5 <test_kheap_phys_addr+0x760>
			{
				free_block(startBlockVAs[s]);
f011e36f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e372:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011e379:	83 ec 0c             	sub    $0xc,%esp
f011e37c:	50                   	push   %eax
f011e37d:	e8 5f 5e 00 00       	call   f01241e1 <free_block>
f011e382:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011e385:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e38b:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011e392:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e395:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e39b:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
		//[BLOCK ALLOCATOR]
		int idx;
		{
			//kfree 8B blocks (except one block of boot-time)
			idx = 0;
			for (int s = 1; s <= 8; ++s)
f011e3a2:	ff 45 dc             	incl   -0x24(%ebp)
f011e3a5:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
f011e3a9:	7e c4                	jle    f011e36f <test_kheap_phys_addr+0x72a>
			{
				free_block(startBlockVAs[s]);
				numOfAllocBlocksPerSize[idx]--;
			}
			assert(numOfAllocBlocksPerSize[idx] == 1);
f011e3ab:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e3b1:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011e3b8:	83 f8 01             	cmp    $0x1,%eax
f011e3bb:	74 19                	je     f011e3d6 <test_kheap_phys_addr+0x791>
f011e3bd:	68 88 ef 13 f0       	push   $0xf013ef88
f011e3c2:	68 aa ef 13 f0       	push   $0xf013efaa
f011e3c7:	68 7d 06 00 00       	push   $0x67d
f011e3cc:	68 8a dd 13 f0       	push   $0xf013dd8a
f011e3d1:	e8 d9 2a fe ff       	call   f0100eaf <_panic>

			//kfree 64B blocks
			idx = 3;
f011e3d6:	c7 85 38 ff ff ff 03 	movl   $0x3,-0xc8(%ebp)
f011e3dd:	00 00 00 
			for (int s = 33; s <= 64; ++s)
f011e3e0:	c7 45 d8 21 00 00 00 	movl   $0x21,-0x28(%ebp)
f011e3e7:	eb 36                	jmp    f011e41f <test_kheap_phys_addr+0x7da>
			{
				free_block(startBlockVAs[s]);
f011e3e9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011e3ec:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011e3f3:	83 ec 0c             	sub    $0xc,%esp
f011e3f6:	50                   	push   %eax
f011e3f7:	e8 e5 5d 00 00       	call   f01241e1 <free_block>
f011e3fc:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011e3ff:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e405:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011e40c:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e40f:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e415:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			}
			assert(numOfAllocBlocksPerSize[idx] == 1);

			//kfree 64B blocks
			idx = 3;
			for (int s = 33; s <= 64; ++s)
f011e41c:	ff 45 d8             	incl   -0x28(%ebp)
f011e41f:	83 7d d8 40          	cmpl   $0x40,-0x28(%ebp)
f011e423:	7e c4                	jle    f011e3e9 <test_kheap_phys_addr+0x7a4>
			{
				free_block(startBlockVAs[s]);
				numOfAllocBlocksPerSize[idx]--;
			}
			assert(numOfAllocBlocksPerSize[idx] == 0);
f011e425:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e42b:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011e432:	85 c0                	test   %eax,%eax
f011e434:	74 19                	je     f011e44f <test_kheap_phys_addr+0x80a>
f011e436:	68 c0 ef 13 f0       	push   $0xf013efc0
f011e43b:	68 aa ef 13 f0       	push   $0xf013efaa
f011e440:	68 86 06 00 00       	push   $0x686
f011e445:	68 8a dd 13 f0       	push   $0xf013dd8a
f011e44a:	e8 60 2a fe ff       	call   f0100eaf <_panic>
			startOfFreedBlocks[0] = 33;
f011e44f:	c7 85 f0 fe ff ff 21 	movl   $0x21,-0x110(%ebp)
f011e456:	00 00 00 
			endOfFreedBlocks[0] = 64;
f011e459:	c7 85 e8 fe ff ff 40 	movl   $0x40,-0x118(%ebp)
f011e460:	00 00 00 

			//kfree 256B blocks
			idx = 5;
f011e463:	c7 85 38 ff ff ff 05 	movl   $0x5,-0xc8(%ebp)
f011e46a:	00 00 00 
			for (int s = 129; s <= 256; ++s)
f011e46d:	c7 45 d4 81 00 00 00 	movl   $0x81,-0x2c(%ebp)
f011e474:	eb 36                	jmp    f011e4ac <test_kheap_phys_addr+0x867>
			{
				free_block(startBlockVAs[s]);
f011e476:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e479:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011e480:	83 ec 0c             	sub    $0xc,%esp
f011e483:	50                   	push   %eax
f011e484:	e8 58 5d 00 00       	call   f01241e1 <free_block>
f011e489:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011e48c:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e492:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011e499:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e49c:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e4a2:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			startOfFreedBlocks[0] = 33;
			endOfFreedBlocks[0] = 64;

			//kfree 256B blocks
			idx = 5;
			for (int s = 129; s <= 256; ++s)
f011e4a9:	ff 45 d4             	incl   -0x2c(%ebp)
f011e4ac:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
f011e4b3:	7e c1                	jle    f011e476 <test_kheap_phys_addr+0x831>
			{
				free_block(startBlockVAs[s]);
				numOfAllocBlocksPerSize[idx]--;
			}
			assert(numOfAllocBlocksPerSize[idx] == 0);
f011e4b5:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011e4bb:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011e4c2:	85 c0                	test   %eax,%eax
f011e4c4:	74 19                	je     f011e4df <test_kheap_phys_addr+0x89a>
f011e4c6:	68 c0 ef 13 f0       	push   $0xf013efc0
f011e4cb:	68 aa ef 13 f0       	push   $0xf013efaa
f011e4d0:	68 91 06 00 00       	push   $0x691
f011e4d5:	68 8a dd 13 f0       	push   $0xf013dd8a
f011e4da:	e8 d0 29 fe ff       	call   f0100eaf <_panic>
			startOfFreedBlocks[1] = 129;
f011e4df:	c7 85 f4 fe ff ff 81 	movl   $0x81,-0x10c(%ebp)
f011e4e6:	00 00 00 
			endOfFreedBlocks[1] = 256;
f011e4e9:	c7 85 ec fe ff ff 00 	movl   $0x100,-0x114(%ebp)
f011e4f0:	01 00 00 
		}
	}

	uint32 expected;
	//5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree
	cprintf_colored(TEXT_cyan,"\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [25%]\n");
f011e4f3:	83 ec 08             	sub    $0x8,%esp
f011e4f6:	68 e4 ef 13 f0       	push   $0xf013efe4
f011e4fb:	6a 03                	push   $0x3
f011e4fd:	e8 7b 36 fe ff       	call   f0101b7d <cprintf_colored>
f011e502:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011e505:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va;
		uint32 offset = 121;
f011e50c:	c7 85 34 ff ff ff 79 	movl   $0x79,-0xcc(%ebp)
f011e513:	00 00 00 
		uint32 startVA = ACTUAL_PAGE_ALLOC_START+offset;
f011e516:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011e51c:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011e521:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
f011e527:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011e52c:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011e531:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		uint32 i = 0;
f011e537:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011e53e:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011e544:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011e547:	eb 25                	jmp    f011e56e <test_kheap_phys_addr+0x929>
		{
			allPAs[i++] = kheap_physical_address(va);
f011e549:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011e54c:	8d 43 01             	lea    0x1(%ebx),%eax
f011e54f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011e552:	83 ec 0c             	sub    $0xc,%esp
f011e555:	ff 75 cc             	pushl  -0x34(%ebp)
f011e558:	e8 2f cf fe ff       	call   f010b48c <kheap_physical_address>
f011e55d:	83 c4 10             	add    $0x10,%esp
f011e560:	89 04 9d 80 79 98 f1 	mov    %eax,-0xe678680(,%ebx,4)
		uint32 va;
		uint32 offset = 121;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START+offset;
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
		uint32 i = 0;
		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011e567:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011e56e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e571:	3b 85 2c ff ff ff    	cmp    -0xd4(%ebp),%eax
f011e577:	72 d0                	jb     f011e549 <test_kheap_phys_addr+0x904>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011e579:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e57c:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		i = 0;
f011e582:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011e589:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011e58f:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011e592:	e9 06 01 00 00       	jmp    f011e69d <test_kheap_phys_addr+0xa58>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011e597:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011e59c:	83 ec 04             	sub    $0x4,%esp
f011e59f:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
f011e5a5:	52                   	push   %edx
f011e5a6:	ff 75 cc             	pushl  -0x34(%ebp)
f011e5a9:	50                   	push   %eax
f011e5aa:	e8 b8 b2 fe ff       	call   f0109867 <get_page_table>
f011e5af:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e5b2:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011e5b8:	85 c0                	test   %eax,%eax
f011e5ba:	75 24                	jne    f011e5e0 <test_kheap_phys_addr+0x99b>
				if (correct)
f011e5bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e5c0:	74 1e                	je     f011e5e0 <test_kheap_phys_addr+0x99b>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e5c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e5c9:	83 ec 04             	sub    $0x4,%esp
f011e5cc:	68 34 f0 13 f0       	push   $0xf013f034
f011e5d1:	68 ae 06 00 00       	push   $0x6ae
f011e5d6:	68 8a dd 13 f0       	push   $0xf013dd8a
f011e5db:	e8 cf 28 fe ff       	call   f0100eaf <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011e5e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e5e3:	c1 e8 0c             	shr    $0xc,%eax
f011e5e6:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e5eb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011e5ee:	e9 87 00 00 00       	jmp    f011e67a <test_kheap_phys_addr+0xa35>
			{
				if (isVAInsideFreedAreas(va, startOfFreedAreas, endOfFreedAreas, 3))
f011e5f3:	6a 03                	push   $0x3
f011e5f5:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f011e5fb:	50                   	push   %eax
f011e5fc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011e602:	50                   	push   %eax
f011e603:	ff 75 cc             	pushl  -0x34(%ebp)
f011e606:	e8 e6 f5 ff ff       	call   f011dbf1 <isVAInsideFreedAreas>
f011e60b:	83 c4 10             	add    $0x10,%esp
f011e60e:	85 c0                	test   %eax,%eax
f011e610:	74 09                	je     f011e61b <test_kheap_phys_addr+0x9d6>
				{
					expected = 0 ;
f011e612:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f011e619:	eb 24                	jmp    f011e63f <test_kheap_phys_addr+0x9fa>
				}
				else
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011e61b:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011e621:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011e624:	c1 e2 02             	shl    $0x2,%edx
f011e627:	01 d0                	add    %edx,%eax
f011e629:	8b 00                	mov    (%eax),%eax
f011e62b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e630:	89 c2                	mov    %eax,%edx
f011e632:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e635:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e63a:	01 d0                	add    %edx,%eax
f011e63c:	89 45 d0             	mov    %eax,-0x30(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011e63f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e642:	8b 04 85 80 79 98 f1 	mov    -0xe678680(,%eax,4),%eax
f011e649:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011e64c:	74 1f                	je     f011e66d <test_kheap_phys_addr+0xa28>
				{
					//cprintf_colored(TEXT_TESTERR_CLR,"\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011e64e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e652:	74 19                	je     f011e66d <test_kheap_phys_addr+0xa28>
					{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"5.2 Wrong kheap_physical_address\n"); }
f011e654:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e65b:	83 ec 08             	sub    $0x8,%esp
f011e65e:	68 94 f0 13 f0       	push   $0xf013f094
f011e663:	6a 0c                	push   $0xc
f011e665:	e8 13 35 fe ff       	call   f0101b7d <cprintf_colored>
f011e66a:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011e66d:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011e674:	ff 45 c4             	incl   -0x3c(%ebp)
f011e677:	ff 45 c8             	incl   -0x38(%ebp)
f011e67a:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011e680:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011e683:	73 18                	jae    f011e69d <test_kheap_phys_addr+0xa58>
f011e685:	81 7d c4 ff 03 00 00 	cmpl   $0x3ff,-0x3c(%ebp)
f011e68c:	7f 0f                	jg     f011e69d <test_kheap_phys_addr+0xa58>
f011e68e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e691:	3b 85 2c ff ff ff    	cmp    -0xd4(%ebp),%eax
f011e697:	0f 82 56 ff ff ff    	jb     f011e5f3 <test_kheap_phys_addr+0x9ae>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011e69d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e6a0:	3b 85 2c ff ff ff    	cmp    -0xd4(%ebp),%eax
f011e6a6:	0f 82 eb fe ff ff    	jb     f011e597 <test_kheap_phys_addr+0x952>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=25 ;
f011e6ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e6b0:	74 04                	je     f011e6b6 <test_kheap_phys_addr+0xa71>
f011e6b2:	83 45 f0 19          	addl   $0x19,-0x10(%ebp)

	//6. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc and kfree
	cprintf_colored(TEXT_cyan,"\n6. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc and kfree [25%]\n");
f011e6b6:	83 ec 08             	sub    $0x8,%esp
f011e6b9:	68 b8 f0 13 f0       	push   $0xf013f0b8
f011e6be:	6a 03                	push   $0x3
f011e6c0:	e8 b8 34 fe ff       	call   f0101b7d <cprintf_colored>
f011e6c5:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011e6c8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va, pa;
		for (int i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011e6cf:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
f011e6d6:	e9 3c 01 00 00       	jmp    f011e817 <test_kheap_phys_addr+0xbd2>
		{
			va = (uint32)startBlockVAs[i];
f011e6db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e6de:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011e6e5:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
			pa = kheap_physical_address(va);
f011e6eb:	83 ec 0c             	sub    $0xc,%esp
f011e6ee:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
f011e6f4:	e8 93 cd fe ff       	call   f010b48c <kheap_physical_address>
f011e6f9:	83 c4 10             	add    $0x10,%esp
f011e6fc:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011e702:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011e707:	83 ec 04             	sub    $0x4,%esp
f011e70a:	8d 95 d8 fe ff ff    	lea    -0x128(%ebp),%edx
f011e710:	52                   	push   %edx
f011e711:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
f011e717:	50                   	push   %eax
f011e718:	e8 4a b1 fe ff       	call   f0109867 <get_page_table>
f011e71d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e720:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011e726:	85 c0                	test   %eax,%eax
f011e728:	75 1e                	jne    f011e748 <test_kheap_phys_addr+0xb03>
			{ correct = 0; panic("6.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e72a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e731:	83 ec 04             	sub    $0x4,%esp
f011e734:	68 0c f1 13 f0       	push   $0xf013f10c
f011e739:	68 d3 06 00 00       	push   $0x6d3
f011e73e:	68 8a dd 13 f0       	push   $0xf013dd8a
f011e743:	e8 67 27 fe ff       	call   f0100eaf <_panic>

			if (isVAInsideFreedAreas(i, startOfFreedBlocks, endOfFreedBlocks, 2))
f011e748:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e74b:	6a 02                	push   $0x2
f011e74d:	8d 95 e8 fe ff ff    	lea    -0x118(%ebp),%edx
f011e753:	52                   	push   %edx
f011e754:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
f011e75a:	52                   	push   %edx
f011e75b:	50                   	push   %eax
f011e75c:	e8 90 f4 ff ff       	call   f011dbf1 <isVAInsideFreedAreas>
f011e761:	83 c4 10             	add    $0x10,%esp
f011e764:	85 c0                	test   %eax,%eax
f011e766:	74 09                	je     f011e771 <test_kheap_phys_addr+0xb2c>
			{
				expected = 0 ;
f011e768:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f011e76f:	eb 33                	jmp    f011e7a4 <test_kheap_phys_addr+0xb5f>
			}
			else
			{
				expected = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0x00000FFF);
f011e771:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011e777:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011e77d:	c1 ea 0c             	shr    $0xc,%edx
f011e780:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011e786:	c1 e2 02             	shl    $0x2,%edx
f011e789:	01 d0                	add    %edx,%eax
f011e78b:	8b 00                	mov    (%eax),%eax
f011e78d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e792:	89 c2                	mov    %eax,%edx
f011e794:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011e79a:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e79f:	01 d0                	add    %edx,%eax
f011e7a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
			}
			if (expected != pa)
f011e7a4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e7a7:	3b 85 20 ff ff ff    	cmp    -0xe0(%ebp),%eax
f011e7ad:	74 65                	je     f011e814 <test_kheap_phys_addr+0xbcf>
			{
				if (correct)
f011e7af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e7b3:	74 5f                	je     f011e814 <test_kheap_phys_addr+0xbcf>
				{
					cprintf_colored(TEXT_TESTERR_CLR,"\nBlock Size = %d, VA = %x, table entry = %x\nkhep_pa = %x, expected = %x\n",i, va, (ptr_table[PTX(va)] & 0xFFFFF000) , pa, expected);
f011e7b5:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011e7bb:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011e7c1:	c1 ea 0c             	shr    $0xc,%edx
f011e7c4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011e7ca:	c1 e2 02             	shl    $0x2,%edx
f011e7cd:	01 d0                	add    %edx,%eax
f011e7cf:	8b 00                	mov    (%eax),%eax
f011e7d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e7d6:	83 ec 04             	sub    $0x4,%esp
f011e7d9:	ff 75 d0             	pushl  -0x30(%ebp)
f011e7dc:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
f011e7e2:	50                   	push   %eax
f011e7e3:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
f011e7e9:	ff 75 c0             	pushl  -0x40(%ebp)
f011e7ec:	68 6c f1 13 f0       	push   $0xf013f16c
f011e7f1:	6a 0c                	push   $0xc
f011e7f3:	e8 85 33 fe ff       	call   f0101b7d <cprintf_colored>
f011e7f8:	83 c4 20             	add    $0x20,%esp
					correct = 0;
f011e7fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR,"6.2 Wrong kheap_physical_address\n");
f011e802:	83 ec 08             	sub    $0x8,%esp
f011e805:	68 b8 f1 13 f0       	push   $0xf013f1b8
f011e80a:	6a 0c                	push   $0xc
f011e80c:	e8 6c 33 fe ff       	call   f0101b7d <cprintf_colored>
f011e811:	83 c4 10             	add    $0x10,%esp
	//6. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc and kfree
	cprintf_colored(TEXT_cyan,"\n6. [BLOCK ALLOCATOR] test kheap_physical_address after kmalloc and kfree [25%]\n");
	correct = 1 ;
	{
		uint32 va, pa;
		for (int i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011e814:	ff 45 c0             	incl   -0x40(%ebp)
f011e817:	81 7d c0 00 08 00 00 	cmpl   $0x800,-0x40(%ebp)
f011e81e:	0f 8e b7 fe ff ff    	jle    f011e6db <test_kheap_phys_addr+0xa96>
					cprintf_colored(TEXT_TESTERR_CLR,"6.2 Wrong kheap_physical_address\n");
				}
			}
		}
	}
	if (correct)	eval+=25 ;
f011e824:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e828:	74 04                	je     f011e82e <test_kheap_phys_addr+0xbe9>
f011e82a:	83 45 f0 19          	addl   $0x19,-0x10(%ebp)

	//7. test kheap_physical_address on non-mapped area
	cprintf_colored(TEXT_cyan,"\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011e82e:	83 ec 08             	sub    $0x8,%esp
f011e831:	68 dc f1 13 f0       	push   $0xf013f1dc
f011e836:	6a 03                	push   $0x3
f011e838:	e8 40 33 fe ff       	call   f0101b7d <cprintf_colored>
f011e83d:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011e840:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START +totalRequestedSize;
f011e847:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011e84c:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011e851:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
		int ii = (KERNEL_HEAP_MAX - startVA) / PAGE_SIZE;
f011e857:	b8 00 f0 ff ff       	mov    $0xfffff000,%eax
f011e85c:	2b 85 1c ff ff ff    	sub    -0xe4(%ebp),%eax
f011e862:	c1 e8 0c             	shr    $0xc,%eax
f011e865:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
		uint32 i = 0;
f011e86b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011e872:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011e878:	89 45 b0             	mov    %eax,-0x50(%ebp)
f011e87b:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f011e882:	e9 cd 00 00 00       	jmp    f011e954 <test_kheap_phys_addr+0xd0f>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011e887:	8b 55 b0             	mov    -0x50(%ebp),%edx
f011e88a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011e88f:	83 ec 04             	sub    $0x4,%esp
f011e892:	8d 8d d4 fe ff ff    	lea    -0x12c(%ebp),%ecx
f011e898:	51                   	push   %ecx
f011e899:	52                   	push   %edx
f011e89a:	50                   	push   %eax
f011e89b:	e8 c7 af fe ff       	call   f0109867 <get_page_table>
f011e8a0:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e8a3:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011e8a9:	85 c0                	test   %eax,%eax
f011e8ab:	75 24                	jne    f011e8d1 <test_kheap_phys_addr+0xc8c>
			{
				if (correct)
f011e8ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e8b1:	74 1e                	je     f011e8d1 <test_kheap_phys_addr+0xc8c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e8b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e8ba:	83 ec 04             	sub    $0x4,%esp
f011e8bd:	68 18 f2 13 f0       	push   $0xf013f218
f011e8c2:	68 fb 06 00 00       	push   $0x6fb
f011e8c7:	68 8a dd 13 f0       	push   $0xf013dd8a
f011e8cc:	e8 de 25 fe ff       	call   f0100eaf <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011e8d1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f011e8d8:	eb 5b                	jmp    f011e935 <test_kheap_phys_addr+0xcf0>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011e8da:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011e8dd:	c1 e0 0c             	shl    $0xc,%eax
f011e8e0:	89 c2                	mov    %eax,%edx
f011e8e2:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011e8e8:	01 d0                	add    %edx,%eax
f011e8ea:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011e8f0:	83 ec 0c             	sub    $0xc,%esp
f011e8f3:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
f011e8f9:	e8 8e cb fe ff       	call   f010b48c <kheap_physical_address>
f011e8fe:	83 c4 10             	add    $0x10,%esp
f011e901:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011e907:	83 bd 10 ff ff ff 00 	cmpl   $0x0,-0xf0(%ebp)
f011e90e:	74 1f                	je     f011e92f <test_kheap_phys_addr+0xcea>
				{
					//cprintf_colored(TEXT_TESTERR_CLR,"\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011e910:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e914:	74 19                	je     f011e92f <test_kheap_phys_addr+0xcea>
					{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"7.2 Wrong kheap_physical_address\n"); }
f011e916:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e91d:	83 ec 08             	sub    $0x8,%esp
f011e920:	68 78 f2 13 f0       	push   $0xf013f278
f011e925:	6a 0c                	push   $0xc
f011e927:	e8 51 32 fe ff       	call   f0101b7d <cprintf_colored>
f011e92c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011e92f:	ff 45 b8             	incl   -0x48(%ebp)
f011e932:	ff 45 bc             	incl   -0x44(%ebp)
f011e935:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011e93b:	39 45 bc             	cmp    %eax,-0x44(%ebp)
f011e93e:	73 09                	jae    f011e949 <test_kheap_phys_addr+0xd04>
f011e940:	81 7d b8 ff 03 00 00 	cmpl   $0x3ff,-0x48(%ebp)
f011e947:	7e 91                	jle    f011e8da <test_kheap_phys_addr+0xc95>
		uint32 startVA = ACTUAL_PAGE_ALLOC_START +totalRequestedSize;
		int ii = (KERNEL_HEAP_MAX - startVA) / PAGE_SIZE;
		uint32 i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011e949:	81 45 b0 00 00 40 00 	addl   $0x400000,-0x50(%ebp)
f011e950:	83 55 b4 00          	adcl   $0x0,-0x4c(%ebp)
f011e954:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011e958:	0f 88 29 ff ff ff    	js     f011e887 <test_kheap_phys_addr+0xc42>
f011e95e:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011e962:	7f 0d                	jg     f011e971 <test_kheap_phys_addr+0xd2c>
f011e964:	81 7d b0 ff ef ff ff 	cmpl   $0xffffefff,-0x50(%ebp)
f011e96b:	0f 86 16 ff ff ff    	jbe    f011e887 <test_kheap_phys_addr+0xc42>
					{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011e971:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e975:	74 04                	je     f011e97b <test_kheap_phys_addr+0xd36>
f011e977:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf_colored(TEXT_light_green,"\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011e97b:	83 ec 04             	sub    $0x4,%esp
f011e97e:	ff 75 f0             	pushl  -0x10(%ebp)
f011e981:	68 9c f2 13 f0       	push   $0xf013f29c
f011e986:	6a 0a                	push   $0xa
f011e988:	e8 f0 31 fe ff       	call   f0101b7d <cprintf_colored>
f011e98d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011e990:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011e995:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011e998:	5b                   	pop    %ebx
f011e999:	5f                   	pop    %edi
f011e99a:	5d                   	pop    %ebp
f011e99b:	c3                   	ret    

f011e99c <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011e99c:	55                   	push   %ebp
f011e99d:	89 e5                	mov    %esp,%ebp
f011e99f:	57                   	push   %edi
f011e9a0:	81 ec 14 01 00 00    	sub    $0x114,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf_colored(TEXT_yellow,"==============================================\n");
f011e9a6:	83 ec 08             	sub    $0x8,%esp
f011e9a9:	68 a4 dd 13 f0       	push   $0xf013dda4
f011e9ae:	6a 0e                	push   $0xe
f011e9b0:	e8 c8 31 fe ff       	call   f0101b7d <cprintf_colored>
f011e9b5:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011e9b8:	83 ec 08             	sub    $0x8,%esp
f011e9bb:	68 d4 dd 13 f0       	push   $0xf013ddd4
f011e9c0:	6a 0e                	push   $0xe
f011e9c2:	e8 b6 31 fe ff       	call   f0101b7d <cprintf_colored>
f011e9c7:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_yellow,"==============================================\n");
f011e9ca:	83 ec 08             	sub    $0x8,%esp
f011e9cd:	68 a4 dd 13 f0       	push   $0xf013dda4
f011e9d2:	6a 0e                	push   $0xe
f011e9d4:	e8 a4 31 fe ff       	call   f0101b7d <cprintf_colored>
f011e9d9:	83 c4 10             	add    $0x10,%esp

	//1. Alloc some spaces in both allocators
	int correct = 1;
f011e9dc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int eval;
	cprintf_colored(TEXT_cyan,"\n1. Alloc some spaces in both allocators\n");
f011e9e3:	83 ec 08             	sub    $0x8,%esp
f011e9e6:	68 ac eb 13 f0       	push   $0xf013ebac
f011e9eb:	6a 03                	push   $0x3
f011e9ed:	e8 8b 31 fe ff       	call   f0101b7d <cprintf_colored>
f011e9f2:	83 c4 10             	add    $0x10,%esp
	{
		eval = initial_block_allocations();
f011e9f5:	e8 ca d0 ff ff       	call   f011bac4 <initial_block_allocations>
f011e9fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
		eval += initial_page_allocations();
f011e9fd:	e8 2f c8 ff ff       	call   f011b231 <initial_page_allocations>
f011ea02:	01 45 f0             	add    %eax,-0x10(%ebp)

		if (eval != 200)
f011ea05:	81 7d f0 c8 00 00 00 	cmpl   $0xc8,-0x10(%ebp)
f011ea0c:	74 1c                	je     f011ea2a <test_kheap_virt_addr+0x8e>
		{
			cprintf_colored(TEXT_TESTERR_CLR,"initial allocations are not correct!\nplease make sure the the kmalloc test is correct before testing the kheap_phys_addr\n");
f011ea0e:	83 ec 08             	sub    $0x8,%esp
f011ea11:	68 d8 eb 13 f0       	push   $0xf013ebd8
f011ea16:	6a 0c                	push   $0xc
f011ea18:	e8 60 31 fe ff       	call   f0101b7d <cprintf_colored>
f011ea1d:	83 c4 10             	add    $0x10,%esp
			return 0;
f011ea20:	b8 00 00 00 00       	mov    $0x0,%eax
f011ea25:	e9 76 0b 00 00       	jmp    f011f5a0 <test_kheap_virt_addr+0xc04>
		}
	}
	eval = 0;
f011ea2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	//2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only
	cprintf_colored(TEXT_cyan,"\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011ea31:	83 ec 08             	sub    $0x8,%esp
f011ea34:	68 d0 f2 13 f0       	push   $0xf013f2d0
f011ea39:	6a 03                	push   $0x3
f011ea3b:	e8 3d 31 fe ff       	call   f0101b7d <cprintf_colored>
f011ea40:	83 c4 10             	add    $0x10,%esp
	int numOfFrames = totalRequestedSize/PAGE_SIZE ;
f011ea43:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011ea48:	c1 e8 0c             	shr    $0xc,%eax
f011ea4b:	89 45 b8             	mov    %eax,-0x48(%ebp)
	correct = 1;
f011ea4e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START ;
f011ea55:	c7 45 b4 00 10 00 f8 	movl   $0xf8001000,-0x4c(%ebp)
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
f011ea5c:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011ea61:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011ea66:	89 45 b0             	mov    %eax,-0x50(%ebp)
		int i = 0;
f011ea69:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011ea70:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011ea73:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ea76:	e9 24 01 00 00       	jmp    f011eb9f <test_kheap_virt_addr+0x203>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ea7b:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011ea80:	83 ec 04             	sub    $0x4,%esp
f011ea83:	8d 95 f0 fe ff ff    	lea    -0x110(%ebp),%edx
f011ea89:	52                   	push   %edx
f011ea8a:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea8d:	50                   	push   %eax
f011ea8e:	e8 d4 ad fe ff       	call   f0109867 <get_page_table>
f011ea93:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ea96:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ea9c:	85 c0                	test   %eax,%eax
f011ea9e:	75 1e                	jne    f011eabe <test_kheap_virt_addr+0x122>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011eaa0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eaa7:	83 ec 04             	sub    $0x4,%esp
f011eaaa:	68 a0 ec 13 f0       	push   $0xf013eca0
f011eaaf:	68 40 07 00 00       	push   $0x740
f011eab4:	68 8a dd 13 f0       	push   $0xf013dd8a
f011eab9:	e8 f1 23 fe ff       	call   f0100eaf <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011eabe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011eac1:	c1 e8 0c             	shr    $0xc,%eax
f011eac4:	25 ff 03 00 00       	and    $0x3ff,%eax
f011eac9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eacc:	e9 b1 00 00 00       	jmp    f011eb82 <test_kheap_virt_addr+0x1e6>
			{
				uint32 offset = j;
f011ead1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ead4:	89 45 ac             	mov    %eax,-0x54(%ebp)
				assert((ptr_table[j] & PERM_PRESENT) == PERM_PRESENT);
f011ead7:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011eadd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011eae0:	c1 e2 02             	shl    $0x2,%edx
f011eae3:	01 d0                	add    %edx,%eax
f011eae5:	8b 00                	mov    (%eax),%eax
f011eae7:	83 e0 01             	and    $0x1,%eax
f011eaea:	85 c0                	test   %eax,%eax
f011eaec:	75 19                	jne    f011eb07 <test_kheap_virt_addr+0x16b>
f011eaee:	68 1c f3 13 f0       	push   $0xf013f31c
f011eaf3:	68 aa ef 13 f0       	push   $0xf013efaa
f011eaf8:	68 45 07 00 00       	push   $0x745
f011eafd:	68 8a dd 13 f0       	push   $0xf013dd8a
f011eb02:	e8 a8 23 fe ff       	call   f0100eaf <_panic>
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011eb07:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011eb0d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011eb10:	c1 e2 02             	shl    $0x2,%edx
f011eb13:	01 d0                	add    %edx,%eax
f011eb15:	8b 00                	mov    (%eax),%eax
f011eb17:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011eb1c:	89 c2                	mov    %eax,%edx
f011eb1e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011eb21:	01 c2                	add    %eax,%edx
f011eb23:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011eb26:	89 14 85 80 79 98 f1 	mov    %edx,-0xe678680(,%eax,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011eb2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011eb30:	8b 04 85 80 79 98 f1 	mov    -0xe678680(,%eax,4),%eax
f011eb37:	83 ec 0c             	sub    $0xc,%esp
f011eb3a:	50                   	push   %eax
f011eb3b:	e8 e0 c8 fe ff       	call   f010b420 <kheap_virtual_address>
f011eb40:	83 c4 10             	add    $0x10,%esp
f011eb43:	89 45 a8             	mov    %eax,-0x58(%ebp)
				//cprintf_colored(TEXT_TESTERR_CLR,"va to check = %x\n", va);
				uint32 expectedVA = (va+offset);
f011eb46:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011eb49:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011eb4c:	01 d0                	add    %edx,%eax
f011eb4e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
				if (retrievedVA != expectedVA)
f011eb51:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011eb54:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011eb57:	74 1c                	je     f011eb75 <test_kheap_virt_addr+0x1d9>
				{
					correct = 0;
f011eb59:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR,"2.2 Wrong kheap_virtual_address. Expected = %x, Actual = %x\n", expectedVA, retrievedVA);
f011eb60:	ff 75 a8             	pushl  -0x58(%ebp)
f011eb63:	ff 75 a4             	pushl  -0x5c(%ebp)
f011eb66:	68 4c f3 13 f0       	push   $0xf013f34c
f011eb6b:	6a 0c                	push   $0xc
f011eb6d:	e8 0b 30 fe ff       	call   f0101b7d <cprintf_colored>
f011eb72:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE;
f011eb75:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011eb7c:	ff 45 e4             	incl   -0x1c(%ebp)
f011eb7f:	ff 45 e8             	incl   -0x18(%ebp)
f011eb82:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011eb85:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011eb88:	7d 15                	jge    f011eb9f <test_kheap_virt_addr+0x203>
f011eb8a:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011eb91:	7f 0c                	jg     f011eb9f <test_kheap_virt_addr+0x203>
f011eb93:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011eb96:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011eb99:	0f 82 32 ff ff ff    	jb     f011ead1 <test_kheap_virt_addr+0x135>
		uint32 va;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START ;
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011eb9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011eba2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011eba5:	0f 82 d0 fe ff ff    	jb     f011ea7b <test_kheap_virt_addr+0xdf>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011ebab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ebaf:	74 04                	je     f011ebb5 <test_kheap_virt_addr+0x219>
f011ebb1:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	//3. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc only
	cprintf_colored(TEXT_cyan,"\n3. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011ebb5:	83 ec 08             	sub    $0x8,%esp
f011ebb8:	68 8c f3 13 f0       	push   $0xf013f38c
f011ebbd:	6a 03                	push   $0x3
f011ebbf:	e8 b9 2f fe ff       	call   f0101b7d <cprintf_colored>
f011ebc4:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011ebc7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va, pa;
		for (int i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011ebce:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f011ebd5:	e9 00 01 00 00       	jmp    f011ecda <test_kheap_virt_addr+0x33e>
		{
			va = (uint32)startBlockVAs[i];
f011ebda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ebdd:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011ebe4:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ebe7:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011ebec:	83 ec 04             	sub    $0x4,%esp
f011ebef:	8d 95 ec fe ff ff    	lea    -0x114(%ebp),%edx
f011ebf5:	52                   	push   %edx
f011ebf6:	ff 75 a0             	pushl  -0x60(%ebp)
f011ebf9:	50                   	push   %eax
f011ebfa:	e8 68 ac fe ff       	call   f0109867 <get_page_table>
f011ebff:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ec02:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ec08:	85 c0                	test   %eax,%eax
f011ec0a:	75 1e                	jne    f011ec2a <test_kheap_virt_addr+0x28e>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ec0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ec13:	83 ec 04             	sub    $0x4,%esp
f011ec16:	68 70 ed 13 f0       	push   $0xf013ed70
f011ec1b:	68 60 07 00 00       	push   $0x760
f011ec20:	68 8a dd 13 f0       	push   $0xf013dd8a
f011ec25:	e8 85 22 fe ff       	call   f0100eaf <_panic>

			assert((ptr_table[PTX(va)] & PERM_PRESENT) == PERM_PRESENT);
f011ec2a:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ec30:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011ec33:	c1 ea 0c             	shr    $0xc,%edx
f011ec36:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011ec3c:	c1 e2 02             	shl    $0x2,%edx
f011ec3f:	01 d0                	add    %edx,%eax
f011ec41:	8b 00                	mov    (%eax),%eax
f011ec43:	83 e0 01             	and    $0x1,%eax
f011ec46:	85 c0                	test   %eax,%eax
f011ec48:	75 19                	jne    f011ec63 <test_kheap_virt_addr+0x2c7>
f011ec4a:	68 d8 f3 13 f0       	push   $0xf013f3d8
f011ec4f:	68 aa ef 13 f0       	push   $0xf013efaa
f011ec54:	68 62 07 00 00       	push   $0x762
f011ec59:	68 8a dd 13 f0       	push   $0xf013dd8a
f011ec5e:	e8 4c 22 fe ff       	call   f0100eaf <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF);
f011ec63:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ec69:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011ec6c:	c1 ea 0c             	shr    $0xc,%edx
f011ec6f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011ec75:	c1 e2 02             	shl    $0x2,%edx
f011ec78:	01 d0                	add    %edx,%eax
f011ec7a:	8b 00                	mov    (%eax),%eax
f011ec7c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ec81:	89 c2                	mov    %eax,%edx
f011ec83:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ec86:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ec8b:	01 d0                	add    %edx,%eax
f011ec8d:	89 45 9c             	mov    %eax,-0x64(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011ec90:	83 ec 0c             	sub    $0xc,%esp
f011ec93:	ff 75 9c             	pushl  -0x64(%ebp)
f011ec96:	e8 85 c7 fe ff       	call   f010b420 <kheap_virtual_address>
f011ec9b:	83 c4 10             	add    $0x10,%esp
f011ec9e:	89 45 98             	mov    %eax,-0x68(%ebp)
			uint32 expectedVA = va;
f011eca1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eca4:	89 45 94             	mov    %eax,-0x6c(%ebp)
			//cprintf_colored(TEXT_TESTERR_CLR,"va to check = %x\n", va);
			if (retrievedVA != expectedVA)
f011eca7:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ecaa:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011ecad:	74 28                	je     f011ecd7 <test_kheap_virt_addr+0x33b>
			{
				if (correct)
f011ecaf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ecb3:	74 22                	je     f011ecd7 <test_kheap_virt_addr+0x33b>
				{
					correct = 0;
f011ecb5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR,"3.2 Wrong kheap_virtual_address at block size %d! Expected = %x, Actual = %x\n", i, expectedVA, retrievedVA);
f011ecbc:	83 ec 0c             	sub    $0xc,%esp
f011ecbf:	ff 75 98             	pushl  -0x68(%ebp)
f011ecc2:	ff 75 94             	pushl  -0x6c(%ebp)
f011ecc5:	ff 75 e0             	pushl  -0x20(%ebp)
f011ecc8:	68 0c f4 13 f0       	push   $0xf013f40c
f011eccd:	6a 0c                	push   $0xc
f011eccf:	e8 a9 2e fe ff       	call   f0101b7d <cprintf_colored>
f011ecd4:	83 c4 20             	add    $0x20,%esp
	//3. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc only
	cprintf_colored(TEXT_cyan,"\n3. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
	correct = 1 ;
	{
		uint32 va, pa;
		for (int i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011ecd7:	ff 45 e0             	incl   -0x20(%ebp)
f011ecda:	81 7d e0 00 08 00 00 	cmpl   $0x800,-0x20(%ebp)
f011ece1:	0f 8e f3 fe ff ff    	jle    f011ebda <test_kheap_virt_addr+0x23e>
					cprintf_colored(TEXT_TESTERR_CLR,"3.2 Wrong kheap_virtual_address at block size %d! Expected = %x, Actual = %x\n", i, expectedVA, retrievedVA);
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011ece7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011eceb:	74 04                	je     f011ecf1 <test_kheap_virt_addr+0x355>
f011eced:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	//4. kfree some of the allocated spaces in both allocators
	cprintf_colored(TEXT_cyan,"\n4. kfree some of the allocated spaces in both allocators\n");
f011ecf1:	83 ec 08             	sub    $0x8,%esp
f011ecf4:	68 f4 ed 13 f0       	push   $0xf013edf4
f011ecf9:	6a 03                	push   $0x3
f011ecfb:	e8 7d 2e fe ff       	call   f0101b7d <cprintf_colored>
f011ed00:	83 c4 10             	add    $0x10,%esp
	uint32 startOfFreedAreas[3] = {0};
f011ed03:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011ed09:	b9 03 00 00 00       	mov    $0x3,%ecx
f011ed0e:	b8 00 00 00 00       	mov    $0x0,%eax
f011ed13:	89 d7                	mov    %edx,%edi
f011ed15:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 endOfFreedAreas[3] = {0};
f011ed17:	8d 95 04 ff ff ff    	lea    -0xfc(%ebp),%edx
f011ed1d:	b9 03 00 00 00       	mov    $0x3,%ecx
f011ed22:	b8 00 00 00 00       	mov    $0x0,%eax
f011ed27:	89 d7                	mov    %edx,%edi
f011ed29:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 startOfFreedBlocks[2] = {0};
f011ed2b:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
f011ed32:	00 00 00 
f011ed35:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
f011ed3c:	00 00 00 
	uint32 endOfFreedBlocks[2] = {0};
f011ed3f:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
f011ed46:	00 00 00 
f011ed49:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%ebp)
f011ed50:	00 00 00 
	{
		//[PAGE ALLOCATOR]
		{
			uint32 startVA = BLOCK_ALLOC_LIMIT + PAGE_SIZE;
f011ed53:	c7 45 90 00 10 00 f8 	movl   $0xf8001000,-0x70(%ebp)

			//kfree 1st 4 MB
			int freeFrames = sys_calculate_free_frames() ;
f011ed5a:	e8 27 19 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011ed5f:	89 45 8c             	mov    %eax,-0x74(%ebp)
			int freeDiskFrames = pf_calculate_free_frames() ;
f011ed62:	e8 cc 6b fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ed67:	89 45 88             	mov    %eax,-0x78(%ebp)
			kfree(ptr_allocations[0]);
f011ed6a:	a1 60 c9 94 f0       	mov    0xf094c960,%eax
f011ed6f:	83 ec 0c             	sub    $0xc,%esp
f011ed72:	50                   	push   %eax
f011ed73:	e8 db c4 fe ff       	call   f010b253 <kfree>
f011ed78:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ed7b:	e8 b3 6b fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ed80:	3b 45 88             	cmp    -0x78(%ebp),%eax
f011ed83:	74 19                	je     f011ed9e <test_kheap_virt_addr+0x402>
f011ed85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ed8c:	83 ec 08             	sub    $0x8,%esp
f011ed8f:	68 30 ee 13 f0       	push   $0xf013ee30
f011ed94:	6a 0c                	push   $0xc
f011ed96:	e8 e2 2d fe ff       	call   f0101b7d <cprintf_colored>
f011ed9b:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < ROUNDUP(requestedSizes[0], PAGE_SIZE)/PAGE_SIZE ) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011ed9e:	e8 e3 18 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011eda3:	89 c2                	mov    %eax,%edx
f011eda5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011eda8:	89 d1                	mov    %edx,%ecx
f011edaa:	29 c1                	sub    %eax,%ecx
f011edac:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f011edb3:	8b 15 20 ca 94 f0    	mov    0xf094ca20,%edx
f011edb9:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011edbc:	01 d0                	add    %edx,%eax
f011edbe:	48                   	dec    %eax
f011edbf:	89 45 80             	mov    %eax,-0x80(%ebp)
f011edc2:	8b 45 80             	mov    -0x80(%ebp),%eax
f011edc5:	ba 00 00 00 00       	mov    $0x0,%edx
f011edca:	f7 75 84             	divl   -0x7c(%ebp)
f011edcd:	8b 45 80             	mov    -0x80(%ebp),%eax
f011edd0:	29 d0                	sub    %edx,%eax
f011edd2:	c1 e8 0c             	shr    $0xc,%eax
f011edd5:	39 c1                	cmp    %eax,%ecx
f011edd7:	73 19                	jae    f011edf2 <test_kheap_virt_addr+0x456>
f011edd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ede0:	83 ec 08             	sub    $0x8,%esp
f011ede3:	68 a0 ee 13 f0       	push   $0xf013eea0
f011ede8:	6a 0c                	push   $0xc
f011edea:	e8 8e 2d fe ff       	call   f0101b7d <cprintf_colored>
f011edef:	83 c4 10             	add    $0x10,%esp
			startOfFreedAreas[0] = startVA ;
f011edf2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011edf5:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
			endOfFreedAreas[0] = startOfFreedAreas[0] + ROUNDUP(requestedSizes[0], PAGE_SIZE) - 1;
f011edfb:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
f011ee01:	c7 85 7c ff ff ff 00 	movl   $0x1000,-0x84(%ebp)
f011ee08:	10 00 00 
f011ee0b:	8b 15 20 ca 94 f0    	mov    0xf094ca20,%edx
f011ee11:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011ee17:	01 d0                	add    %edx,%eax
f011ee19:	48                   	dec    %eax
f011ee1a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f011ee20:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ee26:	ba 00 00 00 00       	mov    $0x0,%edx
f011ee2b:	f7 b5 7c ff ff ff    	divl   -0x84(%ebp)
f011ee31:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ee37:	29 d0                	sub    %edx,%eax
f011ee39:	01 c8                	add    %ecx,%eax
f011ee3b:	48                   	dec    %eax
f011ee3c:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)

			//kfree 1st 2 MB
			freeFrames = sys_calculate_free_frames() ;
f011ee42:	e8 3f 18 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011ee47:	89 45 8c             	mov    %eax,-0x74(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ee4a:	e8 e4 6a fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ee4f:	89 45 88             	mov    %eax,-0x78(%ebp)
			kfree(ptr_allocations[2]);
f011ee52:	a1 68 c9 94 f0       	mov    0xf094c968,%eax
f011ee57:	83 ec 0c             	sub    $0xc,%esp
f011ee5a:	50                   	push   %eax
f011ee5b:	e8 f3 c3 fe ff       	call   f010b253 <kfree>
f011ee60:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ee63:	e8 cb 6a fe ff       	call   f0105933 <pf_calculate_free_frames>
f011ee68:	3b 45 88             	cmp    -0x78(%ebp),%eax
f011ee6b:	74 19                	je     f011ee86 <test_kheap_virt_addr+0x4ea>
f011ee6d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ee74:	83 ec 08             	sub    $0x8,%esp
f011ee77:	68 dc ee 13 f0       	push   $0xf013eedc
f011ee7c:	6a 0c                	push   $0xc
f011ee7e:	e8 fa 2c fe ff       	call   f0101b7d <cprintf_colored>
f011ee83:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < ROUNDUP(requestedSizes[2], PAGE_SIZE)/PAGE_SIZE) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011ee86:	e8 fb 17 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011ee8b:	89 c2                	mov    %eax,%edx
f011ee8d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ee90:	89 d1                	mov    %edx,%ecx
f011ee92:	29 c1                	sub    %eax,%ecx
f011ee94:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f011ee9b:	10 00 00 
f011ee9e:	8b 15 28 ca 94 f0    	mov    0xf094ca28,%edx
f011eea4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011eeaa:	01 d0                	add    %edx,%eax
f011eeac:	48                   	dec    %eax
f011eead:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f011eeb3:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011eeb9:	ba 00 00 00 00       	mov    $0x0,%edx
f011eebe:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f011eec4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011eeca:	29 d0                	sub    %edx,%eax
f011eecc:	c1 e8 0c             	shr    $0xc,%eax
f011eecf:	39 c1                	cmp    %eax,%ecx
f011eed1:	73 19                	jae    f011eeec <test_kheap_virt_addr+0x550>
f011eed3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eeda:	83 ec 08             	sub    $0x8,%esp
f011eedd:	68 4c ef 13 f0       	push   $0xf013ef4c
f011eee2:	6a 0c                	push   $0xc
f011eee4:	e8 94 2c fe ff       	call   f0101b7d <cprintf_colored>
f011eee9:	83 c4 10             	add    $0x10,%esp
			startOfFreedAreas[1] = startVA + ROUNDUP(requestedSizes[0], PAGE_SIZE) + ROUNDUP(requestedSizes[1], PAGE_SIZE) ;
f011eeec:	c7 85 6c ff ff ff 00 	movl   $0x1000,-0x94(%ebp)
f011eef3:	10 00 00 
f011eef6:	8b 15 20 ca 94 f0    	mov    0xf094ca20,%edx
f011eefc:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011ef02:	01 d0                	add    %edx,%eax
f011ef04:	48                   	dec    %eax
f011ef05:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
f011ef0b:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011ef11:	ba 00 00 00 00       	mov    $0x0,%edx
f011ef16:	f7 b5 6c ff ff ff    	divl   -0x94(%ebp)
f011ef1c:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011ef22:	29 d0                	sub    %edx,%eax
f011ef24:	89 c2                	mov    %eax,%edx
f011ef26:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ef29:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ef2c:	c7 85 64 ff ff ff 00 	movl   $0x1000,-0x9c(%ebp)
f011ef33:	10 00 00 
f011ef36:	8b 15 24 ca 94 f0    	mov    0xf094ca24,%edx
f011ef3c:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011ef42:	01 d0                	add    %edx,%eax
f011ef44:	48                   	dec    %eax
f011ef45:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
f011ef4b:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011ef51:	ba 00 00 00 00       	mov    $0x0,%edx
f011ef56:	f7 b5 64 ff ff ff    	divl   -0x9c(%ebp)
f011ef5c:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011ef62:	29 d0                	sub    %edx,%eax
f011ef64:	01 c8                	add    %ecx,%eax
f011ef66:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
			endOfFreedAreas[1] = startOfFreedAreas[1] + ROUNDUP(requestedSizes[2], PAGE_SIZE) - 1;
f011ef6c:	8b 8d 14 ff ff ff    	mov    -0xec(%ebp),%ecx
f011ef72:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f011ef79:	10 00 00 
f011ef7c:	8b 15 28 ca 94 f0    	mov    0xf094ca28,%edx
f011ef82:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011ef88:	01 d0                	add    %edx,%eax
f011ef8a:	48                   	dec    %eax
f011ef8b:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f011ef91:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011ef97:	ba 00 00 00 00       	mov    $0x0,%edx
f011ef9c:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f011efa2:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011efa8:	29 d0                	sub    %edx,%eax
f011efaa:	01 c8                	add    %ecx,%eax
f011efac:	48                   	dec    %eax
f011efad:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)

			//kfree 1st 1 MB
			freeFrames = sys_calculate_free_frames() ;
f011efb3:	e8 ce 16 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011efb8:	89 45 8c             	mov    %eax,-0x74(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011efbb:	e8 73 69 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011efc0:	89 45 88             	mov    %eax,-0x78(%ebp)
			kfree(ptr_allocations[4]);
f011efc3:	a1 70 c9 94 f0       	mov    0xf094c970,%eax
f011efc8:	83 ec 0c             	sub    $0xc,%esp
f011efcb:	50                   	push   %eax
f011efcc:	e8 82 c2 fe ff       	call   f010b253 <kfree>
f011efd1:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011efd4:	e8 5a 69 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011efd9:	3b 45 88             	cmp    -0x78(%ebp),%eax
f011efdc:	74 19                	je     f011eff7 <test_kheap_virt_addr+0x65b>
f011efde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011efe5:	83 ec 08             	sub    $0x8,%esp
f011efe8:	68 dc ee 13 f0       	push   $0xf013eedc
f011efed:	6a 0c                	push   $0xc
f011efef:	e8 89 2b fe ff       	call   f0101b7d <cprintf_colored>
f011eff4:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < ROUNDUP(requestedSizes[4], PAGE_SIZE)/PAGE_SIZE) { correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011eff7:	e8 8a 16 ff ff       	call   f0110686 <sys_calculate_free_frames>
f011effc:	89 c2                	mov    %eax,%edx
f011effe:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011f001:	89 d1                	mov    %edx,%ecx
f011f003:	29 c1                	sub    %eax,%ecx
f011f005:	c7 85 54 ff ff ff 00 	movl   $0x1000,-0xac(%ebp)
f011f00c:	10 00 00 
f011f00f:	8b 15 30 ca 94 f0    	mov    0xf094ca30,%edx
f011f015:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011f01b:	01 d0                	add    %edx,%eax
f011f01d:	48                   	dec    %eax
f011f01e:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
f011f024:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011f02a:	ba 00 00 00 00       	mov    $0x0,%edx
f011f02f:	f7 b5 54 ff ff ff    	divl   -0xac(%ebp)
f011f035:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011f03b:	29 d0                	sub    %edx,%eax
f011f03d:	c1 e8 0c             	shr    $0xc,%eax
f011f040:	39 c1                	cmp    %eax,%ecx
f011f042:	73 19                	jae    f011f05d <test_kheap_virt_addr+0x6c1>
f011f044:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f04b:	83 ec 08             	sub    $0x8,%esp
f011f04e:	68 4c ef 13 f0       	push   $0xf013ef4c
f011f053:	6a 0c                	push   $0xc
f011f055:	e8 23 2b fe ff       	call   f0101b7d <cprintf_colored>
f011f05a:	83 c4 10             	add    $0x10,%esp
			startOfFreedAreas[2] = startOfFreedAreas[1] + ROUNDUP(requestedSizes[2], PAGE_SIZE)+ ROUNDUP(requestedSizes[3], PAGE_SIZE) ;
f011f05d:	8b 8d 14 ff ff ff    	mov    -0xec(%ebp),%ecx
f011f063:	c7 85 4c ff ff ff 00 	movl   $0x1000,-0xb4(%ebp)
f011f06a:	10 00 00 
f011f06d:	8b 15 28 ca 94 f0    	mov    0xf094ca28,%edx
f011f073:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f079:	01 d0                	add    %edx,%eax
f011f07b:	48                   	dec    %eax
f011f07c:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
f011f082:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011f088:	ba 00 00 00 00       	mov    $0x0,%edx
f011f08d:	f7 b5 4c ff ff ff    	divl   -0xb4(%ebp)
f011f093:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011f099:	29 d0                	sub    %edx,%eax
f011f09b:	01 c1                	add    %eax,%ecx
f011f09d:	c7 85 44 ff ff ff 00 	movl   $0x1000,-0xbc(%ebp)
f011f0a4:	10 00 00 
f011f0a7:	8b 15 2c ca 94 f0    	mov    0xf094ca2c,%edx
f011f0ad:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011f0b3:	01 d0                	add    %edx,%eax
f011f0b5:	48                   	dec    %eax
f011f0b6:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
f011f0bc:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011f0c2:	ba 00 00 00 00       	mov    $0x0,%edx
f011f0c7:	f7 b5 44 ff ff ff    	divl   -0xbc(%ebp)
f011f0cd:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011f0d3:	29 d0                	sub    %edx,%eax
f011f0d5:	01 c8                	add    %ecx,%eax
f011f0d7:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
			endOfFreedAreas[2] = startOfFreedAreas[2] + ROUNDUP(requestedSizes[4], PAGE_SIZE) - 1 ;
f011f0dd:	8b 8d 18 ff ff ff    	mov    -0xe8(%ebp),%ecx
f011f0e3:	c7 85 3c ff ff ff 00 	movl   $0x1000,-0xc4(%ebp)
f011f0ea:	10 00 00 
f011f0ed:	8b 15 30 ca 94 f0    	mov    0xf094ca30,%edx
f011f0f3:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011f0f9:	01 d0                	add    %edx,%eax
f011f0fb:	48                   	dec    %eax
f011f0fc:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
f011f102:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011f108:	ba 00 00 00 00       	mov    $0x0,%edx
f011f10d:	f7 b5 3c ff ff ff    	divl   -0xc4(%ebp)
f011f113:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011f119:	29 d0                	sub    %edx,%eax
f011f11b:	01 c8                	add    %ecx,%eax
f011f11d:	48                   	dec    %eax
f011f11e:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
		}
		//[BLOCK ALLOCATOR]
		int idx;
		{
			//kfree 8B blocks (except one block of boot-time)
			idx = 0;
f011f124:	c7 85 34 ff ff ff 00 	movl   $0x0,-0xcc(%ebp)
f011f12b:	00 00 00 
			for (int s = 1; s <= 8; ++s)
f011f12e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
f011f135:	eb 36                	jmp    f011f16d <test_kheap_virt_addr+0x7d1>
			{
				free_block(startBlockVAs[s]);
f011f137:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f13a:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011f141:	83 ec 0c             	sub    $0xc,%esp
f011f144:	50                   	push   %eax
f011f145:	e8 97 50 00 00       	call   f01241e1 <free_block>
f011f14a:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011f14d:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f153:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011f15a:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f15d:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f163:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
		//[BLOCK ALLOCATOR]
		int idx;
		{
			//kfree 8B blocks (except one block of boot-time)
			idx = 0;
			for (int s = 1; s <= 8; ++s)
f011f16a:	ff 45 dc             	incl   -0x24(%ebp)
f011f16d:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
f011f171:	7e c4                	jle    f011f137 <test_kheap_virt_addr+0x79b>
			{
				free_block(startBlockVAs[s]);
				numOfAllocBlocksPerSize[idx]--;
			}
			assert(numOfAllocBlocksPerSize[idx] == 1);
f011f173:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f179:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011f180:	83 f8 01             	cmp    $0x1,%eax
f011f183:	74 19                	je     f011f19e <test_kheap_virt_addr+0x802>
f011f185:	68 88 ef 13 f0       	push   $0xf013ef88
f011f18a:	68 aa ef 13 f0       	push   $0xf013efaa
f011f18f:	68 a3 07 00 00       	push   $0x7a3
f011f194:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f199:	e8 11 1d fe ff       	call   f0100eaf <_panic>

			//kfree 64B blocks
			idx = 3;
f011f19e:	c7 85 34 ff ff ff 03 	movl   $0x3,-0xcc(%ebp)
f011f1a5:	00 00 00 
			for (int s = 33; s <= 64; ++s)
f011f1a8:	c7 45 d8 21 00 00 00 	movl   $0x21,-0x28(%ebp)
f011f1af:	eb 36                	jmp    f011f1e7 <test_kheap_virt_addr+0x84b>
			{
				free_block(startBlockVAs[s]);
f011f1b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f1b4:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011f1bb:	83 ec 0c             	sub    $0xc,%esp
f011f1be:	50                   	push   %eax
f011f1bf:	e8 1d 50 00 00       	call   f01241e1 <free_block>
f011f1c4:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011f1c7:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f1cd:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011f1d4:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f1d7:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f1dd:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			}
			assert(numOfAllocBlocksPerSize[idx] == 1);

			//kfree 64B blocks
			idx = 3;
			for (int s = 33; s <= 64; ++s)
f011f1e4:	ff 45 d8             	incl   -0x28(%ebp)
f011f1e7:	83 7d d8 40          	cmpl   $0x40,-0x28(%ebp)
f011f1eb:	7e c4                	jle    f011f1b1 <test_kheap_virt_addr+0x815>
			{
				free_block(startBlockVAs[s]);
				numOfAllocBlocksPerSize[idx]--;
			}
			assert(numOfAllocBlocksPerSize[idx] == 0);
f011f1ed:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f1f3:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011f1fa:	85 c0                	test   %eax,%eax
f011f1fc:	74 19                	je     f011f217 <test_kheap_virt_addr+0x87b>
f011f1fe:	68 c0 ef 13 f0       	push   $0xf013efc0
f011f203:	68 aa ef 13 f0       	push   $0xf013efaa
f011f208:	68 ac 07 00 00       	push   $0x7ac
f011f20d:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f212:	e8 98 1c fe ff       	call   f0100eaf <_panic>
			startOfFreedBlocks[0] = 33;
f011f217:	c7 85 fc fe ff ff 21 	movl   $0x21,-0x104(%ebp)
f011f21e:	00 00 00 
			endOfFreedBlocks[0] = 64;
f011f221:	c7 85 f4 fe ff ff 40 	movl   $0x40,-0x10c(%ebp)
f011f228:	00 00 00 

			//kfree 256B blocks
			idx = 5;
f011f22b:	c7 85 34 ff ff ff 05 	movl   $0x5,-0xcc(%ebp)
f011f232:	00 00 00 
			for (int s = 129; s <= 256; ++s)
f011f235:	c7 45 d4 81 00 00 00 	movl   $0x81,-0x2c(%ebp)
f011f23c:	eb 36                	jmp    f011f274 <test_kheap_virt_addr+0x8d8>
			{
				free_block(startBlockVAs[s]);
f011f23e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011f241:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011f248:	83 ec 0c             	sub    $0xc,%esp
f011f24b:	50                   	push   %eax
f011f24c:	e8 90 4f 00 00       	call   f01241e1 <free_block>
f011f251:	83 c4 10             	add    $0x10,%esp
				numOfAllocBlocksPerSize[idx]--;
f011f254:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f25a:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011f261:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f264:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f26a:	89 14 85 80 ca 94 f1 	mov    %edx,-0xe6b3580(,%eax,4)
			startOfFreedBlocks[0] = 33;
			endOfFreedBlocks[0] = 64;

			//kfree 256B blocks
			idx = 5;
			for (int s = 129; s <= 256; ++s)
f011f271:	ff 45 d4             	incl   -0x2c(%ebp)
f011f274:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
f011f27b:	7e c1                	jle    f011f23e <test_kheap_virt_addr+0x8a2>
			{
				free_block(startBlockVAs[s]);
				numOfAllocBlocksPerSize[idx]--;
			}
			assert(numOfAllocBlocksPerSize[idx] == 0);
f011f27d:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f283:	8b 04 85 80 ca 94 f1 	mov    -0xe6b3580(,%eax,4),%eax
f011f28a:	85 c0                	test   %eax,%eax
f011f28c:	74 19                	je     f011f2a7 <test_kheap_virt_addr+0x90b>
f011f28e:	68 c0 ef 13 f0       	push   $0xf013efc0
f011f293:	68 aa ef 13 f0       	push   $0xf013efaa
f011f298:	68 b7 07 00 00       	push   $0x7b7
f011f29d:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f2a2:	e8 08 1c fe ff       	call   f0100eaf <_panic>
			startOfFreedBlocks[1] = 129;
f011f2a7:	c7 85 00 ff ff ff 81 	movl   $0x81,-0x100(%ebp)
f011f2ae:	00 00 00 
			endOfFreedBlocks[1] = 256;
f011f2b1:	c7 85 f8 fe ff ff 00 	movl   $0x100,-0x108(%ebp)
f011f2b8:	01 00 00 
		}
	}

	//5. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree
	cprintf_colored(TEXT_cyan,"\n5. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [25%]\n");
f011f2bb:	83 ec 08             	sub    $0x8,%esp
f011f2be:	68 5c f4 13 f0       	push   $0xf013f45c
f011f2c3:	6a 03                	push   $0x3
f011f2c5:	e8 b3 28 fe ff       	call   f0101b7d <cprintf_colored>
f011f2ca:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011f2cd:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START;
f011f2d4:	c7 45 d0 00 10 00 f8 	movl   $0xf8001000,-0x30(%ebp)
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
f011f2db:	a1 80 79 9a f1       	mov    0xf19a7980,%eax
f011f2e0:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011f2e5:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		uint32 i = 0;
f011f2eb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)

		for (i = 0 ; i < numOfFrames; ++i)
f011f2f2:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f011f2f9:	e9 97 00 00 00       	jmp    f011f395 <test_kheap_virt_addr+0x9f9>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011f2fe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f301:	8b 04 85 80 79 98 f1 	mov    -0xe678680(,%eax,4),%eax
f011f308:	83 ec 0c             	sub    $0xc,%esp
f011f30b:	50                   	push   %eax
f011f30c:	e8 0f c1 fe ff       	call   f010b420 <kheap_virtual_address>
f011f311:	83 c4 10             	add    $0x10,%esp
f011f314:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
			uint32 expectedVA ;
			if (isVAInsideFreedAreas(startVA, startOfFreedAreas, endOfFreedAreas, 3))
f011f31a:	6a 03                	push   $0x3
f011f31c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011f322:	50                   	push   %eax
f011f323:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f011f329:	50                   	push   %eax
f011f32a:	ff 75 d0             	pushl  -0x30(%ebp)
f011f32d:	e8 bf e8 ff ff       	call   f011dbf1 <isVAInsideFreedAreas>
f011f332:	83 c4 10             	add    $0x10,%esp
f011f335:	85 c0                	test   %eax,%eax
f011f337:	74 09                	je     f011f342 <test_kheap_virt_addr+0x9a6>
			{
				expectedVA = 0;
f011f339:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011f340:	eb 19                	jmp    f011f35b <test_kheap_virt_addr+0x9bf>
			}
			else
			{
				expectedVA = (startVA + (allPAs[i] & 0xFFF));
f011f342:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f345:	8b 04 85 80 79 98 f1 	mov    -0xe678680(,%eax,4),%eax
f011f34c:	25 ff 0f 00 00       	and    $0xfff,%eax
f011f351:	89 c2                	mov    %eax,%edx
f011f353:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f356:	01 d0                	add    %edx,%eax
f011f358:	89 45 c8             	mov    %eax,-0x38(%ebp)
			}
			if (retrievedVA != expectedVA)
f011f35b:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011f361:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011f364:	74 25                	je     f011f38b <test_kheap_virt_addr+0x9ef>
			{
				if (correct)
f011f366:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f36a:	74 1f                	je     f011f38b <test_kheap_virt_addr+0x9ef>
				{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"5.1 Wrong kheap_virtual_address. Expected = %x, Actual = %x\n", expectedVA, retrievedVA); }
f011f36c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f373:	ff b5 2c ff ff ff    	pushl  -0xd4(%ebp)
f011f379:	ff 75 c8             	pushl  -0x38(%ebp)
f011f37c:	68 ac f4 13 f0       	push   $0xf013f4ac
f011f381:	6a 0c                	push   $0xc
f011f383:	e8 f5 27 fe ff       	call   f0101b7d <cprintf_colored>
f011f388:	83 c4 10             	add    $0x10,%esp
			}
			startVA += PAGE_SIZE;
f011f38b:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
		uint32 va;
		uint32 startVA = ACTUAL_PAGE_ALLOC_START;
		uint32 endVA = ACTUAL_PAGE_ALLOC_START + totalRequestedSize;
		uint32 i = 0;

		for (i = 0 ; i < numOfFrames; ++i)
f011f392:	ff 45 cc             	incl   -0x34(%ebp)
f011f395:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f398:	39 45 cc             	cmp    %eax,-0x34(%ebp)
f011f39b:	0f 82 5d ff ff ff    	jb     f011f2fe <test_kheap_virt_addr+0x962>
				{ correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"5.1 Wrong kheap_virtual_address. Expected = %x, Actual = %x\n", expectedVA, retrievedVA); }
			}
			startVA += PAGE_SIZE;
		}
	}
	if (correct)	eval+=25 ;
f011f3a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f3a5:	74 04                	je     f011f3ab <test_kheap_virt_addr+0xa0f>
f011f3a7:	83 45 f0 19          	addl   $0x19,-0x10(%ebp)

	//6. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc and kfree
	cprintf_colored(TEXT_cyan,"\n6. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [25%]\n");
f011f3ab:	83 ec 08             	sub    $0x8,%esp
f011f3ae:	68 ec f4 13 f0       	push   $0xf013f4ec
f011f3b3:	6a 03                	push   $0x3
f011f3b5:	e8 c3 27 fe ff       	call   f0101b7d <cprintf_colored>
f011f3ba:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011f3bd:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	{
		uint32 va, pa;
		for (int i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011f3c4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
f011f3cb:	e9 0e 01 00 00       	jmp    f011f4de <test_kheap_virt_addr+0xb42>
		{
			va = (uint32)startBlockVAs[i];
f011f3d0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011f3d3:	8b 04 85 80 ca 94 f0 	mov    -0xf6b3580(,%eax,4),%eax
f011f3da:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)

			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011f3e0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f011f3e5:	83 ec 04             	sub    $0x4,%esp
f011f3e8:	8d 95 e8 fe ff ff    	lea    -0x118(%ebp),%edx
f011f3ee:	52                   	push   %edx
f011f3ef:	ff b5 28 ff ff ff    	pushl  -0xd8(%ebp)
f011f3f5:	50                   	push   %eax
f011f3f6:	e8 6c a4 fe ff       	call   f0109867 <get_page_table>
f011f3fb:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011f3fe:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011f404:	85 c0                	test   %eax,%eax
f011f406:	75 1e                	jne    f011f426 <test_kheap_virt_addr+0xa8a>
			{ correct = 0; panic("6.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011f408:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f40f:	83 ec 04             	sub    $0x4,%esp
f011f412:	68 0c f1 13 f0       	push   $0xf013f10c
f011f417:	68 e8 07 00 00       	push   $0x7e8
f011f41c:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f421:	e8 89 1a fe ff       	call   f0100eaf <_panic>

			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011f426:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011f42c:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011f432:	c1 ea 0c             	shr    $0xc,%edx
f011f435:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011f43b:	c1 e2 02             	shl    $0x2,%edx
f011f43e:	01 d0                	add    %edx,%eax
f011f440:	8b 00                	mov    (%eax),%eax
f011f442:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f447:	89 c2                	mov    %eax,%edx
f011f449:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011f44f:	25 ff 0f 00 00       	and    $0xfff,%eax
f011f454:	01 d0                	add    %edx,%eax
f011f456:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)

			uint32 retrievedVA = kheap_virtual_address(pa);
f011f45c:	83 ec 0c             	sub    $0xc,%esp
f011f45f:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
f011f465:	e8 b6 bf fe ff       	call   f010b420 <kheap_virtual_address>
f011f46a:	83 c4 10             	add    $0x10,%esp
f011f46d:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)

			uint32 expectedVA;
			if (isVAInsideFreedAreas(i, startOfFreedBlocks, endOfFreedBlocks, 2))
f011f473:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011f476:	6a 02                	push   $0x2
f011f478:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
f011f47e:	52                   	push   %edx
f011f47f:	8d 95 fc fe ff ff    	lea    -0x104(%ebp),%edx
f011f485:	52                   	push   %edx
f011f486:	50                   	push   %eax
f011f487:	e8 65 e7 ff ff       	call   f011dbf1 <isVAInsideFreedAreas>
f011f48c:	83 c4 10             	add    $0x10,%esp
f011f48f:	85 c0                	test   %eax,%eax
f011f491:	74 09                	je     f011f49c <test_kheap_virt_addr+0xb00>
			{
				expectedVA = 0 ;
f011f493:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f011f49a:	eb 09                	jmp    f011f4a5 <test_kheap_virt_addr+0xb09>
			}
			else
			{
				expectedVA = va;
f011f49c:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011f4a2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			}
			if (expectedVA != retrievedVA)
f011f4a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f4a8:	3b 85 20 ff ff ff    	cmp    -0xe0(%ebp),%eax
f011f4ae:	74 2b                	je     f011f4db <test_kheap_virt_addr+0xb3f>
			{
				if (correct)
f011f4b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f4b4:	74 25                	je     f011f4db <test_kheap_virt_addr+0xb3f>
				{
					correct = 0;
f011f4b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					cprintf_colored(TEXT_TESTERR_CLR,"6.2 Wrong kheap_virtual_address at block size %d! Expected = %x, Actual = %x\n", i, expectedVA, retrievedVA);
f011f4bd:	83 ec 0c             	sub    $0xc,%esp
f011f4c0:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
f011f4c6:	ff 75 c0             	pushl  -0x40(%ebp)
f011f4c9:	ff 75 c4             	pushl  -0x3c(%ebp)
f011f4cc:	68 3c f5 13 f0       	push   $0xf013f53c
f011f4d1:	6a 0c                	push   $0xc
f011f4d3:	e8 a5 26 fe ff       	call   f0101b7d <cprintf_colored>
f011f4d8:	83 c4 20             	add    $0x20,%esp
	//6. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc and kfree
	cprintf_colored(TEXT_cyan,"\n6. [BLOCK ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [25%]\n");
	correct = 1 ;
	{
		uint32 va, pa;
		for (int i = 1; i <= DYN_ALLOC_MAX_BLOCK_SIZE; i++)
f011f4db:	ff 45 c4             	incl   -0x3c(%ebp)
f011f4de:	81 7d c4 00 08 00 00 	cmpl   $0x800,-0x3c(%ebp)
f011f4e5:	0f 8e e5 fe ff ff    	jle    f011f3d0 <test_kheap_virt_addr+0xa34>
					cprintf_colored(TEXT_TESTERR_CLR,"6.2 Wrong kheap_virtual_address at block size %d! Expected = %x, Actual = %x\n", i, expectedVA, retrievedVA);
				}
			}
		}
	}
	if (correct)	eval+=25 ;
f011f4eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f4ef:	74 04                	je     f011f4f5 <test_kheap_virt_addr+0xb59>
f011f4f1:	83 45 f0 19          	addl   $0x19,-0x10(%ebp)

	correct = 1 ;
f011f4f5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	//7. test kheap_virtual_address on frames of KERNEL CODE
	cprintf_colored(TEXT_cyan,"\n6. test kheap_virtual_address on frames of KERNEL CODE [10%]\n");
f011f4fc:	83 ec 08             	sub    $0x8,%esp
f011f4ff:	68 8c f5 13 f0       	push   $0xf013f58c
f011f504:	6a 03                	push   $0x3
f011f506:	e8 72 26 fe ff       	call   f0101b7d <cprintf_colored>
f011f50b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011f50e:	c7 45 bc 00 00 10 00 	movl   $0x100000,-0x44(%ebp)
f011f515:	eb 5b                	jmp    f011f572 <test_kheap_virt_addr+0xbd6>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011f517:	83 ec 0c             	sub    $0xc,%esp
f011f51a:	ff 75 bc             	pushl  -0x44(%ebp)
f011f51d:	e8 fe be fe ff       	call   f010b420 <kheap_virtual_address>
f011f522:	83 c4 10             	add    $0x10,%esp
f011f525:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
			if (retrievedVA != 0)
f011f52b:	83 bd 1c ff ff ff 00 	cmpl   $0x0,-0xe4(%ebp)
f011f532:	74 37                	je     f011f56b <test_kheap_virt_addr+0xbcf>
			{
				if (correct)
f011f534:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f538:	74 31                	je     f011f56b <test_kheap_virt_addr+0xbcf>
				{
					cprintf_colored(TEXT_TESTERR_CLR,"\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011f53a:	ff b5 1c ff ff ff    	pushl  -0xe4(%ebp)
f011f540:	ff 75 bc             	pushl  -0x44(%ebp)
f011f543:	68 cb f5 13 f0       	push   $0xf013f5cb
f011f548:	6a 0c                	push   $0xc
f011f54a:	e8 2e 26 fe ff       	call   f0101b7d <cprintf_colored>
f011f54f:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"7.1 Wrong kheap_virtual_address\n");
f011f552:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f559:	83 ec 08             	sub    $0x8,%esp
f011f55c:	68 e8 f5 13 f0       	push   $0xf013f5e8
f011f561:	6a 0c                	push   $0xc
f011f563:	e8 15 26 fe ff       	call   f0101b7d <cprintf_colored>
f011f568:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//7. test kheap_virtual_address on frames of KERNEL CODE
	cprintf_colored(TEXT_cyan,"\n6. test kheap_virtual_address on frames of KERNEL CODE [10%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011f56b:	81 45 bc 00 10 00 00 	addl   $0x1000,-0x44(%ebp)
f011f572:	b8 d0 85 9a 01       	mov    $0x19a85d0,%eax
f011f577:	39 45 bc             	cmp    %eax,-0x44(%ebp)
f011f57a:	72 9b                	jb     f011f517 <test_kheap_virt_addr+0xb7b>
					correct = 0; cprintf_colored(TEXT_TESTERR_CLR,"7.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011f57c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f580:	74 04                	je     f011f586 <test_kheap_virt_addr+0xbea>
f011f582:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf_colored(TEXT_light_green,"\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011f586:	83 ec 04             	sub    $0x4,%esp
f011f589:	ff 75 f0             	pushl  -0x10(%ebp)
f011f58c:	68 0c f6 13 f0       	push   $0xf013f60c
f011f591:	6a 0a                	push   $0xa
f011f593:	e8 e5 25 fe ff       	call   f0101b7d <cprintf_colored>
f011f598:	83 c4 10             	add    $0x10,%esp

	return 1;
f011f59b:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011f5a0:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011f5a3:	c9                   	leave  
f011f5a4:	c3                   	ret    

f011f5a5 <test_krealloc_FF_page>:

/**********************************************************************************************/
/********************************** KREALLOC TESTING AREA *************************************/
/**********************************************************************************************/
int test_krealloc_FF_page()
{
f011f5a5:	55                   	push   %ebp
f011f5a6:	89 e5                	mov    %esp,%ebp
f011f5a8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f5ab:	83 ec 04             	sub    $0x4,%esp
f011f5ae:	68 71 dd 13 f0       	push   $0xf013dd71
f011f5b3:	68 23 08 00 00       	push   $0x823
f011f5b8:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f5bd:	e8 ed 18 fe ff       	call   f0100eaf <_panic>

f011f5c2 <test_krealloc_NF_page>:
}
int test_krealloc_NF_page()
{
f011f5c2:	55                   	push   %ebp
f011f5c3:	89 e5                	mov    %esp,%ebp
f011f5c5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f5c8:	83 ec 04             	sub    $0x4,%esp
f011f5cb:	68 71 dd 13 f0       	push   $0xf013dd71
f011f5d0:	68 27 08 00 00       	push   $0x827
f011f5d5:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f5da:	e8 d0 18 fe ff       	call   f0100eaf <_panic>

f011f5df <test_krealloc_BF_page>:
}
int test_krealloc_BF_page()
{
f011f5df:	55                   	push   %ebp
f011f5e0:	89 e5                	mov    %esp,%ebp
f011f5e2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f5e5:	83 ec 04             	sub    $0x4,%esp
f011f5e8:	68 71 dd 13 f0       	push   $0xf013dd71
f011f5ed:	68 2b 08 00 00       	push   $0x82b
f011f5f2:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f5f7:	e8 b3 18 fe ff       	call   f0100eaf <_panic>

f011f5fc <test_krealloc_WF_page>:
}
int test_krealloc_WF_page()
{
f011f5fc:	55                   	push   %ebp
f011f5fd:	89 e5                	mov    %esp,%ebp
f011f5ff:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f602:	83 ec 04             	sub    $0x4,%esp
f011f605:	68 71 dd 13 f0       	push   $0xf013dd71
f011f60a:	68 2f 08 00 00       	push   $0x82f
f011f60f:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f614:	e8 96 18 fe ff       	call   f0100eaf <_panic>

f011f619 <test_krealloc_CF_page>:
}
int test_krealloc_CF_page()
{
f011f619:	55                   	push   %ebp
f011f61a:	89 e5                	mov    %esp,%ebp
f011f61c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f61f:	83 ec 04             	sub    $0x4,%esp
f011f622:	68 71 dd 13 f0       	push   $0xf013dd71
f011f627:	68 33 08 00 00       	push   $0x833
f011f62c:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f631:	e8 79 18 fe ff       	call   f0100eaf <_panic>

f011f636 <test_krealloc_FF_block>:
}

int test_krealloc_FF_block()
{
f011f636:	55                   	push   %ebp
f011f637:	89 e5                	mov    %esp,%ebp
f011f639:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f63c:	83 ec 04             	sub    $0x4,%esp
f011f63f:	68 71 dd 13 f0       	push   $0xf013dd71
f011f644:	68 38 08 00 00       	push   $0x838
f011f649:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f64e:	e8 5c 18 fe ff       	call   f0100eaf <_panic>

f011f653 <test_krealloc_NF_block>:
}
int test_krealloc_NF_block()
{
f011f653:	55                   	push   %ebp
f011f654:	89 e5                	mov    %esp,%ebp
f011f656:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f659:	83 ec 04             	sub    $0x4,%esp
f011f65c:	68 71 dd 13 f0       	push   $0xf013dd71
f011f661:	68 3c 08 00 00       	push   $0x83c
f011f666:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f66b:	e8 3f 18 fe ff       	call   f0100eaf <_panic>

f011f670 <test_krealloc_BF_block>:
}
int test_krealloc_BF_block()
{
f011f670:	55                   	push   %ebp
f011f671:	89 e5                	mov    %esp,%ebp
f011f673:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f676:	83 ec 04             	sub    $0x4,%esp
f011f679:	68 71 dd 13 f0       	push   $0xf013dd71
f011f67e:	68 40 08 00 00       	push   $0x840
f011f683:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f688:	e8 22 18 fe ff       	call   f0100eaf <_panic>

f011f68d <test_krealloc_WF_block>:
}
int test_krealloc_WF_block()
{
f011f68d:	55                   	push   %ebp
f011f68e:	89 e5                	mov    %esp,%ebp
f011f690:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f693:	83 ec 04             	sub    $0x4,%esp
f011f696:	68 71 dd 13 f0       	push   $0xf013dd71
f011f69b:	68 44 08 00 00       	push   $0x844
f011f6a0:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f6a5:	e8 05 18 fe ff       	call   f0100eaf <_panic>

f011f6aa <test_krealloc_CF_block>:
}
int test_krealloc_CF_block()
{
f011f6aa:	55                   	push   %ebp
f011f6ab:	89 e5                	mov    %esp,%ebp
f011f6ad:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f6b0:	83 ec 04             	sub    $0x4,%esp
f011f6b3:	68 71 dd 13 f0       	push   $0xf013dd71
f011f6b8:	68 48 08 00 00       	push   $0x848
f011f6bd:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f6c2:	e8 e8 17 fe ff       	call   f0100eaf <_panic>

f011f6c7 <test_krealloc_FF_both>:
}

int test_krealloc_FF_both()
{
f011f6c7:	55                   	push   %ebp
f011f6c8:	89 e5                	mov    %esp,%ebp
f011f6ca:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f6cd:	83 ec 04             	sub    $0x4,%esp
f011f6d0:	68 71 dd 13 f0       	push   $0xf013dd71
f011f6d5:	68 4d 08 00 00       	push   $0x84d
f011f6da:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f6df:	e8 cb 17 fe ff       	call   f0100eaf <_panic>

f011f6e4 <test_krealloc_NF_both>:
}
int test_krealloc_NF_both()
{
f011f6e4:	55                   	push   %ebp
f011f6e5:	89 e5                	mov    %esp,%ebp
f011f6e7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f6ea:	83 ec 04             	sub    $0x4,%esp
f011f6ed:	68 71 dd 13 f0       	push   $0xf013dd71
f011f6f2:	68 51 08 00 00       	push   $0x851
f011f6f7:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f6fc:	e8 ae 17 fe ff       	call   f0100eaf <_panic>

f011f701 <test_krealloc_BF_both>:
}
int test_krealloc_BF_both()
{
f011f701:	55                   	push   %ebp
f011f702:	89 e5                	mov    %esp,%ebp
f011f704:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f707:	83 ec 04             	sub    $0x4,%esp
f011f70a:	68 71 dd 13 f0       	push   $0xf013dd71
f011f70f:	68 55 08 00 00       	push   $0x855
f011f714:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f719:	e8 91 17 fe ff       	call   f0100eaf <_panic>

f011f71e <test_krealloc_WF_both>:
}
int test_krealloc_WF_both()
{
f011f71e:	55                   	push   %ebp
f011f71f:	89 e5                	mov    %esp,%ebp
f011f721:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f724:	83 ec 04             	sub    $0x4,%esp
f011f727:	68 71 dd 13 f0       	push   $0xf013dd71
f011f72c:	68 59 08 00 00       	push   $0x859
f011f731:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f736:	e8 74 17 fe ff       	call   f0100eaf <_panic>

f011f73b <test_krealloc_CF_both>:
}
int test_krealloc_CF_both()
{
f011f73b:	55                   	push   %ebp
f011f73c:	89 e5                	mov    %esp,%ebp
f011f73e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f741:	83 ec 04             	sub    $0x4,%esp
f011f744:	68 71 dd 13 f0       	push   $0xf013dd71
f011f749:	68 5d 08 00 00       	push   $0x85d
f011f74e:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f753:	e8 57 17 fe ff       	call   f0100eaf <_panic>

f011f758 <test_fast_FF>:

/**********************************************************************************************/
/*************************** FAST PAGE ALLOCATOR TESTING AREA *********************************/
/**********************************************************************************************/
int test_fast_FF()
{
f011f758:	55                   	push   %ebp
f011f759:	89 e5                	mov    %esp,%ebp
f011f75b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f75e:	83 ec 04             	sub    $0x4,%esp
f011f761:	68 71 dd 13 f0       	push   $0xf013dd71
f011f766:	68 65 08 00 00       	push   $0x865
f011f76b:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f770:	e8 3a 17 fe ff       	call   f0100eaf <_panic>

f011f775 <test_fast_NF>:
}
int test_fast_NF()
{
f011f775:	55                   	push   %ebp
f011f776:	89 e5                	mov    %esp,%ebp
f011f778:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f77b:	83 ec 04             	sub    $0x4,%esp
f011f77e:	68 71 dd 13 f0       	push   $0xf013dd71
f011f783:	68 69 08 00 00       	push   $0x869
f011f788:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f78d:	e8 1d 17 fe ff       	call   f0100eaf <_panic>

f011f792 <test_fast_BF>:
}
int test_fast_BF()
{
f011f792:	55                   	push   %ebp
f011f793:	89 e5                	mov    %esp,%ebp
f011f795:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f798:	83 ec 04             	sub    $0x4,%esp
f011f79b:	68 71 dd 13 f0       	push   $0xf013dd71
f011f7a0:	68 6d 08 00 00       	push   $0x86d
f011f7a5:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f7aa:	e8 00 17 fe ff       	call   f0100eaf <_panic>

f011f7af <test_fast_WF>:
}
int test_fast_WF()
{
f011f7af:	55                   	push   %ebp
f011f7b0:	89 e5                	mov    %esp,%ebp
f011f7b2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f7b5:	83 ec 04             	sub    $0x4,%esp
f011f7b8:	68 71 dd 13 f0       	push   $0xf013dd71
f011f7bd:	68 71 08 00 00       	push   $0x871
f011f7c2:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f7c7:	e8 e3 16 fe ff       	call   f0100eaf <_panic>

f011f7cc <test_fast_CF>:
}
int test_fast_CF()
{
f011f7cc:	55                   	push   %ebp
f011f7cd:	89 e5                	mov    %esp,%ebp
f011f7cf:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f7d2:	83 ec 04             	sub    $0x4,%esp
f011f7d5:	68 71 dd 13 f0       	push   $0xf013dd71
f011f7da:	68 75 08 00 00       	push   $0x875
f011f7df:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f7e4:	e8 c6 16 fe ff       	call   f0100eaf <_panic>

f011f7e9 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011f7e9:	55                   	push   %ebp
f011f7ea:	89 e5                	mov    %esp,%ebp
f011f7ec:	57                   	push   %edi
f011f7ed:	56                   	push   %esi
f011f7ee:	53                   	push   %ebx
f011f7ef:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011f7f5:	a0 85 81 19 f0       	mov    0xf0198185,%al
f011f7fa:	84 c0                	test   %al,%al
f011f7fc:	74 56                	je     f011f854 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011f7fe:	c6 05 85 81 19 f0 00 	movb   $0x0,0xf0198185
		initFreeFrames = sys_calculate_free_frames() ;
f011f805:	e8 7c 0e ff ff       	call   f0110686 <sys_calculate_free_frames>
f011f80a:	a3 88 79 9a f1       	mov    %eax,0xf19a7988
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011f80f:	e8 1f 61 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011f814:	a3 84 79 9a f1       	mov    %eax,0xf19a7984
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011f819:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011f81f:	bb fd f7 13 f0       	mov    $0xf013f7fd,%ebx
f011f824:	ba 11 00 00 00       	mov    $0x11,%edx
f011f829:	89 c7                	mov    %eax,%edi
f011f82b:	89 de                	mov    %ebx,%esi
f011f82d:	89 d1                	mov    %edx,%ecx
f011f82f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011f831:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011f837:	b9 53 00 00 00       	mov    $0x53,%ecx
f011f83c:	b0 00                	mov    $0x0,%al
f011f83e:	89 d7                	mov    %edx,%edi
f011f840:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011f842:	83 ec 0c             	sub    $0xc,%esp
f011f845:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011f84b:	50                   	push   %eax
f011f84c:	e8 bb 25 fe ff       	call   f0101e0c <execute_command>
f011f851:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011f854:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011f85b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011f862:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f011f867:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f86a:	eb 2b                	jmp    f011f897 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011f86c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f86f:	83 c0 20             	add    $0x20,%eax
f011f872:	83 ec 08             	sub    $0x8,%esp
f011f875:	68 3f f6 13 f0       	push   $0xf013f63f
f011f87a:	50                   	push   %eax
f011f87b:	e8 bb 36 00 00       	call   f0122f3b <strcmp>
f011f880:	83 c4 10             	add    $0x10,%esp
f011f883:	85 c0                	test   %eax,%eax
f011f885:	75 08                	jne    f011f88f <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011f887:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f88a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011f88d:	eb 2f                	jmp    f011f8be <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011f88f:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f011f894:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f897:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f89b:	74 08                	je     f011f8a5 <test_three_creation_functions+0xbc>
f011f89d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f8a0:	8b 40 08             	mov    0x8(%eax),%eax
f011f8a3:	eb 05                	jmp    f011f8aa <test_three_creation_functions+0xc1>
f011f8a5:	b8 00 00 00 00       	mov    $0x0,%eax
f011f8aa:	a3 48 ce 94 f1       	mov    %eax,0xf194ce48
f011f8af:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f011f8b4:	85 c0                	test   %eax,%eax
f011f8b6:	75 b4                	jne    f011f86c <test_three_creation_functions+0x83>
f011f8b8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f8bc:	75 ae                	jne    f011f86c <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011f8be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f8c1:	8b 80 78 06 00 00    	mov    0x678(%eax),%eax
f011f8c7:	85 c0                	test   %eax,%eax
f011f8c9:	74 17                	je     f011f8e2 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011f8cb:	83 ec 04             	sub    $0x4,%esp
f011f8ce:	68 48 f6 13 f0       	push   $0xf013f648
f011f8d3:	68 9c 08 00 00       	push   $0x89c
f011f8d8:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f8dd:	e8 cd 15 fe ff       	call   f0100eaf <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011f8e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f8e5:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011f8eb:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011f8ee:	e8 93 0d ff ff       	call   f0110686 <sys_calculate_free_frames>
f011f8f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011f8f6:	e8 38 60 fe ff       	call   f0105933 <pf_calculate_free_frames>
f011f8fb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf_colored(TEXT_TESTERR_CLR,"\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f8fe:	a1 84 79 9a f1       	mov    0xf19a7984,%eax
f011f903:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011f906:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f909:	74 17                	je     f011f922 <test_three_creation_functions+0x139>
f011f90b:	83 ec 04             	sub    $0x4,%esp
f011f90e:	68 98 f6 13 f0       	push   $0xf013f698
f011f913:	68 a6 08 00 00       	push   $0x8a6
f011f918:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f91d:	e8 8d 15 fe ff       	call   f0100eaf <_panic>
		//cprintf_colored(TEXT_TESTERR_CLR,"\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011f922:	a1 88 79 9a f1       	mov    0xf19a7988,%eax
f011f927:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011f92a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011f92d:	83 c2 15             	add    $0x15,%edx
f011f930:	39 d0                	cmp    %edx,%eax
f011f932:	74 17                	je     f011f94b <test_three_creation_functions+0x162>
f011f934:	83 ec 04             	sub    $0x4,%esp
f011f937:	68 00 f7 13 f0       	push   $0xf013f700
f011f93c:	68 a8 08 00 00       	push   $0x8a8
f011f941:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f946:	e8 64 15 fe ff       	call   f0100eaf <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011f94b:	83 ec 0c             	sub    $0xc,%esp
f011f94e:	68 00 10 00 00       	push   $0x1000
f011f953:	e8 7a b5 fe ff       	call   f010aed2 <kmalloc>
f011f958:	83 c4 10             	add    $0x10,%esp
f011f95b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_PAGE_ALLOC_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011f95e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f961:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011f966:	74 17                	je     f011f97f <test_three_creation_functions+0x196>
f011f968:	83 ec 04             	sub    $0x4,%esp
f011f96b:	68 40 f7 13 f0       	push   $0xf013f740
f011f970:	68 ac 08 00 00       	push   $0x8ac
f011f975:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f97a:	e8 30 15 fe ff       	call   f0100eaf <_panic>
	}

	cprintf_colored(TEXT_TESTERR_CLR,"\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011f97f:	83 ec 08             	sub    $0x8,%esp
f011f982:	68 b0 f7 13 f0       	push   $0xf013f7b0
f011f987:	6a 0c                	push   $0xc
f011f989:	e8 ef 21 fe ff       	call   f0101b7d <cprintf_colored>
f011f98e:	83 c4 10             	add    $0x10,%esp

	return 1;
f011f991:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011f996:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011f999:	5b                   	pop    %ebx
f011f99a:	5e                   	pop    %esi
f011f99b:	5f                   	pop    %edi
f011f99c:	5d                   	pop    %ebp
f011f99d:	c3                   	ret    

f011f99e <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011f99e:	55                   	push   %ebp
f011f99f:	89 e5                	mov    %esp,%ebp
f011f9a1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f9a4:	83 ec 04             	sub    $0x4,%esp
f011f9a7:	68 71 dd 13 f0       	push   $0xf013dd71
f011f9ac:	68 ba 08 00 00       	push   $0x8ba
f011f9b1:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f9b6:	e8 f4 14 fe ff       	call   f0100eaf <_panic>

f011f9bb <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011f9bb:	55                   	push   %ebp
f011f9bc:	89 e5                	mov    %esp,%ebp
f011f9be:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f9c1:	83 ec 04             	sub    $0x4,%esp
f011f9c4:	68 71 dd 13 f0       	push   $0xf013dd71
f011f9c9:	68 c2 08 00 00       	push   $0x8c2
f011f9ce:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f9d3:	e8 d7 14 fe ff       	call   f0100eaf <_panic>

f011f9d8 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011f9d8:	55                   	push   %ebp
f011f9d9:	89 e5                	mov    %esp,%ebp
f011f9db:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f9de:	83 ec 04             	sub    $0x4,%esp
f011f9e1:	68 71 dd 13 f0       	push   $0xf013dd71
f011f9e6:	68 c9 08 00 00       	push   $0x8c9
f011f9eb:	68 8a dd 13 f0       	push   $0xf013dd8a
f011f9f0:	e8 ba 14 fe ff       	call   f0100eaf <_panic>

f011f9f5 <test_kfreelast>:
}


int test_kfreelast()
{
f011f9f5:	55                   	push   %ebp
f011f9f6:	89 e5                	mov    %esp,%ebp
f011f9f8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011f9fb:	83 ec 04             	sub    $0x4,%esp
f011f9fe:	68 71 dd 13 f0       	push   $0xf013dd71
f011fa03:	68 cf 08 00 00       	push   $0x8cf
f011fa08:	68 8a dd 13 f0       	push   $0xf013dd8a
f011fa0d:	e8 9d 14 fe ff       	call   f0100eaf <_panic>

f011fa12 <print_order>:
uint8 firstTimeTest = 1;
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011fa12:	55                   	push   %ebp
f011fa13:	89 e5                	mov    %esp,%ebp
f011fa15:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011fa18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011fa1f:	e9 84 00 00 00       	jmp    f011faa8 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011fa24:	83 ec 08             	sub    $0x8,%esp
f011fa27:	ff 75 f4             	pushl  -0xc(%ebp)
f011fa2a:	68 80 f8 13 f0       	push   $0xf013f880
f011fa2f:	e8 19 21 fe ff       	call   f0101b4d <cprintf>
f011fa34:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011fa37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011fa3e:	eb 4c                	jmp    f011fa8c <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011fa40:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa43:	89 d0                	mov    %edx,%eax
f011fa45:	c1 e0 02             	shl    $0x2,%eax
f011fa48:	01 d0                	add    %edx,%eax
f011fa4a:	c1 e0 03             	shl    $0x3,%eax
f011fa4d:	89 c2                	mov    %eax,%edx
f011fa4f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa52:	01 c2                	add    %eax,%edx
f011fa54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fa57:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011fa5a:	85 c0                	test   %eax,%eax
f011fa5c:	74 36                	je     f011fa94 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011fa5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa61:	89 d0                	mov    %edx,%eax
f011fa63:	c1 e0 02             	shl    $0x2,%eax
f011fa66:	01 d0                	add    %edx,%eax
f011fa68:	c1 e0 03             	shl    $0x3,%eax
f011fa6b:	89 c2                	mov    %eax,%edx
f011fa6d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa70:	01 c2                	add    %eax,%edx
f011fa72:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fa75:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011fa78:	83 ec 08             	sub    $0x8,%esp
f011fa7b:	50                   	push   %eax
f011fa7c:	68 88 f8 13 f0       	push   $0xf013f888
f011fa81:	e8 c7 20 fe ff       	call   f0101b4d <cprintf>
f011fa86:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011fa89:	ff 45 f0             	incl   -0x10(%ebp)
f011fa8c:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011fa90:	7e ae                	jle    f011fa40 <print_order+0x2e>
f011fa92:	eb 01                	jmp    f011fa95 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011fa94:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011fa95:	83 ec 0c             	sub    $0xc,%esp
f011fa98:	68 8d f8 13 f0       	push   $0xf013f88d
f011fa9d:	e8 ab 20 fe ff       	call   f0101b4d <cprintf>
f011faa2:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011faa5:	ff 45 f4             	incl   -0xc(%ebp)
f011faa8:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011faac:	0f 8e 72 ff ff ff    	jle    f011fa24 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011fab2:	90                   	nop
f011fab3:	c9                   	leave  
f011fab4:	c3                   	ret    

f011fab5 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011fab5:	55                   	push   %ebp
f011fab6:	89 e5                	mov    %esp,%ebp
f011fab8:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011fabb:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_kspinlock(&ProcessQueues.qlock);
f011fac2:	83 ec 0c             	sub    $0xc,%esp
f011fac5:	68 c0 cd 94 f1       	push   $0xf194cdc0
f011faca:	e8 76 3a ff ff       	call   f0113545 <acquire_kspinlock>
f011facf:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011fad2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011fad9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011fae0:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fae3:	8b 45 10             	mov    0x10(%ebp),%eax
f011fae6:	01 d0                	add    %edx,%eax
f011fae8:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011faeb:	a1 4c ce 94 f1       	mov    0xf194ce4c,%eax
f011faf0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011faf3:	a1 44 ce 94 f1       	mov    0xf194ce44,%eax
f011faf8:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011fafb:	ff 75 e8             	pushl  -0x18(%ebp)
f011fafe:	ff 75 0c             	pushl  0xc(%ebp)
f011fb01:	ff 75 08             	pushl  0x8(%ebp)
f011fb04:	68 90 f8 13 f0       	push   $0xf013f890
f011fb09:	e8 3f 20 fe ff       	call   f0101b4d <cprintf>
f011fb0e:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011fb11:	eb 34                	jmp    f011fb47 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011fb13:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fb16:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011fb19:	7d 05                	jge    f011fb20 <find_in_range+0x6b>
			{
				i++;
f011fb1b:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011fb1e:	eb 1e                	jmp    f011fb3e <find_in_range+0x89>
			}
			if (i >= end)
f011fb20:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fb23:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011fb26:	7d 29                	jge    f011fb51 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011fb28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fb2b:	8b 40 10             	mov    0x10(%eax),%eax
f011fb2e:	3b 45 08             	cmp    0x8(%ebp),%eax
f011fb31:	75 08                	jne    f011fb3b <find_in_range+0x86>
			{
				ret = i;
f011fb33:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fb36:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011fb39:	eb 17                	jmp    f011fb52 <find_in_range+0x9d>
			}
			i++;
f011fb3b:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011fb3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fb41:	8b 40 0c             	mov    0xc(%eax),%eax
f011fb44:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fb47:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fb4a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011fb4d:	7c c4                	jl     f011fb13 <find_in_range+0x5e>
f011fb4f:	eb 01                	jmp    f011fb52 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011fb51:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f011fb52:	83 ec 0c             	sub    $0xc,%esp
f011fb55:	68 c0 cd 94 f1       	push   $0xf194cdc0
f011fb5a:	e8 8b 3a ff ff       	call   f01135ea <release_kspinlock>
f011fb5f:	83 c4 10             	add    $0x10,%esp
	return ret;
f011fb62:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011fb65:	c9                   	leave  
f011fb66:	c3                   	ret    

f011fb67 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011fb67:	55                   	push   %ebp
f011fb68:	89 e5                	mov    %esp,%ebp
f011fb6a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011fb6d:	83 ec 04             	sub    $0x4,%esp
f011fb70:	68 c1 f8 13 f0       	push   $0xf013f8c1
f011fb75:	6a 47                	push   $0x47
f011fb77:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011fb7c:	e8 2e 13 fe ff       	call   f0100eaf <_panic>

f011fb81 <test_bsd_nice_1>:

}


void test_bsd_nice_1()
{
f011fb81:	55                   	push   %ebp
f011fb82:	89 e5                	mov    %esp,%ebp
f011fb84:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011fb87:	83 ec 04             	sub    $0x4,%esp
f011fb8a:	68 c1 f8 13 f0       	push   $0xf013f8c1
f011fb8f:	6a 4e                	push   $0x4e
f011fb91:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011fb96:	e8 14 13 fe ff       	call   f0100eaf <_panic>

f011fb9b <test_bsd_nice_2>:
}

void test_bsd_nice_2()
{
f011fb9b:	55                   	push   %ebp
f011fb9c:	89 e5                	mov    %esp,%ebp
f011fb9e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011fba1:	83 ec 04             	sub    $0x4,%esp
f011fba4:	68 c1 f8 13 f0       	push   $0xf013f8c1
f011fba9:	6a 53                	push   $0x53
f011fbab:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011fbb0:	e8 fa 12 fe ff       	call   f0100eaf <_panic>

f011fbb5 <test_priorityRR_0>:
}


void test_priorityRR_0()
{
f011fbb5:	55                   	push   %ebp
f011fbb6:	89 e5                	mov    %esp,%ebp
f011fbb8:	57                   	push   %edi
f011fbb9:	56                   	push   %esi
f011fbba:	53                   	push   %ebx
f011fbbb:	83 ec 4c             	sub    $0x4c,%esp
	int numOfIncorrect = 0;
f011fbbe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	if (firstTimeTest)
f011fbc5:	a0 86 81 19 f0       	mov    0xf0198186,%al
f011fbca:	84 c0                	test   %al,%al
f011fbcc:	0f 84 bf 01 00 00    	je     f011fd91 <test_priorityRR_0+0x1dc>
	{
		firstTimeTest = 0;
f011fbd2:	c6 05 86 81 19 f0 00 	movb   $0x0,0xf0198186
		int priority_values[] = {0, 2, 4, 6, 8};
f011fbd9:	8d 45 b0             	lea    -0x50(%ebp),%eax
f011fbdc:	bb 18 fa 13 f0       	mov    $0xf013fa18,%ebx
f011fbe1:	ba 05 00 00 00       	mov    $0x5,%edx
f011fbe6:	89 c7                	mov    %eax,%edi
f011fbe8:	89 de                	mov    %ebx,%esi
f011fbea:	89 d1                	mov    %edx,%ecx
f011fbec:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011fbee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011fbf5:	e9 66 01 00 00       	jmp    f011fd60 <test_priorityRR_0+0x1ab>
		{
			struct Env *env ;
			if (i == 4)
f011fbfa:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011fbfe:	75 1b                	jne    f011fc1b <test_priorityRR_0+0x66>
			{
				env = env_create("priRR_fib_small", 500, 0, 0);
f011fc00:	6a 00                	push   $0x0
f011fc02:	6a 00                	push   $0x0
f011fc04:	68 f4 01 00 00       	push   $0x1f4
f011fc09:	68 ed f8 13 f0       	push   $0xf013f8ed
f011fc0e:	e8 7e ce fe ff       	call   f010ca91 <env_create>
f011fc13:	83 c4 10             	add    $0x10,%esp
f011fc16:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011fc19:	eb 19                	jmp    f011fc34 <test_priorityRR_0+0x7f>
			}
			else
			{
				env = env_create("priRR_fib", 500, 0, 0);
f011fc1b:	6a 00                	push   $0x0
f011fc1d:	6a 00                	push   $0x0
f011fc1f:	68 f4 01 00 00       	push   $0x1f4
f011fc24:	68 fd f8 13 f0       	push   $0xf013f8fd
f011fc29:	e8 63 ce fe ff       	call   f010ca91 <env_create>
f011fc2e:	83 c4 10             	add    $0x10,%esp
f011fc31:	89 45 dc             	mov    %eax,-0x24(%ebp)
			}
			int priority_index = i % TOTAL_TEST_VALUES;
f011fc34:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fc37:	b9 05 00 00 00       	mov    $0x5,%ecx
f011fc3c:	99                   	cltd   
f011fc3d:	f7 f9                	idiv   %ecx
f011fc3f:	89 55 cc             	mov    %edx,-0x34(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f011fc42:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fc45:	8b 54 85 b0          	mov    -0x50(%ebp,%eax,4),%edx
f011fc49:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fc4c:	8b 40 10             	mov    0x10(%eax),%eax
f011fc4f:	83 ec 08             	sub    $0x8,%esp
f011fc52:	52                   	push   %edx
f011fc53:	50                   	push   %eax
f011fc54:	e8 0f 7b fe ff       	call   f0107768 <env_set_priority>
f011fc59:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011fc5c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fc60:	75 14                	jne    f011fc76 <test_priorityRR_0+0xc1>
				panic("Loading programs failed\n");
f011fc62:	83 ec 04             	sub    $0x4,%esp
f011fc65:	68 07 f9 13 f0       	push   $0xf013f907
f011fc6a:	6a 6d                	push   $0x6d
f011fc6c:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011fc71:	e8 39 12 fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f011fc76:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fc79:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011fc7f:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011fc84:	74 14                	je     f011fc9a <test_priorityRR_0+0xe5>
				panic("The program working set size is not correct\n");
f011fc86:	83 ec 04             	sub    $0x4,%esp
f011fc89:	68 20 f9 13 f0       	push   $0xf013f920
f011fc8e:	6a 6f                	push   $0x6f
f011fc90:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011fc95:	e8 15 12 fe ff       	call   f0100eaf <_panic>

			switch (priority_values[priority_index])
f011fc9a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fc9d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
f011fca1:	83 f8 08             	cmp    $0x8,%eax
f011fca4:	0f 87 a5 00 00 00    	ja     f011fd4f <test_priorityRR_0+0x19a>
f011fcaa:	8b 04 85 2c fa 13 f0 	mov    -0xfec05d4(,%eax,4),%eax
f011fcb1:	ff e0                	jmp    *%eax
			{
			case 0:
				prog_orders[0][env_count[0]++] = env->env_id;
f011fcb3:	a1 b0 cb 94 f1       	mov    0xf194cbb0,%eax
f011fcb8:	8d 50 01             	lea    0x1(%eax),%edx
f011fcbb:	89 15 b0 cb 94 f1    	mov    %edx,0xf194cbb0
f011fcc1:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fcc4:	8b 52 10             	mov    0x10(%edx),%edx
f011fcc7:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f011fcce:	eb 7f                	jmp    f011fd4f <test_priorityRR_0+0x19a>
			case 2:
				prog_orders[1][env_count[1]++] = env->env_id;
f011fcd0:	a1 b4 cb 94 f1       	mov    0xf194cbb4,%eax
f011fcd5:	8d 50 01             	lea    0x1(%eax),%edx
f011fcd8:	89 15 b4 cb 94 f1    	mov    %edx,0xf194cbb4
f011fcde:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fce1:	8b 52 10             	mov    0x10(%edx),%edx
f011fce4:	83 c0 0a             	add    $0xa,%eax
f011fce7:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f011fcee:	eb 5f                	jmp    f011fd4f <test_priorityRR_0+0x19a>
			case 4:
				prog_orders[2][env_count[2]++] = env->env_id;
f011fcf0:	a1 b8 cb 94 f1       	mov    0xf194cbb8,%eax
f011fcf5:	8d 50 01             	lea    0x1(%eax),%edx
f011fcf8:	89 15 b8 cb 94 f1    	mov    %edx,0xf194cbb8
f011fcfe:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fd01:	8b 52 10             	mov    0x10(%edx),%edx
f011fd04:	83 c0 14             	add    $0x14,%eax
f011fd07:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f011fd0e:	eb 3f                	jmp    f011fd4f <test_priorityRR_0+0x19a>
			case 6:
				prog_orders[3][env_count[3]++] = env->env_id;
f011fd10:	a1 bc cb 94 f1       	mov    0xf194cbbc,%eax
f011fd15:	8d 50 01             	lea    0x1(%eax),%edx
f011fd18:	89 15 bc cb 94 f1    	mov    %edx,0xf194cbbc
f011fd1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fd21:	8b 52 10             	mov    0x10(%edx),%edx
f011fd24:	83 c0 1e             	add    $0x1e,%eax
f011fd27:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f011fd2e:	eb 1f                	jmp    f011fd4f <test_priorityRR_0+0x19a>
			case 8:
				prog_orders[4][env_count[4]++] = env->env_id;
f011fd30:	a1 c0 cb 94 f1       	mov    0xf194cbc0,%eax
f011fd35:	8d 50 01             	lea    0x1(%eax),%edx
f011fd38:	89 15 c0 cb 94 f1    	mov    %edx,0xf194cbc0
f011fd3e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fd41:	8b 52 10             	mov    0x10(%edx),%edx
f011fd44:	83 c0 28             	add    $0x28,%eax
f011fd47:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f011fd4e:	90                   	nop
			}
			sched_new_env(env);
f011fd4f:	83 ec 0c             	sub    $0xc,%esp
f011fd52:	ff 75 dc             	pushl  -0x24(%ebp)
f011fd55:	e8 39 6a fe ff       	call   f0106793 <sched_new_env>
f011fd5a:	83 c4 10             	add    $0x10,%esp

	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6, 8};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011fd5d:	ff 45 e0             	incl   -0x20(%ebp)
f011fd60:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011fd64:	0f 8e 90 fe ff ff    	jle    f011fbfa <test_priorityRR_0+0x45>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf_colored(TEXT_light_cyan, "\n> Running... (After all running programs finish, Run the same command again.)\n");
f011fd6a:	83 ec 08             	sub    $0x8,%esp
f011fd6d:	68 50 f9 13 f0       	push   $0xf013f950
f011fd72:	6a 0b                	push   $0xb
f011fd74:	e8 04 1e fe ff       	call   f0101b7d <cprintf_colored>
f011fd79:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011fd7c:	83 ec 0c             	sub    $0xc,%esp
f011fd7f:	68 a0 f9 13 f0       	push   $0xf013f9a0
f011fd84:	e8 83 20 fe ff       	call   f0101e0c <execute_command>
f011fd89:	83 c4 10             	add    $0x10,%esp
f011fd8c:	e9 e0 00 00 00       	jmp    f011fe71 <test_priorityRR_0+0x2bc>
	}
	else
	{
		cprintf_colored(TEXT_light_cyan, "\n> Checking...\n");
f011fd91:	83 ec 08             	sub    $0x8,%esp
f011fd94:	68 a7 f9 13 f0       	push   $0xf013f9a7
f011fd99:	6a 0b                	push   $0xb
f011fd9b:	e8 dd 1d fe ff       	call   f0101b7d <cprintf_colored>
f011fda0:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011fda3:	e8 37 71 fe ff       	call   f0106edf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011fda8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011fdaf:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011fdb6:	e9 a5 00 00 00       	jmp    f011fe60 <test_priorityRR_0+0x2ab>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011fdbb:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f011fdc2:	eb 6c                	jmp    f011fe30 <test_priorityRR_0+0x27b>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f011fdc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fdc7:	8b 14 85 b0 cb 94 f1 	mov    -0xe6b3450(,%eax,4),%edx
f011fdce:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011fdd1:	89 c8                	mov    %ecx,%eax
f011fdd3:	c1 e0 02             	shl    $0x2,%eax
f011fdd6:	01 c8                	add    %ecx,%eax
f011fdd8:	01 c0                	add    %eax,%eax
f011fdda:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f011fddd:	01 c8                	add    %ecx,%eax
f011fddf:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f011fde6:	83 ec 04             	sub    $0x4,%esp
f011fde9:	52                   	push   %edx
f011fdea:	ff 75 d8             	pushl  -0x28(%ebp)
f011fded:	50                   	push   %eax
f011fdee:	e8 c2 fc ff ff       	call   f011fab5 <find_in_range>
f011fdf3:	83 c4 10             	add    $0x10,%esp
f011fdf6:	89 45 c8             	mov    %eax,-0x38(%ebp)
				if (exist == -1)
f011fdf9:	83 7d c8 ff          	cmpl   $0xffffffff,-0x38(%ebp)
f011fdfd:	75 2e                	jne    f011fe2d <test_priorityRR_0+0x278>
				{
					//panic("The programs' order of finishing is not correct\n");
					cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d] is not correct\n", prog_orders[i][j]);
f011fdff:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fe02:	89 d0                	mov    %edx,%eax
f011fe04:	c1 e0 02             	shl    $0x2,%eax
f011fe07:	01 d0                	add    %edx,%eax
f011fe09:	01 c0                	add    %eax,%eax
f011fe0b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011fe0e:	01 d0                	add    %edx,%eax
f011fe10:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f011fe17:	83 ec 04             	sub    $0x4,%esp
f011fe1a:	50                   	push   %eax
f011fe1b:	68 b8 f9 13 f0       	push   $0xf013f9b8
f011fe20:	6a 0c                	push   $0xc
f011fe22:	e8 56 1d fe ff       	call   f0101b7d <cprintf_colored>
f011fe27:	83 c4 10             	add    $0x10,%esp
					numOfIncorrect++;
f011fe2a:	ff 45 e4             	incl   -0x1c(%ebp)
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011fe2d:	ff 45 d0             	incl   -0x30(%ebp)
f011fe30:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fe33:	89 d0                	mov    %edx,%eax
f011fe35:	c1 e0 02             	shl    $0x2,%eax
f011fe38:	01 d0                	add    %edx,%eax
f011fe3a:	01 c0                	add    %eax,%eax
f011fe3c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011fe3f:	01 d0                	add    %edx,%eax
f011fe41:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f011fe48:	85 c0                	test   %eax,%eax
f011fe4a:	0f 85 74 ff ff ff    	jne    f011fdc4 <test_priorityRR_0+0x20f>
					//panic("The programs' order of finishing is not correct\n");
					cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d] is not correct\n", prog_orders[i][j]);
					numOfIncorrect++;
				}
			}
			start_idx += env_count[i];
f011fe50:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fe53:	8b 04 85 b0 cb 94 f1 	mov    -0xe6b3450(,%eax,4),%eax
f011fe5a:	01 45 d8             	add    %eax,-0x28(%ebp)
	{
		cprintf_colored(TEXT_light_cyan, "\n> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011fe5d:	ff 45 d4             	incl   -0x2c(%ebp)
f011fe60:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
f011fe64:	0f 8e 51 ff ff ff    	jle    f011fdbb <test_priorityRR_0+0x206>
					numOfIncorrect++;
				}
			}
			start_idx += env_count[i];
		}
		firstTimeTest = 0;
f011fe6a:	c6 05 86 81 19 f0 00 	movb   $0x0,0xf0198186
	}

	int eval = 100 - numOfIncorrect * 100 / TOTAL_TEST_VALUES;
f011fe71:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fe74:	89 d0                	mov    %edx,%eax
f011fe76:	c1 e0 02             	shl    $0x2,%eax
f011fe79:	01 d0                	add    %edx,%eax
f011fe7b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fe82:	01 d0                	add    %edx,%eax
f011fe84:	c1 e0 02             	shl    $0x2,%eax
f011fe87:	89 c1                	mov    %eax,%ecx
f011fe89:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011fe8e:	f7 e9                	imul   %ecx
f011fe90:	d1 fa                	sar    %edx
f011fe92:	89 c8                	mov    %ecx,%eax
f011fe94:	c1 f8 1f             	sar    $0x1f,%eax
f011fe97:	29 c2                	sub    %eax,%edx
f011fe99:	89 d0                	mov    %edx,%eax
f011fe9b:	ba 64 00 00 00       	mov    $0x64,%edx
f011fea0:	29 c2                	sub    %eax,%edx
f011fea2:	89 d0                	mov    %edx,%eax
f011fea4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	cprintf_colored(TEXT_light_green, "\ntest_priorityRR_0 is finished. Eval = %d%\n", eval);
f011fea7:	83 ec 04             	sub    $0x4,%esp
f011feaa:	ff 75 c4             	pushl  -0x3c(%ebp)
f011fead:	68 ec f9 13 f0       	push   $0xf013f9ec
f011feb2:	6a 0a                	push   $0xa
f011feb4:	e8 c4 1c fe ff       	call   f0101b7d <cprintf_colored>
f011feb9:	83 c4 10             	add    $0x10,%esp
}
f011febc:	90                   	nop
f011febd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011fec0:	5b                   	pop    %ebx
f011fec1:	5e                   	pop    %esi
f011fec2:	5f                   	pop    %edi
f011fec3:	5d                   	pop    %ebp
f011fec4:	c3                   	ret    

f011fec5 <test_priorityRR_1>:

void test_priorityRR_1()
{
f011fec5:	55                   	push   %ebp
f011fec6:	89 e5                	mov    %esp,%ebp
f011fec8:	83 ec 38             	sub    $0x38,%esp
	int numOfIncorrect = 0;
f011fecb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (firstTimeTest)
f011fed2:	a0 86 81 19 f0       	mov    0xf0198186,%al
f011fed7:	84 c0                	test   %al,%al
f011fed9:	0f 84 af 01 00 00    	je     f012008e <test_priorityRR_1+0x1c9>
	{
		rsttst();
f011fedf:	e8 df 07 00 00       	call   f01206c3 <rsttst>
		firstTimeTest = 0;
f011fee4:	c6 05 86 81 19 f0 00 	movb   $0x0,0xf0198186
		struct Env *fibPri0Env = env_create("priRR_fib", 500, 0, 0);
f011feeb:	6a 00                	push   $0x0
f011feed:	6a 00                	push   $0x0
f011feef:	68 f4 01 00 00       	push   $0x1f4
f011fef4:	68 fd f8 13 f0       	push   $0xf013f8fd
f011fef9:	e8 93 cb fe ff       	call   f010ca91 <env_create>
f011fefe:	83 c4 10             	add    $0x10,%esp
f011ff01:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibPri4Env = env_create("priRR_fib_pri4", 500, 0, 0);
f011ff04:	6a 00                	push   $0x0
f011ff06:	6a 00                	push   $0x0
f011ff08:	68 f4 01 00 00       	push   $0x1f4
f011ff0d:	68 50 fa 13 f0       	push   $0xf013fa50
f011ff12:	e8 7a cb fe ff       	call   f010ca91 <env_create>
f011ff17:	83 c4 10             	add    $0x10,%esp
f011ff1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		struct Env *fibPri8Env = env_create("priRR_fib_pri8", 500, 0, 0);
f011ff1d:	6a 00                	push   $0x0
f011ff1f:	6a 00                	push   $0x0
f011ff21:	68 f4 01 00 00       	push   $0x1f4
f011ff26:	68 5f fa 13 f0       	push   $0xf013fa5f
f011ff2b:	e8 61 cb fe ff       	call   f010ca91 <env_create>
f011ff30:	83 c4 10             	add    $0x10,%esp
f011ff33:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env *fibPri2ParentEnv = env_create("priRR_fib_create", 500, 0, 0);
f011ff36:	6a 00                	push   $0x0
f011ff38:	6a 00                	push   $0x0
f011ff3a:	68 f4 01 00 00       	push   $0x1f4
f011ff3f:	68 6e fa 13 f0       	push   $0xf013fa6e
f011ff44:	e8 48 cb fe ff       	call   f010ca91 <env_create>
f011ff49:	83 c4 10             	add    $0x10,%esp
f011ff4c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (fibPri0Env == NULL || fibPri4Env == NULL || fibPri8Env == NULL || fibPri2ParentEnv == NULL)
f011ff4f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011ff53:	74 12                	je     f011ff67 <test_priorityRR_1+0xa2>
f011ff55:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ff59:	74 0c                	je     f011ff67 <test_priorityRR_1+0xa2>
f011ff5b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ff5f:	74 06                	je     f011ff67 <test_priorityRR_1+0xa2>
f011ff61:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ff65:	75 17                	jne    f011ff7e <test_priorityRR_1+0xb9>
			panic("Loading programs failed\n");
f011ff67:	83 ec 04             	sub    $0x4,%esp
f011ff6a:	68 07 f9 13 f0       	push   $0xf013f907
f011ff6f:	68 b1 00 00 00       	push   $0xb1
f011ff74:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011ff79:	e8 31 0f fe ff       	call   f0100eaf <_panic>
		if (fibPri0Env->page_WS_max_size != 500 || fibPri4Env->page_WS_max_size != 500 || fibPri8Env->page_WS_max_size != 500 || fibPri2ParentEnv->page_WS_max_size != 500)
f011ff7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ff81:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ff87:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ff8c:	75 30                	jne    f011ffbe <test_priorityRR_1+0xf9>
f011ff8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ff91:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ff97:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ff9c:	75 20                	jne    f011ffbe <test_priorityRR_1+0xf9>
f011ff9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ffa1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ffa7:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ffac:	75 10                	jne    f011ffbe <test_priorityRR_1+0xf9>
f011ffae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ffb1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ffb7:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ffbc:	74 17                	je     f011ffd5 <test_priorityRR_1+0x110>
			panic("The programs should be initially loaded with the given working set size.\n");
f011ffbe:	83 ec 04             	sub    $0x4,%esp
f011ffc1:	68 80 fa 13 f0       	push   $0xf013fa80
f011ffc6:	68 b3 00 00 00       	push   $0xb3
f011ffcb:	68 d1 f8 13 f0       	push   $0xf013f8d1
f011ffd0:	e8 da 0e fe ff       	call   f0100eaf <_panic>
		sched_new_env(fibPri8Env);
f011ffd5:	83 ec 0c             	sub    $0xc,%esp
f011ffd8:	ff 75 e0             	pushl  -0x20(%ebp)
f011ffdb:	e8 b3 67 fe ff       	call   f0106793 <sched_new_env>
f011ffe0:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri0Env);
f011ffe3:	83 ec 0c             	sub    $0xc,%esp
f011ffe6:	ff 75 e8             	pushl  -0x18(%ebp)
f011ffe9:	e8 a5 67 fe ff       	call   f0106793 <sched_new_env>
f011ffee:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri4Env);
f011fff1:	83 ec 0c             	sub    $0xc,%esp
f011fff4:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fff7:	e8 97 67 fe ff       	call   f0106793 <sched_new_env>
f011fffc:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri2ParentEnv);
f011ffff:	83 ec 0c             	sub    $0xc,%esp
f0120002:	ff 75 dc             	pushl  -0x24(%ebp)
f0120005:	e8 89 67 fe ff       	call   f0106793 <sched_new_env>
f012000a:	83 c4 10             	add    $0x10,%esp
		env_set_priority(fibPri2ParentEnv->env_id, 4);
f012000d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120010:	8b 40 10             	mov    0x10(%eax),%eax
f0120013:	83 ec 08             	sub    $0x8,%esp
f0120016:	6a 04                	push   $0x4
f0120018:	50                   	push   %eax
f0120019:	e8 4a 77 fe ff       	call   f0107768 <env_set_priority>
f012001e:	83 c4 10             	add    $0x10,%esp

		prog_orders[0][0] = fibPri0Env->env_id;
f0120021:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120024:	8b 40 10             	mov    0x10(%eax),%eax
f0120027:	a3 c0 ca 94 f1       	mov    %eax,0xf194cac0
		prog_orders[1][0] = fibPri2ParentEnv->env_id ; //id of the parent
f012002c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012002f:	8b 40 10             	mov    0x10(%eax),%eax
f0120032:	a3 e8 ca 94 f1       	mov    %eax,0xf194cae8
		prog_orders[2][0] = fibPri2ParentEnv->env_id + 1; //id of the 1st created child fib
f0120037:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012003a:	8b 40 10             	mov    0x10(%eax),%eax
f012003d:	40                   	inc    %eax
f012003e:	a3 10 cb 94 f1       	mov    %eax,0xf194cb10
		prog_orders[3][0] = fibPri4Env->env_id;
f0120043:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120046:	8b 40 10             	mov    0x10(%eax),%eax
f0120049:	a3 38 cb 94 f1       	mov    %eax,0xf194cb38
		prog_orders[4][0] = fibPri8Env->env_id;
f012004e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120051:	8b 40 10             	mov    0x10(%eax),%eax
f0120054:	a3 60 cb 94 f1       	mov    %eax,0xf194cb60
		prog_orders[5][0] = fibPri2ParentEnv->env_id + 2; //id of the 2nd created child fib
f0120059:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012005c:	8b 40 10             	mov    0x10(%eax),%eax
f012005f:	83 c0 02             	add    $0x2,%eax
f0120062:	a3 88 cb 94 f1       	mov    %eax,0xf194cb88

		cprintf_colored(TEXT_light_cyan, "\n> Running... (After all running programs finish, Run the same command again.)\n");
f0120067:	83 ec 08             	sub    $0x8,%esp
f012006a:	68 50 f9 13 f0       	push   $0xf013f950
f012006f:	6a 0b                	push   $0xb
f0120071:	e8 07 1b fe ff       	call   f0101b7d <cprintf_colored>
f0120076:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0120079:	83 ec 0c             	sub    $0xc,%esp
f012007c:	68 a0 f9 13 f0       	push   $0xf013f9a0
f0120081:	e8 86 1d fe ff       	call   f0101e0c <execute_command>
f0120086:	83 c4 10             	add    $0x10,%esp
f0120089:	e9 a9 00 00 00       	jmp    f0120137 <test_priorityRR_1+0x272>
	}
	else
	{
		cprintf_colored(TEXT_light_cyan, "\n> Checking...\n");
f012008e:	83 ec 08             	sub    $0x8,%esp
f0120091:	68 a7 f9 13 f0       	push   $0xf013f9a7
f0120096:	6a 0b                	push   $0xb
f0120098:	e8 e0 1a fe ff       	call   f0101b7d <cprintf_colored>
f012009d:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f01200a0:	e8 3a 6e fe ff       	call   f0106edf <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f01200a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct Env *env = NULL;
f01200ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
f01200b3:	83 ec 0c             	sub    $0xc,%esp
f01200b6:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01200bb:	e8 85 34 ff ff       	call   f0113545 <acquire_kspinlock>
f01200c0:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01200c3:	a1 4c ce 94 f1       	mov    0xf194ce4c,%eax
f01200c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01200cb:	a1 44 ce 94 f1       	mov    0xf194ce44,%eax
f01200d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f01200d3:	eb 4a                	jmp    f012011f <test_priorityRR_1+0x25a>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d\n", env->prog_name, env->env_id, env->priority);
				if (prog_orders[i][0] != env->env_id)
f01200d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01200d8:	89 d0                	mov    %edx,%eax
f01200da:	c1 e0 02             	shl    $0x2,%eax
f01200dd:	01 d0                	add    %edx,%eax
f01200df:	c1 e0 03             	shl    $0x3,%eax
f01200e2:	05 c0 ca 94 f1       	add    $0xf194cac0,%eax
f01200e7:	8b 10                	mov    (%eax),%edx
f01200e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01200ec:	8b 40 10             	mov    0x10(%eax),%eax
f01200ef:	39 c2                	cmp    %eax,%edx
f01200f1:	74 20                	je     f0120113 <test_priorityRR_1+0x24e>
				{
					cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d - %s] is not correct\n", env->env_id, env->prog_name);
f01200f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01200f6:	8d 50 20             	lea    0x20(%eax),%edx
f01200f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01200fc:	8b 40 10             	mov    0x10(%eax),%eax
f01200ff:	52                   	push   %edx
f0120100:	50                   	push   %eax
f0120101:	68 cc fa 13 f0       	push   $0xf013facc
f0120106:	6a 0c                	push   $0xc
f0120108:	e8 70 1a fe ff       	call   f0101b7d <cprintf_colored>
f012010d:	83 c4 10             	add    $0x10,%esp
					numOfIncorrect++;
f0120110:	ff 45 f4             	incl   -0xc(%ebp)
				}
				i++;
f0120113:	ff 45 f0             	incl   -0x10(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0120116:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120119:	8b 40 0c             	mov    0xc(%eax),%eax
f012011c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f012011f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120122:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0120125:	7c ae                	jl     f01200d5 <test_priorityRR_1+0x210>
					numOfIncorrect++;
				}
				i++;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0120127:	83 ec 0c             	sub    $0xc,%esp
f012012a:	68 c0 cd 94 f1       	push   $0xf194cdc0
f012012f:	e8 b6 34 ff ff       	call   f01135ea <release_kspinlock>
f0120134:	83 c4 10             	add    $0x10,%esp
	}
	int eval = 100 - numOfIncorrect * 100 / 6;
f0120137:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012013a:	89 d0                	mov    %edx,%eax
f012013c:	c1 e0 02             	shl    $0x2,%eax
f012013f:	01 d0                	add    %edx,%eax
f0120141:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120148:	01 d0                	add    %edx,%eax
f012014a:	c1 e0 02             	shl    $0x2,%eax
f012014d:	89 c1                	mov    %eax,%ecx
f012014f:	b8 ab aa aa 2a       	mov    $0x2aaaaaab,%eax
f0120154:	f7 e9                	imul   %ecx
f0120156:	c1 f9 1f             	sar    $0x1f,%ecx
f0120159:	89 d0                	mov    %edx,%eax
f012015b:	29 c8                	sub    %ecx,%eax
f012015d:	ba 64 00 00 00       	mov    $0x64,%edx
f0120162:	29 c2                	sub    %eax,%edx
f0120164:	89 d0                	mov    %edx,%eax
f0120166:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	cprintf_colored(TEXT_light_green, "\ntest_priorityRR_1 is finished. Eval = %d%\n", eval);
f0120169:	83 ec 04             	sub    $0x4,%esp
f012016c:	ff 75 d4             	pushl  -0x2c(%ebp)
f012016f:	68 04 fb 13 f0       	push   $0xf013fb04
f0120174:	6a 0a                	push   $0xa
f0120176:	e8 02 1a fe ff       	call   f0101b7d <cprintf_colored>
f012017b:	83 c4 10             	add    $0x10,%esp
}
f012017e:	90                   	nop
f012017f:	c9                   	leave  
f0120180:	c3                   	ret    

f0120181 <test_priorityRR_2>:

void test_priorityRR_2()
{
f0120181:	55                   	push   %ebp
f0120182:	89 e5                	mov    %esp,%ebp
f0120184:	57                   	push   %edi
f0120185:	56                   	push   %esi
f0120186:	53                   	push   %ebx
f0120187:	83 ec 7c             	sub    $0x7c,%esp
	int numOfIncorrect = 0;
f012018a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int totalNumOfProcesses = 0;
f0120191:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	if (firstTimeTest)
f0120198:	a0 86 81 19 f0       	mov    0xf0198186,%al
f012019d:	84 c0                	test   %al,%al
f012019f:	0f 84 74 02 00 00    	je     f0120419 <test_priorityRR_2+0x298>
	{
		firstTimeTest = 0;
f01201a5:	c6 05 86 81 19 f0 00 	movb   $0x0,0xf0198186
		int priority_values[] = {0, 2, 4, 6};
f01201ac:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01201af:	bb 78 fb 13 f0       	mov    $0xf013fb78,%ebx
f01201b4:	ba 04 00 00 00       	mov    $0x4,%edx
f01201b9:	89 c7                	mov    %eax,%edi
f01201bb:	89 de                	mov    %ebx,%esi
f01201bd:	89 d1                	mov    %edx,%ecx
f01201bf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01201c1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01201c8:	e9 41 01 00 00       	jmp    f012030e <test_priorityRR_2+0x18d>
		{
			struct Env *env = env_create("priRR_fib", 500, 0, 0);
f01201cd:	6a 00                	push   $0x0
f01201cf:	6a 00                	push   $0x0
f01201d1:	68 f4 01 00 00       	push   $0x1f4
f01201d6:	68 fd f8 13 f0       	push   $0xf013f8fd
f01201db:	e8 b1 c8 fe ff       	call   f010ca91 <env_create>
f01201e0:	83 c4 10             	add    $0x10,%esp
f01201e3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			int priority_index = i % (TOTAL_TEST_VALUES-1);
f01201e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01201e9:	25 03 00 00 80       	and    $0x80000003,%eax
f01201ee:	85 c0                	test   %eax,%eax
f01201f0:	79 05                	jns    f01201f7 <test_priorityRR_2+0x76>
f01201f2:	48                   	dec    %eax
f01201f3:	83 c8 fc             	or     $0xfffffffc,%eax
f01201f6:	40                   	inc    %eax
f01201f7:	89 45 c0             	mov    %eax,-0x40(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f01201fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01201fd:	8b 54 85 9c          	mov    -0x64(%ebp,%eax,4),%edx
f0120201:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120204:	8b 40 10             	mov    0x10(%eax),%eax
f0120207:	83 ec 08             	sub    $0x8,%esp
f012020a:	52                   	push   %edx
f012020b:	50                   	push   %eax
f012020c:	e8 57 75 fe ff       	call   f0107768 <env_set_priority>
f0120211:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0120214:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0120218:	75 17                	jne    f0120231 <test_priorityRR_2+0xb0>
				panic("Loading programs failed\n");
f012021a:	83 ec 04             	sub    $0x4,%esp
f012021d:	68 07 f9 13 f0       	push   $0xf013f907
f0120222:	68 f0 00 00 00       	push   $0xf0
f0120227:	68 d1 f8 13 f0       	push   $0xf013f8d1
f012022c:	e8 7e 0c fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0120231:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120234:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f012023a:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f012023f:	74 17                	je     f0120258 <test_priorityRR_2+0xd7>
				panic("The program working set size is not correct\n");
f0120241:	83 ec 04             	sub    $0x4,%esp
f0120244:	68 20 f9 13 f0       	push   $0xf013f920
f0120249:	68 f2 00 00 00       	push   $0xf2
f012024e:	68 d1 f8 13 f0       	push   $0xf013f8d1
f0120253:	e8 57 0c fe ff       	call   f0100eaf <_panic>

			switch (priority_values[priority_index])
f0120258:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012025b:	8b 44 85 9c          	mov    -0x64(%ebp,%eax,4),%eax
f012025f:	83 f8 02             	cmp    $0x2,%eax
f0120262:	74 3a                	je     f012029e <test_priorityRR_2+0x11d>
f0120264:	83 f8 02             	cmp    $0x2,%eax
f0120267:	7f 09                	jg     f0120272 <test_priorityRR_2+0xf1>
f0120269:	85 c0                	test   %eax,%eax
f012026b:	74 11                	je     f012027e <test_priorityRR_2+0xfd>
f012026d:	e9 8b 00 00 00       	jmp    f01202fd <test_priorityRR_2+0x17c>
f0120272:	83 f8 04             	cmp    $0x4,%eax
f0120275:	74 47                	je     f01202be <test_priorityRR_2+0x13d>
f0120277:	83 f8 06             	cmp    $0x6,%eax
f012027a:	74 62                	je     f01202de <test_priorityRR_2+0x15d>
f012027c:	eb 7f                	jmp    f01202fd <test_priorityRR_2+0x17c>
			{
			case 0:
				prog_orders[1][env_count[1]++] = env->env_id;
f012027e:	a1 b4 cb 94 f1       	mov    0xf194cbb4,%eax
f0120283:	8d 50 01             	lea    0x1(%eax),%edx
f0120286:	89 15 b4 cb 94 f1    	mov    %edx,0xf194cbb4
f012028c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f012028f:	8b 52 10             	mov    0x10(%edx),%edx
f0120292:	83 c0 0a             	add    $0xa,%eax
f0120295:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f012029c:	eb 5f                	jmp    f01202fd <test_priorityRR_2+0x17c>
			case 2:
				prog_orders[2][env_count[2]++] = env->env_id;
f012029e:	a1 b8 cb 94 f1       	mov    0xf194cbb8,%eax
f01202a3:	8d 50 01             	lea    0x1(%eax),%edx
f01202a6:	89 15 b8 cb 94 f1    	mov    %edx,0xf194cbb8
f01202ac:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01202af:	8b 52 10             	mov    0x10(%edx),%edx
f01202b2:	83 c0 14             	add    $0x14,%eax
f01202b5:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f01202bc:	eb 3f                	jmp    f01202fd <test_priorityRR_2+0x17c>
			case 4:
				prog_orders[3][env_count[3]++] = env->env_id;
f01202be:	a1 bc cb 94 f1       	mov    0xf194cbbc,%eax
f01202c3:	8d 50 01             	lea    0x1(%eax),%edx
f01202c6:	89 15 bc cb 94 f1    	mov    %edx,0xf194cbbc
f01202cc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01202cf:	8b 52 10             	mov    0x10(%edx),%edx
f01202d2:	83 c0 1e             	add    $0x1e,%eax
f01202d5:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f01202dc:	eb 1f                	jmp    f01202fd <test_priorityRR_2+0x17c>
			case 6:
				prog_orders[4][env_count[4]++] = env->env_id;
f01202de:	a1 c0 cb 94 f1       	mov    0xf194cbc0,%eax
f01202e3:	8d 50 01             	lea    0x1(%eax),%edx
f01202e6:	89 15 c0 cb 94 f1    	mov    %edx,0xf194cbc0
f01202ec:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01202ef:	8b 52 10             	mov    0x10(%edx),%edx
f01202f2:	83 c0 28             	add    $0x28,%eax
f01202f5:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)
				break;
f01202fc:	90                   	nop
			}
			sched_new_env(env);
f01202fd:	83 ec 0c             	sub    $0xc,%esp
f0120300:	ff 75 c4             	pushl  -0x3c(%ebp)
f0120303:	e8 8b 64 fe ff       	call   f0106793 <sched_new_env>
f0120308:	83 c4 10             	add    $0x10,%esp
	int totalNumOfProcesses = 0;
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6};
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f012030b:	ff 45 dc             	incl   -0x24(%ebp)
f012030e:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
f0120312:	0f 8e b5 fe ff ff    	jle    f01201cd <test_priorityRR_2+0x4c>
				break;
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
f0120318:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f012031e:	bb a0 fb 13 f0       	mov    $0xf013fba0,%ebx
f0120323:	ba 08 00 00 00       	mov    $0x8,%edx
f0120328:	89 c7                	mov    %eax,%edi
f012032a:	89 de                	mov    %ebx,%esi
f012032c:	89 d1                	mov    %edx,%ecx
f012032e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f0120330:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0120337:	e9 ac 00 00 00       	jmp    f01203e8 <test_priorityRR_2+0x267>
		{
			struct Env *env = env_create("priRR_fib_small", 500, 0, 0);
f012033c:	6a 00                	push   $0x0
f012033e:	6a 00                	push   $0x0
f0120340:	68 f4 01 00 00       	push   $0x1f4
f0120345:	68 ed f8 13 f0       	push   $0xf013f8ed
f012034a:	e8 42 c7 fe ff       	call   f010ca91 <env_create>
f012034f:	83 c4 10             	add    $0x10,%esp
f0120352:	89 45 bc             	mov    %eax,-0x44(%ebp)
			int priority_index = i ;
f0120355:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120358:	89 45 b8             	mov    %eax,-0x48(%ebp)
			env_set_priority(env->env_id, priority_values2[priority_index]);
f012035b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012035e:	8b 94 85 7c ff ff ff 	mov    -0x84(%ebp,%eax,4),%edx
f0120365:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120368:	8b 40 10             	mov    0x10(%eax),%eax
f012036b:	83 ec 08             	sub    $0x8,%esp
f012036e:	52                   	push   %edx
f012036f:	50                   	push   %eax
f0120370:	e8 f3 73 fe ff       	call   f0107768 <env_set_priority>
f0120375:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0120378:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f012037c:	75 17                	jne    f0120395 <test_priorityRR_2+0x214>
				panic("Loading programs failed\n");
f012037e:	83 ec 04             	sub    $0x4,%esp
f0120381:	68 07 f9 13 f0       	push   $0xf013f907
f0120386:	68 0d 01 00 00       	push   $0x10d
f012038b:	68 d1 f8 13 f0       	push   $0xf013f8d1
f0120390:	e8 1a 0b fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0120395:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120398:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f012039e:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01203a3:	74 17                	je     f01203bc <test_priorityRR_2+0x23b>
				panic("The program working set size is not correct\n");
f01203a5:	83 ec 04             	sub    $0x4,%esp
f01203a8:	68 20 f9 13 f0       	push   $0xf013f920
f01203ad:	68 0f 01 00 00       	push   $0x10f
f01203b2:	68 d1 f8 13 f0       	push   $0xf013f8d1
f01203b7:	e8 f3 0a fe ff       	call   f0100eaf <_panic>

			prog_orders[0][env_count[0]++] = env->env_id;
f01203bc:	a1 b0 cb 94 f1       	mov    0xf194cbb0,%eax
f01203c1:	8d 50 01             	lea    0x1(%eax),%edx
f01203c4:	89 15 b0 cb 94 f1    	mov    %edx,0xf194cbb0
f01203ca:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01203cd:	8b 52 10             	mov    0x10(%edx),%edx
f01203d0:	89 14 85 c0 ca 94 f1 	mov    %edx,-0xe6b3540(,%eax,4)

			sched_new_env(env);
f01203d7:	83 ec 0c             	sub    $0xc,%esp
f01203da:	ff 75 bc             	pushl  -0x44(%ebp)
f01203dd:	e8 b1 63 fe ff       	call   f0106793 <sched_new_env>
f01203e2:	83 c4 10             	add    $0x10,%esp
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01203e5:	ff 45 d8             	incl   -0x28(%ebp)
f01203e8:	83 7d d8 07          	cmpl   $0x7,-0x28(%ebp)
f01203ec:	0f 8e 4a ff ff ff    	jle    f012033c <test_priorityRR_2+0x1bb>
			prog_orders[0][env_count[0]++] = env->env_id;

			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf_colored(TEXT_light_cyan, "\n> Running... (After all running programs finish, Run the same command again.)\n");
f01203f2:	83 ec 08             	sub    $0x8,%esp
f01203f5:	68 50 f9 13 f0       	push   $0xf013f950
f01203fa:	6a 0b                	push   $0xb
f01203fc:	e8 7c 17 fe ff       	call   f0101b7d <cprintf_colored>
f0120401:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0120404:	83 ec 0c             	sub    $0xc,%esp
f0120407:	68 a0 f9 13 f0       	push   $0xf013f9a0
f012040c:	e8 fb 19 fe ff       	call   f0101e0c <execute_command>
f0120411:	83 c4 10             	add    $0x10,%esp
f0120414:	e9 74 01 00 00       	jmp    f012058d <test_priorityRR_2+0x40c>
	}
	else
	{
		cprintf_colored(TEXT_light_cyan, "\n> Checking...\n");
f0120419:	83 ec 08             	sub    $0x8,%esp
f012041c:	68 a7 f9 13 f0       	push   $0xf013f9a7
f0120421:	6a 0b                	push   $0xb
f0120423:	e8 55 17 fe ff       	call   f0101b7d <cprintf_colored>
f0120428:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f012042b:	e8 af 6a fe ff       	call   f0106edf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0120430:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0120437:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f012043e:	e9 39 01 00 00       	jmp    f012057c <test_priorityRR_2+0x3fb>
		{
			if (i == 0) //small programs should finish in their strict order
f0120443:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0120447:	0f 85 87 00 00 00    	jne    f01204d4 <test_priorityRR_2+0x353>
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f012044d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0120454:	eb 66                	jmp    f01204bc <test_priorityRR_2+0x33b>
				{
					totalNumOfProcesses++;
f0120456:	ff 45 e0             	incl   -0x20(%ebp)
					int exist = find_in_range(prog_orders[i][j], j, 1);
f0120459:	8b 55 d0             	mov    -0x30(%ebp),%edx
f012045c:	89 d0                	mov    %edx,%eax
f012045e:	c1 e0 02             	shl    $0x2,%eax
f0120461:	01 d0                	add    %edx,%eax
f0120463:	01 c0                	add    %eax,%eax
f0120465:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120468:	01 d0                	add    %edx,%eax
f012046a:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f0120471:	83 ec 04             	sub    $0x4,%esp
f0120474:	6a 01                	push   $0x1
f0120476:	ff 75 cc             	pushl  -0x34(%ebp)
f0120479:	50                   	push   %eax
f012047a:	e8 36 f6 ff ff       	call   f011fab5 <find_in_range>
f012047f:	83 c4 10             	add    $0x10,%esp
f0120482:	89 45 b4             	mov    %eax,-0x4c(%ebp)
					if (exist == -1)
f0120485:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0120489:	75 2e                	jne    f01204b9 <test_priorityRR_2+0x338>
					{
						//panic("The programs' order of finishing is not correct\n");
						cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d] is not correct\n", prog_orders[i][j]);
f012048b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f012048e:	89 d0                	mov    %edx,%eax
f0120490:	c1 e0 02             	shl    $0x2,%eax
f0120493:	01 d0                	add    %edx,%eax
f0120495:	01 c0                	add    %eax,%eax
f0120497:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012049a:	01 d0                	add    %edx,%eax
f012049c:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f01204a3:	83 ec 04             	sub    $0x4,%esp
f01204a6:	50                   	push   %eax
f01204a7:	68 b8 f9 13 f0       	push   $0xf013f9b8
f01204ac:	6a 0c                	push   $0xc
f01204ae:	e8 ca 16 fe ff       	call   f0101b7d <cprintf_colored>
f01204b3:	83 c4 10             	add    $0x10,%esp
						numOfIncorrect++;
f01204b6:	ff 45 e4             	incl   -0x1c(%ebp)
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			if (i == 0) //small programs should finish in their strict order
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f01204b9:	ff 45 cc             	incl   -0x34(%ebp)
f01204bc:	83 7d cc 07          	cmpl   $0x7,-0x34(%ebp)
f01204c0:	7e 94                	jle    f0120456 <test_priorityRR_2+0x2d5>
						//panic("The programs' order of finishing is not correct\n");
						cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d] is not correct\n", prog_orders[i][j]);
						numOfIncorrect++;
					}
				}
				start_idx += env_count[i];
f01204c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01204c5:	8b 04 85 b0 cb 94 f1 	mov    -0xe6b3450(,%eax,4),%eax
f01204cc:	01 45 d4             	add    %eax,-0x2c(%ebp)
f01204cf:	e9 a5 00 00 00       	jmp    f0120579 <test_priorityRR_2+0x3f8>
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f01204d4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01204db:	eb 6f                	jmp    f012054c <test_priorityRR_2+0x3cb>
				{
					totalNumOfProcesses++;
f01204dd:	ff 45 e0             	incl   -0x20(%ebp)
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f01204e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01204e3:	8b 14 85 b0 cb 94 f1 	mov    -0xe6b3450(,%eax,4),%edx
f01204ea:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f01204ed:	89 c8                	mov    %ecx,%eax
f01204ef:	c1 e0 02             	shl    $0x2,%eax
f01204f2:	01 c8                	add    %ecx,%eax
f01204f4:	01 c0                	add    %eax,%eax
f01204f6:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f01204f9:	01 c8                	add    %ecx,%eax
f01204fb:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f0120502:	83 ec 04             	sub    $0x4,%esp
f0120505:	52                   	push   %edx
f0120506:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120509:	50                   	push   %eax
f012050a:	e8 a6 f5 ff ff       	call   f011fab5 <find_in_range>
f012050f:	83 c4 10             	add    $0x10,%esp
f0120512:	89 45 b0             	mov    %eax,-0x50(%ebp)
					if (exist == -1)
f0120515:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0120519:	75 2e                	jne    f0120549 <test_priorityRR_2+0x3c8>
					{
						//panic("The programs' order of finishing is not correct\n");
						cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d] is not correct\n", prog_orders[i][j]);
f012051b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f012051e:	89 d0                	mov    %edx,%eax
f0120520:	c1 e0 02             	shl    $0x2,%eax
f0120523:	01 d0                	add    %edx,%eax
f0120525:	01 c0                	add    %eax,%eax
f0120527:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012052a:	01 d0                	add    %edx,%eax
f012052c:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f0120533:	83 ec 04             	sub    $0x4,%esp
f0120536:	50                   	push   %eax
f0120537:	68 b8 f9 13 f0       	push   $0xf013f9b8
f012053c:	6a 0c                	push   $0xc
f012053e:	e8 3a 16 fe ff       	call   f0101b7d <cprintf_colored>
f0120543:	83 c4 10             	add    $0x10,%esp
						numOfIncorrect++;
f0120546:	ff 45 e4             	incl   -0x1c(%ebp)
				}
				start_idx += env_count[i];
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f0120549:	ff 45 c8             	incl   -0x38(%ebp)
f012054c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f012054f:	89 d0                	mov    %edx,%eax
f0120551:	c1 e0 02             	shl    $0x2,%eax
f0120554:	01 d0                	add    %edx,%eax
f0120556:	01 c0                	add    %eax,%eax
f0120558:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012055b:	01 d0                	add    %edx,%eax
f012055d:	8b 04 85 c0 ca 94 f1 	mov    -0xe6b3540(,%eax,4),%eax
f0120564:	85 c0                	test   %eax,%eax
f0120566:	0f 85 71 ff ff ff    	jne    f01204dd <test_priorityRR_2+0x35c>
						//panic("The programs' order of finishing is not correct\n");
						cprintf_colored(TEXT_TESTERR_CLR, "The finish order of program [%d] is not correct\n", prog_orders[i][j]);
						numOfIncorrect++;
					}
				}
				start_idx += env_count[i];
f012056c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012056f:	8b 04 85 b0 cb 94 f1 	mov    -0xe6b3450(,%eax,4),%eax
f0120576:	01 45 d4             	add    %eax,-0x2c(%ebp)
	{
		cprintf_colored(TEXT_light_cyan, "\n> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0120579:	ff 45 d0             	incl   -0x30(%ebp)
f012057c:	83 7d d0 04          	cmpl   $0x4,-0x30(%ebp)
f0120580:	0f 8e bd fe ff ff    	jle    f0120443 <test_priorityRR_2+0x2c2>
					}
				}
				start_idx += env_count[i];
			}
		}
		firstTimeTest = 0;
f0120586:	c6 05 86 81 19 f0 00 	movb   $0x0,0xf0198186
	}
	int eval = 100 - numOfIncorrect * 100 / totalNumOfProcesses;
f012058d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120590:	89 d0                	mov    %edx,%eax
f0120592:	c1 e0 02             	shl    $0x2,%eax
f0120595:	01 d0                	add    %edx,%eax
f0120597:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012059e:	01 d0                	add    %edx,%eax
f01205a0:	c1 e0 02             	shl    $0x2,%eax
f01205a3:	99                   	cltd   
f01205a4:	f7 7d e0             	idivl  -0x20(%ebp)
f01205a7:	ba 64 00 00 00       	mov    $0x64,%edx
f01205ac:	29 c2                	sub    %eax,%edx
f01205ae:	89 d0                	mov    %edx,%eax
f01205b0:	89 45 ac             	mov    %eax,-0x54(%ebp)
	cprintf("totalNumOfProcesses = %d\n ", totalNumOfProcesses);
f01205b3:	83 ec 08             	sub    $0x8,%esp
f01205b6:	ff 75 e0             	pushl  -0x20(%ebp)
f01205b9:	68 30 fb 13 f0       	push   $0xf013fb30
f01205be:	e8 8a 15 fe ff       	call   f0101b4d <cprintf>
f01205c3:	83 c4 10             	add    $0x10,%esp
	cprintf_colored(TEXT_light_green, "\ntest_priorityRR_2 is finished. Eval = %d%\n", eval);
f01205c6:	83 ec 04             	sub    $0x4,%esp
f01205c9:	ff 75 ac             	pushl  -0x54(%ebp)
f01205cc:	68 4c fb 13 f0       	push   $0xf013fb4c
f01205d1:	6a 0a                	push   $0xa
f01205d3:	e8 a5 15 fe ff       	call   f0101b7d <cprintf_colored>
f01205d8:	83 c4 10             	add    $0x10,%esp
}
f01205db:	90                   	nop
f01205dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01205df:	5b                   	pop    %ebx
f01205e0:	5e                   	pop    %esi
f01205e1:	5f                   	pop    %edi
f01205e2:	5d                   	pop    %ebp
f01205e3:	c3                   	ret    

f01205e4 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f01205e4:	55                   	push   %ebp
f01205e5:	89 e5                	mov    %esp,%ebp
f01205e7:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f01205ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f01205f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01205f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01205f6:	89 10                	mov    %edx,(%eax)
}
f01205f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01205fb:	c9                   	leave  
f01205fc:	c2 04 00             	ret    $0x4

f01205ff <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f01205ff:	55                   	push   %ebp
f0120600:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f0120602:	8b 45 08             	mov    0x8(%ebp),%eax
f0120605:	85 c0                	test   %eax,%eax
f0120607:	78 16                	js     f012061f <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f0120609:	8b 45 08             	mov    0x8(%ebp),%eax
f012060c:	05 00 20 00 00       	add    $0x2000,%eax
f0120611:	85 c0                	test   %eax,%eax
f0120613:	79 05                	jns    f012061a <fix_round+0x1b>
f0120615:	05 ff 3f 00 00       	add    $0x3fff,%eax
f012061a:	c1 f8 0e             	sar    $0xe,%eax
f012061d:	eb 14                	jmp    f0120633 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f012061f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120622:	2d 00 20 00 00       	sub    $0x2000,%eax
f0120627:	85 c0                	test   %eax,%eax
f0120629:	79 05                	jns    f0120630 <fix_round+0x31>
f012062b:	05 ff 3f 00 00       	add    $0x3fff,%eax
f0120630:	c1 f8 0e             	sar    $0xe,%eax
}
f0120633:	5d                   	pop    %ebp
f0120634:	c3                   	ret    

f0120635 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f0120635:	55                   	push   %ebp
f0120636:	89 e5                	mov    %esp,%ebp
f0120638:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f012063b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012063f:	79 16                	jns    f0120657 <fix_scale+0x22>
f0120641:	68 c0 fb 13 f0       	push   $0xf013fbc0
f0120646:	68 c7 fb 13 f0       	push   $0xf013fbc7
f012064b:	6a 5a                	push   $0x5a
f012064d:	68 dc fb 13 f0       	push   $0xf013fbdc
f0120652:	e8 58 08 fe ff       	call   f0100eaf <_panic>
  return __mk_fix (x.f * n);
f0120657:	8b 45 0c             	mov    0xc(%ebp),%eax
f012065a:	0f af 45 10          	imul   0x10(%ebp),%eax
f012065e:	89 c2                	mov    %eax,%edx
f0120660:	8b 45 08             	mov    0x8(%ebp),%eax
f0120663:	83 ec 08             	sub    $0x8,%esp
f0120666:	52                   	push   %edx
f0120667:	50                   	push   %eax
f0120668:	e8 77 ff ff ff       	call   f01205e4 <__mk_fix>
f012066d:	83 c4 0c             	add    $0xc,%esp
}
f0120670:	8b 45 08             	mov    0x8(%ebp),%eax
f0120673:	c9                   	leave  
f0120674:	c2 04 00             	ret    $0x4

f0120677 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0120677:	55                   	push   %ebp
f0120678:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f012067a:	8b 45 08             	mov    0x8(%ebp),%eax
f012067d:	8b 15 a8 51 96 f1    	mov    0xf19651a8,%edx
f0120683:	29 d0                	sub    %edx,%eax
f0120685:	c1 f8 02             	sar    $0x2,%eax
f0120688:	89 c2                	mov    %eax,%edx
f012068a:	89 d0                	mov    %edx,%eax
f012068c:	c1 e0 03             	shl    $0x3,%eax
f012068f:	01 d0                	add    %edx,%eax
f0120691:	c1 e0 03             	shl    $0x3,%eax
f0120694:	01 d0                	add    %edx,%eax
f0120696:	c1 e0 03             	shl    $0x3,%eax
f0120699:	01 d0                	add    %edx,%eax
f012069b:	c1 e0 03             	shl    $0x3,%eax
f012069e:	01 d0                	add    %edx,%eax
f01206a0:	89 c1                	mov    %eax,%ecx
f01206a2:	c1 e1 0f             	shl    $0xf,%ecx
f01206a5:	01 c8                	add    %ecx,%eax
f01206a7:	c1 e0 03             	shl    $0x3,%eax
f01206aa:	01 d0                	add    %edx,%eax
f01206ac:	f7 d8                	neg    %eax
}
f01206ae:	5d                   	pop    %ebp
f01206af:	c3                   	ret    

f01206b0 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f01206b0:	55                   	push   %ebp
f01206b1:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01206b3:	ff 75 08             	pushl  0x8(%ebp)
f01206b6:	e8 bc ff ff ff       	call   f0120677 <to_frame_number>
f01206bb:	83 c4 04             	add    $0x4,%esp
f01206be:	c1 e0 0c             	shl    $0xc,%eax
}
f01206c1:	c9                   	leave  
f01206c2:	c3                   	ret    

f01206c3 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f01206c3:	55                   	push   %ebp
f01206c4:	89 e5                	mov    %esp,%ebp
f01206c6:	83 ec 08             	sub    $0x8,%esp
	init_kspinlock(&tstcntlock, "tstcnt lock");
f01206c9:	83 ec 08             	sub    $0x8,%esp
f01206cc:	68 f0 fb 13 f0       	push   $0xf013fbf0
f01206d1:	68 a0 54 96 f1       	push   $0xf19654a0
f01206d6:	e8 39 2e ff ff       	call   f0113514 <init_kspinlock>
f01206db:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&tstcntlock);
f01206de:	83 ec 0c             	sub    $0xc,%esp
f01206e1:	68 a0 54 96 f1       	push   $0xf19654a0
f01206e6:	e8 5a 2e ff ff       	call   f0113545 <acquire_kspinlock>
f01206eb:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f01206ee:	c7 05 08 cd 94 f1 00 	movl   $0x0,0xf194cd08
f01206f5:	00 00 00 
	}
	release_kspinlock(&tstcntlock);
f01206f8:	83 ec 0c             	sub    $0xc,%esp
f01206fb:	68 a0 54 96 f1       	push   $0xf19654a0
f0120700:	e8 e5 2e ff ff       	call   f01135ea <release_kspinlock>
f0120705:	83 c4 10             	add    $0x10,%esp
}
f0120708:	90                   	nop
f0120709:	c9                   	leave  
f012070a:	c3                   	ret    

f012070b <inctst>:
void inctst()
{
f012070b:	55                   	push   %ebp
f012070c:	89 e5                	mov    %esp,%ebp
f012070e:	83 ec 08             	sub    $0x8,%esp
	acquire_kspinlock(&tstcntlock);
f0120711:	83 ec 0c             	sub    $0xc,%esp
f0120714:	68 a0 54 96 f1       	push   $0xf19654a0
f0120719:	e8 27 2e ff ff       	call   f0113545 <acquire_kspinlock>
f012071e:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f0120721:	a1 08 cd 94 f1       	mov    0xf194cd08,%eax
f0120726:	40                   	inc    %eax
f0120727:	a3 08 cd 94 f1       	mov    %eax,0xf194cd08
	}
	release_kspinlock(&tstcntlock);
f012072c:	83 ec 0c             	sub    $0xc,%esp
f012072f:	68 a0 54 96 f1       	push   $0xf19654a0
f0120734:	e8 b1 2e ff ff       	call   f01135ea <release_kspinlock>
f0120739:	83 c4 10             	add    $0x10,%esp
}
f012073c:	90                   	nop
f012073d:	c9                   	leave  
f012073e:	c3                   	ret    

f012073f <gettst>:
uint32 gettst()
{
f012073f:	55                   	push   %ebp
f0120740:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f0120742:	a1 08 cd 94 f1       	mov    0xf194cd08,%eax
}
f0120747:	5d                   	pop    %ebp
f0120748:	c3                   	ret    

f0120749 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f0120749:	55                   	push   %ebp
f012074a:	89 e5                	mov    %esp,%ebp
f012074c:	83 ec 28             	sub    $0x28,%esp
f012074f:	8b 45 14             	mov    0x14(%ebp),%eax
f0120752:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f0120755:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f012075c:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f0120760:	83 f8 65             	cmp    $0x65,%eax
f0120763:	74 5d                	je     f01207c2 <tst+0x79>
f0120765:	83 f8 65             	cmp    $0x65,%eax
f0120768:	7f 0a                	jg     f0120774 <tst+0x2b>
f012076a:	83 f8 62             	cmp    $0x62,%eax
f012076d:	74 73                	je     f01207e2 <tst+0x99>
f012076f:	e9 91 00 00 00       	jmp    f0120805 <tst+0xbc>
f0120774:	83 f8 67             	cmp    $0x67,%eax
f0120777:	74 29                	je     f01207a2 <tst+0x59>
f0120779:	83 f8 6c             	cmp    $0x6c,%eax
f012077c:	0f 85 83 00 00 00    	jne    f0120805 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f0120782:	8b 45 08             	mov    0x8(%ebp),%eax
f0120785:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120788:	73 09                	jae    f0120793 <tst+0x4a>
			chk = 1;
f012078a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0120791:	eb 68                	jmp    f01207fb <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0120793:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120797:	74 62                	je     f01207fb <tst+0xb2>
			chk = 1;
f0120799:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01207a0:	eb 59                	jmp    f01207fb <tst+0xb2>
	case 'g':
		if (n > v1)
f01207a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01207a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01207a8:	76 09                	jbe    f01207b3 <tst+0x6a>
			chk = 1;
f01207aa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f01207b1:	eb 4b                	jmp    f01207fe <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f01207b3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f01207b7:	74 45                	je     f01207fe <tst+0xb5>
			chk = 1;
f01207b9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01207c0:	eb 3c                	jmp    f01207fe <tst+0xb5>
	case 'e':
		if (n == v1)
f01207c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01207c5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01207c8:	75 09                	jne    f01207d3 <tst+0x8a>
			chk = 1;
f01207ca:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f01207d1:	eb 2e                	jmp    f0120801 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f01207d3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f01207d7:	74 28                	je     f0120801 <tst+0xb8>
			chk = 1;
f01207d9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01207e0:	eb 1f                	jmp    f0120801 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f01207e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01207e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01207e8:	72 1a                	jb     f0120804 <tst+0xbb>
f01207ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01207ed:	3b 45 10             	cmp    0x10(%ebp),%eax
f01207f0:	77 12                	ja     f0120804 <tst+0xbb>
			chk = 1;
f01207f2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01207f9:	eb 09                	jmp    f0120804 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01207fb:	90                   	nop
f01207fc:	eb 07                	jmp    f0120805 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01207fe:	90                   	nop
f01207ff:	eb 04                	jmp    f0120805 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0120801:	90                   	nop
f0120802:	eb 01                	jmp    f0120805 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f0120804:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f0120805:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120809:	75 14                	jne    f012081f <tst+0xd6>
f012080b:	83 ec 04             	sub    $0x4,%esp
f012080e:	68 fc fb 13 f0       	push   $0xf013fbfc
f0120813:	6a 49                	push   $0x49
f0120815:	68 0f fc 13 f0       	push   $0xf013fc0f
f012081a:	e8 90 06 fe ff       	call   f0100eaf <_panic>

	acquire_kspinlock(&tstcntlock);
f012081f:	83 ec 0c             	sub    $0xc,%esp
f0120822:	68 a0 54 96 f1       	push   $0xf19654a0
f0120827:	e8 19 2d ff ff       	call   f0113545 <acquire_kspinlock>
f012082c:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f012082f:	a1 08 cd 94 f1       	mov    0xf194cd08,%eax
f0120834:	40                   	inc    %eax
f0120835:	a3 08 cd 94 f1       	mov    %eax,0xf194cd08
	}
	release_kspinlock(&tstcntlock);
f012083a:	83 ec 0c             	sub    $0xc,%esp
f012083d:	68 a0 54 96 f1       	push   $0xf19654a0
f0120842:	e8 a3 2d ff ff       	call   f01135ea <release_kspinlock>
f0120847:	83 c4 10             	add    $0x10,%esp

	return;
f012084a:	90                   	nop
}
f012084b:	c9                   	leave  
f012084c:	c3                   	ret    

f012084d <chktst>:

void chktst(uint32 n)
{
f012084d:	55                   	push   %ebp
f012084e:	89 e5                	mov    %esp,%ebp
f0120850:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_kspinlock(&tstcntlock);
f0120853:	83 ec 0c             	sub    $0xc,%esp
f0120856:	68 a0 54 96 f1       	push   $0xf19654a0
f012085b:	e8 e5 2c ff ff       	call   f0113545 <acquire_kspinlock>
f0120860:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0120863:	a1 08 cd 94 f1       	mov    0xf194cd08,%eax
f0120868:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_kspinlock(&tstcntlock);
f012086b:	83 ec 0c             	sub    $0xc,%esp
f012086e:	68 a0 54 96 f1       	push   $0xf19654a0
f0120873:	e8 72 2d ff ff       	call   f01135ea <release_kspinlock>
f0120878:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f012087b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012087e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120881:	75 12                	jne    f0120895 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0120883:	83 ec 0c             	sub    $0xc,%esp
f0120886:	68 28 fc 13 f0       	push   $0xf013fc28
f012088b:	e8 bd 12 fe ff       	call   f0101b4d <cprintf>
f0120890:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0120893:	eb 14                	jmp    f01208a9 <chktst+0x5c>
	}
	release_kspinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0120895:	83 ec 04             	sub    $0x4,%esp
f0120898:	68 54 fc 13 f0       	push   $0xf013fc54
f012089d:	6a 5f                	push   $0x5f
f012089f:	68 0f fc 13 f0       	push   $0xf013fc0f
f01208a4:	e8 06 06 fe ff       	call   f0100eaf <_panic>
}
f01208a9:	c9                   	leave  
f01208aa:	c3                   	ret    

f01208ab <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f01208ab:	55                   	push   %ebp
f01208ac:	89 e5                	mov    %esp,%ebp
f01208ae:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f01208b1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01208b5:	77 07                	ja     f01208be <nearest_pow2_ceil+0x13>
f01208b7:	b8 01 00 00 00       	mov    $0x1,%eax
f01208bc:	eb 20                	jmp    f01208de <nearest_pow2_ceil+0x33>
	int power = 2;
f01208be:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f01208c5:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f01208c8:	eb 08                	jmp    f01208d2 <nearest_pow2_ceil+0x27>
		power <<= 1;
f01208ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01208cd:	01 c0                	add    %eax,%eax
f01208cf:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f01208d2:	d1 6d 08             	shrl   0x8(%ebp)
f01208d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01208d9:	75 ef                	jne    f01208ca <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f01208db:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01208de:	c9                   	leave  
f01208df:	c3                   	ret    

f01208e0 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f01208e0:	55                   	push   %ebp
f01208e1:	89 e5                	mov    %esp,%ebp
f01208e3:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f01208e6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01208ea:	77 07                	ja     f01208f3 <log2_ceil+0x13>
f01208ec:	b8 01 00 00 00       	mov    $0x1,%eax
f01208f1:	eb 1b                	jmp    f012090e <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f01208f3:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f01208fa:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f01208fd:	eb 03                	jmp    f0120902 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f01208ff:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f0120902:	d1 6d 08             	shrl   0x8(%ebp)
f0120905:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120909:	75 f4                	jne    f01208ff <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f012090b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f012090e:	c9                   	leave  
f012090f:	c3                   	ret    

f0120910 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f0120910:	55                   	push   %ebp
f0120911:	89 e5                	mov    %esp,%ebp
f0120913:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0120916:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f012091d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0120924:	eb 12                	jmp    f0120938 <fixedPt2Str+0x28>
		mulFactor *= 10;
f0120926:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120929:	89 d0                	mov    %edx,%eax
f012092b:	c1 e0 02             	shl    $0x2,%eax
f012092e:	01 d0                	add    %edx,%eax
f0120930:	01 c0                	add    %eax,%eax
f0120932:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0120935:	ff 45 f0             	incl   -0x10(%ebp)
f0120938:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012093b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f012093e:	7c e6                	jl     f0120926 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f0120940:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0120943:	83 ec 04             	sub    $0x4,%esp
f0120946:	ff 75 f4             	pushl  -0xc(%ebp)
f0120949:	ff 75 08             	pushl  0x8(%ebp)
f012094c:	50                   	push   %eax
f012094d:	e8 e3 fc ff ff       	call   f0120635 <fix_scale>
f0120952:	83 c4 0c             	add    $0xc,%esp
f0120955:	83 ec 0c             	sub    $0xc,%esp
f0120958:	ff 75 dc             	pushl  -0x24(%ebp)
f012095b:	e8 9f fc ff ff       	call   f01205ff <fix_round>
f0120960:	83 c4 10             	add    $0x10,%esp
f0120963:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0120966:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120969:	99                   	cltd   
f012096a:	f7 7d f4             	idivl  -0xc(%ebp)
f012096d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f0120970:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120973:	99                   	cltd   
f0120974:	f7 7d f4             	idivl  -0xc(%ebp)
f0120977:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f012097a:	83 ec 08             	sub    $0x8,%esp
f012097d:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120980:	50                   	push   %eax
f0120981:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120984:	e8 fb 29 00 00       	call   f0123384 <ltostr>
f0120989:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f012098c:	83 ec 08             	sub    $0x8,%esp
f012098f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120992:	50                   	push   %eax
f0120993:	ff 75 e0             	pushl  -0x20(%ebp)
f0120996:	e8 e9 29 00 00       	call   f0123384 <ltostr>
f012099b:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f012099e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01209a1:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01209a6:	f7 e9                	imul   %ecx
f01209a8:	c1 fa 02             	sar    $0x2,%edx
f01209ab:	89 c8                	mov    %ecx,%eax
f01209ad:	c1 f8 1f             	sar    $0x1f,%eax
f01209b0:	29 c2                	sub    %eax,%edx
f01209b2:	89 d0                	mov    %edx,%eax
f01209b4:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f01209b7:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f01209be:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f01209c5:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f01209cb:	eb 31                	jmp    f01209fe <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f01209cd:	83 ec 04             	sub    $0x4,%esp
f01209d0:	8d 45 aa             	lea    -0x56(%ebp),%eax
f01209d3:	50                   	push   %eax
f01209d4:	8d 45 aa             	lea    -0x56(%ebp),%eax
f01209d7:	50                   	push   %eax
f01209d8:	68 70 fc 13 f0       	push   $0xf013fc70
f01209dd:	e8 7b 2a 00 00       	call   f012345d <strcconcat>
f01209e2:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f01209e5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01209e8:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01209ed:	f7 e9                	imul   %ecx
f01209ef:	c1 fa 02             	sar    $0x2,%edx
f01209f2:	89 c8                	mov    %ecx,%eax
f01209f4:	c1 f8 1f             	sar    $0x1f,%eax
f01209f7:	29 c2                	sub    %eax,%edx
f01209f9:	89 d0                	mov    %edx,%eax
f01209fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f01209fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120a01:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120a04:	7c c7                	jl     f01209cd <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f0120a06:	83 ec 04             	sub    $0x4,%esp
f0120a09:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0120a0c:	50                   	push   %eax
f0120a0d:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120a10:	50                   	push   %eax
f0120a11:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120a14:	50                   	push   %eax
f0120a15:	e8 43 2a 00 00       	call   f012345d <strcconcat>
f0120a1a:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f0120a1d:	83 ec 04             	sub    $0x4,%esp
f0120a20:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120a23:	50                   	push   %eax
f0120a24:	68 72 fc 13 f0       	push   $0xf013fc72
f0120a29:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120a2c:	50                   	push   %eax
f0120a2d:	e8 2b 2a 00 00       	call   f012345d <strcconcat>
f0120a32:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0120a35:	83 ec 04             	sub    $0x4,%esp
f0120a38:	ff 75 10             	pushl  0x10(%ebp)
f0120a3b:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0120a3e:	50                   	push   %eax
f0120a3f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120a42:	50                   	push   %eax
f0120a43:	e8 15 2a 00 00       	call   f012345d <strcconcat>
f0120a48:	83 c4 10             	add    $0x10,%esp

}
f0120a4b:	90                   	nop
f0120a4c:	c9                   	leave  
f0120a4d:	c3                   	ret    

f0120a4e <sys_utilities>:
struct sleeplock __tstslplk__;
int __numOfSlaves = 0;
#define __maxNumOfKSems (10)
struct ksemaphore __ksems[__maxNumOfKSems];
void sys_utilities(char* utilityName, int value)
{
f0120a4e:	55                   	push   %ebp
f0120a4f:	89 e5                	mov    %esp,%ebp
f0120a51:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
#if USE_KHEAP
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0120a57:	83 ec 0c             	sub    $0xc,%esp
f0120a5a:	68 74 fc 13 f0       	push   $0xf013fc74
f0120a5f:	e8 cb 23 00 00       	call   f0122e2f <strlen>
f0120a64:	83 c4 10             	add    $0x10,%esp
f0120a67:	83 ec 04             	sub    $0x4,%esp
f0120a6a:	50                   	push   %eax
f0120a6b:	68 74 fc 13 f0       	push   $0xf013fc74
f0120a70:	ff 75 08             	pushl  0x8(%ebp)
f0120a73:	e8 fb 24 00 00       	call   f0122f73 <strncmp>
f0120a78:	83 c4 10             	add    $0x10,%esp
f0120a7b:	85 c0                	test   %eax,%eax
f0120a7d:	0f 85 a2 00 00 00    	jne    f0120b25 <sys_utilities+0xd7>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120a83:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f0120a89:	50                   	push   %eax
f0120a8a:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f0120a90:	50                   	push   %eax
f0120a91:	68 82 fc 13 f0       	push   $0xf013fc82
f0120a96:	ff 75 08             	pushl  0x8(%ebp)
f0120a99:	e8 55 2a 00 00       	call   f01234f3 <strsplit>
f0120a9e:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0120aa1:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f0120aa7:	83 ec 04             	sub    $0x4,%esp
f0120aaa:	6a 0a                	push   $0xa
f0120aac:	6a 00                	push   $0x0
f0120aae:	50                   	push   %eax
f0120aaf:	e8 8a 27 00 00       	call   f012323e <strtol>
f0120ab4:	83 c4 10             	add    $0x10,%esp
f0120ab7:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		struct Env* env = NULL ;
f0120abd:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%ebp)
f0120ac4:	00 00 00 
		envid2env(envID, &env, 0);
f0120ac7:	83 ec 04             	sub    $0x4,%esp
f0120aca:	6a 00                	push   $0x0
f0120acc:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
f0120ad2:	50                   	push   %eax
f0120ad3:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
f0120ad9:	e8 ba cb fe ff       	call   f010d698 <envid2env>
f0120ade:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0120ae1:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0120ae7:	8b 40 10             	mov    0x10(%eax),%eax
f0120aea:	3b 85 44 ff ff ff    	cmp    -0xbc(%ebp),%eax
f0120af0:	74 19                	je     f0120b0b <sys_utilities+0xbd>
f0120af2:	68 84 fc 13 f0       	push   $0xf013fc84
f0120af7:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0120afc:	68 a8 00 00 00       	push   $0xa8
f0120b01:	68 0f fc 13 f0       	push   $0xf013fc0f
f0120b06:	e8 a4 03 fe ff       	call   f0100eaf <_panic>
		env_set_nice(env, value);
f0120b0b:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0120b11:	83 ec 08             	sub    $0x8,%esp
f0120b14:	ff 75 0c             	pushl  0xc(%ebp)
f0120b17:	50                   	push   %eax
f0120b18:	e8 f4 6b fe ff       	call   f0107711 <env_set_nice>
f0120b1d:	83 c4 10             	add    $0x10,%esp
f0120b20:	e9 99 0d 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strncmp(utilityName, "__PRIRRSetPriority@", strlen("__PRIRRSetPriority@")) == 0)
f0120b25:	83 ec 0c             	sub    $0xc,%esp
f0120b28:	68 99 fc 13 f0       	push   $0xf013fc99
f0120b2d:	e8 fd 22 00 00       	call   f0122e2f <strlen>
f0120b32:	83 c4 10             	add    $0x10,%esp
f0120b35:	83 ec 04             	sub    $0x4,%esp
f0120b38:	50                   	push   %eax
f0120b39:	68 99 fc 13 f0       	push   $0xf013fc99
f0120b3e:	ff 75 08             	pushl  0x8(%ebp)
f0120b41:	e8 2d 24 00 00       	call   f0122f73 <strncmp>
f0120b46:	83 c4 10             	add    $0x10,%esp
f0120b49:	85 c0                	test   %eax,%eax
f0120b4b:	0f 85 a1 00 00 00    	jne    f0120bf2 <sys_utilities+0x1a4>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120b51:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0120b57:	50                   	push   %eax
f0120b58:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f0120b5e:	50                   	push   %eax
f0120b5f:	68 82 fc 13 f0       	push   $0xf013fc82
f0120b64:	ff 75 08             	pushl  0x8(%ebp)
f0120b67:	e8 87 29 00 00       	call   f01234f3 <strsplit>
f0120b6c:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0120b6f:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f0120b75:	83 ec 04             	sub    $0x4,%esp
f0120b78:	6a 0a                	push   $0xa
f0120b7a:	6a 00                	push   $0x0
f0120b7c:	50                   	push   %eax
f0120b7d:	e8 bc 26 00 00       	call   f012323e <strtol>
f0120b82:	83 c4 10             	add    $0x10,%esp
f0120b85:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		struct Env* env = NULL ;
f0120b8b:	c7 85 34 ff ff ff 00 	movl   $0x0,-0xcc(%ebp)
f0120b92:	00 00 00 
		envid2env(envID, &env, 0);
f0120b95:	83 ec 04             	sub    $0x4,%esp
f0120b98:	6a 00                	push   $0x0
f0120b9a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0120ba0:	50                   	push   %eax
f0120ba1:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
f0120ba7:	e8 ec ca fe ff       	call   f010d698 <envid2env>
f0120bac:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0120baf:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0120bb5:	8b 40 10             	mov    0x10(%eax),%eax
f0120bb8:	3b 85 48 ff ff ff    	cmp    -0xb8(%ebp),%eax
f0120bbe:	74 19                	je     f0120bd9 <sys_utilities+0x18b>
f0120bc0:	68 84 fc 13 f0       	push   $0xf013fc84
f0120bc5:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0120bca:	68 b4 00 00 00       	push   $0xb4
f0120bcf:	68 0f fc 13 f0       	push   $0xf013fc0f
f0120bd4:	e8 d6 02 fe ff       	call   f0100eaf <_panic>
		env_set_priority(envID, value);
f0120bd9:	83 ec 08             	sub    $0x8,%esp
f0120bdc:	ff 75 0c             	pushl  0xc(%ebp)
f0120bdf:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
f0120be5:	e8 7e 6b fe ff       	call   f0107768 <env_set_priority>
f0120bea:	83 c4 10             	add    $0x10,%esp
f0120bed:	e9 cc 0c 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f0120bf2:	83 ec 0c             	sub    $0xc,%esp
f0120bf5:	68 ad fc 13 f0       	push   $0xf013fcad
f0120bfa:	e8 30 22 00 00       	call   f0122e2f <strlen>
f0120bff:	83 c4 10             	add    $0x10,%esp
f0120c02:	83 ec 04             	sub    $0x4,%esp
f0120c05:	50                   	push   %eax
f0120c06:	68 ad fc 13 f0       	push   $0xf013fcad
f0120c0b:	ff 75 08             	pushl  0x8(%ebp)
f0120c0e:	e8 60 23 00 00       	call   f0122f73 <strncmp>
f0120c13:	83 c4 10             	add    $0x10,%esp
f0120c16:	85 c0                	test   %eax,%eax
f0120c18:	0f 85 ea 01 00 00    	jne    f0120e08 <sys_utilities+0x3ba>
	{
		int* numOfInstances = (int*) value ;
f0120c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120c21:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120c27:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
f0120c2d:	50                   	push   %eax
f0120c2e:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f0120c34:	50                   	push   %eax
f0120c35:	68 82 fc 13 f0       	push   $0xf013fc82
f0120c3a:	ff 75 08             	pushl  0x8(%ebp)
f0120c3d:	e8 b1 28 00 00       	call   f01234f3 <strsplit>
f0120c42:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0120c45:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f0120c4b:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		struct Env* env = NULL ;
f0120c51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0120c58:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f0120c5f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0120c66:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120c6c:	8b 00                	mov    (%eax),%eax
f0120c6e:	85 c0                	test   %eax,%eax
f0120c70:	79 22                	jns    f0120c94 <sys_utilities+0x246>
		{
			chkAscending = 0;
f0120c72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0120c79:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120c7f:	8b 00                	mov    (%eax),%eax
f0120c81:	f7 d8                	neg    %eax
f0120c83:	89 c2                	mov    %eax,%edx
f0120c85:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120c8b:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0120c8d:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f0120c94:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_kspinlock(&ProcessQueues.qlock);
f0120c9b:	83 ec 0c             	sub    $0xc,%esp
f0120c9e:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0120ca3:	e8 9d 28 ff ff       	call   f0113545 <acquire_kspinlock>
f0120ca8:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0120cab:	a1 4c ce 94 f1       	mov    0xf194ce4c,%eax
f0120cb0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0120cb6:	a1 44 ce 94 f1       	mov    0xf194ce44,%eax
f0120cbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0120cbe:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0120cc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0120cc7:	eb 75                	jmp    f0120d3e <sys_utilities+0x2f0>
			{
				if (strcmp(env->prog_name, progName) != 0)
f0120cc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ccc:	83 c0 20             	add    $0x20,%eax
f0120ccf:	83 ec 08             	sub    $0x8,%esp
f0120cd2:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
f0120cd8:	50                   	push   %eax
f0120cd9:	e8 5d 22 00 00       	call   f0122f3b <strcmp>
f0120cde:	83 c4 10             	add    $0x10,%esp
f0120ce1:	85 c0                	test   %eax,%eax
f0120ce3:	75 4c                	jne    f0120d31 <sys_utilities+0x2e3>
					continue;
				(*numOfInstances)-- ;
f0120ce5:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120ceb:	8b 00                	mov    (%eax),%eax
f0120ced:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120cf0:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120cf6:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f0120cf8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120cfc:	74 14                	je     f0120d12 <sys_utilities+0x2c4>
				{
					if (prevEnvID > env->env_id)
f0120cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d01:	8b 40 10             	mov    0x10(%eax),%eax
f0120d04:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120d07:	7d 1d                	jge    f0120d26 <sys_utilities+0x2d8>
					{
						success = 0;
f0120d09:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0120d10:	eb 32                	jmp    f0120d44 <sys_utilities+0x2f6>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f0120d12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d15:	8b 40 10             	mov    0x10(%eax),%eax
f0120d18:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120d1b:	7e 09                	jle    f0120d26 <sys_utilities+0x2d8>
					{
						success = 0;
f0120d1d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0120d24:	eb 1e                	jmp    f0120d44 <sys_utilities+0x2f6>
					}
				}
				prevEnvID = env->env_id;
f0120d26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d29:	8b 40 10             	mov    0x10(%eax),%eax
f0120d2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120d2f:	eb 01                	jmp    f0120d32 <sys_utilities+0x2e4>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0120d31:	90                   	nop
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0120d32:	ff 4d e4             	decl   -0x1c(%ebp)
f0120d35:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d38:	8b 40 0c             	mov    0xc(%eax),%eax
f0120d3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120d3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120d42:	7f 85                	jg     f0120cc9 <sys_utilities+0x27b>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0120d44:	83 ec 0c             	sub    $0xc,%esp
f0120d47:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0120d4c:	e8 99 28 ff ff       	call   f01135ea <release_kspinlock>
f0120d51:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f0120d54:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120d5a:	8b 00                	mov    (%eax),%eax
f0120d5c:	85 c0                	test   %eax,%eax
f0120d5e:	75 06                	jne    f0120d66 <sys_utilities+0x318>
f0120d60:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120d64:	75 51                	jne    f0120db7 <sys_utilities+0x369>
		{
			cons_lock();
f0120d66:	e8 63 0d fe ff       	call   f0101ace <cons_lock>
			{
				cprintf("###########################################\n");
f0120d6b:	83 ec 0c             	sub    $0xc,%esp
f0120d6e:	68 c0 fc 13 f0       	push   $0xf013fcc0
f0120d73:	e8 d5 0d fe ff       	call   f0101b4d <cprintf>
f0120d78:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is FAILED\n", progName);
f0120d7b:	83 ec 08             	sub    $0x8,%esp
f0120d7e:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
f0120d84:	68 f0 fc 13 f0       	push   $0xf013fcf0
f0120d89:	e8 bf 0d fe ff       	call   f0101b4d <cprintf>
f0120d8e:	83 c4 10             	add    $0x10,%esp
				cprintf("###########################################\n");
f0120d91:	83 ec 0c             	sub    $0xc,%esp
f0120d94:	68 c0 fc 13 f0       	push   $0xf013fcc0
f0120d99:	e8 af 0d fe ff       	call   f0101b4d <cprintf>
f0120d9e:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0120da1:	e8 41 0d fe ff       	call   f0101ae7 <cons_unlock>
			*numOfInstances = 0; //to indicate the failure of test
f0120da6:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120dac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120db2:	e9 07 0b 00 00       	jmp    f01218be <sys_utilities+0xe70>
		}
		else
		{
			cons_lock();
f0120db7:	e8 12 0d fe ff       	call   f0101ace <cons_lock>
			{
				cprintf("####################################################\n");
f0120dbc:	83 ec 0c             	sub    $0xc,%esp
f0120dbf:	68 10 fd 13 f0       	push   $0xf013fd10
f0120dc4:	e8 84 0d fe ff       	call   f0101b4d <cprintf>
f0120dc9:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is SUCCEEDED\n", progName);
f0120dcc:	83 ec 08             	sub    $0x8,%esp
f0120dcf:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
f0120dd5:	68 48 fd 13 f0       	push   $0xf013fd48
f0120dda:	e8 6e 0d fe ff       	call   f0101b4d <cprintf>
f0120ddf:	83 c4 10             	add    $0x10,%esp
				cprintf("####################################################\n");
f0120de2:	83 ec 0c             	sub    $0xc,%esp
f0120de5:	68 10 fd 13 f0       	push   $0xf013fd10
f0120dea:	e8 5e 0d fe ff       	call   f0101b4d <cprintf>
f0120def:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0120df2:	e8 f0 0c fe ff       	call   f0101ae7 <cons_unlock>
			*numOfInstances = 1; //to indicate the success of test
f0120df7:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0120dfd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f0120e03:	e9 b6 0a 00 00       	jmp    f01218be <sys_utilities+0xe70>
		}
	}
	else if (strncmp(utilityName, "__NthClkRepl@", strlen("__NthClkRepl@")) == 0)
f0120e08:	83 ec 0c             	sub    $0xc,%esp
f0120e0b:	68 6b fd 13 f0       	push   $0xf013fd6b
f0120e10:	e8 1a 20 00 00       	call   f0122e2f <strlen>
f0120e15:	83 c4 10             	add    $0x10,%esp
f0120e18:	83 ec 04             	sub    $0x4,%esp
f0120e1b:	50                   	push   %eax
f0120e1c:	68 6b fd 13 f0       	push   $0xf013fd6b
f0120e21:	ff 75 08             	pushl  0x8(%ebp)
f0120e24:	e8 4a 21 00 00       	call   f0122f73 <strncmp>
f0120e29:	83 c4 10             	add    $0x10,%esp
f0120e2c:	85 c0                	test   %eax,%eax
f0120e2e:	0f 85 82 00 00 00    	jne    f0120eb6 <sys_utilities+0x468>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120e34:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f0120e3a:	50                   	push   %eax
f0120e3b:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f0120e41:	50                   	push   %eax
f0120e42:	68 82 fc 13 f0       	push   $0xf013fc82
f0120e47:	ff 75 08             	pushl  0x8(%ebp)
f0120e4a:	e8 a4 26 00 00       	call   f01234f3 <strsplit>
f0120e4f:	83 c4 10             	add    $0x10,%esp
		int type = strtol(tokens[1], NULL, 10);
f0120e52:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f0120e58:	83 ec 04             	sub    $0x4,%esp
f0120e5b:	6a 0a                	push   $0xa
f0120e5d:	6a 00                	push   $0x0
f0120e5f:	50                   	push   %eax
f0120e60:	e8 d9 23 00 00       	call   f012323e <strtol>
f0120e65:	83 c4 10             	add    $0x10,%esp
f0120e68:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		int N = value;
f0120e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e71:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (type == 2)
f0120e74:	83 bd 58 ff ff ff 02 	cmpl   $0x2,-0xa8(%ebp)
f0120e7b:	75 03                	jne    f0120e80 <sys_utilities+0x432>
			N *= -1;
f0120e7d:	f7 5d e0             	negl   -0x20(%ebp)
		setPageReplacmentAlgorithmNchanceCLOCK(N);
f0120e80:	83 ec 0c             	sub    $0xc,%esp
f0120e83:	ff 75 e0             	pushl  -0x20(%ebp)
f0120e86:	e8 bd 07 ff ff       	call   f0111648 <setPageReplacmentAlgorithmNchanceCLOCK>
f0120e8b:	83 c4 10             	add    $0x10,%esp
		cons_lock();
f0120e8e:	e8 3b 0c fe ff       	call   f0101ace <cons_lock>
		{
			cprintf("\n*********************************************************"
f0120e93:	83 ec 04             	sub    $0x4,%esp
f0120e96:	ff 75 e0             	pushl  -0x20(%ebp)
f0120e99:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
f0120e9f:	68 7c fd 13 f0       	push   $0xf013fd7c
f0120ea4:	e8 a4 0c fe ff       	call   f0101b4d <cprintf>
f0120ea9:	83 c4 10             	add    $0x10,%esp
					"\nPAGE REPLACEMENT IS SET TO Nth Clock type = %d (N = %d)."
					"\n*********************************************************\n", type, N);
		}
		cons_unlock();
f0120eac:	e8 36 0c fe ff       	call   f0101ae7 <cons_unlock>
f0120eb1:	e9 08 0a 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f0120eb6:	83 ec 08             	sub    $0x8,%esp
f0120eb9:	68 2b fe 13 f0       	push   $0xf013fe2b
f0120ebe:	ff 75 08             	pushl  0x8(%ebp)
f0120ec1:	e8 75 20 00 00       	call   f0122f3b <strcmp>
f0120ec6:	83 c4 10             	add    $0x10,%esp
f0120ec9:	85 c0                	test   %eax,%eax
f0120ecb:	75 77                	jne    f0120f44 <sys_utilities+0x4f6>
	{
		if (__firstTimeSleep)
f0120ecd:	a1 88 81 19 f0       	mov    0xf0198188,%eax
f0120ed2:	85 c0                	test   %eax,%eax
f0120ed4:	74 34                	je     f0120f0a <sys_utilities+0x4bc>
		{
			__firstTimeSleep = 0;
f0120ed6:	c7 05 88 81 19 f0 00 	movl   $0x0,0xf0198188
f0120edd:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f0120ee0:	83 ec 08             	sub    $0x8,%esp
f0120ee3:	68 35 fe 13 f0       	push   $0xf013fe35
f0120ee8:	68 a0 79 9a f1       	push   $0xf19a79a0
f0120eed:	e8 a2 2a ff ff       	call   f0113994 <init_channel>
f0120ef2:	83 c4 10             	add    $0x10,%esp
			init_kspinlock(&__tstchan_lk__, "Test Channel Lock");
f0120ef5:	83 ec 08             	sub    $0x8,%esp
f0120ef8:	68 42 fe 13 f0       	push   $0xf013fe42
f0120efd:	68 60 85 9a f1       	push   $0xf19a8560
f0120f02:	e8 0d 26 ff ff       	call   f0113514 <init_kspinlock>
f0120f07:	83 c4 10             	add    $0x10,%esp
		}
		acquire_kspinlock(&__tstchan_lk__);
f0120f0a:	83 ec 0c             	sub    $0xc,%esp
f0120f0d:	68 60 85 9a f1       	push   $0xf19a8560
f0120f12:	e8 2e 26 ff ff       	call   f0113545 <acquire_kspinlock>
f0120f17:	83 c4 10             	add    $0x10,%esp
		{
			sleep(&__tstchan__, &__tstchan_lk__);
f0120f1a:	83 ec 08             	sub    $0x8,%esp
f0120f1d:	68 60 85 9a f1       	push   $0xf19a8560
f0120f22:	68 a0 79 9a f1       	push   $0xf19a79a0
f0120f27:	e8 95 2a ff ff       	call   f01139c1 <sleep>
f0120f2c:	83 c4 10             	add    $0x10,%esp
		}
		release_kspinlock(&__tstchan_lk__);
f0120f2f:	83 ec 0c             	sub    $0xc,%esp
f0120f32:	68 60 85 9a f1       	push   $0xf19a8560
f0120f37:	e8 ae 26 ff ff       	call   f01135ea <release_kspinlock>
f0120f3c:	83 c4 10             	add    $0x10,%esp
f0120f3f:	e9 7a 09 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f0120f44:	83 ec 08             	sub    $0x8,%esp
f0120f47:	68 54 fe 13 f0       	push   $0xf013fe54
f0120f4c:	ff 75 08             	pushl  0x8(%ebp)
f0120f4f:	e8 e7 1f 00 00       	call   f0122f3b <strcmp>
f0120f54:	83 c4 10             	add    $0x10,%esp
f0120f57:	85 c0                	test   %eax,%eax
f0120f59:	75 15                	jne    f0120f70 <sys_utilities+0x522>
	{
		wakeup_one(&__tstchan__);
f0120f5b:	83 ec 0c             	sub    $0xc,%esp
f0120f5e:	68 a0 79 9a f1       	push   $0xf19a79a0
f0120f63:	e8 d0 2a ff ff       	call   f0113a38 <wakeup_one>
f0120f68:	83 c4 10             	add    $0x10,%esp
f0120f6b:	e9 4e 09 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f0120f70:	83 ec 08             	sub    $0x8,%esp
f0120f73:	68 62 fe 13 f0       	push   $0xf013fe62
f0120f78:	ff 75 08             	pushl  0x8(%ebp)
f0120f7b:	e8 bb 1f 00 00       	call   f0122f3b <strcmp>
f0120f80:	83 c4 10             	add    $0x10,%esp
f0120f83:	85 c0                	test   %eax,%eax
f0120f85:	75 15                	jne    f0120f9c <sys_utilities+0x54e>
	{
		wakeup_all(&__tstchan__);
f0120f87:	83 ec 0c             	sub    $0xc,%esp
f0120f8a:	68 a0 79 9a f1       	push   $0xf19a79a0
f0120f8f:	e8 15 2b ff ff       	call   f0113aa9 <wakeup_all>
f0120f94:	83 c4 10             	add    $0x10,%esp
f0120f97:	e9 22 09 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f0120f9c:	83 ec 08             	sub    $0x8,%esp
f0120f9f:	68 70 fe 13 f0       	push   $0xf013fe70
f0120fa4:	ff 75 08             	pushl  0x8(%ebp)
f0120fa7:	e8 8f 1f 00 00       	call   f0122f3b <strcmp>
f0120fac:	83 c4 10             	add    $0x10,%esp
f0120faf:	85 c0                	test   %eax,%eax
f0120fb1:	75 3d                	jne    f0120ff0 <sys_utilities+0x5a2>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f0120fb3:	83 ec 0c             	sub    $0xc,%esp
f0120fb6:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0120fbb:	e8 85 25 ff ff       	call   f0113545 <acquire_kspinlock>
f0120fc0:	83 c4 10             	add    $0x10,%esp
		{
			int* numOfProcesses = (int*) value ;
f0120fc3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fc6:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f0120fcc:	a1 ac 79 9a f1       	mov    0xf19a79ac,%eax
f0120fd1:	89 c2                	mov    %eax,%edx
f0120fd3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0120fd9:	89 10                	mov    %edx,(%eax)
		}
		release_kspinlock(&ProcessQueues.qlock);
f0120fdb:	83 ec 0c             	sub    $0xc,%esp
f0120fde:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0120fe3:	e8 02 26 ff ff       	call   f01135ea <release_kspinlock>
f0120fe8:	83 c4 10             	add    $0x10,%esp
f0120feb:	e9 ce 08 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f0120ff0:	83 ec 08             	sub    $0x8,%esp
f0120ff3:	68 85 fe 13 f0       	push   $0xf013fe85
f0120ff8:	ff 75 08             	pushl  0x8(%ebp)
f0120ffb:	e8 3b 1f 00 00       	call   f0122f3b <strcmp>
f0121000:	83 c4 10             	add    $0x10,%esp
f0121003:	85 c0                	test   %eax,%eax
f0121005:	75 40                	jne    f0121047 <sys_utilities+0x5f9>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f0121007:	83 ec 0c             	sub    $0xc,%esp
f012100a:	68 c0 cd 94 f1       	push   $0xf194cdc0
f012100f:	e8 31 25 ff ff       	call   f0113545 <acquire_kspinlock>
f0121014:	83 c4 10             	add    $0x10,%esp
		{
			int* numOfProcesses = (int*) value ;
f0121017:	8b 45 0c             	mov    0xc(%ebp),%eax
f012101a:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f0121020:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121025:	8b 40 0c             	mov    0xc(%eax),%eax
f0121028:	89 c2                	mov    %eax,%edx
f012102a:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f0121030:	89 10                	mov    %edx,(%eax)
		}
		release_kspinlock(&ProcessQueues.qlock);
f0121032:	83 ec 0c             	sub    $0xc,%esp
f0121035:	68 c0 cd 94 f1       	push   $0xf194cdc0
f012103a:	e8 ab 25 ff ff       	call   f01135ea <release_kspinlock>
f012103f:	83 c4 10             	add    $0x10,%esp
f0121042:	e9 77 08 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f0121047:	83 ec 08             	sub    $0x8,%esp
f012104a:	68 9b fe 13 f0       	push   $0xf013fe9b
f012104f:	ff 75 08             	pushl  0x8(%ebp)
f0121052:	e8 e4 1e 00 00       	call   f0122f3b <strcmp>
f0121057:	83 c4 10             	add    $0x10,%esp
f012105a:	85 c0                	test   %eax,%eax
f012105c:	75 3d                	jne    f012109b <sys_utilities+0x64d>
	{
		if (__firstTimeSleepLock)
f012105e:	a1 8c 81 19 f0       	mov    0xf019818c,%eax
f0121063:	85 c0                	test   %eax,%eax
f0121065:	74 1f                	je     f0121086 <sys_utilities+0x638>
		{
			__firstTimeSleepLock = 0;
f0121067:	c7 05 8c 81 19 f0 00 	movl   $0x0,0xf019818c
f012106e:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f0121071:	83 ec 08             	sub    $0x8,%esp
f0121074:	68 b0 fe 13 f0       	push   $0xf013feb0
f0121079:	68 40 84 9a f1       	push   $0xf19a8440
f012107e:	e8 58 27 ff ff       	call   f01137db <init_sleeplock>
f0121083:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f0121086:	83 ec 0c             	sub    $0xc,%esp
f0121089:	68 40 84 9a f1       	push   $0xf19a8440
f012108e:	e8 f6 27 ff ff       	call   f0113889 <acquire_sleeplock>
f0121093:	83 c4 10             	add    $0x10,%esp
f0121096:	e9 23 08 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f012109b:	83 ec 08             	sub    $0x8,%esp
f012109e:	68 c0 fe 13 f0       	push   $0xf013fec0
f01210a3:	ff 75 08             	pushl  0x8(%ebp)
f01210a6:	e8 90 1e 00 00       	call   f0122f3b <strcmp>
f01210ab:	83 c4 10             	add    $0x10,%esp
f01210ae:	85 c0                	test   %eax,%eax
f01210b0:	75 15                	jne    f01210c7 <sys_utilities+0x679>
	{
		release_sleeplock(&__tstslplk__);
f01210b2:	83 ec 0c             	sub    $0xc,%esp
f01210b5:	68 40 84 9a f1       	push   $0xf19a8440
f01210ba:	e8 24 28 ff ff       	call   f01138e3 <release_sleeplock>
f01210bf:	83 c4 10             	add    $0x10,%esp
f01210c2:	e9 f7 07 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f01210c7:	83 ec 08             	sub    $0x8,%esp
f01210ca:	68 d5 fe 13 f0       	push   $0xf013fed5
f01210cf:	ff 75 08             	pushl  0x8(%ebp)
f01210d2:	e8 64 1e 00 00       	call   f0122f3b <strcmp>
f01210d7:	83 c4 10             	add    $0x10,%esp
f01210da:	85 c0                	test   %eax,%eax
f01210dc:	75 3d                	jne    f012111b <sys_utilities+0x6cd>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01210de:	83 ec 0c             	sub    $0xc,%esp
f01210e1:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01210e6:	e8 5a 24 ff ff       	call   f0113545 <acquire_kspinlock>
f01210eb:	83 c4 10             	add    $0x10,%esp
		{
			int* numOfProcesses = (int*) value ;
f01210ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210f1:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f01210f7:	a1 c0 84 9a f1       	mov    0xf19a84c0,%eax
f01210fc:	89 c2                	mov    %eax,%edx
f01210fe:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0121104:	89 10                	mov    %edx,(%eax)
			//cprintf("__GetLockQueueSize__ = %d\n", *numOfProcesses);
		}
		release_kspinlock(&ProcessQueues.qlock);
f0121106:	83 ec 0c             	sub    $0xc,%esp
f0121109:	68 c0 cd 94 f1       	push   $0xf194cdc0
f012110e:	e8 d7 24 ff ff       	call   f01135ea <release_kspinlock>
f0121113:	83 c4 10             	add    $0x10,%esp
f0121116:	e9 a3 07 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f012111b:	83 ec 08             	sub    $0x8,%esp
f012111e:	68 ea fe 13 f0       	push   $0xf013feea
f0121123:	ff 75 08             	pushl  0x8(%ebp)
f0121126:	e8 10 1e 00 00       	call   f0122f3b <strcmp>
f012112b:	83 c4 10             	add    $0x10,%esp
f012112e:	85 c0                	test   %eax,%eax
f0121130:	75 1c                	jne    f012114e <sys_utilities+0x700>
	{
		int* lockVal = (int*) value ;
f0121132:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121135:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		*lockVal =__tstslplk__.locked;
f012113b:	8b 15 40 84 9a f1    	mov    0xf19a8440,%edx
f0121141:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f0121147:	89 10                	mov    %edx,(%eax)
f0121149:	e9 70 07 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f012114e:	83 ec 08             	sub    $0x8,%esp
f0121151:	68 fb fe 13 f0       	push   $0xf013fefb
f0121156:	ff 75 08             	pushl  0x8(%ebp)
f0121159:	e8 dd 1d 00 00       	call   f0122f3b <strcmp>
f012115e:	83 c4 10             	add    $0x10,%esp
f0121161:	85 c0                	test   %eax,%eax
f0121163:	75 1d                	jne    f0121182 <sys_utilities+0x734>
	{
		uint32* lockOwnerID = (uint32*) value ;
f0121165:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121168:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f012116e:	a1 44 85 9a f1       	mov    0xf19a8544,%eax
f0121173:	89 c2                	mov    %eax,%edx
f0121175:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f012117b:	89 10                	mov    %edx,(%eax)
f012117d:	e9 3c 07 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__GetConsLockedCnt__") == 0)
f0121182:	83 ec 08             	sub    $0x8,%esp
f0121185:	68 0c ff 13 f0       	push   $0xf013ff0c
f012118a:	ff 75 08             	pushl  0x8(%ebp)
f012118d:	e8 a9 1d 00 00       	call   f0122f3b <strcmp>
f0121192:	83 c4 10             	add    $0x10,%esp
f0121195:	85 c0                	test   %eax,%eax
f0121197:	75 48                	jne    f01211e1 <sys_utilities+0x793>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f0121199:	83 ec 0c             	sub    $0xc,%esp
f012119c:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01211a1:	e8 9f 23 ff ff       	call   f0113545 <acquire_kspinlock>
f01211a6:	83 c4 10             	add    $0x10,%esp
		{
			uint32* consLockCnt = (uint32*) value ;
f01211a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01211ac:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			*consLockCnt = queue_size(&(conslock.chan.queue));
f01211b2:	83 ec 0c             	sub    $0xc,%esp
f01211b5:	68 74 cc 94 f1       	push   $0xf194cc74
f01211ba:	e8 3e 4e fe ff       	call   f0105ffd <queue_size>
f01211bf:	83 c4 10             	add    $0x10,%esp
f01211c2:	89 c2                	mov    %eax,%edx
f01211c4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01211ca:	89 10                	mov    %edx,(%eax)
		}
		release_kspinlock(&ProcessQueues.qlock);
f01211cc:	83 ec 0c             	sub    $0xc,%esp
f01211cf:	68 c0 cd 94 f1       	push   $0xf194cdc0
f01211d4:	e8 11 24 ff ff       	call   f01135ea <release_kspinlock>
f01211d9:	83 c4 10             	add    $0x10,%esp
f01211dc:	e9 dd 06 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__tmpReleaseConsLock__") == 0)
f01211e1:	83 ec 08             	sub    $0x8,%esp
f01211e4:	68 21 ff 13 f0       	push   $0xf013ff21
f01211e9:	ff 75 08             	pushl  0x8(%ebp)
f01211ec:	e8 4a 1d 00 00       	call   f0122f3b <strcmp>
f01211f1:	83 c4 10             	add    $0x10,%esp
f01211f4:	85 c0                	test   %eax,%eax
f01211f6:	0f 84 c2 06 00 00    	je     f01218be <sys_utilities+0xe70>
	/*else if (strcmp(utilityName, "__getKernelSBreak__") == 0)
	{
		uint32* ksbrk = (uint32*) value ;
	 *ksbrk = (uint32)sbrk(0);
	}*/
	else if (strcmp(utilityName, "__changeInterruptStatus__") == 0)
f01211fc:	83 ec 08             	sub    $0x8,%esp
f01211ff:	68 38 ff 13 f0       	push   $0xf013ff38
f0121204:	ff 75 08             	pushl  0x8(%ebp)
f0121207:	e8 2f 1d 00 00       	call   f0122f3b <strcmp>
f012120c:	83 c4 10             	add    $0x10,%esp
f012120f:	85 c0                	test   %eax,%eax
f0121211:	0f 85 ae 00 00 00    	jne    f01212c5 <sys_utilities+0x877>
	{
		if (value == 0)
f0121217:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012121b:	75 4f                	jne    f012126c <sys_utilities+0x81e>
		{
			kclock_stop();
f012121d:	e8 03 4b fe ff       	call   f0105d25 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0121222:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f0121223:	e8 20 c4 fe ff       	call   f010d648 <get_cpu_proc>
f0121228:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
			if (p == NULL)
f012122e:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0121235:	75 17                	jne    f012124e <sys_utilities+0x800>
			{
				panic("cons_lock: no running process to block");
f0121237:	83 ec 04             	sub    $0x4,%esp
f012123a:	68 54 ff 13 f0       	push   $0xf013ff54
f012123f:	68 7d 01 00 00       	push   $0x17d
f0121244:	68 0f fc 13 f0       	push   $0xf013fc0f
f0121249:	e8 61 fc fd ff       	call   f0100eaf <_panic>
			}
			p->env_tf->tf_eflags &= ~FL_IF ;
f012124e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0121254:	8b 00                	mov    (%eax),%eax
f0121256:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f012125c:	8b 12                	mov    (%edx),%edx
f012125e:	8b 52 38             	mov    0x38(%edx),%edx
f0121261:	80 e6 fd             	and    $0xfd,%dh
f0121264:	89 50 38             	mov    %edx,0x38(%eax)
f0121267:	e9 52 06 00 00       	jmp    f01218be <sys_utilities+0xe70>
			//cprintf("\nINTERRUPT WILL BE DISABLED\n");
		}
		else if (value == 1)
f012126c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0121270:	0f 85 48 06 00 00    	jne    f01218be <sys_utilities+0xe70>
		{
			kclock_stop();
f0121276:	e8 aa 4a fe ff       	call   f0105d25 <kclock_stop>
f012127b:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f012127c:	e8 c7 c3 fe ff       	call   f010d648 <get_cpu_proc>
f0121281:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (p == NULL)
f0121287:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f012128e:	75 17                	jne    f01212a7 <sys_utilities+0x859>
			{
				panic("cons_unlock: no running process to block");
f0121290:	83 ec 04             	sub    $0x4,%esp
f0121293:	68 7c ff 13 f0       	push   $0xf013ff7c
f0121298:	68 89 01 00 00       	push   $0x189
f012129d:	68 0f fc 13 f0       	push   $0xf013fc0f
f01212a2:	e8 08 fc fd ff       	call   f0100eaf <_panic>
			}
			p->env_tf->tf_eflags |= FL_IF ;
f01212a7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01212ad:	8b 00                	mov    (%eax),%eax
f01212af:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f01212b5:	8b 12                	mov    (%edx),%edx
f01212b7:	8b 52 38             	mov    0x38(%edx),%edx
f01212ba:	80 ce 02             	or     $0x2,%dh
f01212bd:	89 50 38             	mov    %edx,0x38(%eax)
f01212c0:	e9 f9 05 00 00       	jmp    f01218be <sys_utilities+0xe70>
			//cprintf("\nINTERRUPT WILL BE ENABLED\n");
		}
	}
	else if (strncmp(utilityName, "__getProcState@", strlen("__getProcState@")) == 0)
f01212c5:	83 ec 0c             	sub    $0xc,%esp
f01212c8:	68 a5 ff 13 f0       	push   $0xf013ffa5
f01212cd:	e8 5d 1b 00 00       	call   f0122e2f <strlen>
f01212d2:	83 c4 10             	add    $0x10,%esp
f01212d5:	83 ec 04             	sub    $0x4,%esp
f01212d8:	50                   	push   %eax
f01212d9:	68 a5 ff 13 f0       	push   $0xf013ffa5
f01212de:	ff 75 08             	pushl  0x8(%ebp)
f01212e1:	e8 8d 1c 00 00       	call   f0122f73 <strncmp>
f01212e6:	83 c4 10             	add    $0x10,%esp
f01212e9:	85 c0                	test   %eax,%eax
f01212eb:	0f 85 af 00 00 00    	jne    f01213a0 <sys_utilities+0x952>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f01212f1:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f01212f7:	50                   	push   %eax
f01212f8:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f01212fe:	50                   	push   %eax
f01212ff:	68 82 fc 13 f0       	push   $0xf013fc82
f0121304:	ff 75 08             	pushl  0x8(%ebp)
f0121307:	e8 e7 21 00 00       	call   f01234f3 <strsplit>
f012130c:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f012130f:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f0121315:	83 ec 04             	sub    $0x4,%esp
f0121318:	6a 0a                	push   $0xa
f012131a:	6a 00                	push   $0x0
f012131c:	50                   	push   %eax
f012131d:	e8 1c 1f 00 00       	call   f012323e <strtol>
f0121322:	83 c4 10             	add    $0x10,%esp
f0121325:	89 45 d0             	mov    %eax,-0x30(%ebp)
		struct Env* env = NULL ;
f0121328:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f012132f:	00 00 00 
		int ret = envid2env(envID, &env, 0);
f0121332:	83 ec 04             	sub    $0x4,%esp
f0121335:	6a 00                	push   $0x0
f0121337:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f012133d:	50                   	push   %eax
f012133e:	ff 75 d0             	pushl  -0x30(%ebp)
f0121341:	e8 52 c3 fe ff       	call   f010d698 <envid2env>
f0121346:	83 c4 10             	add    $0x10,%esp
f0121349:	89 45 cc             	mov    %eax,-0x34(%ebp)
		uint32* procState = (uint32*) value ;
f012134c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012134f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ret == E_BAD_ENV)
f0121352:	83 7d cc fe          	cmpl   $0xfffffffe,-0x34(%ebp)
f0121356:	75 0e                	jne    f0121366 <sys_utilities+0x918>
		{
			//cprintf("\n\n<<<<<<<<<<< BAD ENV >>>>>>>>>>>\n\n");
			*procState = E_BAD_ENV;
f0121358:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012135b:	c7 00 fe ff ff ff    	movl   $0xfffffffe,(%eax)
f0121361:	e9 55 06 00 00       	jmp    f01219bb <sys_utilities+0xf6d>
			return;
		}
		else
		{
			assert(env->env_id == envID) ;
f0121366:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f012136c:	8b 40 10             	mov    0x10(%eax),%eax
f012136f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0121372:	74 19                	je     f012138d <sys_utilities+0x93f>
f0121374:	68 84 fc 13 f0       	push   $0xf013fc84
f0121379:	68 c7 fb 13 f0       	push   $0xf013fbc7
f012137e:	68 a1 01 00 00       	push   $0x1a1
f0121383:	68 0f fc 13 f0       	push   $0xf013fc0f
f0121388:	e8 22 fb fd ff       	call   f0100eaf <_panic>
			*procState = env->env_status;
f012138d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0121393:	8b 50 18             	mov    0x18(%eax),%edx
f0121396:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121399:	89 10                	mov    %edx,(%eax)
f012139b:	e9 1e 05 00 00       	jmp    f01218be <sys_utilities+0xe70>
		}
	}
	else if (strcmp(utilityName, "__IsOPTRepl__") == 0)
f01213a0:	83 ec 08             	sub    $0x8,%esp
f01213a3:	68 b5 ff 13 f0       	push   $0xf013ffb5
f01213a8:	ff 75 08             	pushl  0x8(%ebp)
f01213ab:	e8 8b 1b 00 00       	call   f0122f3b <strcmp>
f01213b0:	83 c4 10             	add    $0x10,%esp
f01213b3:	85 c0                	test   %eax,%eax
f01213b5:	75 1d                	jne    f01213d4 <sys_utilities+0x986>
	{
		uint32* isOPTRepl = (uint32*) value ;
f01213b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01213ba:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		*isOPTRepl = isPageReplacmentAlgorithmOPTIMAL();
f01213c0:	e8 56 03 ff ff       	call   f011171b <isPageReplacmentAlgorithmOPTIMAL>
f01213c5:	89 c2                	mov    %eax,%edx
f01213c7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01213cd:	89 10                	mov    %edx,(%eax)
f01213cf:	e9 ea 04 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strcmp(utilityName, "__CheckUserKernStack__") == 0)
f01213d4:	83 ec 08             	sub    $0x8,%esp
f01213d7:	68 c3 ff 13 f0       	push   $0xf013ffc3
f01213dc:	ff 75 08             	pushl  0x8(%ebp)
f01213df:	e8 57 1b 00 00       	call   f0122f3b <strcmp>
f01213e4:	83 c4 10             	add    $0x10,%esp
f01213e7:	85 c0                	test   %eax,%eax
f01213e9:	0f 85 dc 00 00 00    	jne    f01214cb <sys_utilities+0xa7d>
	{
		uint32* correct = (uint32*) value ;
f01213ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01213f2:	89 45 90             	mov    %eax,-0x70(%ebp)
		*correct = 1;
f01213f5:	8b 45 90             	mov    -0x70(%ebp),%eax
f01213f8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		struct Env *e = get_cpu_proc();
f01213fe:	e8 45 c2 fe ff       	call   f010d648 <get_cpu_proc>
f0121403:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 kstackBottom = (uint32)e->kstack;
f0121406:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0121409:	8b 40 70             	mov    0x70(%eax),%eax
f012140c:	89 45 88             	mov    %eax,-0x78(%ebp)
		uint32 kstackTop = kstackBottom + KERNEL_STACK_SIZE;
f012140f:	8b 45 88             	mov    -0x78(%ebp),%eax
f0121412:	05 00 80 00 00       	add    $0x8000,%eax
f0121417:	89 45 84             	mov    %eax,-0x7c(%ebp)

		for (uint32 va = kstackBottom; va < kstackTop ; va+=PAGE_SIZE)
f012141a:	8b 45 88             	mov    -0x78(%ebp),%eax
f012141d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0121420:	e9 95 00 00 00       	jmp    f01214ba <sys_utilities+0xa6c>
		{
			uint32 *ptrTable;
			struct FrameInfo *ptrFI = get_frame_info(e->env_page_directory, va, &ptrTable);
f0121425:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0121428:	8b 40 64             	mov    0x64(%eax),%eax
f012142b:	83 ec 04             	sub    $0x4,%esp
f012142e:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
f0121434:	52                   	push   %edx
f0121435:	ff 75 dc             	pushl  -0x24(%ebp)
f0121438:	50                   	push   %eax
f0121439:	e8 ac 87 fe ff       	call   f0109bea <get_frame_info>
f012143e:	83 c4 10             	add    $0x10,%esp
f0121441:	89 45 80             	mov    %eax,-0x80(%ebp)
			//Check Guard Page
			if (va == kstackBottom && (ptrTable[PTX(va)] & PERM_PRESENT) != 0)
f0121444:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121447:	3b 45 88             	cmp    -0x78(%ebp),%eax
f012144a:	75 40                	jne    f012148c <sys_utilities+0xa3e>
f012144c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0121452:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121455:	c1 ea 0c             	shr    $0xc,%edx
f0121458:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f012145e:	c1 e2 02             	shl    $0x2,%edx
f0121461:	01 d0                	add    %edx,%eax
f0121463:	8b 00                	mov    (%eax),%eax
f0121465:	83 e0 01             	and    $0x1,%eax
f0121468:	85 c0                	test   %eax,%eax
f012146a:	74 20                	je     f012148c <sys_utilities+0xa3e>
			{
				cprintf_colored(TEXT_TESTERR_CLR, "User Kern Stack ERROR#1: guard page is not set correctly\n");
f012146c:	83 ec 08             	sub    $0x8,%esp
f012146f:	68 dc ff 13 f0       	push   $0xf013ffdc
f0121474:	6a 0c                	push   $0xc
f0121476:	e8 02 07 fe ff       	call   f0101b7d <cprintf_colored>
f012147b:	83 c4 10             	add    $0x10,%esp
				*correct = 0;
f012147e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0121481:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				break;
f0121487:	e9 32 04 00 00       	jmp    f01218be <sys_utilities+0xe70>
			}
			else if (ptrFI == NULL)
f012148c:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0121490:	75 21                	jne    f01214b3 <sys_utilities+0xa65>
			{
				cprintf_colored(TEXT_TESTERR_CLR, "User Kern Stack ERROR#2: page is not set correctly\n");
f0121492:	83 ec 08             	sub    $0x8,%esp
f0121495:	68 18 00 14 f0       	push   $0xf0140018
f012149a:	6a 0c                	push   $0xc
f012149c:	e8 dc 06 fe ff       	call   f0101b7d <cprintf_colored>
f01214a1:	83 c4 10             	add    $0x10,%esp
				*correct = 0;
f01214a4:	8b 45 90             	mov    -0x70(%ebp),%eax
f01214a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				break;
f01214ad:	90                   	nop
f01214ae:	e9 0b 04 00 00       	jmp    f01218be <sys_utilities+0xe70>
		*correct = 1;
		struct Env *e = get_cpu_proc();
		uint32 kstackBottom = (uint32)e->kstack;
		uint32 kstackTop = kstackBottom + KERNEL_STACK_SIZE;

		for (uint32 va = kstackBottom; va < kstackTop ; va+=PAGE_SIZE)
f01214b3:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f01214ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01214bd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01214c0:	0f 82 5f ff ff ff    	jb     f0121425 <sys_utilities+0x9d7>
f01214c6:	e9 f3 03 00 00       	jmp    f01218be <sys_utilities+0xe70>
				*correct = 0;
				break;
			}
		}
	}
	else if (strncmp(utilityName, "__CheckRefStream@", strlen("__CheckRefStream@")) == 0)
f01214cb:	83 ec 0c             	sub    $0xc,%esp
f01214ce:	68 4c 00 14 f0       	push   $0xf014004c
f01214d3:	e8 57 19 00 00       	call   f0122e2f <strlen>
f01214d8:	83 c4 10             	add    $0x10,%esp
f01214db:	83 ec 04             	sub    $0x4,%esp
f01214de:	50                   	push   %eax
f01214df:	68 4c 00 14 f0       	push   $0xf014004c
f01214e4:	ff 75 08             	pushl  0x8(%ebp)
f01214e7:	e8 87 1a 00 00       	call   f0122f73 <strncmp>
f01214ec:	83 c4 10             	add    $0x10,%esp
f01214ef:	85 c0                	test   %eax,%eax
f01214f1:	0f 85 77 01 00 00    	jne    f012166e <sys_utilities+0xc20>
	{
#define MAX_REF_CNT 128
		bool* correct = (bool*) value ;
f01214f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01214fa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*correct = 1;
f01214fd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121500:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		int number_of_tokens;
		char *tokens[MAX_REF_CNT];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0121506:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
f012150c:	50                   	push   %eax
f012150d:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f0121513:	50                   	push   %eax
f0121514:	68 82 fc 13 f0       	push   $0xf013fc82
f0121519:	ff 75 08             	pushl  0x8(%ebp)
f012151c:	e8 d2 1f 00 00       	call   f01234f3 <strsplit>
f0121521:	83 c4 10             	add    $0x10,%esp
		int numOfRefs = strtol(tokens[1], NULL, 10);
f0121524:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f012152a:	83 ec 04             	sub    $0x4,%esp
f012152d:	6a 0a                	push   $0xa
f012152f:	6a 00                	push   $0x0
f0121531:	50                   	push   %eax
f0121532:	e8 07 1d 00 00       	call   f012323e <strtol>
f0121537:	83 c4 10             	add    $0x10,%esp
f012153a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		assert(numOfRefs < MAX_REF_CNT);
f012153d:	83 7d c0 7f          	cmpl   $0x7f,-0x40(%ebp)
f0121541:	7e 19                	jle    f012155c <sys_utilities+0xb0e>
f0121543:	68 5e 00 14 f0       	push   $0xf014005e
f0121548:	68 c7 fb 13 f0       	push   $0xf013fbc7
f012154d:	68 ce 01 00 00       	push   $0x1ce
f0121552:	68 0f fc 13 f0       	push   $0xf013fc0f
f0121557:	e8 53 f9 fd ff       	call   f0100eaf <_panic>
		struct Env* env = get_cpu_proc() ;
f012155c:	e8 e7 c0 fe ff       	call   f010d648 <get_cpu_proc>
f0121561:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if (numOfRefs != LIST_SIZE(&(env->referenceStreamList)))
f0121564:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0121567:	8b 90 bc 00 00 00    	mov    0xbc(%eax),%edx
f012156d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121570:	39 c2                	cmp    %eax,%edx
f0121572:	74 2b                	je     f012159f <sys_utilities+0xb51>
		{
			cprintf("num of references MISMATCHED! Expected = %d, Actual = %d\n", numOfRefs, LIST_SIZE(&(env->referenceStreamList)));
f0121574:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0121577:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
f012157d:	83 ec 04             	sub    $0x4,%esp
f0121580:	50                   	push   %eax
f0121581:	ff 75 c0             	pushl  -0x40(%ebp)
f0121584:	68 78 00 14 f0       	push   $0xf0140078
f0121589:	e8 bf 05 fe ff       	call   f0101b4d <cprintf>
f012158e:	83 c4 10             	add    $0x10,%esp
			*correct = 0;
f0121591:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121594:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return;
f012159a:	e9 1c 04 00 00       	jmp    f01219bb <sys_utilities+0xf6d>
		}

		uint32 *expectedRefStream = (uint32 *)strtol(tokens[2], NULL, 10);
f012159f:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
f01215a5:	83 ec 04             	sub    $0x4,%esp
f01215a8:	6a 0a                	push   $0xa
f01215aa:	6a 00                	push   $0x0
f01215ac:	50                   	push   %eax
f01215ad:	e8 8c 1c 00 00       	call   f012323e <strtol>
f01215b2:	83 c4 10             	add    $0x10,%esp
f01215b5:	89 45 b8             	mov    %eax,-0x48(%ebp)

		//Check the expected reference stream against the calculated one
		struct PageRefElement *curRef = LIST_FIRST(&(env->referenceStreamList));
f01215b8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01215bb:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01215c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
		for (int i = 0; i < numOfRefs; ++i)
f01215c4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f01215cb:	e9 8d 00 00 00       	jmp    f012165d <sys_utilities+0xc0f>
		{
			if (ROUNDDOWN(expectedRefStream[i], PAGE_SIZE) != ROUNDDOWN(curRef->virtual_address, PAGE_SIZE))
f01215d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01215d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01215da:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01215dd:	01 d0                	add    %edx,%eax
f01215df:	8b 00                	mov    (%eax),%eax
f01215e1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01215e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01215e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01215ec:	89 c2                	mov    %eax,%edx
f01215ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01215f1:	8b 00                	mov    (%eax),%eax
f01215f3:	89 45 b0             	mov    %eax,-0x50(%ebp)
f01215f6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01215f9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01215fe:	39 c2                	cmp    %eax,%edx
f0121600:	74 4f                	je     f0121651 <sys_utilities+0xc03>
			{
				cprintf("Ref#%d MISMATCHED! Expected = %d, Actual = %d\n", ROUNDDOWN(expectedRefStream[i], PAGE_SIZE), ROUNDDOWN(curRef->virtual_address, PAGE_SIZE));
f0121602:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121605:	8b 00                	mov    (%eax),%eax
f0121607:	89 45 ac             	mov    %eax,-0x54(%ebp)
f012160a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f012160d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0121612:	89 c2                	mov    %eax,%edx
f0121614:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121617:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f012161e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121621:	01 c8                	add    %ecx,%eax
f0121623:	8b 00                	mov    (%eax),%eax
f0121625:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0121628:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012162b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0121630:	83 ec 04             	sub    $0x4,%esp
f0121633:	52                   	push   %edx
f0121634:	50                   	push   %eax
f0121635:	68 b4 00 14 f0       	push   $0xf01400b4
f012163a:	e8 0e 05 fe ff       	call   f0101b4d <cprintf>
f012163f:	83 c4 10             	add    $0x10,%esp
				*correct = 0;
f0121642:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121645:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				return;
f012164b:	90                   	nop
f012164c:	e9 6a 03 00 00       	jmp    f01219bb <sys_utilities+0xf6d>
			}
			curRef = LIST_NEXT(curRef);
f0121651:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121654:	8b 40 04             	mov    0x4(%eax),%eax
f0121657:	89 45 d8             	mov    %eax,-0x28(%ebp)

		uint32 *expectedRefStream = (uint32 *)strtol(tokens[2], NULL, 10);

		//Check the expected reference stream against the calculated one
		struct PageRefElement *curRef = LIST_FIRST(&(env->referenceStreamList));
		for (int i = 0; i < numOfRefs; ++i)
f012165a:	ff 45 d4             	incl   -0x2c(%ebp)
f012165d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121660:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0121663:	0f 8c 67 ff ff ff    	jl     f01215d0 <sys_utilities+0xb82>
f0121669:	e9 50 02 00 00       	jmp    f01218be <sys_utilities+0xe70>
				return;
			}
			curRef = LIST_NEXT(curRef);
		}
	}
	else if (strcmp(utilityName, "__InvPage__") == 0)
f012166e:	83 ec 08             	sub    $0x8,%esp
f0121671:	68 e3 00 14 f0       	push   $0xf01400e3
f0121676:	ff 75 08             	pushl  0x8(%ebp)
f0121679:	e8 bd 18 00 00       	call   f0122f3b <strcmp>
f012167e:	83 c4 10             	add    $0x10,%esp
f0121681:	85 c0                	test   %eax,%eax
f0121683:	75 24                	jne    f01216a9 <sys_utilities+0xc5b>
	{
		uint32 va = (uint32) value ;
f0121685:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121688:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		struct Env* env = get_cpu_proc() ;
f012168b:	e8 b8 bf fe ff       	call   f010d648 <get_cpu_proc>
f0121690:	89 45 a0             	mov    %eax,-0x60(%ebp)
		env_page_ws_invalidate(env, va);
f0121693:	83 ec 08             	sub    $0x8,%esp
f0121696:	ff 75 a4             	pushl  -0x5c(%ebp)
f0121699:	ff 75 a0             	pushl  -0x60(%ebp)
f012169c:	e8 81 a2 fe ff       	call   f010b922 <env_page_ws_invalidate>
f01216a1:	83 c4 10             	add    $0x10,%esp
f01216a4:	e9 15 02 00 00       	jmp    f01218be <sys_utilities+0xe70>
	}
	else if (strncmp(utilityName, "__NumOfSlaves@", strlen("__NumOfSlaves@")) == 0)
f01216a9:	83 ec 0c             	sub    $0xc,%esp
f01216ac:	68 ef 00 14 f0       	push   $0xf01400ef
f01216b1:	e8 79 17 00 00       	call   f0122e2f <strlen>
f01216b6:	83 c4 10             	add    $0x10,%esp
f01216b9:	83 ec 04             	sub    $0x4,%esp
f01216bc:	50                   	push   %eax
f01216bd:	68 ef 00 14 f0       	push   $0xf01400ef
f01216c2:	ff 75 08             	pushl  0x8(%ebp)
f01216c5:	e8 a9 18 00 00       	call   f0122f73 <strncmp>
f01216ca:	83 c4 10             	add    $0x10,%esp
f01216cd:	85 c0                	test   %eax,%eax
f01216cf:	75 7e                	jne    f012174f <sys_utilities+0xd01>
	{
		uint32* numOfSlaves = (uint32*) value ;
f01216d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216d4:	89 45 9c             	mov    %eax,-0x64(%ebp)

		int number_of_tokens;
		char *tokens[MAX_REF_CNT];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f01216d7:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f01216dd:	50                   	push   %eax
f01216de:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f01216e4:	50                   	push   %eax
f01216e5:	68 82 fc 13 f0       	push   $0xf013fc82
f01216ea:	ff 75 08             	pushl  0x8(%ebp)
f01216ed:	e8 01 1e 00 00       	call   f01234f3 <strsplit>
f01216f2:	83 c4 10             	add    $0x10,%esp
		if (strcmp(tokens[1], "Set") == 0)
f01216f5:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f01216fb:	83 ec 08             	sub    $0x8,%esp
f01216fe:	68 fe 00 14 f0       	push   $0xf01400fe
f0121703:	50                   	push   %eax
f0121704:	e8 32 18 00 00       	call   f0122f3b <strcmp>
f0121709:	83 c4 10             	add    $0x10,%esp
f012170c:	85 c0                	test   %eax,%eax
f012170e:	75 0f                	jne    f012171f <sys_utilities+0xcd1>
		{
			__numOfSlaves = *numOfSlaves;
f0121710:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0121713:	8b 00                	mov    (%eax),%eax
f0121715:	a3 c4 cb 94 f1       	mov    %eax,0xf194cbc4
f012171a:	e9 9f 01 00 00       	jmp    f01218be <sys_utilities+0xe70>
		}
		else if (strcmp(tokens[1], "Get") == 0)
f012171f:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f0121725:	83 ec 08             	sub    $0x8,%esp
f0121728:	68 02 01 14 f0       	push   $0xf0140102
f012172d:	50                   	push   %eax
f012172e:	e8 08 18 00 00       	call   f0122f3b <strcmp>
f0121733:	83 c4 10             	add    $0x10,%esp
f0121736:	85 c0                	test   %eax,%eax
f0121738:	0f 85 80 01 00 00    	jne    f01218be <sys_utilities+0xe70>
		{
			*numOfSlaves = __numOfSlaves ;
f012173e:	a1 c4 cb 94 f1       	mov    0xf194cbc4,%eax
f0121743:	89 c2                	mov    %eax,%edx
f0121745:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0121748:	89 10                	mov    %edx,(%eax)
f012174a:	e9 6f 01 00 00       	jmp    f01218be <sys_utilities+0xe70>
		}
	}
	else if (strncmp(utilityName, "__KSem@", strlen("__KSem@")) == 0)
f012174f:	83 ec 0c             	sub    $0xc,%esp
f0121752:	68 06 01 14 f0       	push   $0xf0140106
f0121757:	e8 d3 16 00 00       	call   f0122e2f <strlen>
f012175c:	83 c4 10             	add    $0x10,%esp
f012175f:	83 ec 04             	sub    $0x4,%esp
f0121762:	50                   	push   %eax
f0121763:	68 06 01 14 f0       	push   $0xf0140106
f0121768:	ff 75 08             	pushl  0x8(%ebp)
f012176b:	e8 03 18 00 00       	call   f0122f73 <strncmp>
f0121770:	83 c4 10             	add    $0x10,%esp
f0121773:	85 c0                	test   %eax,%eax
f0121775:	0f 85 43 01 00 00    	jne    f01218be <sys_utilities+0xe70>
	{

		int number_of_tokens;
		char *tokens[MAX_REF_CNT];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f012177b:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
f0121781:	50                   	push   %eax
f0121782:	8d 85 08 fd ff ff    	lea    -0x2f8(%ebp),%eax
f0121788:	50                   	push   %eax
f0121789:	68 82 fc 13 f0       	push   $0xf013fc82
f012178e:	ff 75 08             	pushl  0x8(%ebp)
f0121791:	e8 5d 1d 00 00       	call   f01234f3 <strsplit>
f0121796:	83 c4 10             	add    $0x10,%esp
		int semNum = strtol(tokens[1], NULL, 10);
f0121799:	8b 85 0c fd ff ff    	mov    -0x2f4(%ebp),%eax
f012179f:	83 ec 04             	sub    $0x4,%esp
f01217a2:	6a 0a                	push   $0xa
f01217a4:	6a 00                	push   $0x0
f01217a6:	50                   	push   %eax
f01217a7:	e8 92 1a 00 00       	call   f012323e <strtol>
f01217ac:	83 c4 10             	add    $0x10,%esp
f01217af:	89 45 98             	mov    %eax,-0x68(%ebp)
		//cprintf("%s - semNum = %d, action = %s\n", utilityName, semNum, tokens[2]);
		if (strcmp(tokens[2], "Init") == 0)
f01217b2:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
f01217b8:	83 ec 08             	sub    $0x8,%esp
f01217bb:	68 0e 01 14 f0       	push   $0xf014010e
f01217c0:	50                   	push   %eax
f01217c1:	e8 75 17 00 00       	call   f0122f3b <strcmp>
f01217c6:	83 c4 10             	add    $0x10,%esp
f01217c9:	85 c0                	test   %eax,%eax
f01217cb:	75 43                	jne    f0121810 <sys_utilities+0xdc2>
		{
			char semName[10] ;
			ltostr(semNum, semName);
f01217cd:	83 ec 08             	sub    $0x8,%esp
f01217d0:	8d 85 0a ff ff ff    	lea    -0xf6(%ebp),%eax
f01217d6:	50                   	push   %eax
f01217d7:	ff 75 98             	pushl  -0x68(%ebp)
f01217da:	e8 a5 1b 00 00       	call   f0123384 <ltostr>
f01217df:	83 c4 10             	add    $0x10,%esp
			init_ksemaphore(&(__ksems[semNum]), *((int*)value), semName);
f01217e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217e5:	8b 10                	mov    (%eax),%edx
f01217e7:	8b 45 98             	mov    -0x68(%ebp),%eax
f01217ea:	c1 e0 02             	shl    $0x2,%eax
f01217ed:	89 c1                	mov    %eax,%ecx
f01217ef:	c1 e1 06             	shl    $0x6,%ecx
f01217f2:	01 c8                	add    %ecx,%eax
f01217f4:	8d 88 00 7a 9a f1    	lea    -0xe658600(%eax),%ecx
f01217fa:	83 ec 04             	sub    $0x4,%esp
f01217fd:	8d 85 0a ff ff ff    	lea    -0xf6(%ebp),%eax
f0121803:	50                   	push   %eax
f0121804:	52                   	push   %edx
f0121805:	51                   	push   %ecx
f0121806:	e8 17 23 ff ff       	call   f0113b22 <init_ksemaphore>
f012180b:	83 c4 10             	add    $0x10,%esp
f012180e:	eb 74                	jmp    f0121884 <sys_utilities+0xe36>
		}
		else if (strcmp(tokens[2], "Wait") == 0)
f0121810:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
f0121816:	83 ec 08             	sub    $0x8,%esp
f0121819:	68 13 01 14 f0       	push   $0xf0140113
f012181e:	50                   	push   %eax
f012181f:	e8 17 17 00 00       	call   f0122f3b <strcmp>
f0121824:	83 c4 10             	add    $0x10,%esp
f0121827:	85 c0                	test   %eax,%eax
f0121829:	75 20                	jne    f012184b <sys_utilities+0xdfd>
		{
			wait_ksemaphore(&(__ksems[semNum]));
f012182b:	8b 45 98             	mov    -0x68(%ebp),%eax
f012182e:	c1 e0 02             	shl    $0x2,%eax
f0121831:	89 c2                	mov    %eax,%edx
f0121833:	c1 e2 06             	shl    $0x6,%edx
f0121836:	01 d0                	add    %edx,%eax
f0121838:	05 00 7a 9a f1       	add    $0xf19a7a00,%eax
f012183d:	83 ec 0c             	sub    $0xc,%esp
f0121840:	50                   	push   %eax
f0121841:	e8 32 23 ff ff       	call   f0113b78 <wait_ksemaphore>
f0121846:	83 c4 10             	add    $0x10,%esp
f0121849:	eb 39                	jmp    f0121884 <sys_utilities+0xe36>
		}
		else if (strcmp(tokens[2], "Signal") == 0)
f012184b:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
f0121851:	83 ec 08             	sub    $0x8,%esp
f0121854:	68 18 01 14 f0       	push   $0xf0140118
f0121859:	50                   	push   %eax
f012185a:	e8 dc 16 00 00       	call   f0122f3b <strcmp>
f012185f:	83 c4 10             	add    $0x10,%esp
f0121862:	85 c0                	test   %eax,%eax
f0121864:	75 1e                	jne    f0121884 <sys_utilities+0xe36>
		{
			signal_ksemaphore(&(__ksems[semNum]));
f0121866:	8b 45 98             	mov    -0x68(%ebp),%eax
f0121869:	c1 e0 02             	shl    $0x2,%eax
f012186c:	89 c2                	mov    %eax,%edx
f012186e:	c1 e2 06             	shl    $0x6,%edx
f0121871:	01 d0                	add    %edx,%eax
f0121873:	05 00 7a 9a f1       	add    $0xf19a7a00,%eax
f0121878:	83 ec 0c             	sub    $0xc,%esp
f012187b:	50                   	push   %eax
f012187c:	e8 53 23 ff ff       	call   f0113bd4 <signal_ksemaphore>
f0121881:	83 c4 10             	add    $0x10,%esp
		}
		if (strcmp(tokens[2], "Get") == 0)
f0121884:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
f012188a:	83 ec 08             	sub    $0x8,%esp
f012188d:	68 02 01 14 f0       	push   $0xf0140102
f0121892:	50                   	push   %eax
f0121893:	e8 a3 16 00 00       	call   f0122f3b <strcmp>
f0121898:	83 c4 10             	add    $0x10,%esp
f012189b:	85 c0                	test   %eax,%eax
f012189d:	75 1f                	jne    f01218be <sys_utilities+0xe70>
		{
			int *val = ((int*)value);
f012189f:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218a2:	89 45 94             	mov    %eax,-0x6c(%ebp)
			*val = __ksems[semNum].count;
f01218a5:	8b 45 98             	mov    -0x68(%ebp),%eax
f01218a8:	c1 e0 02             	shl    $0x2,%eax
f01218ab:	89 c2                	mov    %eax,%edx
f01218ad:	c1 e2 06             	shl    $0x6,%edx
f01218b0:	01 d0                	add    %edx,%eax
f01218b2:	05 00 7a 9a f1       	add    $0xf19a7a00,%eax
f01218b7:	8b 10                	mov    (%eax),%edx
f01218b9:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01218bc:	89 10                	mov    %edx,(%eax)
		}
	}

	if ((int)value < 0)
f01218be:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01218c2:	0f 89 f3 00 00 00    	jns    f01219bb <sys_utilities+0xf6d>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f01218c8:	83 ec 08             	sub    $0x8,%esp
f01218cb:	68 1f 01 14 f0       	push   $0xf014011f
f01218d0:	ff 75 08             	pushl  0x8(%ebp)
f01218d3:	e8 63 16 00 00       	call   f0122f3b <strcmp>
f01218d8:	83 c4 10             	add    $0x10,%esp
f01218db:	85 c0                	test   %eax,%eax
f01218dd:	0f 85 d8 00 00 00    	jne    f01219bb <sys_utilities+0xf6d>
		{
			switch (value)
f01218e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218e6:	83 c0 08             	add    $0x8,%eax
f01218e9:	83 f8 07             	cmp    $0x7,%eax
f01218ec:	0f 87 c8 00 00 00    	ja     f01219ba <sys_utilities+0xf6c>
f01218f2:	8b 04 85 6c 04 14 f0 	mov    -0xfebfb94(,%eax,4),%eax
f01218f9:	ff e0                	jmp    *%eax
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f01218fb:	83 ec 0c             	sub    $0xc,%esp
f01218fe:	68 30 01 14 f0       	push   $0xf0140130
f0121903:	e8 45 02 fe ff       	call   f0101b4d <cprintf>
f0121908:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f012190b:	e8 08 fd fe ff       	call   f0111618 <setPageReplacmentAlgorithmFIFO>
				break;
f0121910:	e9 a6 00 00 00       	jmp    f01219bb <sys_utilities+0xf6d>
			case -PG_REP_CLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO CLOCK.\n*************************************\n");
f0121915:	83 ec 0c             	sub    $0xc,%esp
f0121918:	68 a0 01 14 f0       	push   $0xf01401a0
f012191d:	e8 2b 02 fe ff       	call   f0101b4d <cprintf>
f0121922:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmCLOCK();
f0121925:	e8 de fc fe ff       	call   f0111608 <setPageReplacmentAlgorithmCLOCK>
				break;
f012192a:	e9 8c 00 00 00       	jmp    f01219bb <sys_utilities+0xf6d>
			case -PG_REP_MODIFIEDCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO MODIFIED CLOCK.\n*************************************\n");
f012192f:	83 ec 0c             	sub    $0xc,%esp
f0121932:	68 10 02 14 f0       	push   $0xf0140210
f0121937:	e8 11 02 fe ff       	call   f0101b4d <cprintf>
f012193c:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmModifiedCLOCK();
f012193f:	e8 e4 fc fe ff       	call   f0111628 <setPageReplacmentAlgorithmModifiedCLOCK>
				break;
f0121944:	eb 75                	jmp    f01219bb <sys_utilities+0xf6d>
			case -PG_REP_OPTIMAL:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO OPTIMAL.\n*************************************\n");
f0121946:	83 ec 0c             	sub    $0xc,%esp
f0121949:	68 8c 02 14 f0       	push   $0xf014028c
f012194e:	e8 fa 01 fe ff       	call   f0101b4d <cprintf>
f0121953:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmOPTIMAL();
f0121956:	e8 13 fd fe ff       	call   f011166e <setPageReplacmentAlgorithmOPTIMAL>
				break;
f012195b:	eb 5e                	jmp    f01219bb <sys_utilities+0xf6d>
			case -PG_REP_LRU_TIME_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU AGING.\n*************************************\n");
f012195d:	83 ec 0c             	sub    $0xc,%esp
f0121960:	68 00 03 14 f0       	push   $0xf0140300
f0121965:	e8 e3 01 fe ff       	call   f0101b4d <cprintf>
f012196a:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
f012196d:	83 ec 0c             	sub    $0xc,%esp
f0121970:	6a 01                	push   $0x1
f0121972:	e8 5e fc fe ff       	call   f01115d5 <setPageReplacmentAlgorithmLRU>
f0121977:	83 c4 10             	add    $0x10,%esp
				break;
f012197a:	eb 3f                	jmp    f01219bb <sys_utilities+0xf6d>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f012197c:	83 ec 0c             	sub    $0xc,%esp
f012197f:	68 74 03 14 f0       	push   $0xf0140374
f0121984:	e8 c4 01 fe ff       	call   f0101b4d <cprintf>
f0121989:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f012198c:	83 ec 0c             	sub    $0xc,%esp
f012198f:	6a 02                	push   $0x2
f0121991:	e8 3f fc fe ff       	call   f01115d5 <setPageReplacmentAlgorithmLRU>
f0121996:	83 c4 10             	add    $0x10,%esp
				break;
f0121999:	eb 20                	jmp    f01219bb <sys_utilities+0xf6d>
			case -PG_REP_NchanceCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO Nth Clock Normal (N=1).\n*************************************\n");
f012199b:	83 ec 0c             	sub    $0xc,%esp
f012199e:	68 e8 03 14 f0       	push   $0xf01403e8
f01219a3:	e8 a5 01 fe ff       	call   f0101b4d <cprintf>
f01219a8:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmNchanceCLOCK(1);
f01219ab:	83 ec 0c             	sub    $0xc,%esp
f01219ae:	6a 01                	push   $0x1
f01219b0:	e8 93 fc fe ff       	call   f0111648 <setPageReplacmentAlgorithmNchanceCLOCK>
f01219b5:	83 c4 10             	add    $0x10,%esp
				break;
f01219b8:	eb 01                	jmp    f01219bb <sys_utilities+0xf6d>
			default:
				break;
f01219ba:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/
#endif
}
f01219bb:	c9                   	leave  
f01219bc:	c3                   	ret    

f01219bd <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f01219bd:	55                   	push   %ebp
f01219be:	89 e5                	mov    %esp,%ebp
f01219c0:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f01219c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01219c6:	8b 00                	mov    (%eax),%eax
f01219c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f01219cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01219ce:	8b 00                	mov    (%eax),%eax
f01219d0:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f01219d3:	eb 52                	jmp    f0121a27 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f01219d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01219d8:	8b 00                	mov    (%eax),%eax
f01219da:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f01219dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01219e0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01219e3:	75 12                	jne    f01219f7 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f01219e5:	83 ec 0c             	sub    $0xc,%esp
f01219e8:	68 8c 04 14 f0       	push   $0xf014048c
f01219ed:	e8 5b 01 fe ff       	call   f0101b4d <cprintf>
f01219f2:	83 c4 10             	add    $0x10,%esp
			break;
f01219f5:	eb 3f                	jmp    f0121a36 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f01219f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01219fb:	74 38                	je     f0121a35 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f01219fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121a00:	8b 00                	mov    (%eax),%eax
f0121a02:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0121a05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121a08:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121a0b:	75 12                	jne    f0121a1f <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f0121a0d:	83 ec 0c             	sub    $0xc,%esp
f0121a10:	68 a8 04 14 f0       	push   $0xf01404a8
f0121a15:	e8 33 01 fe ff       	call   f0101b4d <cprintf>
f0121a1a:	83 c4 10             	add    $0x10,%esp
			break;
f0121a1d:	eb 17                	jmp    f0121a36 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f0121a1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121a22:	8b 00                	mov    (%eax),%eax
f0121a24:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f0121a27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121a2b:	74 09                	je     f0121a36 <detect_loop_in_FrameInfo_list+0x79>
f0121a2d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121a31:	75 a2                	jne    f01219d5 <detect_loop_in_FrameInfo_list+0x18>
f0121a33:	eb 01                	jmp    f0121a36 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f0121a35:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f0121a36:	83 ec 0c             	sub    $0xc,%esp
f0121a39:	68 bf 04 14 f0       	push   $0xf01404bf
f0121a3e:	e8 0a 01 fe ff       	call   f0101b4d <cprintf>
f0121a43:	83 c4 10             	add    $0x10,%esp
}
f0121a46:	90                   	nop
f0121a47:	c9                   	leave  
f0121a48:	c3                   	ret    

f0121a49 <scarce_memory>:

void scarce_memory()
{
f0121a49:	55                   	push   %ebp
f0121a4a:	89 e5                	mov    %esp,%ebp
f0121a4c:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f0121a4f:	a1 90 cf 94 f1       	mov    0xf194cf90,%eax
f0121a54:	ba 64 00 00 00       	mov    $0x64,%edx
f0121a59:	29 c2                	sub    %eax,%edx
f0121a5b:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0121a60:	0f af c2             	imul   %edx,%eax
f0121a63:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121a68:	f7 e2                	mul    %edx
f0121a6a:	89 d0                	mov    %edx,%eax
f0121a6c:	c1 e8 05             	shr    $0x5,%eax
f0121a6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f0121a72:	a1 90 cf 94 f1       	mov    0xf194cf90,%eax
f0121a77:	ba 64 00 00 00       	mov    $0x64,%edx
f0121a7c:	29 c2                	sub    %eax,%edx
f0121a7e:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0121a83:	89 d1                	mov    %edx,%ecx
f0121a85:	0f af c8             	imul   %eax,%ecx
f0121a88:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121a8d:	f7 e1                	mul    %ecx
f0121a8f:	c1 ea 05             	shr    $0x5,%edx
f0121a92:	89 d0                	mov    %edx,%eax
f0121a94:	c1 e0 02             	shl    $0x2,%eax
f0121a97:	01 d0                	add    %edx,%eax
f0121a99:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121aa0:	01 d0                	add    %edx,%eax
f0121aa2:	c1 e0 02             	shl    $0x2,%eax
f0121aa5:	29 c1                	sub    %eax,%ecx
f0121aa7:	89 ca                	mov    %ecx,%edx
f0121aa9:	85 d2                	test   %edx,%edx
f0121aab:	74 03                	je     f0121ab0 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f0121aad:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f0121ab0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_kspinlock(&MemFrameLists.mfllock);
f0121ab7:	83 ec 0c             	sub    $0xc,%esp
f0121aba:	68 80 ce 94 f1       	push   $0xf194ce80
f0121abf:	e8 81 1a ff ff       	call   f0113545 <acquire_kspinlock>
f0121ac4:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f0121ac7:	a1 6c ce 94 f1       	mov    0xf194ce6c,%eax
f0121acc:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f0121acf:	8b 15 58 d0 94 f1    	mov    0xf194d058,%edx
f0121ad5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121ad8:	29 c2                	sub    %eax,%edx
f0121ada:	89 d0                	mov    %edx,%eax
f0121adc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f0121adf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121ae2:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121ae5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f0121ae8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0121aef:	eb 12                	jmp    f0121b03 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f0121af1:	83 ec 0c             	sub    $0xc,%esp
f0121af4:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0121af7:	50                   	push   %eax
f0121af8:	e8 59 7b fe ff       	call   f0109656 <allocate_frame>
f0121afd:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0121b00:	ff 45 f0             	incl   -0x10(%ebp)
f0121b03:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121b06:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0121b09:	76 e6                	jbe    f0121af1 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f0121b0b:	83 ec 0c             	sub    $0xc,%esp
f0121b0e:	68 80 ce 94 f1       	push   $0xf194ce80
f0121b13:	e8 d2 1a ff ff       	call   f01135ea <release_kspinlock>
f0121b18:	83 c4 10             	add    $0x10,%esp

}
f0121b1b:	90                   	nop
f0121b1c:	c9                   	leave  
f0121b1d:	c3                   	ret    

f0121b1e <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f0121b1e:	55                   	push   %ebp
f0121b1f:	89 e5                	mov    %esp,%ebp
f0121b21:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f0121b24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f0121b2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f0121b32:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0121b39:	e8 0a bb fe ff       	call   f010d648 <get_cpu_proc>
f0121b3e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0121b41:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121b45:	75 19                	jne    f0121b60 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f0121b47:	68 d9 04 14 f0       	push   $0xf01404d9
f0121b4c:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0121b51:	68 82 02 00 00       	push   $0x282
f0121b56:	68 0f fc 13 f0       	push   $0xf013fc0f
f0121b5b:	e8 4f f3 fd ff       	call   f0100eaf <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f0121b60:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0121b64:	0f 85 d6 01 00 00    	jne    f0121d40 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f0121b6a:	83 ec 0c             	sub    $0xc,%esp
f0121b6d:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121b72:	e8 ce 19 ff ff       	call   f0113545 <acquire_kspinlock>
f0121b77:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f0121b7a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0121b81:	e9 d2 00 00 00       	jmp    f0121c58 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f0121b86:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0121b8d:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121b92:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0121b95:	c1 e2 04             	shl    $0x4,%edx
f0121b98:	01 d0                	add    %edx,%eax
f0121b9a:	8b 00                	mov    (%eax),%eax
f0121b9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0121b9f:	eb 7c                	jmp    f0121c1d <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f0121ba1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ba4:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0121baa:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0121bad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121bb0:	8b 90 70 06 00 00    	mov    0x670(%eax),%edx
f0121bb6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121bb9:	0f af c2             	imul   %edx,%eax
f0121bbc:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121bc1:	f7 e2                	mul    %edx
f0121bc3:	89 d0                	mov    %edx,%eax
f0121bc5:	c1 e8 05             	shr    $0x5,%eax
f0121bc8:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0121bcb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121bce:	8b 90 70 06 00 00    	mov    0x670(%eax),%edx
f0121bd4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121bd7:	89 d1                	mov    %edx,%ecx
f0121bd9:	0f af c8             	imul   %eax,%ecx
f0121bdc:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121be1:	f7 e1                	mul    %ecx
f0121be3:	c1 ea 05             	shr    $0x5,%edx
f0121be6:	89 d0                	mov    %edx,%eax
f0121be8:	c1 e0 02             	shl    $0x2,%eax
f0121beb:	01 d0                	add    %edx,%eax
f0121bed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121bf4:	01 d0                	add    %edx,%eax
f0121bf6:	c1 e0 02             	shl    $0x2,%eax
f0121bf9:	29 c1                	sub    %eax,%ecx
f0121bfb:	89 ca                	mov    %ecx,%edx
f0121bfd:	85 d2                	test   %edx,%edx
f0121bff:	74 03                	je     f0121c04 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f0121c01:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f0121c04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121c07:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0121c0a:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121c0f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0121c12:	c1 e2 04             	shl    $0x4,%edx
f0121c15:	01 d0                	add    %edx,%eax
f0121c17:	8b 40 08             	mov    0x8(%eax),%eax
f0121c1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0121c1d:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121c22:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0121c25:	c1 e2 04             	shl    $0x4,%edx
f0121c28:	01 d0                	add    %edx,%eax
f0121c2a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121c2e:	74 08                	je     f0121c38 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f0121c30:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121c33:	8b 52 08             	mov    0x8(%edx),%edx
f0121c36:	eb 05                	jmp    f0121c3d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f0121c38:	ba 00 00 00 00       	mov    $0x0,%edx
f0121c3d:	89 50 08             	mov    %edx,0x8(%eax)
f0121c40:	8b 40 08             	mov    0x8(%eax),%eax
f0121c43:	85 c0                	test   %eax,%eax
f0121c45:	0f 85 56 ff ff ff    	jne    f0121ba1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f0121c4b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121c4f:	0f 85 4c ff ff ff    	jne    f0121ba1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f0121c55:	ff 45 e8             	incl   -0x18(%ebp)
f0121c58:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0121c5d:	0f b6 c0             	movzbl %al,%eax
f0121c60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121c63:	0f 8f 1d ff ff ff    	jg     f0121b86 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f0121c69:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f0121c70:	a1 40 ce 94 f1       	mov    0xf194ce40,%eax
f0121c75:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0121c78:	eb 1a                	jmp    f0121c94 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f0121c7a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c7d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0121c83:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f0121c86:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121c89:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f0121c8c:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0121c91:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0121c94:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121c98:	74 08                	je     f0121ca2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f0121c9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c9d:	8b 40 08             	mov    0x8(%eax),%eax
f0121ca0:	eb 05                	jmp    f0121ca7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f0121ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0121ca7:	a3 48 ce 94 f1       	mov    %eax,0xf194ce48
f0121cac:	a1 48 ce 94 f1       	mov    0xf194ce48,%eax
f0121cb1:	85 c0                	test   %eax,%eax
f0121cb3:	75 c5                	jne    f0121c7a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f0121cb5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121cb9:	75 bf                	jne    f0121c7a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0121cbb:	83 ec 0c             	sub    $0xc,%esp
f0121cbe:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121cc3:	e8 22 19 ff ff       	call   f01135ea <release_kspinlock>
f0121cc8:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f0121ccb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121ccf:	0f 84 d4 00 00 00    	je     f0121da9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0121cd5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121cd8:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0121cde:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0121ce1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121ce4:	8b 90 70 06 00 00    	mov    0x670(%eax),%edx
f0121cea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121ced:	0f af c2             	imul   %edx,%eax
f0121cf0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121cf5:	f7 e2                	mul    %edx
f0121cf7:	89 d0                	mov    %edx,%eax
f0121cf9:	c1 e8 05             	shr    $0x5,%eax
f0121cfc:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0121cff:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121d02:	8b 90 70 06 00 00    	mov    0x670(%eax),%edx
f0121d08:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121d0b:	89 d1                	mov    %edx,%ecx
f0121d0d:	0f af c8             	imul   %eax,%ecx
f0121d10:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121d15:	f7 e1                	mul    %ecx
f0121d17:	c1 ea 05             	shr    $0x5,%edx
f0121d1a:	89 d0                	mov    %edx,%eax
f0121d1c:	c1 e0 02             	shl    $0x2,%eax
f0121d1f:	01 d0                	add    %edx,%eax
f0121d21:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121d28:	01 d0                	add    %edx,%eax
f0121d2a:	c1 e0 02             	shl    $0x2,%eax
f0121d2d:	29 c1                	sub    %eax,%ecx
f0121d2f:	89 ca                	mov    %ecx,%edx
f0121d31:	85 d2                	test   %edx,%edx
f0121d33:	74 03                	je     f0121d38 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f0121d35:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0121d38:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121d3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121d3e:	eb 69                	jmp    f0121da9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0121d40:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121d43:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0121d49:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0121d4c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121d4f:	8b 90 70 06 00 00    	mov    0x670(%eax),%edx
f0121d55:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121d58:	0f af c2             	imul   %edx,%eax
f0121d5b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121d60:	f7 e2                	mul    %edx
f0121d62:	89 d0                	mov    %edx,%eax
f0121d64:	c1 e8 05             	shr    $0x5,%eax
f0121d67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0121d6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121d6d:	8b 90 70 06 00 00    	mov    0x670(%eax),%edx
f0121d73:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121d76:	89 d1                	mov    %edx,%ecx
f0121d78:	0f af c8             	imul   %eax,%ecx
f0121d7b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121d80:	f7 e1                	mul    %ecx
f0121d82:	c1 ea 05             	shr    $0x5,%edx
f0121d85:	89 d0                	mov    %edx,%eax
f0121d87:	c1 e0 02             	shl    $0x2,%eax
f0121d8a:	01 d0                	add    %edx,%eax
f0121d8c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121d93:	01 d0                	add    %edx,%eax
f0121d95:	c1 e0 02             	shl    $0x2,%eax
f0121d98:	29 c1                	sub    %eax,%ecx
f0121d9a:	89 ca                	mov    %ecx,%edx
f0121d9c:	85 d2                	test   %edx,%edx
f0121d9e:	74 03                	je     f0121da3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f0121da0:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0121da3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121da6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f0121da9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121daf:	01 c2                	add    %eax,%edx
f0121db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121db4:	01 d0                	add    %edx,%eax
}
f0121db6:	c9                   	leave  
f0121db7:	c3                   	ret    

f0121db8 <schenv>:


void schenv()
{
f0121db8:	55                   	push   %ebp
f0121db9:	89 e5                	mov    %esp,%ebp
f0121dbb:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f0121dbe:	c6 05 7c 54 96 f1 00 	movb   $0x0,0xf196547c
	__ne = NULL;
f0121dc5:	c7 05 94 51 96 f1 00 	movl   $0x0,0xf1965194
f0121dcc:	00 00 00 
	acquire_kspinlock(&ProcessQueues.qlock);
f0121dcf:	83 ec 0c             	sub    $0xc,%esp
f0121dd2:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121dd7:	e8 69 17 ff ff       	call   f0113545 <acquire_kspinlock>
f0121ddc:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0121ddf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121de6:	eb 3f                	jmp    f0121e27 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f0121de8:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121ded:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121df0:	c1 e2 04             	shl    $0x4,%edx
f0121df3:	01 d0                	add    %edx,%eax
f0121df5:	83 ec 0c             	sub    $0xc,%esp
f0121df8:	50                   	push   %eax
f0121df9:	e8 ff 41 fe ff       	call   f0105ffd <queue_size>
f0121dfe:	83 c4 10             	add    $0x10,%esp
f0121e01:	85 c0                	test   %eax,%eax
f0121e03:	74 1f                	je     f0121e24 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f0121e05:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121e0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121e0d:	c1 e2 04             	shl    $0x4,%edx
f0121e10:	01 d0                	add    %edx,%eax
f0121e12:	8b 40 04             	mov    0x4(%eax),%eax
f0121e15:	a3 94 51 96 f1       	mov    %eax,0xf1965194
				__nl = i;
f0121e1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e1d:	a2 7c 54 96 f1       	mov    %al,0xf196547c
				break;
f0121e22:	eb 10                	jmp    f0121e34 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0121e24:	ff 45 f4             	incl   -0xc(%ebp)
f0121e27:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0121e2c:	0f b6 c0             	movzbl %al,%eax
f0121e2f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121e32:	7f b4                	jg     f0121de8 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0121e34:	83 ec 0c             	sub    $0xc,%esp
f0121e37:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121e3c:	e8 a9 17 ff ff       	call   f01135ea <release_kspinlock>
f0121e41:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f0121e44:	e8 ff b7 fe ff       	call   f010d648 <get_cpu_proc>
f0121e49:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f0121e4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121e50:	0f 84 82 00 00 00    	je     f0121ed8 <schenv+0x120>
	{
		if (__ne != NULL)
f0121e56:	a1 94 51 96 f1       	mov    0xf1965194,%eax
f0121e5b:	85 c0                	test   %eax,%eax
f0121e5d:	74 49                	je     f0121ea8 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f0121e5f:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121e64:	0f b6 c0             	movzbl %al,%eax
f0121e67:	8d 50 01             	lea    0x1(%eax),%edx
f0121e6a:	a0 7c 54 96 f1       	mov    0xf196547c,%al
f0121e6f:	0f b6 c0             	movzbl %al,%eax
f0121e72:	39 c2                	cmp    %eax,%edx
f0121e74:	7d 62                	jge    f0121ed8 <schenv+0x120>
			{
				__ne = cur_env;
f0121e76:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121e79:	a3 94 51 96 f1       	mov    %eax,0xf1965194
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0121e7e:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121e83:	0f b6 c0             	movzbl %al,%eax
f0121e86:	8a 15 00 54 96 f1    	mov    0xf1965400,%dl
f0121e8c:	0f b6 d2             	movzbl %dl,%edx
f0121e8f:	4a                   	dec    %edx
f0121e90:	39 d0                	cmp    %edx,%eax
f0121e92:	7d 08                	jge    f0121e9c <schenv+0xe4>
f0121e94:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121e99:	40                   	inc    %eax
f0121e9a:	eb 05                	jmp    f0121ea1 <schenv+0xe9>
f0121e9c:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121ea1:	a2 7c 54 96 f1       	mov    %al,0xf196547c
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f0121ea6:	eb 30                	jmp    f0121ed8 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f0121ea8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121eab:	a3 94 51 96 f1       	mov    %eax,0xf1965194
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0121eb0:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121eb5:	0f b6 c0             	movzbl %al,%eax
f0121eb8:	8a 15 00 54 96 f1    	mov    0xf1965400,%dl
f0121ebe:	0f b6 d2             	movzbl %dl,%edx
f0121ec1:	4a                   	dec    %edx
f0121ec2:	39 d0                	cmp    %edx,%eax
f0121ec4:	7d 08                	jge    f0121ece <schenv+0x116>
f0121ec6:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121ecb:	40                   	inc    %eax
f0121ecc:	eb 05                	jmp    f0121ed3 <schenv+0x11b>
f0121ece:	a0 a1 cd 94 f1       	mov    0xf194cda1,%al
f0121ed3:	a2 7c 54 96 f1       	mov    %al,0xf196547c
		}
	}
}
f0121ed8:	90                   	nop
f0121ed9:	c9                   	leave  
f0121eda:	c3                   	ret    

f0121edb <chksch>:

void chksch(uint8 onoff)
{
f0121edb:	55                   	push   %ebp
f0121edc:	89 e5                	mov    %esp,%ebp
f0121ede:	83 ec 18             	sub    $0x18,%esp
f0121ee1:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ee4:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0121ee7:	e8 8d 59 fe ff       	call   f0107879 <isSchedMethodBSD>
f0121eec:	85 c0                	test   %eax,%eax
f0121eee:	74 48                	je     f0121f38 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f0121ef0:	e8 56 58 fe ff       	call   f010774b <get_load_average>
f0121ef5:	a3 1c 54 96 f1       	mov    %eax,0xf196541c
f0121efa:	a1 1c 54 96 f1       	mov    0xf196541c,%eax
f0121eff:	a3 5c d0 94 f1       	mov    %eax,0xf194d05c
		acquire_kspinlock(&ProcessQueues.qlock);
f0121f04:	83 ec 0c             	sub    $0xc,%esp
f0121f07:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121f0c:	e8 34 16 ff ff       	call   f0113545 <acquire_kspinlock>
f0121f11:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f0121f14:	a1 4c ce 94 f1       	mov    0xf194ce4c,%eax
f0121f19:	a3 f0 ce 94 f1       	mov    %eax,0xf194cef0
		}
		release_kspinlock(&ProcessQueues.qlock);
f0121f1e:	83 ec 0c             	sub    $0xc,%esp
f0121f21:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121f26:	e8 bf 16 ff ff       	call   f01135ea <release_kspinlock>
f0121f2b:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f0121f2e:	c7 05 a4 51 96 f1 01 	movl   $0x1,0xf19651a4
f0121f35:	00 00 00 
	}
	__chkstatus = onoff;
f0121f38:	8a 45 f4             	mov    -0xc(%ebp),%al
f0121f3b:	a2 8c 51 96 f1       	mov    %al,0xf196518c
}
f0121f40:	90                   	nop
f0121f41:	c9                   	leave  
f0121f42:	c3                   	ret    

f0121f43 <chk1>:
void chk1()
{
f0121f43:	55                   	push   %ebp
f0121f44:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f0121f46:	90                   	nop
f0121f47:	5d                   	pop    %ebp
f0121f48:	c3                   	ret    

f0121f49 <chk2>:
void chk2(struct Env* __se)
{
f0121f49:	55                   	push   %ebp
f0121f4a:	89 e5                	mov    %esp,%ebp
f0121f4c:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f0121f4f:	a0 8c 51 96 f1       	mov    0xf196518c,%al
f0121f54:	84 c0                	test   %al,%al
f0121f56:	0f 84 59 03 00 00    	je     f01222b5 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0121f5c:	e8 18 59 fe ff       	call   f0107879 <isSchedMethodBSD>
f0121f61:	85 c0                	test   %eax,%eax
f0121f63:	0f 84 4d 03 00 00    	je     f01222b6 <chk2+0x36d>
	{
		__nla = get_load_average();
f0121f69:	e8 dd 57 fe ff       	call   f010774b <get_load_average>
f0121f6e:	a3 94 cf 94 f1       	mov    %eax,0xf194cf94
		acquire_kspinlock(&ProcessQueues.qlock);
f0121f73:	83 ec 0c             	sub    $0xc,%esp
f0121f76:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121f7b:	e8 c5 15 ff ff       	call   f0113545 <acquire_kspinlock>
f0121f80:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0121f83:	a1 4c ce 94 f1       	mov    0xf194ce4c,%eax
f0121f88:	a3 98 51 96 f1       	mov    %eax,0xf1965198
		}
		release_kspinlock(&ProcessQueues.qlock);
f0121f8d:	83 ec 0c             	sub    $0xc,%esp
f0121f90:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121f95:	e8 50 16 ff ff       	call   f01135ea <release_kspinlock>
f0121f9a:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f0121f9d:	a1 a4 51 96 f1       	mov    0xf19651a4,%eax
f0121fa2:	85 c0                	test   %eax,%eax
f0121fa4:	74 72                	je     f0122018 <chk2+0xcf>
		{
			acquire_kspinlock(&ProcessQueues.qlock);
f0121fa6:	83 ec 0c             	sub    $0xc,%esp
f0121fa9:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0121fae:	e8 92 15 ff ff       	call   f0113545 <acquire_kspinlock>
f0121fb3:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f0121fb6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121fba:	0f 95 c0             	setne  %al
f0121fbd:	0f b6 c0             	movzbl %al,%eax
f0121fc0:	a3 d4 52 96 f1       	mov    %eax,0xf19652d4
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0121fc5:	a0 00 54 96 f1       	mov    0xf1965400,%al
f0121fca:	0f b6 c0             	movzbl %al,%eax
f0121fcd:	48                   	dec    %eax
f0121fce:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121fd1:	eb 20                	jmp    f0121ff3 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0121fd3:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0121fd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121fdb:	c1 e2 04             	shl    $0x4,%edx
f0121fde:	01 d0                	add    %edx,%eax
f0121fe0:	8b 40 0c             	mov    0xc(%eax),%eax
f0121fe3:	8b 15 d4 52 96 f1    	mov    0xf19652d4,%edx
f0121fe9:	01 d0                	add    %edx,%eax
f0121feb:	a3 d4 52 96 f1       	mov    %eax,0xf19652d4
		{
			acquire_kspinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0121ff0:	ff 4d f4             	decl   -0xc(%ebp)
f0121ff3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121ff7:	79 da                	jns    f0121fd3 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f0121ff9:	c7 05 a4 51 96 f1 00 	movl   $0x0,0xf19651a4
f0122000:	00 00 00 
			}
			release_kspinlock(&ProcessQueues.qlock);
f0122003:	83 ec 0c             	sub    $0xc,%esp
f0122006:	68 c0 cd 94 f1       	push   $0xf194cdc0
f012200b:	e8 da 15 ff ff       	call   f01135ea <release_kspinlock>
f0122010:	83 c4 10             	add    $0x10,%esp
f0122013:	e9 91 02 00 00       	jmp    f01222a9 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f0122018:	8b 15 f0 ce 94 f1    	mov    0xf194cef0,%edx
f012201e:	a1 98 51 96 f1       	mov    0xf1965198,%eax
f0122023:	39 c2                	cmp    %eax,%edx
f0122025:	74 63                	je     f012208a <chk2+0x141>
			{
				acquire_kspinlock(&ProcessQueues.qlock);
f0122027:	83 ec 0c             	sub    $0xc,%esp
f012202a:	68 c0 cd 94 f1       	push   $0xf194cdc0
f012202f:	e8 11 15 ff ff       	call   f0113545 <acquire_kspinlock>
f0122034:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f0122037:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012203b:	0f 95 c0             	setne  %al
f012203e:	0f b6 c0             	movzbl %al,%eax
f0122041:	a3 d4 52 96 f1       	mov    %eax,0xf19652d4
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0122046:	a0 00 54 96 f1       	mov    0xf1965400,%al
f012204b:	0f b6 c0             	movzbl %al,%eax
f012204e:	48                   	dec    %eax
f012204f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122052:	eb 20                	jmp    f0122074 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0122054:	a1 50 ce 94 f1       	mov    0xf194ce50,%eax
f0122059:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012205c:	c1 e2 04             	shl    $0x4,%edx
f012205f:	01 d0                	add    %edx,%eax
f0122061:	8b 40 0c             	mov    0xc(%eax),%eax
f0122064:	8b 15 d4 52 96 f1    	mov    0xf19652d4,%edx
f012206a:	01 d0                	add    %edx,%eax
f012206c:	a3 d4 52 96 f1       	mov    %eax,0xf19652d4
			{
				acquire_kspinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0122071:	ff 4d f0             	decl   -0x10(%ebp)
f0122074:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122078:	79 da                	jns    f0122054 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_kspinlock(&ProcessQueues.qlock);
f012207a:	83 ec 0c             	sub    $0xc,%esp
f012207d:	68 c0 cd 94 f1       	push   $0xf194cdc0
f0122082:	e8 63 15 ff ff       	call   f01135ea <release_kspinlock>
f0122087:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f012208a:	e8 55 56 fe ff       	call   f01076e4 <timer_ticks>
f012208f:	6a 00                	push   $0x0
f0122091:	68 e8 03 00 00       	push   $0x3e8
f0122096:	52                   	push   %edx
f0122097:	50                   	push   %eax
f0122098:	e8 ff 25 00 00       	call   f012469c <__moddi3>
f012209d:	83 c4 10             	add    $0x10,%esp
f01220a0:	09 d0                	or     %edx,%eax
f01220a2:	85 c0                	test   %eax,%eax
f01220a4:	75 32                	jne    f01220d8 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f01220a6:	8b 15 5c d0 94 f1    	mov    0xf194d05c,%edx
f01220ac:	a1 94 cf 94 f1       	mov    0xf194cf94,%eax
f01220b1:	39 c2                	cmp    %eax,%edx
f01220b3:	75 19                	jne    f01220ce <chk2+0x185>
f01220b5:	68 e9 04 14 f0       	push   $0xf01404e9
f01220ba:	68 c7 fb 13 f0       	push   $0xf013fbc7
f01220bf:	68 3e 03 00 00       	push   $0x33e
f01220c4:	68 0f fc 13 f0       	push   $0xf013fc0f
f01220c9:	e8 70 ee fd ff       	call   f0100f3e <_panic_all>
				__histla = __nla;
f01220ce:	a1 94 cf 94 f1       	mov    0xf194cf94,%eax
f01220d3:	a3 5c d0 94 f1       	mov    %eax,0xf194d05c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f01220d8:	e8 07 56 fe ff       	call   f01076e4 <timer_ticks>
f01220dd:	6a 00                	push   $0x0
f01220df:	6a 64                	push   $0x64
f01220e1:	52                   	push   %edx
f01220e2:	50                   	push   %eax
f01220e3:	e8 b4 25 00 00       	call   f012469c <__moddi3>
f01220e8:	83 c4 10             	add    $0x10,%esp
f01220eb:	09 d0                	or     %edx,%eax
f01220ed:	85 c0                	test   %eax,%eax
f01220ef:	0f 85 b4 01 00 00    	jne    f01222a9 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f01220f5:	8b 0d 1c 54 96 f1    	mov    0xf196541c,%ecx
f01220fb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0122100:	f7 e9                	imul   %ecx
f0122102:	c1 fa 05             	sar    $0x5,%edx
f0122105:	89 c8                	mov    %ecx,%eax
f0122107:	c1 f8 1f             	sar    $0x1f,%eax
f012210a:	29 c2                	sub    %eax,%edx
f012210c:	89 d0                	mov    %edx,%eax
f012210e:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f0122111:	8b 0d 1c 54 96 f1    	mov    0xf196541c,%ecx
f0122117:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f012211c:	f7 e9                	imul   %ecx
f012211e:	c1 fa 05             	sar    $0x5,%edx
f0122121:	89 c8                	mov    %ecx,%eax
f0122123:	c1 f8 1f             	sar    $0x1f,%eax
f0122126:	29 c2                	sub    %eax,%edx
f0122128:	89 d0                	mov    %edx,%eax
f012212a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f012212d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0122130:	89 d0                	mov    %edx,%eax
f0122132:	c1 e0 02             	shl    $0x2,%eax
f0122135:	01 d0                	add    %edx,%eax
f0122137:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012213e:	01 d0                	add    %edx,%eax
f0122140:	c1 e0 02             	shl    $0x2,%eax
f0122143:	29 c1                	sub    %eax,%ecx
f0122145:	89 c8                	mov    %ecx,%eax
f0122147:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f012214a:	8b 0d 94 cf 94 f1    	mov    0xf194cf94,%ecx
f0122150:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0122155:	f7 e9                	imul   %ecx
f0122157:	c1 fa 05             	sar    $0x5,%edx
f012215a:	89 c8                	mov    %ecx,%eax
f012215c:	c1 f8 1f             	sar    $0x1f,%eax
f012215f:	29 c2                	sub    %eax,%edx
f0122161:	89 d0                	mov    %edx,%eax
f0122163:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f0122166:	8b 0d 94 cf 94 f1    	mov    0xf194cf94,%ecx
f012216c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0122171:	f7 e9                	imul   %ecx
f0122173:	c1 fa 05             	sar    $0x5,%edx
f0122176:	89 c8                	mov    %ecx,%eax
f0122178:	c1 f8 1f             	sar    $0x1f,%eax
f012217b:	29 c2                	sub    %eax,%edx
f012217d:	89 d0                	mov    %edx,%eax
f012217f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0122182:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0122185:	89 d0                	mov    %edx,%eax
f0122187:	c1 e0 02             	shl    $0x2,%eax
f012218a:	01 d0                	add    %edx,%eax
f012218c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122193:	01 d0                	add    %edx,%eax
f0122195:	c1 e0 02             	shl    $0x2,%eax
f0122198:	29 c1                	sub    %eax,%ecx
f012219a:	89 c8                	mov    %ecx,%eax
f012219c:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f012219f:	8b 15 98 51 96 f1    	mov    0xf1965198,%edx
f01221a5:	a1 f0 ce 94 f1       	mov    0xf194cef0,%eax
f01221aa:	39 c2                	cmp    %eax,%edx
f01221ac:	0f 85 ed 00 00 00    	jne    f012229f <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f01221b2:	a1 d4 52 96 f1       	mov    0xf19652d4,%eax
f01221b7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01221ba:	7e 5b                	jle    f0122217 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f01221bc:	a1 d4 52 96 f1       	mov    0xf19652d4,%eax
f01221c1:	83 ec 08             	sub    $0x8,%esp
f01221c4:	ff 75 e0             	pushl  -0x20(%ebp)
f01221c7:	ff 75 e4             	pushl  -0x1c(%ebp)
f01221ca:	ff 75 e8             	pushl  -0x18(%ebp)
f01221cd:	ff 75 ec             	pushl  -0x14(%ebp)
f01221d0:	50                   	push   %eax
f01221d1:	68 fc 04 14 f0       	push   $0xf01404fc
f01221d6:	e8 72 f9 fd ff       	call   f0101b4d <cprintf>
f01221db:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f01221de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221e1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01221e4:	0f 8f b5 00 00 00    	jg     f012229f <chk2+0x356>
f01221ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01221ed:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01221f0:	75 0c                	jne    f01221fe <chk2+0x2b5>
f01221f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01221f5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01221f8:	0f 8d a1 00 00 00    	jge    f012229f <chk2+0x356>
f01221fe:	68 44 05 14 f0       	push   $0xf0140544
f0122203:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0122208:	68 53 03 00 00       	push   $0x353
f012220d:	68 0f fc 13 f0       	push   $0xf013fc0f
f0122212:	e8 27 ed fd ff       	call   f0100f3e <_panic_all>
					}
					else if (__nproc < plaint)
f0122217:	a1 d4 52 96 f1       	mov    0xf19652d4,%eax
f012221c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f012221f:	7d 53                	jge    f0122274 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0122221:	a1 d4 52 96 f1       	mov    0xf19652d4,%eax
f0122226:	83 ec 08             	sub    $0x8,%esp
f0122229:	ff 75 e0             	pushl  -0x20(%ebp)
f012222c:	ff 75 e4             	pushl  -0x1c(%ebp)
f012222f:	ff 75 e8             	pushl  -0x18(%ebp)
f0122232:	ff 75 ec             	pushl  -0x14(%ebp)
f0122235:	50                   	push   %eax
f0122236:	68 84 05 14 f0       	push   $0xf0140584
f012223b:	e8 0d f9 fd ff       	call   f0101b4d <cprintf>
f0122240:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f0122243:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122246:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0122249:	7c 54                	jl     f012229f <chk2+0x356>
f012224b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012224e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0122251:	75 08                	jne    f012225b <chk2+0x312>
f0122253:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122256:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0122259:	7e 44                	jle    f012229f <chk2+0x356>
f012225b:	68 cc 05 14 f0       	push   $0xf01405cc
f0122260:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0122265:	68 59 03 00 00       	push   $0x359
f012226a:	68 0f fc 13 f0       	push   $0xf013fc0f
f012226f:	e8 ca ec fd ff       	call   f0100f3e <_panic_all>
					}
					else if (__nproc == plaint)
f0122274:	a1 d4 52 96 f1       	mov    0xf19652d4,%eax
f0122279:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f012227c:	75 21                	jne    f012229f <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f012227e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122281:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0122284:	74 19                	je     f012229f <chk2+0x356>
f0122286:	68 0c 06 14 f0       	push   $0xf014060c
f012228b:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0122290:	68 5d 03 00 00       	push   $0x35d
f0122295:	68 0f fc 13 f0       	push   $0xf013fc0f
f012229a:	e8 9f ec fd ff       	call   f0100f3e <_panic_all>
					}
				}
				__pla = __nla;
f012229f:	a1 94 cf 94 f1       	mov    0xf194cf94,%eax
f01222a4:	a3 1c 54 96 f1       	mov    %eax,0xf196541c
			}
		}
		__pnexit = __nnexit;
f01222a9:	a1 98 51 96 f1       	mov    0xf1965198,%eax
f01222ae:	a3 f0 ce 94 f1       	mov    %eax,0xf194cef0
f01222b3:	eb 01                	jmp    f01222b6 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f01222b5:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f01222b6:	c9                   	leave  
f01222b7:	c3                   	ret    

f01222b8 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f01222b8:	55                   	push   %ebp
f01222b9:	89 e5                	mov    %esp,%ebp
f01222bb:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f01222be:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01222c5:	eb 40                	jmp    f0122307 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f01222c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01222ca:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f01222d0:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01222d5:	83 ec 08             	sub    $0x8,%esp
f01222d8:	52                   	push   %edx
f01222d9:	50                   	push   %eax
f01222da:	e8 af 01 00 00       	call   f012248e <check_va2pa>
f01222df:	83 c4 10             	add    $0x10,%esp
f01222e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01222e5:	74 19                	je     f0122300 <check_boot_pgdir+0x48>
f01222e7:	68 20 06 14 f0       	push   $0xf0140620
f01222ec:	68 c7 fb 13 f0       	push   $0xf013fbc7
f01222f1:	68 a4 03 00 00       	push   $0x3a4
f01222f6:	68 0f fc 13 f0       	push   $0xf013fc0f
f01222fb:	e8 af eb fd ff       	call   f0100eaf <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0122300:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0122307:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012230a:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0122310:	a1 70 53 96 f1       	mov    0xf1965370,%eax
f0122315:	39 c2                	cmp    %eax,%edx
f0122317:	72 ae                	jb     f01222c7 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0122319:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0122320:	e9 81 00 00 00       	jmp    f01223a6 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f0122325:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122328:	25 ff 7f 00 00       	and    $0x7fff,%eax
f012232d:	85 c0                	test   %eax,%eax
f012232f:	74 6d                	je     f012239e <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f0122331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122334:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f012233a:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f012233f:	83 ec 08             	sub    $0x8,%esp
f0122342:	52                   	push   %edx
f0122343:	50                   	push   %eax
f0122344:	e8 45 01 00 00       	call   f012248e <check_va2pa>
f0122349:	83 c4 10             	add    $0x10,%esp
f012234c:	c7 45 f0 00 f0 18 f0 	movl   $0xf018f000,-0x10(%ebp)
f0122353:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f012235a:	77 17                	ja     f0122373 <check_boot_pgdir+0xbb>
f012235c:	ff 75 f0             	pushl  -0x10(%ebp)
f012235f:	68 58 06 14 f0       	push   $0xf0140658
f0122364:	68 b2 03 00 00       	push   $0x3b2
f0122369:	68 0f fc 13 f0       	push   $0xf013fc0f
f012236e:	e8 3c eb fd ff       	call   f0100eaf <_panic>
f0122373:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122376:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f012237c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012237f:	01 ca                	add    %ecx,%edx
f0122381:	39 d0                	cmp    %edx,%eax
f0122383:	74 1a                	je     f012239f <check_boot_pgdir+0xe7>
f0122385:	68 8c 06 14 f0       	push   $0xf014068c
f012238a:	68 c7 fb 13 f0       	push   $0xf013fbc7
f012238f:	68 b2 03 00 00       	push   $0x3b2
f0122394:	68 0f fc 13 f0       	push   $0xf013fc0f
f0122399:	e8 11 eb fd ff       	call   f0100eaf <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f012239e:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f012239f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01223a6:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f01223ad:	0f 86 72 ff ff ff    	jbe    f0122325 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f01223b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01223ba:	e9 af 00 00 00       	jmp    f012246e <check_boot_pgdir+0x1b6>
		switch (i) {
f01223bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01223c2:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f01223c7:	74 11                	je     f01223da <check_boot_pgdir+0x122>
f01223c9:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f01223ce:	72 36                	jb     f0122406 <check_boot_pgdir+0x14e>
f01223d0:	2d bd 03 00 00       	sub    $0x3bd,%eax
f01223d5:	83 f8 02             	cmp    $0x2,%eax
f01223d8:	77 2c                	ja     f0122406 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f01223da:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01223df:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01223e2:	c1 e2 02             	shl    $0x2,%edx
f01223e5:	01 d0                	add    %edx,%eax
f01223e7:	8b 00                	mov    (%eax),%eax
f01223e9:	85 c0                	test   %eax,%eax
f01223eb:	75 7a                	jne    f0122467 <check_boot_pgdir+0x1af>
f01223ed:	68 12 07 14 f0       	push   $0xf0140712
f01223f2:	68 c7 fb 13 f0       	push   $0xf013fbc7
f01223f7:	68 bd 03 00 00       	push   $0x3bd
f01223fc:	68 0f fc 13 f0       	push   $0xf013fc0f
f0122401:	e8 a9 ea fd ff       	call   f0100eaf <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f0122406:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f012240d:	76 2c                	jbe    f012243b <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f012240f:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0122414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122417:	c1 e2 02             	shl    $0x2,%edx
f012241a:	01 d0                	add    %edx,%eax
f012241c:	8b 00                	mov    (%eax),%eax
f012241e:	85 c0                	test   %eax,%eax
f0122420:	75 48                	jne    f012246a <check_boot_pgdir+0x1b2>
f0122422:	68 12 07 14 f0       	push   $0xf0140712
f0122427:	68 c7 fb 13 f0       	push   $0xf013fbc7
f012242c:	68 c1 03 00 00       	push   $0x3c1
f0122431:	68 0f fc 13 f0       	push   $0xf013fc0f
f0122436:	e8 74 ea fd ff       	call   f0100eaf <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f012243b:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f0122440:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122443:	c1 e2 02             	shl    $0x2,%edx
f0122446:	01 d0                	add    %edx,%eax
f0122448:	8b 00                	mov    (%eax),%eax
f012244a:	85 c0                	test   %eax,%eax
f012244c:	74 1c                	je     f012246a <check_boot_pgdir+0x1b2>
f012244e:	68 28 07 14 f0       	push   $0xf0140728
f0122453:	68 c7 fb 13 f0       	push   $0xf013fbc7
f0122458:	68 c3 03 00 00       	push   $0x3c3
f012245d:	68 0f fc 13 f0       	push   $0xf013fc0f
f0122462:	e8 48 ea fd ff       	call   f0100eaf <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f0122467:	90                   	nop
f0122468:	eb 01                	jmp    f012246b <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f012246a:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f012246b:	ff 45 f4             	incl   -0xc(%ebp)
f012246e:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0122475:	0f 86 44 ff ff ff    	jbe    f01223bf <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f012247b:	83 ec 0c             	sub    $0xc,%esp
f012247e:	68 44 07 14 f0       	push   $0xf0140744
f0122483:	e8 c5 f6 fd ff       	call   f0101b4d <cprintf>
f0122488:	83 c4 10             	add    $0x10,%esp
}
f012248b:	90                   	nop
f012248c:	c9                   	leave  
f012248d:	c3                   	ret    

f012248e <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f012248e:	55                   	push   %ebp
f012248f:	89 e5                	mov    %esp,%ebp
f0122491:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f0122494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122497:	c1 e8 16             	shr    $0x16,%eax
f012249a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01224a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01224a4:	01 d0                	add    %edx,%eax
f01224a6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f01224a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01224ac:	8b 00                	mov    (%eax),%eax
f01224ae:	83 e0 01             	and    $0x1,%eax
f01224b1:	85 c0                	test   %eax,%eax
f01224b3:	75 0a                	jne    f01224bf <check_va2pa+0x31>
		return ~0;
f01224b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01224ba:	e9 87 00 00 00       	jmp    f0122546 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f01224bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01224c2:	8b 00                	mov    (%eax),%eax
f01224c4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01224c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01224cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01224cf:	c1 e8 0c             	shr    $0xc,%eax
f01224d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01224d5:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f01224da:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01224dd:	72 17                	jb     f01224f6 <check_va2pa+0x68>
f01224df:	ff 75 f0             	pushl  -0x10(%ebp)
f01224e2:	68 68 07 14 f0       	push   $0xf0140768
f01224e7:	68 d9 03 00 00       	push   $0x3d9
f01224ec:	68 0f fc 13 f0       	push   $0xf013fc0f
f01224f1:	e8 b9 e9 fd ff       	call   f0100eaf <_panic>
f01224f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01224f9:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01224fe:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f0122501:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122504:	c1 e8 0c             	shr    $0xc,%eax
f0122507:	25 ff 03 00 00       	and    $0x3ff,%eax
f012250c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122513:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0122516:	01 d0                	add    %edx,%eax
f0122518:	8b 00                	mov    (%eax),%eax
f012251a:	83 e0 01             	and    $0x1,%eax
f012251d:	85 c0                	test   %eax,%eax
f012251f:	75 07                	jne    f0122528 <check_va2pa+0x9a>
		return ~0;
f0122521:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0122526:	eb 1e                	jmp    f0122546 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f0122528:	8b 45 0c             	mov    0xc(%ebp),%eax
f012252b:	c1 e8 0c             	shr    $0xc,%eax
f012252e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0122533:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012253a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012253d:	01 d0                	add    %edx,%eax
f012253f:	8b 00                	mov    (%eax),%eax
f0122541:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0122546:	c9                   	leave  
f0122547:	c3                   	ret    

f0122548 <clone_kern_dir>:
}
 */

//

uint32* clone_kern_dir() {
f0122548:	55                   	push   %ebp
f0122549:	89 e5                	mov    %esp,%ebp
f012254b:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
f012254e:	83 ec 0c             	sub    $0xc,%esp
f0122551:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0122554:	50                   	push   %eax
f0122555:	e8 fc 70 fe ff       	call   f0109656 <allocate_frame>
f012255a:	83 c4 10             	add    $0x10,%esp
	uint32 dir_pa = to_physical_address(ptr_fi);
f012255d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122560:	83 ec 0c             	sub    $0xc,%esp
f0122563:	50                   	push   %eax
f0122564:	e8 47 e1 ff ff       	call   f01206b0 <to_physical_address>
f0122569:	83 c4 10             	add    $0x10,%esp
f012256c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
f012256f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122572:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0122575:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122578:	c1 e8 0c             	shr    $0xc,%eax
f012257b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f012257e:	a1 58 d0 94 f1       	mov    0xf194d058,%eax
f0122583:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0122586:	72 17                	jb     f012259f <clone_kern_dir+0x57>
f0122588:	ff 75 ec             	pushl  -0x14(%ebp)
f012258b:	68 68 07 14 f0       	push   $0xf0140768
f0122590:	68 59 04 00 00       	push   $0x459
f0122595:	68 0f fc 13 f0       	push   $0xf013fc0f
f012259a:	e8 10 e9 fd ff       	call   f0100eaf <_panic>
f012259f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01225a2:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01225a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i = 0; i < 1024; ++i) {
f01225aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01225b1:	eb 23                	jmp    f01225d6 <clone_kern_dir+0x8e>
		dir_ptr[i] = ptr_page_directory[i];
f01225b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01225b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01225bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01225c0:	01 c2                	add    %eax,%edx
f01225c2:	a1 78 53 96 f1       	mov    0xf1965378,%eax
f01225c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01225ca:	c1 e1 02             	shl    $0x2,%ecx
f01225cd:	01 c8                	add    %ecx,%eax
f01225cf:	8b 00                	mov    (%eax),%eax
f01225d1:	89 02                	mov    %eax,(%edx)
uint32* clone_kern_dir() {
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
	uint32 dir_pa = to_physical_address(ptr_fi);
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
	for (int i = 0; i < 1024; ++i) {
f01225d3:	ff 45 f4             	incl   -0xc(%ebp)
f01225d6:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01225dd:	7e d4                	jle    f01225b3 <clone_kern_dir+0x6b>
f01225df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01225e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01225e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01225e8:	0f 22 d8             	mov    %eax,%cr3
		dir_ptr[i] = ptr_page_directory[i];
	}
	lcr3(dir_pa);
	return dir_ptr;
f01225eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f01225ee:	c9                   	leave  
f01225ef:	c3                   	ret    

f01225f0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f01225f0:	55                   	push   %ebp
f01225f1:	89 e5                	mov    %esp,%ebp
f01225f3:	53                   	push   %ebx
f01225f4:	83 ec 14             	sub    $0x14,%esp
f01225f7:	8b 45 10             	mov    0x10(%ebp),%eax
f01225fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01225fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0122600:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f0122603:	8b 45 18             	mov    0x18(%ebp),%eax
f0122606:	ba 00 00 00 00       	mov    $0x0,%edx
f012260b:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f012260e:	77 55                	ja     f0122665 <printnum+0x75>
f0122610:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f0122613:	72 05                	jb     f012261a <printnum+0x2a>
f0122615:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0122618:	77 4b                	ja     f0122665 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f012261a:	8b 45 1c             	mov    0x1c(%ebp),%eax
f012261d:	8d 58 ff             	lea    -0x1(%eax),%ebx
f0122620:	8b 45 18             	mov    0x18(%ebp),%eax
f0122623:	ba 00 00 00 00       	mov    $0x0,%edx
f0122628:	52                   	push   %edx
f0122629:	50                   	push   %eax
f012262a:	ff 75 f4             	pushl  -0xc(%ebp)
f012262d:	ff 75 f0             	pushl  -0x10(%ebp)
f0122630:	e8 ff 21 00 00       	call   f0124834 <__udivdi3>
f0122635:	83 c4 10             	add    $0x10,%esp
f0122638:	83 ec 04             	sub    $0x4,%esp
f012263b:	ff 75 20             	pushl  0x20(%ebp)
f012263e:	53                   	push   %ebx
f012263f:	ff 75 18             	pushl  0x18(%ebp)
f0122642:	52                   	push   %edx
f0122643:	50                   	push   %eax
f0122644:	ff 75 0c             	pushl  0xc(%ebp)
f0122647:	ff 75 08             	pushl  0x8(%ebp)
f012264a:	e8 a1 ff ff ff       	call   f01225f0 <printnum>
f012264f:	83 c4 20             	add    $0x20,%esp
f0122652:	eb 1a                	jmp    f012266e <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f0122654:	83 ec 08             	sub    $0x8,%esp
f0122657:	ff 75 0c             	pushl  0xc(%ebp)
f012265a:	ff 75 20             	pushl  0x20(%ebp)
f012265d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122660:	ff d0                	call   *%eax
f0122662:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f0122665:	ff 4d 1c             	decl   0x1c(%ebp)
f0122668:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f012266c:	7f e6                	jg     f0122654 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f012266e:	8b 4d 18             	mov    0x18(%ebp),%ecx
f0122671:	bb 00 00 00 00       	mov    $0x0,%ebx
f0122676:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122679:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012267c:	53                   	push   %ebx
f012267d:	51                   	push   %ecx
f012267e:	52                   	push   %edx
f012267f:	50                   	push   %eax
f0122680:	e8 bf 22 00 00       	call   f0124944 <__umoddi3>
f0122685:	83 c4 10             	add    $0x10,%esp
f0122688:	05 b4 09 14 f0       	add    $0xf01409b4,%eax
f012268d:	8a 00                	mov    (%eax),%al
f012268f:	0f be c0             	movsbl %al,%eax
f0122692:	83 ec 08             	sub    $0x8,%esp
f0122695:	ff 75 0c             	pushl  0xc(%ebp)
f0122698:	50                   	push   %eax
f0122699:	8b 45 08             	mov    0x8(%ebp),%eax
f012269c:	ff d0                	call   *%eax
f012269e:	83 c4 10             	add    $0x10,%esp
}
f01226a1:	90                   	nop
f01226a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01226a5:	c9                   	leave  
f01226a6:	c3                   	ret    

f01226a7 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f01226a7:	55                   	push   %ebp
f01226a8:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f01226aa:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f01226ae:	7e 1c                	jle    f01226cc <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f01226b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01226b3:	8b 00                	mov    (%eax),%eax
f01226b5:	8d 50 08             	lea    0x8(%eax),%edx
f01226b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01226bb:	89 10                	mov    %edx,(%eax)
f01226bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01226c0:	8b 00                	mov    (%eax),%eax
f01226c2:	83 e8 08             	sub    $0x8,%eax
f01226c5:	8b 50 04             	mov    0x4(%eax),%edx
f01226c8:	8b 00                	mov    (%eax),%eax
f01226ca:	eb 40                	jmp    f012270c <getuint+0x65>
	else if (lflag)
f01226cc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01226d0:	74 1e                	je     f01226f0 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f01226d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01226d5:	8b 00                	mov    (%eax),%eax
f01226d7:	8d 50 04             	lea    0x4(%eax),%edx
f01226da:	8b 45 08             	mov    0x8(%ebp),%eax
f01226dd:	89 10                	mov    %edx,(%eax)
f01226df:	8b 45 08             	mov    0x8(%ebp),%eax
f01226e2:	8b 00                	mov    (%eax),%eax
f01226e4:	83 e8 04             	sub    $0x4,%eax
f01226e7:	8b 00                	mov    (%eax),%eax
f01226e9:	ba 00 00 00 00       	mov    $0x0,%edx
f01226ee:	eb 1c                	jmp    f012270c <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f01226f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01226f3:	8b 00                	mov    (%eax),%eax
f01226f5:	8d 50 04             	lea    0x4(%eax),%edx
f01226f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01226fb:	89 10                	mov    %edx,(%eax)
f01226fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0122700:	8b 00                	mov    (%eax),%eax
f0122702:	83 e8 04             	sub    $0x4,%eax
f0122705:	8b 00                	mov    (%eax),%eax
f0122707:	ba 00 00 00 00       	mov    $0x0,%edx
}
f012270c:	5d                   	pop    %ebp
f012270d:	c3                   	ret    

f012270e <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f012270e:	55                   	push   %ebp
f012270f:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f0122711:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0122715:	7e 1c                	jle    f0122733 <getint+0x25>
		return va_arg(*ap, long long);
f0122717:	8b 45 08             	mov    0x8(%ebp),%eax
f012271a:	8b 00                	mov    (%eax),%eax
f012271c:	8d 50 08             	lea    0x8(%eax),%edx
f012271f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122722:	89 10                	mov    %edx,(%eax)
f0122724:	8b 45 08             	mov    0x8(%ebp),%eax
f0122727:	8b 00                	mov    (%eax),%eax
f0122729:	83 e8 08             	sub    $0x8,%eax
f012272c:	8b 50 04             	mov    0x4(%eax),%edx
f012272f:	8b 00                	mov    (%eax),%eax
f0122731:	eb 38                	jmp    f012276b <getint+0x5d>
	else if (lflag)
f0122733:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122737:	74 1a                	je     f0122753 <getint+0x45>
		return va_arg(*ap, long);
f0122739:	8b 45 08             	mov    0x8(%ebp),%eax
f012273c:	8b 00                	mov    (%eax),%eax
f012273e:	8d 50 04             	lea    0x4(%eax),%edx
f0122741:	8b 45 08             	mov    0x8(%ebp),%eax
f0122744:	89 10                	mov    %edx,(%eax)
f0122746:	8b 45 08             	mov    0x8(%ebp),%eax
f0122749:	8b 00                	mov    (%eax),%eax
f012274b:	83 e8 04             	sub    $0x4,%eax
f012274e:	8b 00                	mov    (%eax),%eax
f0122750:	99                   	cltd   
f0122751:	eb 18                	jmp    f012276b <getint+0x5d>
	else
		return va_arg(*ap, int);
f0122753:	8b 45 08             	mov    0x8(%ebp),%eax
f0122756:	8b 00                	mov    (%eax),%eax
f0122758:	8d 50 04             	lea    0x4(%eax),%edx
f012275b:	8b 45 08             	mov    0x8(%ebp),%eax
f012275e:	89 10                	mov    %edx,(%eax)
f0122760:	8b 45 08             	mov    0x8(%ebp),%eax
f0122763:	8b 00                	mov    (%eax),%eax
f0122765:	83 e8 04             	sub    $0x4,%eax
f0122768:	8b 00                	mov    (%eax),%eax
f012276a:	99                   	cltd   
}
f012276b:	5d                   	pop    %ebp
f012276c:	c3                   	ret    

f012276d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f012276d:	55                   	push   %ebp
f012276e:	89 e5                	mov    %esp,%ebp
f0122770:	56                   	push   %esi
f0122771:	53                   	push   %ebx
f0122772:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f0122775:	eb 17                	jmp    f012278e <vprintfmt+0x21>
			if (ch == '\0')
f0122777:	85 db                	test   %ebx,%ebx
f0122779:	0f 84 c1 03 00 00    	je     f0122b40 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f012277f:	83 ec 08             	sub    $0x8,%esp
f0122782:	ff 75 0c             	pushl  0xc(%ebp)
f0122785:	53                   	push   %ebx
f0122786:	8b 45 08             	mov    0x8(%ebp),%eax
f0122789:	ff d0                	call   *%eax
f012278b:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f012278e:	8b 45 10             	mov    0x10(%ebp),%eax
f0122791:	8d 50 01             	lea    0x1(%eax),%edx
f0122794:	89 55 10             	mov    %edx,0x10(%ebp)
f0122797:	8a 00                	mov    (%eax),%al
f0122799:	0f b6 d8             	movzbl %al,%ebx
f012279c:	83 fb 25             	cmp    $0x25,%ebx
f012279f:	75 d6                	jne    f0122777 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f01227a1:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f01227a5:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f01227ac:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f01227b3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f01227ba:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f01227c1:	8b 45 10             	mov    0x10(%ebp),%eax
f01227c4:	8d 50 01             	lea    0x1(%eax),%edx
f01227c7:	89 55 10             	mov    %edx,0x10(%ebp)
f01227ca:	8a 00                	mov    (%eax),%al
f01227cc:	0f b6 d8             	movzbl %al,%ebx
f01227cf:	8d 43 dd             	lea    -0x23(%ebx),%eax
f01227d2:	83 f8 5b             	cmp    $0x5b,%eax
f01227d5:	0f 87 3d 03 00 00    	ja     f0122b18 <vprintfmt+0x3ab>
f01227db:	8b 04 85 d8 09 14 f0 	mov    -0xfebf628(,%eax,4),%eax
f01227e2:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f01227e4:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f01227e8:	eb d7                	jmp    f01227c1 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f01227ea:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f01227ee:	eb d1                	jmp    f01227c1 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f01227f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f01227f7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01227fa:	89 d0                	mov    %edx,%eax
f01227fc:	c1 e0 02             	shl    $0x2,%eax
f01227ff:	01 d0                	add    %edx,%eax
f0122801:	01 c0                	add    %eax,%eax
f0122803:	01 d8                	add    %ebx,%eax
f0122805:	83 e8 30             	sub    $0x30,%eax
f0122808:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f012280b:	8b 45 10             	mov    0x10(%ebp),%eax
f012280e:	8a 00                	mov    (%eax),%al
f0122810:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f0122813:	83 fb 2f             	cmp    $0x2f,%ebx
f0122816:	7e 3e                	jle    f0122856 <vprintfmt+0xe9>
f0122818:	83 fb 39             	cmp    $0x39,%ebx
f012281b:	7f 39                	jg     f0122856 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f012281d:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f0122820:	eb d5                	jmp    f01227f7 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f0122822:	8b 45 14             	mov    0x14(%ebp),%eax
f0122825:	83 c0 04             	add    $0x4,%eax
f0122828:	89 45 14             	mov    %eax,0x14(%ebp)
f012282b:	8b 45 14             	mov    0x14(%ebp),%eax
f012282e:	83 e8 04             	sub    $0x4,%eax
f0122831:	8b 00                	mov    (%eax),%eax
f0122833:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f0122836:	eb 1f                	jmp    f0122857 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f0122838:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012283c:	79 83                	jns    f01227c1 <vprintfmt+0x54>
				width = 0;
f012283e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f0122845:	e9 77 ff ff ff       	jmp    f01227c1 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f012284a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f0122851:	e9 6b ff ff ff       	jmp    f01227c1 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f0122856:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f0122857:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012285b:	0f 89 60 ff ff ff    	jns    f01227c1 <vprintfmt+0x54>
				width = precision, precision = -1;
f0122861:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122864:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0122867:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f012286e:	e9 4e ff ff ff       	jmp    f01227c1 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f0122873:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f0122876:	e9 46 ff ff ff       	jmp    f01227c1 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f012287b:	8b 45 14             	mov    0x14(%ebp),%eax
f012287e:	83 c0 04             	add    $0x4,%eax
f0122881:	89 45 14             	mov    %eax,0x14(%ebp)
f0122884:	8b 45 14             	mov    0x14(%ebp),%eax
f0122887:	83 e8 04             	sub    $0x4,%eax
f012288a:	8b 00                	mov    (%eax),%eax
f012288c:	83 ec 08             	sub    $0x8,%esp
f012288f:	ff 75 0c             	pushl  0xc(%ebp)
f0122892:	50                   	push   %eax
f0122893:	8b 45 08             	mov    0x8(%ebp),%eax
f0122896:	ff d0                	call   *%eax
f0122898:	83 c4 10             	add    $0x10,%esp
			break;
f012289b:	e9 9b 02 00 00       	jmp    f0122b3b <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f01228a0:	8b 45 14             	mov    0x14(%ebp),%eax
f01228a3:	83 c0 04             	add    $0x4,%eax
f01228a6:	89 45 14             	mov    %eax,0x14(%ebp)
f01228a9:	8b 45 14             	mov    0x14(%ebp),%eax
f01228ac:	83 e8 04             	sub    $0x4,%eax
f01228af:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f01228b1:	85 db                	test   %ebx,%ebx
f01228b3:	79 02                	jns    f01228b7 <vprintfmt+0x14a>
				err = -err;
f01228b5:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f01228b7:	83 fb 64             	cmp    $0x64,%ebx
f01228ba:	7f 0b                	jg     f01228c7 <vprintfmt+0x15a>
f01228bc:	8b 34 9d 20 08 14 f0 	mov    -0xfebf7e0(,%ebx,4),%esi
f01228c3:	85 f6                	test   %esi,%esi
f01228c5:	75 19                	jne    f01228e0 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f01228c7:	53                   	push   %ebx
f01228c8:	68 c5 09 14 f0       	push   $0xf01409c5
f01228cd:	ff 75 0c             	pushl  0xc(%ebp)
f01228d0:	ff 75 08             	pushl  0x8(%ebp)
f01228d3:	e8 70 02 00 00       	call   f0122b48 <printfmt>
f01228d8:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f01228db:	e9 5b 02 00 00       	jmp    f0122b3b <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f01228e0:	56                   	push   %esi
f01228e1:	68 ce 09 14 f0       	push   $0xf01409ce
f01228e6:	ff 75 0c             	pushl  0xc(%ebp)
f01228e9:	ff 75 08             	pushl  0x8(%ebp)
f01228ec:	e8 57 02 00 00       	call   f0122b48 <printfmt>
f01228f1:	83 c4 10             	add    $0x10,%esp
			break;
f01228f4:	e9 42 02 00 00       	jmp    f0122b3b <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f01228f9:	8b 45 14             	mov    0x14(%ebp),%eax
f01228fc:	83 c0 04             	add    $0x4,%eax
f01228ff:	89 45 14             	mov    %eax,0x14(%ebp)
f0122902:	8b 45 14             	mov    0x14(%ebp),%eax
f0122905:	83 e8 04             	sub    $0x4,%eax
f0122908:	8b 30                	mov    (%eax),%esi
f012290a:	85 f6                	test   %esi,%esi
f012290c:	75 05                	jne    f0122913 <vprintfmt+0x1a6>
				p = "(null)";
f012290e:	be d1 09 14 f0       	mov    $0xf01409d1,%esi
			if (width > 0 && padc != '-')
f0122913:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122917:	7e 6d                	jle    f0122986 <vprintfmt+0x219>
f0122919:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f012291d:	74 67                	je     f0122986 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f012291f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122922:	83 ec 08             	sub    $0x8,%esp
f0122925:	50                   	push   %eax
f0122926:	56                   	push   %esi
f0122927:	e8 26 05 00 00       	call   f0122e52 <strnlen>
f012292c:	83 c4 10             	add    $0x10,%esp
f012292f:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f0122932:	eb 16                	jmp    f012294a <vprintfmt+0x1dd>
					putch(padc, putdat);
f0122934:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f0122938:	83 ec 08             	sub    $0x8,%esp
f012293b:	ff 75 0c             	pushl  0xc(%ebp)
f012293e:	50                   	push   %eax
f012293f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122942:	ff d0                	call   *%eax
f0122944:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f0122947:	ff 4d e4             	decl   -0x1c(%ebp)
f012294a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012294e:	7f e4                	jg     f0122934 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0122950:	eb 34                	jmp    f0122986 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f0122952:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122956:	74 1c                	je     f0122974 <vprintfmt+0x207>
f0122958:	83 fb 1f             	cmp    $0x1f,%ebx
f012295b:	7e 05                	jle    f0122962 <vprintfmt+0x1f5>
f012295d:	83 fb 7e             	cmp    $0x7e,%ebx
f0122960:	7e 12                	jle    f0122974 <vprintfmt+0x207>
					putch('?', putdat);
f0122962:	83 ec 08             	sub    $0x8,%esp
f0122965:	ff 75 0c             	pushl  0xc(%ebp)
f0122968:	6a 3f                	push   $0x3f
f012296a:	8b 45 08             	mov    0x8(%ebp),%eax
f012296d:	ff d0                	call   *%eax
f012296f:	83 c4 10             	add    $0x10,%esp
f0122972:	eb 0f                	jmp    f0122983 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f0122974:	83 ec 08             	sub    $0x8,%esp
f0122977:	ff 75 0c             	pushl  0xc(%ebp)
f012297a:	53                   	push   %ebx
f012297b:	8b 45 08             	mov    0x8(%ebp),%eax
f012297e:	ff d0                	call   *%eax
f0122980:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0122983:	ff 4d e4             	decl   -0x1c(%ebp)
f0122986:	89 f0                	mov    %esi,%eax
f0122988:	8d 70 01             	lea    0x1(%eax),%esi
f012298b:	8a 00                	mov    (%eax),%al
f012298d:	0f be d8             	movsbl %al,%ebx
f0122990:	85 db                	test   %ebx,%ebx
f0122992:	74 24                	je     f01229b8 <vprintfmt+0x24b>
f0122994:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0122998:	78 b8                	js     f0122952 <vprintfmt+0x1e5>
f012299a:	ff 4d e0             	decl   -0x20(%ebp)
f012299d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01229a1:	79 af                	jns    f0122952 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f01229a3:	eb 13                	jmp    f01229b8 <vprintfmt+0x24b>
				putch(' ', putdat);
f01229a5:	83 ec 08             	sub    $0x8,%esp
f01229a8:	ff 75 0c             	pushl  0xc(%ebp)
f01229ab:	6a 20                	push   $0x20
f01229ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01229b0:	ff d0                	call   *%eax
f01229b2:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f01229b5:	ff 4d e4             	decl   -0x1c(%ebp)
f01229b8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01229bc:	7f e7                	jg     f01229a5 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f01229be:	e9 78 01 00 00       	jmp    f0122b3b <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f01229c3:	83 ec 08             	sub    $0x8,%esp
f01229c6:	ff 75 e8             	pushl  -0x18(%ebp)
f01229c9:	8d 45 14             	lea    0x14(%ebp),%eax
f01229cc:	50                   	push   %eax
f01229cd:	e8 3c fd ff ff       	call   f012270e <getint>
f01229d2:	83 c4 10             	add    $0x10,%esp
f01229d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01229d8:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f01229db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01229de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01229e1:	85 d2                	test   %edx,%edx
f01229e3:	79 23                	jns    f0122a08 <vprintfmt+0x29b>
				putch('-', putdat);
f01229e5:	83 ec 08             	sub    $0x8,%esp
f01229e8:	ff 75 0c             	pushl  0xc(%ebp)
f01229eb:	6a 2d                	push   $0x2d
f01229ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01229f0:	ff d0                	call   *%eax
f01229f2:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f01229f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01229f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01229fb:	f7 d8                	neg    %eax
f01229fd:	83 d2 00             	adc    $0x0,%edx
f0122a00:	f7 da                	neg    %edx
f0122a02:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122a05:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f0122a08:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0122a0f:	e9 bc 00 00 00       	jmp    f0122ad0 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f0122a14:	83 ec 08             	sub    $0x8,%esp
f0122a17:	ff 75 e8             	pushl  -0x18(%ebp)
f0122a1a:	8d 45 14             	lea    0x14(%ebp),%eax
f0122a1d:	50                   	push   %eax
f0122a1e:	e8 84 fc ff ff       	call   f01226a7 <getuint>
f0122a23:	83 c4 10             	add    $0x10,%esp
f0122a26:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122a29:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f0122a2c:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0122a33:	e9 98 00 00 00       	jmp    f0122ad0 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f0122a38:	83 ec 08             	sub    $0x8,%esp
f0122a3b:	ff 75 0c             	pushl  0xc(%ebp)
f0122a3e:	6a 58                	push   $0x58
f0122a40:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a43:	ff d0                	call   *%eax
f0122a45:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f0122a48:	83 ec 08             	sub    $0x8,%esp
f0122a4b:	ff 75 0c             	pushl  0xc(%ebp)
f0122a4e:	6a 58                	push   $0x58
f0122a50:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a53:	ff d0                	call   *%eax
f0122a55:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f0122a58:	83 ec 08             	sub    $0x8,%esp
f0122a5b:	ff 75 0c             	pushl  0xc(%ebp)
f0122a5e:	6a 58                	push   $0x58
f0122a60:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a63:	ff d0                	call   *%eax
f0122a65:	83 c4 10             	add    $0x10,%esp
			break;
f0122a68:	e9 ce 00 00 00       	jmp    f0122b3b <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f0122a6d:	83 ec 08             	sub    $0x8,%esp
f0122a70:	ff 75 0c             	pushl  0xc(%ebp)
f0122a73:	6a 30                	push   $0x30
f0122a75:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a78:	ff d0                	call   *%eax
f0122a7a:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f0122a7d:	83 ec 08             	sub    $0x8,%esp
f0122a80:	ff 75 0c             	pushl  0xc(%ebp)
f0122a83:	6a 78                	push   $0x78
f0122a85:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a88:	ff d0                	call   *%eax
f0122a8a:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f0122a8d:	8b 45 14             	mov    0x14(%ebp),%eax
f0122a90:	83 c0 04             	add    $0x4,%eax
f0122a93:	89 45 14             	mov    %eax,0x14(%ebp)
f0122a96:	8b 45 14             	mov    0x14(%ebp),%eax
f0122a99:	83 e8 04             	sub    $0x4,%eax
f0122a9c:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f0122a9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122aa1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f0122aa8:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f0122aaf:	eb 1f                	jmp    f0122ad0 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f0122ab1:	83 ec 08             	sub    $0x8,%esp
f0122ab4:	ff 75 e8             	pushl  -0x18(%ebp)
f0122ab7:	8d 45 14             	lea    0x14(%ebp),%eax
f0122aba:	50                   	push   %eax
f0122abb:	e8 e7 fb ff ff       	call   f01226a7 <getuint>
f0122ac0:	83 c4 10             	add    $0x10,%esp
f0122ac3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122ac6:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f0122ac9:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f0122ad0:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0122ad4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122ad7:	83 ec 04             	sub    $0x4,%esp
f0122ada:	52                   	push   %edx
f0122adb:	ff 75 e4             	pushl  -0x1c(%ebp)
f0122ade:	50                   	push   %eax
f0122adf:	ff 75 f4             	pushl  -0xc(%ebp)
f0122ae2:	ff 75 f0             	pushl  -0x10(%ebp)
f0122ae5:	ff 75 0c             	pushl  0xc(%ebp)
f0122ae8:	ff 75 08             	pushl  0x8(%ebp)
f0122aeb:	e8 00 fb ff ff       	call   f01225f0 <printnum>
f0122af0:	83 c4 20             	add    $0x20,%esp
			break;
f0122af3:	eb 46                	jmp    f0122b3b <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f0122af5:	83 ec 08             	sub    $0x8,%esp
f0122af8:	ff 75 0c             	pushl  0xc(%ebp)
f0122afb:	53                   	push   %ebx
f0122afc:	8b 45 08             	mov    0x8(%ebp),%eax
f0122aff:	ff d0                	call   *%eax
f0122b01:	83 c4 10             	add    $0x10,%esp
			break;
f0122b04:	eb 35                	jmp    f0122b3b <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f0122b06:	c6 05 a0 cd 94 f1 00 	movb   $0x0,0xf194cda0
			break;
f0122b0d:	eb 2c                	jmp    f0122b3b <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f0122b0f:	c6 05 a0 cd 94 f1 01 	movb   $0x1,0xf194cda0
			break;
f0122b16:	eb 23                	jmp    f0122b3b <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f0122b18:	83 ec 08             	sub    $0x8,%esp
f0122b1b:	ff 75 0c             	pushl  0xc(%ebp)
f0122b1e:	6a 25                	push   $0x25
f0122b20:	8b 45 08             	mov    0x8(%ebp),%eax
f0122b23:	ff d0                	call   *%eax
f0122b25:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f0122b28:	ff 4d 10             	decl   0x10(%ebp)
f0122b2b:	eb 03                	jmp    f0122b30 <vprintfmt+0x3c3>
f0122b2d:	ff 4d 10             	decl   0x10(%ebp)
f0122b30:	8b 45 10             	mov    0x10(%ebp),%eax
f0122b33:	48                   	dec    %eax
f0122b34:	8a 00                	mov    (%eax),%al
f0122b36:	3c 25                	cmp    $0x25,%al
f0122b38:	75 f3                	jne    f0122b2d <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f0122b3a:	90                   	nop
		}
	}
f0122b3b:	e9 35 fc ff ff       	jmp    f0122775 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f0122b40:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f0122b41:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0122b44:	5b                   	pop    %ebx
f0122b45:	5e                   	pop    %esi
f0122b46:	5d                   	pop    %ebp
f0122b47:	c3                   	ret    

f0122b48 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f0122b48:	55                   	push   %ebp
f0122b49:	89 e5                	mov    %esp,%ebp
f0122b4b:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f0122b4e:	8d 45 10             	lea    0x10(%ebp),%eax
f0122b51:	83 c0 04             	add    $0x4,%eax
f0122b54:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f0122b57:	8b 45 10             	mov    0x10(%ebp),%eax
f0122b5a:	ff 75 f4             	pushl  -0xc(%ebp)
f0122b5d:	50                   	push   %eax
f0122b5e:	ff 75 0c             	pushl  0xc(%ebp)
f0122b61:	ff 75 08             	pushl  0x8(%ebp)
f0122b64:	e8 04 fc ff ff       	call   f012276d <vprintfmt>
f0122b69:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f0122b6c:	90                   	nop
f0122b6d:	c9                   	leave  
f0122b6e:	c3                   	ret    

f0122b6f <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f0122b6f:	55                   	push   %ebp
f0122b70:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f0122b72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b75:	8b 40 08             	mov    0x8(%eax),%eax
f0122b78:	8d 50 01             	lea    0x1(%eax),%edx
f0122b7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b7e:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f0122b81:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b84:	8b 10                	mov    (%eax),%edx
f0122b86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b89:	8b 40 04             	mov    0x4(%eax),%eax
f0122b8c:	39 c2                	cmp    %eax,%edx
f0122b8e:	73 12                	jae    f0122ba2 <sprintputch+0x33>
		*b->buf++ = ch;
f0122b90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b93:	8b 00                	mov    (%eax),%eax
f0122b95:	8d 48 01             	lea    0x1(%eax),%ecx
f0122b98:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122b9b:	89 0a                	mov    %ecx,(%edx)
f0122b9d:	8b 55 08             	mov    0x8(%ebp),%edx
f0122ba0:	88 10                	mov    %dl,(%eax)
}
f0122ba2:	90                   	nop
f0122ba3:	5d                   	pop    %ebp
f0122ba4:	c3                   	ret    

f0122ba5 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f0122ba5:	55                   	push   %ebp
f0122ba6:	89 e5                	mov    %esp,%ebp
f0122ba8:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f0122bab:	8b 45 08             	mov    0x8(%ebp),%eax
f0122bae:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0122bb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122bb4:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122bb7:	8b 45 08             	mov    0x8(%ebp),%eax
f0122bba:	01 d0                	add    %edx,%eax
f0122bbc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122bbf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f0122bc6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122bca:	74 06                	je     f0122bd2 <vsnprintf+0x2d>
f0122bcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122bd0:	7f 07                	jg     f0122bd9 <vsnprintf+0x34>
		return -E_INVAL;
f0122bd2:	b8 03 00 00 00       	mov    $0x3,%eax
f0122bd7:	eb 20                	jmp    f0122bf9 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f0122bd9:	ff 75 14             	pushl  0x14(%ebp)
f0122bdc:	ff 75 10             	pushl  0x10(%ebp)
f0122bdf:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0122be2:	50                   	push   %eax
f0122be3:	68 6f 2b 12 f0       	push   $0xf0122b6f
f0122be8:	e8 80 fb ff ff       	call   f012276d <vprintfmt>
f0122bed:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f0122bf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122bf3:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f0122bf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0122bf9:	c9                   	leave  
f0122bfa:	c3                   	ret    

f0122bfb <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f0122bfb:	55                   	push   %ebp
f0122bfc:	89 e5                	mov    %esp,%ebp
f0122bfe:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f0122c01:	8d 45 10             	lea    0x10(%ebp),%eax
f0122c04:	83 c0 04             	add    $0x4,%eax
f0122c07:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f0122c0a:	8b 45 10             	mov    0x10(%ebp),%eax
f0122c0d:	ff 75 f4             	pushl  -0xc(%ebp)
f0122c10:	50                   	push   %eax
f0122c11:	ff 75 0c             	pushl  0xc(%ebp)
f0122c14:	ff 75 08             	pushl  0x8(%ebp)
f0122c17:	e8 89 ff ff ff       	call   f0122ba5 <vsnprintf>
f0122c1c:	83 c4 10             	add    $0x10,%esp
f0122c1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f0122c22:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0122c25:	c9                   	leave  
f0122c26:	c3                   	ret    

f0122c27 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f0122c27:	55                   	push   %ebp
f0122c28:	89 e5                	mov    %esp,%ebp
f0122c2a:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f0122c2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122c31:	74 13                	je     f0122c46 <readline+0x1f>
		cprintf("%s", prompt);
f0122c33:	83 ec 08             	sub    $0x8,%esp
f0122c36:	ff 75 08             	pushl  0x8(%ebp)
f0122c39:	68 48 0b 14 f0       	push   $0xf0140b48
f0122c3e:	e8 0a ef fd ff       	call   f0101b4d <cprintf>
f0122c43:	83 c4 10             	add    $0x10,%esp

	i = 0;
f0122c46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f0122c4d:	83 ec 0c             	sub    $0xc,%esp
f0122c50:	6a 00                	push   $0x0
f0122c52:	e8 fd ed fd ff       	call   f0101a54 <iscons>
f0122c57:	83 c4 10             	add    $0x10,%esp
f0122c5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f0122c5d:	e8 d9 ed fd ff       	call   f0101a3b <getchar>
f0122c62:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f0122c65:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0122c69:	79 22                	jns    f0122c8d <readline+0x66>
			if (c != -E_EOF)
f0122c6b:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0122c6f:	0f 84 ad 00 00 00    	je     f0122d22 <readline+0xfb>
				cprintf("read error: %e\n", c);
f0122c75:	83 ec 08             	sub    $0x8,%esp
f0122c78:	ff 75 ec             	pushl  -0x14(%ebp)
f0122c7b:	68 4b 0b 14 f0       	push   $0xf0140b4b
f0122c80:	e8 c8 ee fd ff       	call   f0101b4d <cprintf>
f0122c85:	83 c4 10             	add    $0x10,%esp
			break;
f0122c88:	e9 95 00 00 00       	jmp    f0122d22 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f0122c8d:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0122c91:	7e 34                	jle    f0122cc7 <readline+0xa0>
f0122c93:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0122c9a:	7f 2b                	jg     f0122cc7 <readline+0xa0>
			if (echoing)
f0122c9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122ca0:	74 0e                	je     f0122cb0 <readline+0x89>
				cputchar(c);
f0122ca2:	83 ec 0c             	sub    $0xc,%esp
f0122ca5:	ff 75 ec             	pushl  -0x14(%ebp)
f0122ca8:	e8 77 ed fd ff       	call   f0101a24 <cputchar>
f0122cad:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0122cb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122cb3:	8d 50 01             	lea    0x1(%eax),%edx
f0122cb6:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0122cb9:	89 c2                	mov    %eax,%edx
f0122cbb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122cbe:	01 d0                	add    %edx,%eax
f0122cc0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122cc3:	88 10                	mov    %dl,(%eax)
f0122cc5:	eb 56                	jmp    f0122d1d <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f0122cc7:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f0122ccb:	75 1f                	jne    f0122cec <readline+0xc5>
f0122ccd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122cd1:	7e 19                	jle    f0122cec <readline+0xc5>
			if (echoing)
f0122cd3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122cd7:	74 0e                	je     f0122ce7 <readline+0xc0>
				cputchar(c);
f0122cd9:	83 ec 0c             	sub    $0xc,%esp
f0122cdc:	ff 75 ec             	pushl  -0x14(%ebp)
f0122cdf:	e8 40 ed fd ff       	call   f0101a24 <cputchar>
f0122ce4:	83 c4 10             	add    $0x10,%esp

			i--;
f0122ce7:	ff 4d f4             	decl   -0xc(%ebp)
f0122cea:	eb 31                	jmp    f0122d1d <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f0122cec:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0122cf0:	74 0a                	je     f0122cfc <readline+0xd5>
f0122cf2:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f0122cf6:	0f 85 61 ff ff ff    	jne    f0122c5d <readline+0x36>
			if (echoing)
f0122cfc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122d00:	74 0e                	je     f0122d10 <readline+0xe9>
				cputchar(c);
f0122d02:	83 ec 0c             	sub    $0xc,%esp
f0122d05:	ff 75 ec             	pushl  -0x14(%ebp)
f0122d08:	e8 17 ed fd ff       	call   f0101a24 <cputchar>
f0122d0d:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f0122d10:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122d13:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122d16:	01 d0                	add    %edx,%eax
f0122d18:	c6 00 00             	movb   $0x0,(%eax)
			break;
f0122d1b:	eb 06                	jmp    f0122d23 <readline+0xfc>
		}
	}
f0122d1d:	e9 3b ff ff ff       	jmp    f0122c5d <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f0122d22:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f0122d23:	90                   	nop
f0122d24:	c9                   	leave  
f0122d25:	c3                   	ret    

f0122d26 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f0122d26:	55                   	push   %ebp
f0122d27:	89 e5                	mov    %esp,%ebp
f0122d29:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f0122d2c:	e8 08 d8 fe ff       	call   f0110539 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f0122d31:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122d35:	74 13                	je     f0122d4a <atomic_readline+0x24>
			cprintf("%s", prompt);
f0122d37:	83 ec 08             	sub    $0x8,%esp
f0122d3a:	ff 75 08             	pushl  0x8(%ebp)
f0122d3d:	68 48 0b 14 f0       	push   $0xf0140b48
f0122d42:	e8 06 ee fd ff       	call   f0101b4d <cprintf>
f0122d47:	83 c4 10             	add    $0x10,%esp

		i = 0;
f0122d4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f0122d51:	83 ec 0c             	sub    $0xc,%esp
f0122d54:	6a 00                	push   $0x0
f0122d56:	e8 f9 ec fd ff       	call   f0101a54 <iscons>
f0122d5b:	83 c4 10             	add    $0x10,%esp
f0122d5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f0122d61:	e8 d5 ec fd ff       	call   f0101a3b <getchar>
f0122d66:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f0122d69:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0122d6d:	79 22                	jns    f0122d91 <atomic_readline+0x6b>
				if (c != -E_EOF)
f0122d6f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0122d73:	0f 84 ad 00 00 00    	je     f0122e26 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f0122d79:	83 ec 08             	sub    $0x8,%esp
f0122d7c:	ff 75 ec             	pushl  -0x14(%ebp)
f0122d7f:	68 4b 0b 14 f0       	push   $0xf0140b4b
f0122d84:	e8 c4 ed fd ff       	call   f0101b4d <cprintf>
f0122d89:	83 c4 10             	add    $0x10,%esp
				break;
f0122d8c:	e9 95 00 00 00       	jmp    f0122e26 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f0122d91:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0122d95:	7e 34                	jle    f0122dcb <atomic_readline+0xa5>
f0122d97:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0122d9e:	7f 2b                	jg     f0122dcb <atomic_readline+0xa5>
				if (echoing)
f0122da0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122da4:	74 0e                	je     f0122db4 <atomic_readline+0x8e>
					cputchar(c);
f0122da6:	83 ec 0c             	sub    $0xc,%esp
f0122da9:	ff 75 ec             	pushl  -0x14(%ebp)
f0122dac:	e8 73 ec fd ff       	call   f0101a24 <cputchar>
f0122db1:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f0122db4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122db7:	8d 50 01             	lea    0x1(%eax),%edx
f0122dba:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0122dbd:	89 c2                	mov    %eax,%edx
f0122dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122dc2:	01 d0                	add    %edx,%eax
f0122dc4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122dc7:	88 10                	mov    %dl,(%eax)
f0122dc9:	eb 56                	jmp    f0122e21 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f0122dcb:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f0122dcf:	75 1f                	jne    f0122df0 <atomic_readline+0xca>
f0122dd1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122dd5:	7e 19                	jle    f0122df0 <atomic_readline+0xca>
				if (echoing)
f0122dd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122ddb:	74 0e                	je     f0122deb <atomic_readline+0xc5>
					cputchar(c);
f0122ddd:	83 ec 0c             	sub    $0xc,%esp
f0122de0:	ff 75 ec             	pushl  -0x14(%ebp)
f0122de3:	e8 3c ec fd ff       	call   f0101a24 <cputchar>
f0122de8:	83 c4 10             	add    $0x10,%esp
				i--;
f0122deb:	ff 4d f4             	decl   -0xc(%ebp)
f0122dee:	eb 31                	jmp    f0122e21 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f0122df0:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0122df4:	74 0a                	je     f0122e00 <atomic_readline+0xda>
f0122df6:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f0122dfa:	0f 85 61 ff ff ff    	jne    f0122d61 <atomic_readline+0x3b>
				if (echoing)
f0122e00:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122e04:	74 0e                	je     f0122e14 <atomic_readline+0xee>
					cputchar(c);
f0122e06:	83 ec 0c             	sub    $0xc,%esp
f0122e09:	ff 75 ec             	pushl  -0x14(%ebp)
f0122e0c:	e8 13 ec fd ff       	call   f0101a24 <cputchar>
f0122e11:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f0122e14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122e17:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122e1a:	01 d0                	add    %edx,%eax
f0122e1c:	c6 00 00             	movb   $0x0,(%eax)
				break;
f0122e1f:	eb 06                	jmp    f0122e27 <atomic_readline+0x101>
			}
		}
f0122e21:	e9 3b ff ff ff       	jmp    f0122d61 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f0122e26:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f0122e27:	e8 1b d7 fe ff       	call   f0110547 <sys_unlock_cons>
}
f0122e2c:	90                   	nop
f0122e2d:	c9                   	leave  
f0122e2e:	c3                   	ret    

f0122e2f <strlen>:

#include <inc/string.h>

int
strlen(const char *s)
{
f0122e2f:	55                   	push   %ebp
f0122e30:	89 e5                	mov    %esp,%ebp
f0122e32:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f0122e35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122e3c:	eb 06                	jmp    f0122e44 <strlen+0x15>
		n++;
f0122e3e:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f0122e41:	ff 45 08             	incl   0x8(%ebp)
f0122e44:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e47:	8a 00                	mov    (%eax),%al
f0122e49:	84 c0                	test   %al,%al
f0122e4b:	75 f1                	jne    f0122e3e <strlen+0xf>
		n++;
	return n;
f0122e4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122e50:	c9                   	leave  
f0122e51:	c3                   	ret    

f0122e52 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f0122e52:	55                   	push   %ebp
f0122e53:	89 e5                	mov    %esp,%ebp
f0122e55:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0122e58:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122e5f:	eb 09                	jmp    f0122e6a <strnlen+0x18>
		n++;
f0122e61:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0122e64:	ff 45 08             	incl   0x8(%ebp)
f0122e67:	ff 4d 0c             	decl   0xc(%ebp)
f0122e6a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122e6e:	74 09                	je     f0122e79 <strnlen+0x27>
f0122e70:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e73:	8a 00                	mov    (%eax),%al
f0122e75:	84 c0                	test   %al,%al
f0122e77:	75 e8                	jne    f0122e61 <strnlen+0xf>
		n++;
	return n;
f0122e79:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122e7c:	c9                   	leave  
f0122e7d:	c3                   	ret    

f0122e7e <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f0122e7e:	55                   	push   %ebp
f0122e7f:	89 e5                	mov    %esp,%ebp
f0122e81:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f0122e84:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e87:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f0122e8a:	90                   	nop
f0122e8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e8e:	8d 50 01             	lea    0x1(%eax),%edx
f0122e91:	89 55 08             	mov    %edx,0x8(%ebp)
f0122e94:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122e97:	8d 4a 01             	lea    0x1(%edx),%ecx
f0122e9a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0122e9d:	8a 12                	mov    (%edx),%dl
f0122e9f:	88 10                	mov    %dl,(%eax)
f0122ea1:	8a 00                	mov    (%eax),%al
f0122ea3:	84 c0                	test   %al,%al
f0122ea5:	75 e4                	jne    f0122e8b <strcpy+0xd>
		/* do nothing */;
	return ret;
f0122ea7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122eaa:	c9                   	leave  
f0122eab:	c3                   	ret    

f0122eac <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f0122eac:	55                   	push   %ebp
f0122ead:	89 e5                	mov    %esp,%ebp
f0122eaf:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f0122eb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0122eb5:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f0122eb8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122ebf:	eb 1f                	jmp    f0122ee0 <strncpy+0x34>
		*dst++ = *src;
f0122ec1:	8b 45 08             	mov    0x8(%ebp),%eax
f0122ec4:	8d 50 01             	lea    0x1(%eax),%edx
f0122ec7:	89 55 08             	mov    %edx,0x8(%ebp)
f0122eca:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122ecd:	8a 12                	mov    (%edx),%dl
f0122ecf:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f0122ed1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122ed4:	8a 00                	mov    (%eax),%al
f0122ed6:	84 c0                	test   %al,%al
f0122ed8:	74 03                	je     f0122edd <strncpy+0x31>
			src++;
f0122eda:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f0122edd:	ff 45 fc             	incl   -0x4(%ebp)
f0122ee0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122ee3:	3b 45 10             	cmp    0x10(%ebp),%eax
f0122ee6:	72 d9                	jb     f0122ec1 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f0122ee8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0122eeb:	c9                   	leave  
f0122eec:	c3                   	ret    

f0122eed <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f0122eed:	55                   	push   %ebp
f0122eee:	89 e5                	mov    %esp,%ebp
f0122ef0:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f0122ef3:	8b 45 08             	mov    0x8(%ebp),%eax
f0122ef6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f0122ef9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122efd:	74 30                	je     f0122f2f <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f0122eff:	eb 16                	jmp    f0122f17 <strlcpy+0x2a>
			*dst++ = *src++;
f0122f01:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f04:	8d 50 01             	lea    0x1(%eax),%edx
f0122f07:	89 55 08             	mov    %edx,0x8(%ebp)
f0122f0a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122f0d:	8d 4a 01             	lea    0x1(%edx),%ecx
f0122f10:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0122f13:	8a 12                	mov    (%edx),%dl
f0122f15:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f0122f17:	ff 4d 10             	decl   0x10(%ebp)
f0122f1a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122f1e:	74 09                	je     f0122f29 <strlcpy+0x3c>
f0122f20:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122f23:	8a 00                	mov    (%eax),%al
f0122f25:	84 c0                	test   %al,%al
f0122f27:	75 d8                	jne    f0122f01 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f0122f29:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f2c:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f0122f2f:	8b 55 08             	mov    0x8(%ebp),%edx
f0122f32:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122f35:	29 c2                	sub    %eax,%edx
f0122f37:	89 d0                	mov    %edx,%eax
}
f0122f39:	c9                   	leave  
f0122f3a:	c3                   	ret    

f0122f3b <strcmp>:

int
strcmp(const char *p, const char *q)
{
f0122f3b:	55                   	push   %ebp
f0122f3c:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f0122f3e:	eb 06                	jmp    f0122f46 <strcmp+0xb>
		p++, q++;
f0122f40:	ff 45 08             	incl   0x8(%ebp)
f0122f43:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f0122f46:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f49:	8a 00                	mov    (%eax),%al
f0122f4b:	84 c0                	test   %al,%al
f0122f4d:	74 0e                	je     f0122f5d <strcmp+0x22>
f0122f4f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f52:	8a 10                	mov    (%eax),%dl
f0122f54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122f57:	8a 00                	mov    (%eax),%al
f0122f59:	38 c2                	cmp    %al,%dl
f0122f5b:	74 e3                	je     f0122f40 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f0122f5d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f60:	8a 00                	mov    (%eax),%al
f0122f62:	0f b6 d0             	movzbl %al,%edx
f0122f65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122f68:	8a 00                	mov    (%eax),%al
f0122f6a:	0f b6 c0             	movzbl %al,%eax
f0122f6d:	29 c2                	sub    %eax,%edx
f0122f6f:	89 d0                	mov    %edx,%eax
}
f0122f71:	5d                   	pop    %ebp
f0122f72:	c3                   	ret    

f0122f73 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f0122f73:	55                   	push   %ebp
f0122f74:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f0122f76:	eb 09                	jmp    f0122f81 <strncmp+0xe>
		n--, p++, q++;
f0122f78:	ff 4d 10             	decl   0x10(%ebp)
f0122f7b:	ff 45 08             	incl   0x8(%ebp)
f0122f7e:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f0122f81:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122f85:	74 17                	je     f0122f9e <strncmp+0x2b>
f0122f87:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f8a:	8a 00                	mov    (%eax),%al
f0122f8c:	84 c0                	test   %al,%al
f0122f8e:	74 0e                	je     f0122f9e <strncmp+0x2b>
f0122f90:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f93:	8a 10                	mov    (%eax),%dl
f0122f95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122f98:	8a 00                	mov    (%eax),%al
f0122f9a:	38 c2                	cmp    %al,%dl
f0122f9c:	74 da                	je     f0122f78 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f0122f9e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122fa2:	75 07                	jne    f0122fab <strncmp+0x38>
		return 0;
f0122fa4:	b8 00 00 00 00       	mov    $0x0,%eax
f0122fa9:	eb 14                	jmp    f0122fbf <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f0122fab:	8b 45 08             	mov    0x8(%ebp),%eax
f0122fae:	8a 00                	mov    (%eax),%al
f0122fb0:	0f b6 d0             	movzbl %al,%edx
f0122fb3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122fb6:	8a 00                	mov    (%eax),%al
f0122fb8:	0f b6 c0             	movzbl %al,%eax
f0122fbb:	29 c2                	sub    %eax,%edx
f0122fbd:	89 d0                	mov    %edx,%eax
}
f0122fbf:	5d                   	pop    %ebp
f0122fc0:	c3                   	ret    

f0122fc1 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f0122fc1:	55                   	push   %ebp
f0122fc2:	89 e5                	mov    %esp,%ebp
f0122fc4:	83 ec 04             	sub    $0x4,%esp
f0122fc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122fca:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0122fcd:	eb 12                	jmp    f0122fe1 <strchr+0x20>
		if (*s == c)
f0122fcf:	8b 45 08             	mov    0x8(%ebp),%eax
f0122fd2:	8a 00                	mov    (%eax),%al
f0122fd4:	3a 45 fc             	cmp    -0x4(%ebp),%al
f0122fd7:	75 05                	jne    f0122fde <strchr+0x1d>
			return (char *) s;
f0122fd9:	8b 45 08             	mov    0x8(%ebp),%eax
f0122fdc:	eb 11                	jmp    f0122fef <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f0122fde:	ff 45 08             	incl   0x8(%ebp)
f0122fe1:	8b 45 08             	mov    0x8(%ebp),%eax
f0122fe4:	8a 00                	mov    (%eax),%al
f0122fe6:	84 c0                	test   %al,%al
f0122fe8:	75 e5                	jne    f0122fcf <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f0122fea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122fef:	c9                   	leave  
f0122ff0:	c3                   	ret    

f0122ff1 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f0122ff1:	55                   	push   %ebp
f0122ff2:	89 e5                	mov    %esp,%ebp
f0122ff4:	83 ec 04             	sub    $0x4,%esp
f0122ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122ffa:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0122ffd:	eb 0d                	jmp    f012300c <strfind+0x1b>
		if (*s == c)
f0122fff:	8b 45 08             	mov    0x8(%ebp),%eax
f0123002:	8a 00                	mov    (%eax),%al
f0123004:	3a 45 fc             	cmp    -0x4(%ebp),%al
f0123007:	74 0e                	je     f0123017 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f0123009:	ff 45 08             	incl   0x8(%ebp)
f012300c:	8b 45 08             	mov    0x8(%ebp),%eax
f012300f:	8a 00                	mov    (%eax),%al
f0123011:	84 c0                	test   %al,%al
f0123013:	75 ea                	jne    f0122fff <strfind+0xe>
f0123015:	eb 01                	jmp    f0123018 <strfind+0x27>
		if (*s == c)
			break;
f0123017:	90                   	nop
	return (char *) s;
f0123018:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012301b:	c9                   	leave  
f012301c:	c3                   	ret    

f012301d <memset>:

// *************** The faster implementation of memset & memcpy is implemented by *************
// ****************** Team80 (Yahia Khaled, Malek Ahmed et al) - FCIS'24-25 *******************
void *
memset(void *v, int c, uint32 n)
{
f012301d:	55                   	push   %ebp
f012301e:	89 e5                	mov    %esp,%ebp
f0123020:	83 ec 10             	sub    $0x10,%esp
//	m = n;
//	while (--m >= 0)
//		*p++ = c;

	/*Faster Implementation*/
	uint64* p64 = (uint64*)v;
f0123023:	8b 45 08             	mov    0x8(%ebp),%eax
f0123026:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(n >= 8){
f0123029:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f012302d:	76 63                	jbe    f0123092 <memset+0x75>
		uint64 data_block = c;
f012302f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123032:	99                   	cltd   
f0123033:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0123036:	89 55 f4             	mov    %edx,-0xc(%ebp)
		data_block |= data_block << 8;
f0123039:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012303c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012303f:	0f a4 c2 08          	shld   $0x8,%eax,%edx
f0123043:	c1 e0 08             	shl    $0x8,%eax
f0123046:	09 45 f0             	or     %eax,-0x10(%ebp)
f0123049:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 16;
f012304c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012304f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123052:	0f a4 c2 10          	shld   $0x10,%eax,%edx
f0123056:	c1 e0 10             	shl    $0x10,%eax
f0123059:	09 45 f0             	or     %eax,-0x10(%ebp)
f012305c:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 32;
f012305f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123062:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123065:	89 c2                	mov    %eax,%edx
f0123067:	b8 00 00 00 00       	mov    $0x0,%eax
f012306c:	09 45 f0             	or     %eax,-0x10(%ebp)
f012306f:	09 55 f4             	or     %edx,-0xc(%ebp)

		while(n >= 8)
f0123072:	eb 18                	jmp    f012308c <memset+0x6f>
			*p64++ = data_block, n -= 8;
f0123074:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0123077:	8d 41 08             	lea    0x8(%ecx),%eax
f012307a:	89 45 fc             	mov    %eax,-0x4(%ebp)
f012307d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123080:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123083:	89 01                	mov    %eax,(%ecx)
f0123085:	89 51 04             	mov    %edx,0x4(%ecx)
f0123088:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
		uint64 data_block = c;
		data_block |= data_block << 8;
		data_block |= data_block << 16;
		data_block |= data_block << 32;

		while(n >= 8)
f012308c:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f0123090:	77 e2                	ja     f0123074 <memset+0x57>
			*p64++ = data_block, n -= 8;
	}

	if(n){
f0123092:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0123096:	74 23                	je     f01230bb <memset+0x9e>
		uint8* p8 = (uint8*)p64;
f0123098:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012309b:	89 45 f8             	mov    %eax,-0x8(%ebp)
		while (n-- > 0)
f012309e:	eb 0e                	jmp    f01230ae <memset+0x91>
			*p8++ = (uint8)c;
f01230a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01230a3:	8d 50 01             	lea    0x1(%eax),%edx
f01230a6:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01230a9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01230ac:	88 10                	mov    %dl,(%eax)
			*p64++ = data_block, n -= 8;
	}

	if(n){
		uint8* p8 = (uint8*)p64;
		while (n-- > 0)
f01230ae:	8b 45 10             	mov    0x10(%ebp),%eax
f01230b1:	8d 50 ff             	lea    -0x1(%eax),%edx
f01230b4:	89 55 10             	mov    %edx,0x10(%ebp)
f01230b7:	85 c0                	test   %eax,%eax
f01230b9:	75 e5                	jne    f01230a0 <memset+0x83>
			*p8++ = (uint8)c;
	}

	return v;
f01230bb:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01230be:	c9                   	leave  
f01230bf:	c3                   	ret    

f01230c0 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f01230c0:	55                   	push   %ebp
f01230c1:	89 e5                	mov    %esp,%ebp
f01230c3:	83 ec 10             	sub    $0x10,%esp
	//	s = src;
	//	d = dst;
	//	while (n-- > 0)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
f01230c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01230c9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint64* d64 = (uint64*)dst;
f01230cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01230cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if(n >= 8){
f01230d2:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f01230d6:	76 24                	jbe    f01230fc <memcpy+0x3c>
		while(n >= 8){
f01230d8:	eb 1c                	jmp    f01230f6 <memcpy+0x36>
			*d64 = *s64;
f01230da:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01230dd:	8b 50 04             	mov    0x4(%eax),%edx
f01230e0:	8b 00                	mov    (%eax),%eax
f01230e2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f01230e5:	89 01                	mov    %eax,(%ecx)
f01230e7:	89 51 04             	mov    %edx,0x4(%ecx)
			n -= 8;
f01230ea:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
			++s64;
f01230ee:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
			++d64;
f01230f2:	83 45 f8 08          	addl   $0x8,-0x8(%ebp)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
	uint64* d64 = (uint64*)dst;
	if(n >= 8){
		while(n >= 8){
f01230f6:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f01230fa:	77 de                	ja     f01230da <memcpy+0x1a>
			++s64;
			++d64;
		}
	}

	if(n){
f01230fc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0123100:	74 31                	je     f0123133 <memcpy+0x73>
		uint8* s8 = (uint8*)s64;
f0123102:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0123105:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint8* d8 = (uint8*)d64;
f0123108:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012310b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (n-- > 0)
f012310e:	eb 16                	jmp    f0123126 <memcpy+0x66>
			*d8++ = *s8++;
f0123110:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123113:	8d 50 01             	lea    0x1(%eax),%edx
f0123116:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0123119:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012311c:	8d 4a 01             	lea    0x1(%edx),%ecx
f012311f:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0123122:	8a 12                	mov    (%edx),%dl
f0123124:	88 10                	mov    %dl,(%eax)
	}

	if(n){
		uint8* s8 = (uint8*)s64;
		uint8* d8 = (uint8*)d64;
		while (n-- > 0)
f0123126:	8b 45 10             	mov    0x10(%ebp),%eax
f0123129:	8d 50 ff             	lea    -0x1(%eax),%edx
f012312c:	89 55 10             	mov    %edx,0x10(%ebp)
f012312f:	85 c0                	test   %eax,%eax
f0123131:	75 dd                	jne    f0123110 <memcpy+0x50>
			*d8++ = *s8++;
	}
	return dst;
f0123133:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0123136:	c9                   	leave  
f0123137:	c3                   	ret    

f0123138 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f0123138:	55                   	push   %ebp
f0123139:	89 e5                	mov    %esp,%ebp
f012313b:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f012313e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123141:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0123144:	8b 45 08             	mov    0x8(%ebp),%eax
f0123147:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f012314a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012314d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0123150:	73 50                	jae    f01231a2 <memmove+0x6a>
f0123152:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0123155:	8b 45 10             	mov    0x10(%ebp),%eax
f0123158:	01 d0                	add    %edx,%eax
f012315a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012315d:	76 43                	jbe    f01231a2 <memmove+0x6a>
		s += n;
f012315f:	8b 45 10             	mov    0x10(%ebp),%eax
f0123162:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f0123165:	8b 45 10             	mov    0x10(%ebp),%eax
f0123168:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f012316b:	eb 10                	jmp    f012317d <memmove+0x45>
			*--d = *--s;
f012316d:	ff 4d f8             	decl   -0x8(%ebp)
f0123170:	ff 4d fc             	decl   -0x4(%ebp)
f0123173:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0123176:	8a 10                	mov    (%eax),%dl
f0123178:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012317b:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f012317d:	8b 45 10             	mov    0x10(%ebp),%eax
f0123180:	8d 50 ff             	lea    -0x1(%eax),%edx
f0123183:	89 55 10             	mov    %edx,0x10(%ebp)
f0123186:	85 c0                	test   %eax,%eax
f0123188:	75 e3                	jne    f012316d <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f012318a:	eb 23                	jmp    f01231af <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f012318c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012318f:	8d 50 01             	lea    0x1(%eax),%edx
f0123192:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0123195:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0123198:	8d 4a 01             	lea    0x1(%edx),%ecx
f012319b:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f012319e:	8a 12                	mov    (%edx),%dl
f01231a0:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f01231a2:	8b 45 10             	mov    0x10(%ebp),%eax
f01231a5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01231a8:	89 55 10             	mov    %edx,0x10(%ebp)
f01231ab:	85 c0                	test   %eax,%eax
f01231ad:	75 dd                	jne    f012318c <memmove+0x54>
			*d++ = *s++;

	return dst;
f01231af:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01231b2:	c9                   	leave  
f01231b3:	c3                   	ret    

f01231b4 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f01231b4:	55                   	push   %ebp
f01231b5:	89 e5                	mov    %esp,%ebp
f01231b7:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f01231ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01231bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f01231c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01231c3:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f01231c6:	eb 2a                	jmp    f01231f2 <memcmp+0x3e>
		if (*s1 != *s2)
f01231c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01231cb:	8a 10                	mov    (%eax),%dl
f01231cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01231d0:	8a 00                	mov    (%eax),%al
f01231d2:	38 c2                	cmp    %al,%dl
f01231d4:	74 16                	je     f01231ec <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f01231d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01231d9:	8a 00                	mov    (%eax),%al
f01231db:	0f b6 d0             	movzbl %al,%edx
f01231de:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01231e1:	8a 00                	mov    (%eax),%al
f01231e3:	0f b6 c0             	movzbl %al,%eax
f01231e6:	29 c2                	sub    %eax,%edx
f01231e8:	89 d0                	mov    %edx,%eax
f01231ea:	eb 18                	jmp    f0123204 <memcmp+0x50>
		s1++, s2++;
f01231ec:	ff 45 fc             	incl   -0x4(%ebp)
f01231ef:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f01231f2:	8b 45 10             	mov    0x10(%ebp),%eax
f01231f5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01231f8:	89 55 10             	mov    %edx,0x10(%ebp)
f01231fb:	85 c0                	test   %eax,%eax
f01231fd:	75 c9                	jne    f01231c8 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f01231ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0123204:	c9                   	leave  
f0123205:	c3                   	ret    

f0123206 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f0123206:	55                   	push   %ebp
f0123207:	89 e5                	mov    %esp,%ebp
f0123209:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f012320c:	8b 55 08             	mov    0x8(%ebp),%edx
f012320f:	8b 45 10             	mov    0x10(%ebp),%eax
f0123212:	01 d0                	add    %edx,%eax
f0123214:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f0123217:	eb 15                	jmp    f012322e <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f0123219:	8b 45 08             	mov    0x8(%ebp),%eax
f012321c:	8a 00                	mov    (%eax),%al
f012321e:	0f b6 d0             	movzbl %al,%edx
f0123221:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123224:	0f b6 c0             	movzbl %al,%eax
f0123227:	39 c2                	cmp    %eax,%edx
f0123229:	74 0d                	je     f0123238 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f012322b:	ff 45 08             	incl   0x8(%ebp)
f012322e:	8b 45 08             	mov    0x8(%ebp),%eax
f0123231:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0123234:	72 e3                	jb     f0123219 <memfind+0x13>
f0123236:	eb 01                	jmp    f0123239 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f0123238:	90                   	nop
	return (void *) s;
f0123239:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012323c:	c9                   	leave  
f012323d:	c3                   	ret    

f012323e <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f012323e:	55                   	push   %ebp
f012323f:	89 e5                	mov    %esp,%ebp
f0123241:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f0123244:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f012324b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0123252:	eb 03                	jmp    f0123257 <strtol+0x19>
		s++;
f0123254:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0123257:	8b 45 08             	mov    0x8(%ebp),%eax
f012325a:	8a 00                	mov    (%eax),%al
f012325c:	3c 20                	cmp    $0x20,%al
f012325e:	74 f4                	je     f0123254 <strtol+0x16>
f0123260:	8b 45 08             	mov    0x8(%ebp),%eax
f0123263:	8a 00                	mov    (%eax),%al
f0123265:	3c 09                	cmp    $0x9,%al
f0123267:	74 eb                	je     f0123254 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f0123269:	8b 45 08             	mov    0x8(%ebp),%eax
f012326c:	8a 00                	mov    (%eax),%al
f012326e:	3c 2b                	cmp    $0x2b,%al
f0123270:	75 05                	jne    f0123277 <strtol+0x39>
		s++;
f0123272:	ff 45 08             	incl   0x8(%ebp)
f0123275:	eb 13                	jmp    f012328a <strtol+0x4c>
	else if (*s == '-')
f0123277:	8b 45 08             	mov    0x8(%ebp),%eax
f012327a:	8a 00                	mov    (%eax),%al
f012327c:	3c 2d                	cmp    $0x2d,%al
f012327e:	75 0a                	jne    f012328a <strtol+0x4c>
		s++, neg = 1;
f0123280:	ff 45 08             	incl   0x8(%ebp)
f0123283:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f012328a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012328e:	74 06                	je     f0123296 <strtol+0x58>
f0123290:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f0123294:	75 20                	jne    f01232b6 <strtol+0x78>
f0123296:	8b 45 08             	mov    0x8(%ebp),%eax
f0123299:	8a 00                	mov    (%eax),%al
f012329b:	3c 30                	cmp    $0x30,%al
f012329d:	75 17                	jne    f01232b6 <strtol+0x78>
f012329f:	8b 45 08             	mov    0x8(%ebp),%eax
f01232a2:	40                   	inc    %eax
f01232a3:	8a 00                	mov    (%eax),%al
f01232a5:	3c 78                	cmp    $0x78,%al
f01232a7:	75 0d                	jne    f01232b6 <strtol+0x78>
		s += 2, base = 16;
f01232a9:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f01232ad:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f01232b4:	eb 28                	jmp    f01232de <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f01232b6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01232ba:	75 15                	jne    f01232d1 <strtol+0x93>
f01232bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01232bf:	8a 00                	mov    (%eax),%al
f01232c1:	3c 30                	cmp    $0x30,%al
f01232c3:	75 0c                	jne    f01232d1 <strtol+0x93>
		s++, base = 8;
f01232c5:	ff 45 08             	incl   0x8(%ebp)
f01232c8:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f01232cf:	eb 0d                	jmp    f01232de <strtol+0xa0>
	else if (base == 0)
f01232d1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01232d5:	75 07                	jne    f01232de <strtol+0xa0>
		base = 10;
f01232d7:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f01232de:	8b 45 08             	mov    0x8(%ebp),%eax
f01232e1:	8a 00                	mov    (%eax),%al
f01232e3:	3c 2f                	cmp    $0x2f,%al
f01232e5:	7e 19                	jle    f0123300 <strtol+0xc2>
f01232e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01232ea:	8a 00                	mov    (%eax),%al
f01232ec:	3c 39                	cmp    $0x39,%al
f01232ee:	7f 10                	jg     f0123300 <strtol+0xc2>
			dig = *s - '0';
f01232f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01232f3:	8a 00                	mov    (%eax),%al
f01232f5:	0f be c0             	movsbl %al,%eax
f01232f8:	83 e8 30             	sub    $0x30,%eax
f01232fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01232fe:	eb 42                	jmp    f0123342 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f0123300:	8b 45 08             	mov    0x8(%ebp),%eax
f0123303:	8a 00                	mov    (%eax),%al
f0123305:	3c 60                	cmp    $0x60,%al
f0123307:	7e 19                	jle    f0123322 <strtol+0xe4>
f0123309:	8b 45 08             	mov    0x8(%ebp),%eax
f012330c:	8a 00                	mov    (%eax),%al
f012330e:	3c 7a                	cmp    $0x7a,%al
f0123310:	7f 10                	jg     f0123322 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0123312:	8b 45 08             	mov    0x8(%ebp),%eax
f0123315:	8a 00                	mov    (%eax),%al
f0123317:	0f be c0             	movsbl %al,%eax
f012331a:	83 e8 57             	sub    $0x57,%eax
f012331d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0123320:	eb 20                	jmp    f0123342 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0123322:	8b 45 08             	mov    0x8(%ebp),%eax
f0123325:	8a 00                	mov    (%eax),%al
f0123327:	3c 40                	cmp    $0x40,%al
f0123329:	7e 39                	jle    f0123364 <strtol+0x126>
f012332b:	8b 45 08             	mov    0x8(%ebp),%eax
f012332e:	8a 00                	mov    (%eax),%al
f0123330:	3c 5a                	cmp    $0x5a,%al
f0123332:	7f 30                	jg     f0123364 <strtol+0x126>
			dig = *s - 'A' + 10;
f0123334:	8b 45 08             	mov    0x8(%ebp),%eax
f0123337:	8a 00                	mov    (%eax),%al
f0123339:	0f be c0             	movsbl %al,%eax
f012333c:	83 e8 37             	sub    $0x37,%eax
f012333f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0123342:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123345:	3b 45 10             	cmp    0x10(%ebp),%eax
f0123348:	7d 19                	jge    f0123363 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f012334a:	ff 45 08             	incl   0x8(%ebp)
f012334d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0123350:	0f af 45 10          	imul   0x10(%ebp),%eax
f0123354:	89 c2                	mov    %eax,%edx
f0123356:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123359:	01 d0                	add    %edx,%eax
f012335b:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f012335e:	e9 7b ff ff ff       	jmp    f01232de <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f0123363:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f0123364:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123368:	74 08                	je     f0123372 <strtol+0x134>
		*endptr = (char *) s;
f012336a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012336d:	8b 55 08             	mov    0x8(%ebp),%edx
f0123370:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f0123372:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0123376:	74 07                	je     f012337f <strtol+0x141>
f0123378:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012337b:	f7 d8                	neg    %eax
f012337d:	eb 03                	jmp    f0123382 <strtol+0x144>
f012337f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0123382:	c9                   	leave  
f0123383:	c3                   	ret    

f0123384 <ltostr>:

void
ltostr(long value, char *str)
{
f0123384:	55                   	push   %ebp
f0123385:	89 e5                	mov    %esp,%ebp
f0123387:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f012338a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f0123391:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f0123398:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012339c:	79 13                	jns    f01233b1 <ltostr+0x2d>
	{
		neg = 1;
f012339e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f01233a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01233a8:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f01233ab:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f01233ae:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f01233b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01233b4:	b9 0a 00 00 00       	mov    $0xa,%ecx
f01233b9:	99                   	cltd   
f01233ba:	f7 f9                	idiv   %ecx
f01233bc:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f01233bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01233c2:	8d 50 01             	lea    0x1(%eax),%edx
f01233c5:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01233c8:	89 c2                	mov    %eax,%edx
f01233ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01233cd:	01 d0                	add    %edx,%eax
f01233cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01233d2:	83 c2 30             	add    $0x30,%edx
f01233d5:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f01233d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01233da:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01233df:	f7 e9                	imul   %ecx
f01233e1:	c1 fa 02             	sar    $0x2,%edx
f01233e4:	89 c8                	mov    %ecx,%eax
f01233e6:	c1 f8 1f             	sar    $0x1f,%eax
f01233e9:	29 c2                	sub    %eax,%edx
f01233eb:	89 d0                	mov    %edx,%eax
f01233ed:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f01233f0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01233f4:	75 bb                	jne    f01233b1 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f01233f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f01233fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0123400:	48                   	dec    %eax
f0123401:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0123404:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0123408:	74 3d                	je     f0123447 <ltostr+0xc3>
		start = 1 ;
f012340a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f0123411:	eb 34                	jmp    f0123447 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0123413:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123416:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123419:	01 d0                	add    %edx,%eax
f012341b:	8a 00                	mov    (%eax),%al
f012341d:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f0123420:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123423:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123426:	01 c2                	add    %eax,%edx
f0123428:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f012342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012342e:	01 c8                	add    %ecx,%eax
f0123430:	8a 00                	mov    (%eax),%al
f0123432:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0123434:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123437:	8b 45 0c             	mov    0xc(%ebp),%eax
f012343a:	01 c2                	add    %eax,%edx
f012343c:	8a 45 eb             	mov    -0x15(%ebp),%al
f012343f:	88 02                	mov    %al,(%edx)
		start++ ;
f0123441:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0123444:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0123447:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012344a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f012344d:	7c c4                	jl     f0123413 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f012344f:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0123452:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123455:	01 d0                	add    %edx,%eax
f0123457:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f012345a:	90                   	nop
f012345b:	c9                   	leave  
f012345c:	c3                   	ret    

f012345d <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f012345d:	55                   	push   %ebp
f012345e:	89 e5                	mov    %esp,%ebp
f0123460:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0123463:	ff 75 08             	pushl  0x8(%ebp)
f0123466:	e8 c4 f9 ff ff       	call   f0122e2f <strlen>
f012346b:	83 c4 04             	add    $0x4,%esp
f012346e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f0123471:	ff 75 0c             	pushl  0xc(%ebp)
f0123474:	e8 b6 f9 ff ff       	call   f0122e2f <strlen>
f0123479:	83 c4 04             	add    $0x4,%esp
f012347c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f012347f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f0123486:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012348d:	eb 17                	jmp    f01234a6 <strcconcat+0x49>
		final[s] = str1[s] ;
f012348f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0123492:	8b 45 10             	mov    0x10(%ebp),%eax
f0123495:	01 c2                	add    %eax,%edx
f0123497:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f012349a:	8b 45 08             	mov    0x8(%ebp),%eax
f012349d:	01 c8                	add    %ecx,%eax
f012349f:	8a 00                	mov    (%eax),%al
f01234a1:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f01234a3:	ff 45 fc             	incl   -0x4(%ebp)
f01234a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01234a9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01234ac:	7c e1                	jl     f012348f <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f01234ae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f01234b5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f01234bc:	eb 1f                	jmp    f01234dd <strcconcat+0x80>
		final[s++] = str2[i] ;
f01234be:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01234c1:	8d 50 01             	lea    0x1(%eax),%edx
f01234c4:	89 55 fc             	mov    %edx,-0x4(%ebp)
f01234c7:	89 c2                	mov    %eax,%edx
f01234c9:	8b 45 10             	mov    0x10(%ebp),%eax
f01234cc:	01 c2                	add    %eax,%edx
f01234ce:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f01234d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01234d4:	01 c8                	add    %ecx,%eax
f01234d6:	8a 00                	mov    (%eax),%al
f01234d8:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f01234da:	ff 45 f8             	incl   -0x8(%ebp)
f01234dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01234e0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01234e3:	7c d9                	jl     f01234be <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f01234e5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01234e8:	8b 45 10             	mov    0x10(%ebp),%eax
f01234eb:	01 d0                	add    %edx,%eax
f01234ed:	c6 00 00             	movb   $0x0,(%eax)
}
f01234f0:	90                   	nop
f01234f1:	c9                   	leave  
f01234f2:	c3                   	ret    

f01234f3 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f01234f3:	55                   	push   %ebp
f01234f4:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f01234f6:	8b 45 14             	mov    0x14(%ebp),%eax
f01234f9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f01234ff:	8b 45 14             	mov    0x14(%ebp),%eax
f0123502:	8b 00                	mov    (%eax),%eax
f0123504:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012350b:	8b 45 10             	mov    0x10(%ebp),%eax
f012350e:	01 d0                	add    %edx,%eax
f0123510:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0123516:	eb 0c                	jmp    f0123524 <strsplit+0x31>
			*string++ = 0;
f0123518:	8b 45 08             	mov    0x8(%ebp),%eax
f012351b:	8d 50 01             	lea    0x1(%eax),%edx
f012351e:	89 55 08             	mov    %edx,0x8(%ebp)
f0123521:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0123524:	8b 45 08             	mov    0x8(%ebp),%eax
f0123527:	8a 00                	mov    (%eax),%al
f0123529:	84 c0                	test   %al,%al
f012352b:	74 18                	je     f0123545 <strsplit+0x52>
f012352d:	8b 45 08             	mov    0x8(%ebp),%eax
f0123530:	8a 00                	mov    (%eax),%al
f0123532:	0f be c0             	movsbl %al,%eax
f0123535:	50                   	push   %eax
f0123536:	ff 75 0c             	pushl  0xc(%ebp)
f0123539:	e8 83 fa ff ff       	call   f0122fc1 <strchr>
f012353e:	83 c4 08             	add    $0x8,%esp
f0123541:	85 c0                	test   %eax,%eax
f0123543:	75 d3                	jne    f0123518 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0123545:	8b 45 08             	mov    0x8(%ebp),%eax
f0123548:	8a 00                	mov    (%eax),%al
f012354a:	84 c0                	test   %al,%al
f012354c:	74 5a                	je     f01235a8 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f012354e:	8b 45 14             	mov    0x14(%ebp),%eax
f0123551:	8b 00                	mov    (%eax),%eax
f0123553:	83 f8 0f             	cmp    $0xf,%eax
f0123556:	75 07                	jne    f012355f <strsplit+0x6c>
		{
			return 0;
f0123558:	b8 00 00 00 00       	mov    $0x0,%eax
f012355d:	eb 66                	jmp    f01235c5 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f012355f:	8b 45 14             	mov    0x14(%ebp),%eax
f0123562:	8b 00                	mov    (%eax),%eax
f0123564:	8d 48 01             	lea    0x1(%eax),%ecx
f0123567:	8b 55 14             	mov    0x14(%ebp),%edx
f012356a:	89 0a                	mov    %ecx,(%edx)
f012356c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0123573:	8b 45 10             	mov    0x10(%ebp),%eax
f0123576:	01 c2                	add    %eax,%edx
f0123578:	8b 45 08             	mov    0x8(%ebp),%eax
f012357b:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f012357d:	eb 03                	jmp    f0123582 <strsplit+0x8f>
			string++;
f012357f:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0123582:	8b 45 08             	mov    0x8(%ebp),%eax
f0123585:	8a 00                	mov    (%eax),%al
f0123587:	84 c0                	test   %al,%al
f0123589:	74 8b                	je     f0123516 <strsplit+0x23>
f012358b:	8b 45 08             	mov    0x8(%ebp),%eax
f012358e:	8a 00                	mov    (%eax),%al
f0123590:	0f be c0             	movsbl %al,%eax
f0123593:	50                   	push   %eax
f0123594:	ff 75 0c             	pushl  0xc(%ebp)
f0123597:	e8 25 fa ff ff       	call   f0122fc1 <strchr>
f012359c:	83 c4 08             	add    $0x8,%esp
f012359f:	85 c0                	test   %eax,%eax
f01235a1:	74 dc                	je     f012357f <strsplit+0x8c>
			string++;
	}
f01235a3:	e9 6e ff ff ff       	jmp    f0123516 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f01235a8:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f01235a9:	8b 45 14             	mov    0x14(%ebp),%eax
f01235ac:	8b 00                	mov    (%eax),%eax
f01235ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01235b5:	8b 45 10             	mov    0x10(%ebp),%eax
f01235b8:	01 d0                	add    %edx,%eax
f01235ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f01235c0:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01235c5:	c9                   	leave  
f01235c6:	c3                   	ret    

f01235c7 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f01235c7:	55                   	push   %ebp
f01235c8:	89 e5                	mov    %esp,%ebp
f01235ca:	83 ec 10             	sub    $0x10,%esp
	char* ret = dst;
f01235cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01235d0:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (int i = 0; i < strlen(src); ++i)
f01235d3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01235da:	eb 4a                	jmp    f0123626 <str2lower+0x5f>
	{
		dst[i] = src[i] ;
f01235dc:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01235df:	8b 45 08             	mov    0x8(%ebp),%eax
f01235e2:	01 c2                	add    %eax,%edx
f01235e4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f01235e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01235ea:	01 c8                	add    %ecx,%eax
f01235ec:	8a 00                	mov    (%eax),%al
f01235ee:	88 02                	mov    %al,(%edx)
		if (src[i] >= 'A' && src[i] <= 'Z')
f01235f0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01235f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01235f6:	01 d0                	add    %edx,%eax
f01235f8:	8a 00                	mov    (%eax),%al
f01235fa:	3c 40                	cmp    $0x40,%al
f01235fc:	7e 25                	jle    f0123623 <str2lower+0x5c>
f01235fe:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0123601:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123604:	01 d0                	add    %edx,%eax
f0123606:	8a 00                	mov    (%eax),%al
f0123608:	3c 5a                	cmp    $0x5a,%al
f012360a:	7f 17                	jg     f0123623 <str2lower+0x5c>
		{
			dst[i] += 32 ;
f012360c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012360f:	8b 45 08             	mov    0x8(%ebp),%eax
f0123612:	01 d0                	add    %edx,%eax
f0123614:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0123617:	8b 55 08             	mov    0x8(%ebp),%edx
f012361a:	01 ca                	add    %ecx,%edx
f012361c:	8a 12                	mov    (%edx),%dl
f012361e:	83 c2 20             	add    $0x20,%edx
f0123621:	88 10                	mov    %dl,(%eax)


char* str2lower(char *dst, const char *src)
{
	char* ret = dst;
	for (int i = 0; i < strlen(src); ++i)
f0123623:	ff 45 fc             	incl   -0x4(%ebp)
f0123626:	ff 75 0c             	pushl  0xc(%ebp)
f0123629:	e8 01 f8 ff ff       	call   f0122e2f <strlen>
f012362e:	83 c4 04             	add    $0x4,%esp
f0123631:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0123634:	7f a6                	jg     f01235dc <str2lower+0x15>
		if (src[i] >= 'A' && src[i] <= 'Z')
		{
			dst[i] += 32 ;
		}
	}
	return ret;
f0123636:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0123639:	c9                   	leave  
f012363a:	c3                   	ret    

f012363b <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f012363b:	55                   	push   %ebp
f012363c:	89 e5                	mov    %esp,%ebp
f012363e:	83 ec 10             	sub    $0x10,%esp
f0123641:	c7 45 f8 f7 01 00 00 	movl   $0x1f7,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0123648:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012364b:	89 c2                	mov    %eax,%edx
f012364d:	ec                   	in     (%dx),%al
f012364e:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0123651:	8a 45 f7             	mov    -0x9(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0123654:	0f b6 c0             	movzbl %al,%eax
f0123657:	89 45 fc             	mov    %eax,-0x4(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
		signal_ksemaphore(&DISKsem);
#endif
	}

}
f012365a:	90                   	nop
f012365b:	c9                   	leave  
f012365c:	c3                   	ret    

f012365d <ide_init>:

void ide_init()
{
f012365d:	55                   	push   %ebp
f012365e:	89 e5                	mov    %esp,%ebp
		irq_install_handler(14, &disk_interrupt_handler);
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
		init_ksemaphore(&DISKmutex, 1, "DISK mutex");
	}
#endif
}
f0123660:	90                   	nop
f0123661:	5d                   	pop    %ebp
f0123662:	c3                   	ret    

f0123663 <ide_wait_ready>:


static int ide_wait_ready(bool check_error)
{
f0123663:	55                   	push   %ebp
f0123664:	89 e5                	mov    %esp,%ebp
f0123666:	83 ec 18             	sub    $0x18,%esp
	int r;
	//cprintf("ide_wait_ready: begin\n");

#if DISK_IO_METHOD == PROGRAMMED_IO
	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0123669:	90                   	nop
f012366a:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0123671:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123674:	89 c2                	mov    %eax,%edx
f0123676:	ec                   	in     (%dx),%al
f0123677:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f012367a:	8a 45 ef             	mov    -0x11(%ebp),%al
f012367d:	0f b6 c0             	movzbl %al,%eax
f0123680:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0123683:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123686:	25 c0 00 00 00       	and    $0xc0,%eax
f012368b:	83 f8 40             	cmp    $0x40,%eax
f012368e:	75 da                	jne    f012366a <ide_wait_ready+0x7>
			wait_ksemaphore(&DISKsem);
#endif
		}
	}
#endif
	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0123690:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123694:	74 24                	je     f01236ba <ide_wait_ready+0x57>
f0123696:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123699:	83 e0 21             	and    $0x21,%eax
f012369c:	85 c0                	test   %eax,%eax
f012369e:	74 1a                	je     f01236ba <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f01236a0:	83 ec 0c             	sub    $0xc,%esp
f01236a3:	ff 75 f4             	pushl  -0xc(%ebp)
f01236a6:	ff 75 f4             	pushl  -0xc(%ebp)
f01236a9:	68 5c 0b 14 f0       	push   $0xf0140b5c
f01236ae:	6a 62                	push   $0x62
f01236b0:	68 7f 0b 14 f0       	push   $0xf0140b7f
f01236b5:	e8 f5 d7 fd ff       	call   f0100eaf <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	//cprintf("ide_wait_ready: end\n");

	return 0;
f01236ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01236bf:	c9                   	leave  
f01236c0:	c3                   	ret    

f01236c1 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f01236c1:	55                   	push   %ebp
f01236c2:	89 e5                	mov    %esp,%ebp
f01236c4:	57                   	push   %edi
f01236c5:	53                   	push   %ebx
f01236c6:	83 ec 40             	sub    $0x40,%esp
	int r;

	assert(nsecs <= 256);
f01236c9:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01236d0:	76 16                	jbe    f01236e8 <ide_read+0x27>
f01236d2:	68 8a 0b 14 f0       	push   $0xf0140b8a
f01236d7:	68 97 0b 14 f0       	push   $0xf0140b97
f01236dc:	6a 6f                	push   $0x6f
f01236de:	68 7f 0b 14 f0       	push   $0xf0140b7f
f01236e3:	e8 c7 d7 fd ff       	call   f0100eaf <_panic>

	//TODODONE'24 el7: FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	struct Env* e = get_cpu_proc();
f01236e8:	e8 5b 9f fe ff       	call   f010d648 <get_cpu_proc>
f01236ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
		wait_ksemaphore(&DISKmutex);
#endif
	}
	{
		if (e) LOG_STATMENT(cprintf("ide_read: %d inside CS\n", e->env_id););
		ide_wait_ready(0);
f01236f0:	83 ec 0c             	sub    $0xc,%esp
f01236f3:	6a 00                	push   $0x0
f01236f5:	e8 69 ff ff ff       	call   f0123663 <ide_wait_ready>
f01236fa:	83 c4 10             	add    $0x10,%esp

		outb(0x1F2, nsecs);
f01236fd:	8b 45 10             	mov    0x10(%ebp),%eax
f0123700:	0f b6 c0             	movzbl %al,%eax
f0123703:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f012370a:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f012370d:	8a 45 ce             	mov    -0x32(%ebp),%al
f0123710:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0123713:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f0123714:	8b 45 08             	mov    0x8(%ebp),%eax
f0123717:	0f b6 c0             	movzbl %al,%eax
f012371a:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f0123721:	88 45 cf             	mov    %al,-0x31(%ebp)
f0123724:	8a 45 cf             	mov    -0x31(%ebp),%al
f0123727:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012372a:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f012372b:	8b 45 08             	mov    0x8(%ebp),%eax
f012372e:	c1 e8 08             	shr    $0x8,%eax
f0123731:	0f b6 c0             	movzbl %al,%eax
f0123734:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f012373b:	88 45 d0             	mov    %al,-0x30(%ebp)
f012373e:	8a 45 d0             	mov    -0x30(%ebp),%al
f0123741:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0123744:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f0123745:	8b 45 08             	mov    0x8(%ebp),%eax
f0123748:	c1 e8 10             	shr    $0x10,%eax
f012374b:	0f b6 c0             	movzbl %al,%eax
f012374e:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f0123755:	88 45 d1             	mov    %al,-0x2f(%ebp)
f0123758:	8a 45 d1             	mov    -0x2f(%ebp),%al
f012375b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012375e:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f012375f:	a1 c8 cb 94 f1       	mov    0xf194cbc8,%eax
f0123764:	83 e0 01             	and    $0x1,%eax
f0123767:	c1 e0 04             	shl    $0x4,%eax
f012376a:	88 c2                	mov    %al,%dl
f012376c:	8b 45 08             	mov    0x8(%ebp),%eax
f012376f:	c1 e8 18             	shr    $0x18,%eax
f0123772:	83 e0 0f             	and    $0xf,%eax
f0123775:	09 d0                	or     %edx,%eax
f0123777:	83 c8 e0             	or     $0xffffffe0,%eax
f012377a:	0f b6 c0             	movzbl %al,%eax
f012377d:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f0123784:	88 45 d2             	mov    %al,-0x2e(%ebp)
f0123787:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012378a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012378d:	ee                   	out    %al,(%dx)
f012378e:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f0123795:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
f0123799:	8a 45 d3             	mov    -0x2d(%ebp),%al
f012379c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012379f:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01237a0:	eb 67                	jmp    f0123809 <ide_read+0x148>
			if ((r = ide_wait_ready(1)) < 0)
f01237a2:	83 ec 0c             	sub    $0xc,%esp
f01237a5:	6a 01                	push   $0x1
f01237a7:	e8 b7 fe ff ff       	call   f0123663 <ide_wait_ready>
f01237ac:	83 c4 10             	add    $0x10,%esp
f01237af:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01237b2:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01237b6:	79 17                	jns    f01237cf <ide_read+0x10e>
			{
				panic("FAILURE to read %d sectors to disk\n",nsecs);
f01237b8:	ff 75 10             	pushl  0x10(%ebp)
f01237bb:	68 ac 0b 14 f0       	push   $0xf0140bac
f01237c0:	68 8c 00 00 00       	push   $0x8c
f01237c5:	68 7f 0b 14 f0       	push   $0xf0140b7f
f01237ca:	e8 e0 d6 fd ff       	call   f0100eaf <_panic>
f01237cf:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f01237d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01237d9:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01237dc:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f01237e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01237e6:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f01237e9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01237ec:	89 cb                	mov    %ecx,%ebx
f01237ee:	89 df                	mov    %ebx,%edi
f01237f0:	89 c1                	mov    %eax,%ecx
f01237f2:	fc                   	cld    
f01237f3:	f2 6d                	repnz insl (%dx),%es:(%edi)
f01237f5:	89 c8                	mov    %ecx,%eax
f01237f7:	89 fb                	mov    %edi,%ebx
f01237f9:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f01237fc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F4, (secno >> 8) & 0xFF);
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01237ff:	ff 4d 10             	decl   0x10(%ebp)
f0123802:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0123809:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012380d:	75 93                	jne    f01237a2 <ide_read+0xe1>
#elif DISK_IO_METHOD == INT_SEMAPHORE
		signal_ksemaphore(&DISKmutex);
#endif
	}

	return 0;
f012380f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0123814:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0123817:	5b                   	pop    %ebx
f0123818:	5f                   	pop    %edi
f0123819:	5d                   	pop    %ebp
f012381a:	c3                   	ret    

f012381b <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f012381b:	55                   	push   %ebp
f012381c:	89 e5                	mov    %esp,%ebp
f012381e:	56                   	push   %esi
f012381f:	53                   	push   %ebx
f0123820:	83 ec 40             	sub    $0x40,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0123823:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f012382a:	76 19                	jbe    f0123845 <ide_write+0x2a>
f012382c:	68 8a 0b 14 f0       	push   $0xf0140b8a
f0123831:	68 97 0b 14 f0       	push   $0xf0140b97
f0123836:	68 a6 00 00 00       	push   $0xa6
f012383b:	68 7f 0b 14 f0       	push   $0xf0140b7f
f0123840:	e8 6a d6 fd ff       	call   f0100eaf <_panic>

	struct Env* e = get_cpu_proc();
f0123845:	e8 fe 9d fe ff       	call   f010d648 <get_cpu_proc>
f012384a:	89 45 f4             	mov    %eax,-0xc(%ebp)
#endif
	}
	{
		if (e) LOG_STATMENT(cprintf("ide_write: %d inside CS\n", e->env_id););

		ide_wait_ready(0);
f012384d:	83 ec 0c             	sub    $0xc,%esp
f0123850:	6a 00                	push   $0x0
f0123852:	e8 0c fe ff ff       	call   f0123663 <ide_wait_ready>
f0123857:	83 c4 10             	add    $0x10,%esp

		//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
		outb(0x1F2, nsecs);
f012385a:	8b 45 10             	mov    0x10(%ebp),%eax
f012385d:	0f b6 c0             	movzbl %al,%eax
f0123860:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f0123867:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f012386a:	8a 45 ce             	mov    -0x32(%ebp),%al
f012386d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0123870:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f0123871:	8b 45 08             	mov    0x8(%ebp),%eax
f0123874:	0f b6 c0             	movzbl %al,%eax
f0123877:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f012387e:	88 45 cf             	mov    %al,-0x31(%ebp)
f0123881:	8a 45 cf             	mov    -0x31(%ebp),%al
f0123884:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0123887:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f0123888:	8b 45 08             	mov    0x8(%ebp),%eax
f012388b:	c1 e8 08             	shr    $0x8,%eax
f012388e:	0f b6 c0             	movzbl %al,%eax
f0123891:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f0123898:	88 45 d0             	mov    %al,-0x30(%ebp)
f012389b:	8a 45 d0             	mov    -0x30(%ebp),%al
f012389e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01238a1:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f01238a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01238a5:	c1 e8 10             	shr    $0x10,%eax
f01238a8:	0f b6 c0             	movzbl %al,%eax
f01238ab:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f01238b2:	88 45 d1             	mov    %al,-0x2f(%ebp)
f01238b5:	8a 45 d1             	mov    -0x2f(%ebp),%al
f01238b8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01238bb:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f01238bc:	a1 c8 cb 94 f1       	mov    0xf194cbc8,%eax
f01238c1:	83 e0 01             	and    $0x1,%eax
f01238c4:	c1 e0 04             	shl    $0x4,%eax
f01238c7:	88 c2                	mov    %al,%dl
f01238c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01238cc:	c1 e8 18             	shr    $0x18,%eax
f01238cf:	83 e0 0f             	and    $0xf,%eax
f01238d2:	09 d0                	or     %edx,%eax
f01238d4:	83 c8 e0             	or     $0xffffffe0,%eax
f01238d7:	0f b6 c0             	movzbl %al,%eax
f01238da:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f01238e1:	88 45 d2             	mov    %al,-0x2e(%ebp)
f01238e4:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01238e7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01238ea:	ee                   	out    %al,(%dx)
f01238eb:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f01238f2:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
f01238f6:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01238f9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01238fc:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01238fd:	eb 67                	jmp    f0123966 <ide_write+0x14b>
			if ((r = ide_wait_ready(1)) < 0)
f01238ff:	83 ec 0c             	sub    $0xc,%esp
f0123902:	6a 01                	push   $0x1
f0123904:	e8 5a fd ff ff       	call   f0123663 <ide_wait_ready>
f0123909:	83 c4 10             	add    $0x10,%esp
f012390c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f012390f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0123913:	79 17                	jns    f012392c <ide_write+0x111>
			{
				panic("FAILURE to write %d sectors to disk\n",nsecs);
f0123915:	ff 75 10             	pushl  0x10(%ebp)
f0123918:	68 d0 0b 14 f0       	push   $0xf0140bd0
f012391d:	68 c7 00 00 00       	push   $0xc7
f0123922:	68 7f 0b 14 f0       	push   $0xf0140b7f
f0123927:	e8 83 d5 fd ff       	call   f0100eaf <_panic>
f012392c:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f0123933:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123936:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0123939:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0123940:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123943:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f0123946:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0123949:	89 cb                	mov    %ecx,%ebx
f012394b:	89 de                	mov    %ebx,%esi
f012394d:	89 c1                	mov    %eax,%ecx
f012394f:	fc                   	cld    
f0123950:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0123952:	89 c8                	mov    %ecx,%eax
f0123954:	89 f3                	mov    %esi,%ebx
f0123956:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f0123959:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f012395c:	ff 4d 10             	decl   0x10(%ebp)
f012395f:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0123966:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012396a:	75 93                	jne    f01238ff <ide_write+0xe4>
		LOG_STATMENT(cprintf("ide_write: %d Left CS\n", e->env_id););
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f012396c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0123971:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0123974:	5b                   	pop    %ebx
f0123975:	5e                   	pop    %esi
f0123976:	5d                   	pop    %ebp
f0123977:	c3                   	ret    

f0123978 <to_page_va>:
//==================================
//==================================
// [1] GET PAGE VA:
//==================================
__inline__ uint32 to_page_va(struct PageInfoElement *ptrPageInfo)
{
f0123978:	55                   	push   %ebp
f0123979:	89 e5                	mov    %esp,%ebp
f012397b:	83 ec 18             	sub    $0x18,%esp
	if (ptrPageInfo < &pageBlockInfoArr[0] || ptrPageInfo >= &pageBlockInfoArr[DYN_ALLOC_MAX_SIZE/PAGE_SIZE])
f012397e:	81 7d 08 60 d0 94 f1 	cmpl   $0xf194d060,0x8(%ebp)
f0123985:	72 09                	jb     f0123990 <to_page_va+0x18>
f0123987:	81 7d 08 60 50 96 f1 	cmpl   $0xf1965060,0x8(%ebp)
f012398e:	72 14                	jb     f01239a4 <to_page_va+0x2c>
			panic("to_page_va called with invalid pageInfoPtr");
f0123990:	83 ec 04             	sub    $0x4,%esp
f0123993:	68 f8 0b 14 f0       	push   $0xf0140bf8
f0123998:	6a 15                	push   $0x15
f012399a:	68 23 0c 14 f0       	push   $0xf0140c23
f012399f:	e8 0b d5 fd ff       	call   f0100eaf <_panic>
	//Get start VA of the page from the corresponding Page Info pointer
	int idxInPageInfoArr = (ptrPageInfo - pageBlockInfoArr);
f01239a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01239a7:	ba 60 d0 94 f1       	mov    $0xf194d060,%edx
f01239ac:	29 d0                	sub    %edx,%eax
f01239ae:	c1 f8 02             	sar    $0x2,%eax
f01239b1:	89 c2                	mov    %eax,%edx
f01239b3:	89 d0                	mov    %edx,%eax
f01239b5:	c1 e0 02             	shl    $0x2,%eax
f01239b8:	01 d0                	add    %edx,%eax
f01239ba:	c1 e0 02             	shl    $0x2,%eax
f01239bd:	01 d0                	add    %edx,%eax
f01239bf:	c1 e0 02             	shl    $0x2,%eax
f01239c2:	01 d0                	add    %edx,%eax
f01239c4:	89 c1                	mov    %eax,%ecx
f01239c6:	c1 e1 08             	shl    $0x8,%ecx
f01239c9:	01 c8                	add    %ecx,%eax
f01239cb:	89 c1                	mov    %eax,%ecx
f01239cd:	c1 e1 10             	shl    $0x10,%ecx
f01239d0:	01 c8                	add    %ecx,%eax
f01239d2:	01 c0                	add    %eax,%eax
f01239d4:	01 d0                	add    %edx,%eax
f01239d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return dynAllocStart + (idxInPageInfoArr << PGSHIFT);
f01239d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01239dc:	c1 e0 0c             	shl    $0xc,%eax
f01239df:	89 c2                	mov    %eax,%edx
f01239e1:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f01239e6:	01 d0                	add    %edx,%eax
}
f01239e8:	c9                   	leave  
f01239e9:	c3                   	ret    

f01239ea <to_page_info>:

//==================================
// [2] GET PAGE INFO OF PAGE VA:
//==================================
__inline__ struct PageInfoElement * to_page_info(uint32 va)
{
f01239ea:	55                   	push   %ebp
f01239eb:	89 e5                	mov    %esp,%ebp
f01239ed:	83 ec 18             	sub    $0x18,%esp
	int idxInPageInfoArr = (va - dynAllocStart) >> PGSHIFT;
f01239f0:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f01239f5:	8b 55 08             	mov    0x8(%ebp),%edx
f01239f8:	29 c2                	sub    %eax,%edx
f01239fa:	89 d0                	mov    %edx,%eax
f01239fc:	c1 e8 0c             	shr    $0xc,%eax
f01239ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (idxInPageInfoArr < 0 || idxInPageInfoArr >= DYN_ALLOC_MAX_SIZE/PAGE_SIZE)
f0123a02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123a06:	78 09                	js     f0123a11 <to_page_info+0x27>
f0123a08:	81 7d f4 ff 1f 00 00 	cmpl   $0x1fff,-0xc(%ebp)
f0123a0f:	7e 14                	jle    f0123a25 <to_page_info+0x3b>
		panic("to_page_info called with invalid pa");
f0123a11:	83 ec 04             	sub    $0x4,%esp
f0123a14:	68 3c 0c 14 f0       	push   $0xf0140c3c
f0123a19:	6a 22                	push   $0x22
f0123a1b:	68 23 0c 14 f0       	push   $0xf0140c23
f0123a20:	e8 8a d4 fd ff       	call   f0100eaf <_panic>
	return &pageBlockInfoArr[idxInPageInfoArr];
f0123a25:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123a28:	89 d0                	mov    %edx,%eax
f0123a2a:	01 c0                	add    %eax,%eax
f0123a2c:	01 d0                	add    %edx,%eax
f0123a2e:	c1 e0 02             	shl    $0x2,%eax
f0123a31:	05 60 d0 94 f1       	add    $0xf194d060,%eax
}
f0123a36:	c9                   	leave  
f0123a37:	c3                   	ret    

f0123a38 <initialize_dynamic_allocator>:
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
bool is_initialized = 0;
void initialize_dynamic_allocator(uint32 daStart, uint32 daEnd)
{
f0123a38:	55                   	push   %ebp
f0123a39:	89 e5                	mov    %esp,%ebp
f0123a3b:	83 ec 28             	sub    $0x28,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(daEnd <= daStart + DYN_ALLOC_MAX_SIZE);
f0123a3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0123a41:	05 00 00 00 02       	add    $0x2000000,%eax
f0123a46:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0123a49:	73 16                	jae    f0123a61 <initialize_dynamic_allocator+0x29>
f0123a4b:	68 60 0c 14 f0       	push   $0xf0140c60
f0123a50:	68 86 0c 14 f0       	push   $0xf0140c86
f0123a55:	6a 34                	push   $0x34
f0123a57:	68 23 0c 14 f0       	push   $0xf0140c23
f0123a5c:	e8 4e d4 fd ff       	call   f0100eaf <_panic>
		is_initialized = 1;
f0123a61:	c7 05 cc cb 94 f1 01 	movl   $0x1,0xf194cbcc
f0123a68:	00 00 00 
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #1 initialize_dynamic_allocator
	//Your code is here

	dynAllocStart = daStart;
f0123a6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0123a6e:	a3 bc 51 96 f1       	mov    %eax,0xf19651bc
	dynAllocEnd = daEnd;
f0123a73:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123a76:	a3 e0 cb 94 f1       	mov    %eax,0xf194cbe0

	LIST_INIT(&freePagesList);
f0123a7b:	c7 05 f4 ce 94 f1 00 	movl   $0x0,0xf194cef4
f0123a82:	00 00 00 
f0123a85:	c7 05 f8 ce 94 f1 00 	movl   $0x0,0xf194cef8
f0123a8c:	00 00 00 
f0123a8f:	c7 05 00 cf 94 f1 00 	movl   $0x0,0xf194cf00
f0123a96:	00 00 00 

	uint32 num=LOG2_MAX_SIZE - LOG2_MIN_SIZE + 1;
f0123a99:	c7 45 e8 09 00 00 00 	movl   $0x9,-0x18(%ebp)

	for(int i = 0; i < num ; ++i){
f0123aa0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0123aa7:	eb 36                	jmp    f0123adf <initialize_dynamic_allocator+0xa7>
	    LIST_INIT(&freeBlockLists[i]);
f0123aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123aac:	c1 e0 04             	shl    $0x4,%eax
f0123aaf:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f0123ab4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123abd:	c1 e0 04             	shl    $0x4,%eax
f0123ac0:	05 e4 52 96 f1       	add    $0xf19652e4,%eax
f0123ac5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123acb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123ace:	c1 e0 04             	shl    $0x4,%eax
f0123ad1:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0123ad6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	LIST_INIT(&freePagesList);

	uint32 num=LOG2_MAX_SIZE - LOG2_MIN_SIZE + 1;

	for(int i = 0; i < num ; ++i){
f0123adc:	ff 45 f4             	incl   -0xc(%ebp)
f0123adf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123ae2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0123ae5:	72 c2                	jb     f0123aa9 <initialize_dynamic_allocator+0x71>
	    LIST_INIT(&freeBlockLists[i]);
	}

	uint32 total_num_pages=(dynAllocEnd - dynAllocStart) / PAGE_SIZE;
f0123ae7:	8b 15 e0 cb 94 f1    	mov    0xf194cbe0,%edx
f0123aed:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f0123af2:	29 c2                	sub    %eax,%edx
f0123af4:	89 d0                	mov    %edx,%eax
f0123af6:	c1 e8 0c             	shr    $0xc,%eax
f0123af9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	for(int i = 0; i < total_num_pages ; ++i){
f0123afc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0123b03:	e9 c8 00 00 00       	jmp    f0123bd0 <initialize_dynamic_allocator+0x198>
		pageBlockInfoArr[i].block_size = 0;
f0123b08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123b0b:	89 d0                	mov    %edx,%eax
f0123b0d:	01 c0                	add    %eax,%eax
f0123b0f:	01 d0                	add    %edx,%eax
f0123b11:	c1 e0 02             	shl    $0x2,%eax
f0123b14:	05 68 d0 94 f1       	add    $0xf194d068,%eax
f0123b19:	66 c7 00 00 00       	movw   $0x0,(%eax)
	    pageBlockInfoArr[i].num_of_free_blocks = 0;
f0123b1e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123b21:	89 d0                	mov    %edx,%eax
f0123b23:	01 c0                	add    %eax,%eax
f0123b25:	01 d0                	add    %edx,%eax
f0123b27:	c1 e0 02             	shl    $0x2,%eax
f0123b2a:	05 6a d0 94 f1       	add    $0xf194d06a,%eax
f0123b2f:	66 c7 00 00 00       	movw   $0x0,(%eax)

	    LIST_INSERT_TAIL(&freePagesList, &pageBlockInfoArr[i]);
f0123b34:	8b 15 f8 ce 94 f1    	mov    0xf194cef8,%edx
f0123b3a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0123b3d:	89 c8                	mov    %ecx,%eax
f0123b3f:	01 c0                	add    %eax,%eax
f0123b41:	01 c8                	add    %ecx,%eax
f0123b43:	c1 e0 02             	shl    $0x2,%eax
f0123b46:	05 64 d0 94 f1       	add    $0xf194d064,%eax
f0123b4b:	89 10                	mov    %edx,(%eax)
f0123b4d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123b50:	89 d0                	mov    %edx,%eax
f0123b52:	01 c0                	add    %eax,%eax
f0123b54:	01 d0                	add    %edx,%eax
f0123b56:	c1 e0 02             	shl    $0x2,%eax
f0123b59:	05 64 d0 94 f1       	add    $0xf194d064,%eax
f0123b5e:	8b 00                	mov    (%eax),%eax
f0123b60:	85 c0                	test   %eax,%eax
f0123b62:	74 1b                	je     f0123b7f <initialize_dynamic_allocator+0x147>
f0123b64:	8b 15 f8 ce 94 f1    	mov    0xf194cef8,%edx
f0123b6a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0123b6d:	89 c8                	mov    %ecx,%eax
f0123b6f:	01 c0                	add    %eax,%eax
f0123b71:	01 c8                	add    %ecx,%eax
f0123b73:	c1 e0 02             	shl    $0x2,%eax
f0123b76:	05 60 d0 94 f1       	add    $0xf194d060,%eax
f0123b7b:	89 02                	mov    %eax,(%edx)
f0123b7d:	eb 16                	jmp    f0123b95 <initialize_dynamic_allocator+0x15d>
f0123b7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123b82:	89 d0                	mov    %edx,%eax
f0123b84:	01 c0                	add    %eax,%eax
f0123b86:	01 d0                	add    %edx,%eax
f0123b88:	c1 e0 02             	shl    $0x2,%eax
f0123b8b:	05 60 d0 94 f1       	add    $0xf194d060,%eax
f0123b90:	a3 f4 ce 94 f1       	mov    %eax,0xf194cef4
f0123b95:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123b98:	89 d0                	mov    %edx,%eax
f0123b9a:	01 c0                	add    %eax,%eax
f0123b9c:	01 d0                	add    %edx,%eax
f0123b9e:	c1 e0 02             	shl    $0x2,%eax
f0123ba1:	05 60 d0 94 f1       	add    $0xf194d060,%eax
f0123ba6:	a3 f8 ce 94 f1       	mov    %eax,0xf194cef8
f0123bab:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123bae:	89 d0                	mov    %edx,%eax
f0123bb0:	01 c0                	add    %eax,%eax
f0123bb2:	01 d0                	add    %edx,%eax
f0123bb4:	c1 e0 02             	shl    $0x2,%eax
f0123bb7:	05 60 d0 94 f1       	add    $0xf194d060,%eax
f0123bbc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123bc2:	a1 00 cf 94 f1       	mov    0xf194cf00,%eax
f0123bc7:	40                   	inc    %eax
f0123bc8:	a3 00 cf 94 f1       	mov    %eax,0xf194cf00
	    LIST_INIT(&freeBlockLists[i]);
	}

	uint32 total_num_pages=(dynAllocEnd - dynAllocStart) / PAGE_SIZE;

	for(int i = 0; i < total_num_pages ; ++i){
f0123bcd:	ff 45 f0             	incl   -0x10(%ebp)
f0123bd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123bd3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0123bd6:	0f 82 2c ff ff ff    	jb     f0123b08 <initialize_dynamic_allocator+0xd0>
	    pageBlockInfoArr[i].num_of_free_blocks = 0;

	    LIST_INSERT_TAIL(&freePagesList, &pageBlockInfoArr[i]);
	}

	for(uint32 i = total_num_pages; i < DYN_ALLOC_MAX_SIZE / PAGE_SIZE; ++i) {
f0123bdc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123bdf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0123be2:	eb 2f                	jmp    f0123c13 <initialize_dynamic_allocator+0x1db>
	        pageBlockInfoArr[i].block_size = 0;
f0123be4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0123be7:	89 d0                	mov    %edx,%eax
f0123be9:	01 c0                	add    %eax,%eax
f0123beb:	01 d0                	add    %edx,%eax
f0123bed:	c1 e0 02             	shl    $0x2,%eax
f0123bf0:	05 68 d0 94 f1       	add    $0xf194d068,%eax
f0123bf5:	66 c7 00 00 00       	movw   $0x0,(%eax)
	        pageBlockInfoArr[i].num_of_free_blocks = 0;
f0123bfa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0123bfd:	89 d0                	mov    %edx,%eax
f0123bff:	01 c0                	add    %eax,%eax
f0123c01:	01 d0                	add    %edx,%eax
f0123c03:	c1 e0 02             	shl    $0x2,%eax
f0123c06:	05 6a d0 94 f1       	add    $0xf194d06a,%eax
f0123c0b:	66 c7 00 00 00       	movw   $0x0,(%eax)
	    pageBlockInfoArr[i].num_of_free_blocks = 0;

	    LIST_INSERT_TAIL(&freePagesList, &pageBlockInfoArr[i]);
	}

	for(uint32 i = total_num_pages; i < DYN_ALLOC_MAX_SIZE / PAGE_SIZE; ++i) {
f0123c10:	ff 45 ec             	incl   -0x14(%ebp)
f0123c13:	81 7d ec ff 1f 00 00 	cmpl   $0x1fff,-0x14(%ebp)
f0123c1a:	76 c8                	jbe    f0123be4 <initialize_dynamic_allocator+0x1ac>
	}

	//Comment the following line
	//panic("initialize_dynamic_allocator() Not implemented yet");

}
f0123c1c:	90                   	nop
f0123c1d:	c9                   	leave  
f0123c1e:	c3                   	ret    

f0123c1f <get_block_size>:

//===========================
// [2] GET BLOCK SIZE:
//===========================
__inline__ uint32 get_block_size(void *va)
{
f0123c1f:	55                   	push   %ebp
f0123c20:	89 e5                	mov    %esp,%ebp
f0123c22:	83 ec 10             	sub    $0x10,%esp
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #2 get_block_size
	//Your code is here

	int index = ((uint32)va - dynAllocStart) / PAGE_SIZE;
f0123c25:	8b 55 08             	mov    0x8(%ebp),%edx
f0123c28:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f0123c2d:	29 c2                	sub    %eax,%edx
f0123c2f:	89 d0                	mov    %edx,%eax
f0123c31:	c1 e8 0c             	shr    $0xc,%eax
f0123c34:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return pageBlockInfoArr[index].block_size;
f0123c37:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0123c3a:	89 d0                	mov    %edx,%eax
f0123c3c:	01 c0                	add    %eax,%eax
f0123c3e:	01 d0                	add    %edx,%eax
f0123c40:	c1 e0 02             	shl    $0x2,%eax
f0123c43:	05 68 d0 94 f1       	add    $0xf194d068,%eax
f0123c48:	8b 00                	mov    (%eax),%eax
f0123c4a:	0f b7 c0             	movzwl %ax,%eax

	//Comment the following line
	//panic("get_block_size() Not implemented yet");
}
f0123c4d:	c9                   	leave  
f0123c4e:	c3                   	ret    

f0123c4f <nearest_pow2_ceil.1513>:
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #3 alloc_block
	//Your code is here

    inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0123c4f:	55                   	push   %ebp
f0123c50:	89 e5                	mov    %esp,%ebp
f0123c52:	83 ec 14             	sub    $0x14,%esp
f0123c55:	89 4d ec             	mov    %ecx,-0x14(%ebp)
        if (x <= 1) return 1;
f0123c58:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0123c5c:	77 07                	ja     f0123c65 <nearest_pow2_ceil.1513+0x16>
f0123c5e:	b8 01 00 00 00       	mov    $0x1,%eax
f0123c63:	eb 20                	jmp    f0123c85 <nearest_pow2_ceil.1513+0x36>
        int power = 2;
f0123c65:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
        x--;
f0123c6c:	ff 4d 08             	decl   0x8(%ebp)
        while (x >>= 1) power <<= 1;
f0123c6f:	eb 08                	jmp    f0123c79 <nearest_pow2_ceil.1513+0x2a>
f0123c71:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0123c74:	01 c0                	add    %eax,%eax
f0123c76:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0123c79:	d1 6d 08             	shrl   0x8(%ebp)
f0123c7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123c80:	75 ef                	jne    f0123c71 <nearest_pow2_ceil.1513+0x22>
        return power;
f0123c82:	8b 45 fc             	mov    -0x4(%ebp),%eax
    }
f0123c85:	c9                   	leave  
f0123c86:	c3                   	ret    

f0123c87 <alloc_block>:

//===========================
// 3) ALLOCATE BLOCK:
//===========================
void *alloc_block(uint32 size)
{
f0123c87:	55                   	push   %ebp
f0123c88:	89 e5                	mov    %esp,%ebp
f0123c8a:	83 ec 38             	sub    $0x38,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(size <= DYN_ALLOC_MAX_BLOCK_SIZE);
f0123c8d:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0123c94:	76 16                	jbe    f0123cac <alloc_block+0x25>
f0123c96:	68 9c 0c 14 f0       	push   $0xf0140c9c
f0123c9b:	68 86 0c 14 f0       	push   $0xf0140c86
f0123ca0:	6a 72                	push   $0x72
f0123ca2:	68 23 0c 14 f0       	push   $0xf0140c23
f0123ca7:	e8 03 d2 fd ff       	call   f0100eaf <_panic>
            bits_cnt++;
        }
        return bits_cnt;
    }

    if(!size) return NULL;
f0123cac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123cb0:	75 0a                	jne    f0123cbc <alloc_block+0x35>
f0123cb2:	b8 00 00 00 00       	mov    $0x0,%eax
f0123cb7:	e9 bd 04 00 00       	jmp    f0124179 <alloc_block+0x4f2>

    uint32 min_block_size = 1 << LOG2_MIN_SIZE;
f0123cbc:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
    if (size < min_block_size)
f0123cc3:	8b 45 08             	mov    0x8(%ebp),%eax
f0123cc6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0123cc9:	73 06                	jae    f0123cd1 <alloc_block+0x4a>
        size = min_block_size;
f0123ccb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0123cce:	89 45 08             	mov    %eax,0x8(%ebp)

    int pow = nearest_pow2_ceil(size);
f0123cd1:	83 ec 0c             	sub    $0xc,%esp
f0123cd4:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0123cd7:	ff 75 08             	pushl  0x8(%ebp)
f0123cda:	89 c1                	mov    %eax,%ecx
f0123cdc:	e8 6e ff ff ff       	call   f0123c4f <nearest_pow2_ceil.1513>
f0123ce1:	83 c4 10             	add    $0x10,%esp
f0123ce4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int index = log2_ceil(pow) - LOG2_MIN_SIZE;
f0123ce7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0123cea:	83 ec 0c             	sub    $0xc,%esp
f0123ced:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0123cf0:	52                   	push   %edx
f0123cf1:	89 c1                	mov    %eax,%ecx
f0123cf3:	e8 83 04 00 00       	call   f012417b <log2_ceil.1520>
f0123cf8:	83 c4 10             	add    $0x10,%esp
f0123cfb:	83 e8 03             	sub    $0x3,%eax
f0123cfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    // CASE 1: free block exists
    if (!LIST_EMPTY(&freeBlockLists[index])) {
f0123d01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123d04:	c1 e0 04             	shl    $0x4,%eax
f0123d07:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f0123d0c:	8b 00                	mov    (%eax),%eax
f0123d0e:	85 c0                	test   %eax,%eax
f0123d10:	0f 84 d8 00 00 00    	je     f0123dee <alloc_block+0x167>
        struct BlockElement *e = LIST_FIRST(&freeBlockLists[index]);
f0123d16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123d19:	c1 e0 04             	shl    $0x4,%eax
f0123d1c:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f0123d21:	8b 00                	mov    (%eax),%eax
f0123d23:	89 45 e0             	mov    %eax,-0x20(%ebp)
        LIST_REMOVE(&freeBlockLists[index], e);
f0123d26:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0123d2a:	75 17                	jne    f0123d43 <alloc_block+0xbc>
f0123d2c:	83 ec 04             	sub    $0x4,%esp
f0123d2f:	68 bd 0c 14 f0       	push   $0xf0140cbd
f0123d34:	68 98 00 00 00       	push   $0x98
f0123d39:	68 23 0c 14 f0       	push   $0xf0140c23
f0123d3e:	e8 6c d1 fd ff       	call   f0100eaf <_panic>
f0123d43:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d46:	8b 00                	mov    (%eax),%eax
f0123d48:	85 c0                	test   %eax,%eax
f0123d4a:	74 10                	je     f0123d5c <alloc_block+0xd5>
f0123d4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d4f:	8b 00                	mov    (%eax),%eax
f0123d51:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123d54:	8b 52 04             	mov    0x4(%edx),%edx
f0123d57:	89 50 04             	mov    %edx,0x4(%eax)
f0123d5a:	eb 14                	jmp    f0123d70 <alloc_block+0xe9>
f0123d5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d5f:	8b 40 04             	mov    0x4(%eax),%eax
f0123d62:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0123d65:	c1 e2 04             	shl    $0x4,%edx
f0123d68:	81 c2 e4 52 96 f1    	add    $0xf19652e4,%edx
f0123d6e:	89 02                	mov    %eax,(%edx)
f0123d70:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d73:	8b 40 04             	mov    0x4(%eax),%eax
f0123d76:	85 c0                	test   %eax,%eax
f0123d78:	74 0f                	je     f0123d89 <alloc_block+0x102>
f0123d7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d7d:	8b 40 04             	mov    0x4(%eax),%eax
f0123d80:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123d83:	8b 12                	mov    (%edx),%edx
f0123d85:	89 10                	mov    %edx,(%eax)
f0123d87:	eb 13                	jmp    f0123d9c <alloc_block+0x115>
f0123d89:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d8c:	8b 00                	mov    (%eax),%eax
f0123d8e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0123d91:	c1 e2 04             	shl    $0x4,%edx
f0123d94:	81 c2 e0 52 96 f1    	add    $0xf19652e0,%edx
f0123d9a:	89 02                	mov    %eax,(%edx)
f0123d9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123d9f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123da5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123da8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123daf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123db2:	c1 e0 04             	shl    $0x4,%eax
f0123db5:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0123dba:	8b 00                	mov    (%eax),%eax
f0123dbc:	8d 50 ff             	lea    -0x1(%eax),%edx
f0123dbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123dc2:	c1 e0 04             	shl    $0x4,%eax
f0123dc5:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0123dca:	89 10                	mov    %edx,(%eax)
        to_page_info((uint32) e)->num_of_free_blocks--;
f0123dcc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123dcf:	83 ec 0c             	sub    $0xc,%esp
f0123dd2:	50                   	push   %eax
f0123dd3:	e8 12 fc ff ff       	call   f01239ea <to_page_info>
f0123dd8:	83 c4 10             	add    $0x10,%esp
f0123ddb:	89 c2                	mov    %eax,%edx
f0123ddd:	66 8b 42 0a          	mov    0xa(%edx),%ax
f0123de1:	48                   	dec    %eax
f0123de2:	66 89 42 0a          	mov    %ax,0xa(%edx)
        return (void *)e;
f0123de6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123de9:	e9 8b 03 00 00       	jmp    f0124179 <alloc_block+0x4f2>
    }

    // CASE 2: allocate a new page
    if (!LIST_EMPTY(&freePagesList)) {
f0123dee:	a1 f4 ce 94 f1       	mov    0xf194cef4,%eax
f0123df3:	85 c0                	test   %eax,%eax
f0123df5:	0f 84 64 02 00 00    	je     f012405f <alloc_block+0x3d8>
        struct PageInfoElement *page_info_e = LIST_FIRST(&freePagesList);
f0123dfb:	a1 f4 ce 94 f1       	mov    0xf194cef4,%eax
f0123e00:	89 45 dc             	mov    %eax,-0x24(%ebp)
        LIST_REMOVE(&freePagesList, page_info_e);
f0123e03:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123e07:	75 17                	jne    f0123e20 <alloc_block+0x199>
f0123e09:	83 ec 04             	sub    $0x4,%esp
f0123e0c:	68 bd 0c 14 f0       	push   $0xf0140cbd
f0123e11:	68 a0 00 00 00       	push   $0xa0
f0123e16:	68 23 0c 14 f0       	push   $0xf0140c23
f0123e1b:	e8 8f d0 fd ff       	call   f0100eaf <_panic>
f0123e20:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e23:	8b 00                	mov    (%eax),%eax
f0123e25:	85 c0                	test   %eax,%eax
f0123e27:	74 10                	je     f0123e39 <alloc_block+0x1b2>
f0123e29:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e2c:	8b 00                	mov    (%eax),%eax
f0123e2e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123e31:	8b 52 04             	mov    0x4(%edx),%edx
f0123e34:	89 50 04             	mov    %edx,0x4(%eax)
f0123e37:	eb 0b                	jmp    f0123e44 <alloc_block+0x1bd>
f0123e39:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e3c:	8b 40 04             	mov    0x4(%eax),%eax
f0123e3f:	a3 f8 ce 94 f1       	mov    %eax,0xf194cef8
f0123e44:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e47:	8b 40 04             	mov    0x4(%eax),%eax
f0123e4a:	85 c0                	test   %eax,%eax
f0123e4c:	74 0f                	je     f0123e5d <alloc_block+0x1d6>
f0123e4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e51:	8b 40 04             	mov    0x4(%eax),%eax
f0123e54:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123e57:	8b 12                	mov    (%edx),%edx
f0123e59:	89 10                	mov    %edx,(%eax)
f0123e5b:	eb 0a                	jmp    f0123e67 <alloc_block+0x1e0>
f0123e5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e60:	8b 00                	mov    (%eax),%eax
f0123e62:	a3 f4 ce 94 f1       	mov    %eax,0xf194cef4
f0123e67:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123e70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123e73:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123e7a:	a1 00 cf 94 f1       	mov    0xf194cf00,%eax
f0123e7f:	48                   	dec    %eax
f0123e80:	a3 00 cf 94 f1       	mov    %eax,0xf194cf00

        page_info_e->block_size = pow;
f0123e85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123e88:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123e8b:	66 89 42 08          	mov    %ax,0x8(%edx)
        page_info_e->num_of_free_blocks = PAGE_SIZE / pow;
f0123e8f:	b8 00 10 00 00       	mov    $0x1000,%eax
f0123e94:	99                   	cltd   
f0123e95:	f7 7d e8             	idivl  -0x18(%ebp)
f0123e98:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123e9b:	66 89 42 0a          	mov    %ax,0xa(%edx)

        uint32 page_address = to_page_va(page_info_e);
f0123e9f:	83 ec 0c             	sub    $0xc,%esp
f0123ea2:	ff 75 dc             	pushl  -0x24(%ebp)
f0123ea5:	e8 ce fa ff ff       	call   f0123978 <to_page_va>
f0123eaa:	83 c4 10             	add    $0x10,%esp
f0123ead:	89 45 d8             	mov    %eax,-0x28(%ebp)
        get_page((void *)page_address);
f0123eb0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123eb3:	83 ec 0c             	sub    $0xc,%esp
f0123eb6:	50                   	push   %eax
f0123eb7:	e8 1d 6f fe ff       	call   f010add9 <get_page>
f0123ebc:	83 c4 10             	add    $0x10,%esp

        for (int i = 0; i < PAGE_SIZE / pow; ++i) {
f0123ebf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0123ec6:	e9 aa 00 00 00       	jmp    f0123f75 <alloc_block+0x2ee>
            struct BlockElement *block = (struct BlockElement *)(page_address + i * pow);
f0123ecb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123ece:	0f af 45 e8          	imul   -0x18(%ebp),%eax
f0123ed2:	89 c2                	mov    %eax,%edx
f0123ed4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123ed7:	01 d0                	add    %edx,%eax
f0123ed9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            LIST_INSERT_TAIL(&freeBlockLists[index], block);
f0123edc:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0123ee0:	75 17                	jne    f0123ef9 <alloc_block+0x272>
f0123ee2:	83 ec 04             	sub    $0x4,%esp
f0123ee5:	68 dc 0c 14 f0       	push   $0xf0140cdc
f0123eea:	68 aa 00 00 00       	push   $0xaa
f0123eef:	68 23 0c 14 f0       	push   $0xf0140c23
f0123ef4:	e8 b6 cf fd ff       	call   f0100eaf <_panic>
f0123ef9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123efc:	c1 e0 04             	shl    $0x4,%eax
f0123eff:	05 e4 52 96 f1       	add    $0xf19652e4,%eax
f0123f04:	8b 10                	mov    (%eax),%edx
f0123f06:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123f09:	89 50 04             	mov    %edx,0x4(%eax)
f0123f0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123f0f:	8b 40 04             	mov    0x4(%eax),%eax
f0123f12:	85 c0                	test   %eax,%eax
f0123f14:	74 14                	je     f0123f2a <alloc_block+0x2a3>
f0123f16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123f19:	c1 e0 04             	shl    $0x4,%eax
f0123f1c:	05 e4 52 96 f1       	add    $0xf19652e4,%eax
f0123f21:	8b 00                	mov    (%eax),%eax
f0123f23:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0123f26:	89 10                	mov    %edx,(%eax)
f0123f28:	eb 11                	jmp    f0123f3b <alloc_block+0x2b4>
f0123f2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123f2d:	c1 e0 04             	shl    $0x4,%eax
f0123f30:	8d 90 e0 52 96 f1    	lea    -0xe69ad20(%eax),%edx
f0123f36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123f39:	89 02                	mov    %eax,(%edx)
f0123f3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123f3e:	c1 e0 04             	shl    $0x4,%eax
f0123f41:	8d 90 e4 52 96 f1    	lea    -0xe69ad1c(%eax),%edx
f0123f47:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123f4a:	89 02                	mov    %eax,(%edx)
f0123f4c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123f4f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123f55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123f58:	c1 e0 04             	shl    $0x4,%eax
f0123f5b:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0123f60:	8b 00                	mov    (%eax),%eax
f0123f62:	8d 50 01             	lea    0x1(%eax),%edx
f0123f65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123f68:	c1 e0 04             	shl    $0x4,%eax
f0123f6b:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0123f70:	89 10                	mov    %edx,(%eax)
        page_info_e->num_of_free_blocks = PAGE_SIZE / pow;

        uint32 page_address = to_page_va(page_info_e);
        get_page((void *)page_address);

        for (int i = 0; i < PAGE_SIZE / pow; ++i) {
f0123f72:	ff 45 f4             	incl   -0xc(%ebp)
f0123f75:	b8 00 10 00 00       	mov    $0x1000,%eax
f0123f7a:	99                   	cltd   
f0123f7b:	f7 7d e8             	idivl  -0x18(%ebp)
f0123f7e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0123f81:	0f 8f 44 ff ff ff    	jg     f0123ecb <alloc_block+0x244>
            struct BlockElement *block = (struct BlockElement *)(page_address + i * pow);
            LIST_INSERT_TAIL(&freeBlockLists[index], block);
        }

        struct BlockElement *e = LIST_FIRST(&freeBlockLists[index]);
f0123f87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123f8a:	c1 e0 04             	shl    $0x4,%eax
f0123f8d:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f0123f92:	8b 00                	mov    (%eax),%eax
f0123f94:	89 45 d0             	mov    %eax,-0x30(%ebp)
        LIST_REMOVE(&freeBlockLists[index], e);
f0123f97:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0123f9b:	75 17                	jne    f0123fb4 <alloc_block+0x32d>
f0123f9d:	83 ec 04             	sub    $0x4,%esp
f0123fa0:	68 bd 0c 14 f0       	push   $0xf0140cbd
f0123fa5:	68 ae 00 00 00       	push   $0xae
f0123faa:	68 23 0c 14 f0       	push   $0xf0140c23
f0123faf:	e8 fb ce fd ff       	call   f0100eaf <_panic>
f0123fb4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123fb7:	8b 00                	mov    (%eax),%eax
f0123fb9:	85 c0                	test   %eax,%eax
f0123fbb:	74 10                	je     f0123fcd <alloc_block+0x346>
f0123fbd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123fc0:	8b 00                	mov    (%eax),%eax
f0123fc2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0123fc5:	8b 52 04             	mov    0x4(%edx),%edx
f0123fc8:	89 50 04             	mov    %edx,0x4(%eax)
f0123fcb:	eb 14                	jmp    f0123fe1 <alloc_block+0x35a>
f0123fcd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123fd0:	8b 40 04             	mov    0x4(%eax),%eax
f0123fd3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0123fd6:	c1 e2 04             	shl    $0x4,%edx
f0123fd9:	81 c2 e4 52 96 f1    	add    $0xf19652e4,%edx
f0123fdf:	89 02                	mov    %eax,(%edx)
f0123fe1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123fe4:	8b 40 04             	mov    0x4(%eax),%eax
f0123fe7:	85 c0                	test   %eax,%eax
f0123fe9:	74 0f                	je     f0123ffa <alloc_block+0x373>
f0123feb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123fee:	8b 40 04             	mov    0x4(%eax),%eax
f0123ff1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0123ff4:	8b 12                	mov    (%edx),%edx
f0123ff6:	89 10                	mov    %edx,(%eax)
f0123ff8:	eb 13                	jmp    f012400d <alloc_block+0x386>
f0123ffa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123ffd:	8b 00                	mov    (%eax),%eax
f0123fff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0124002:	c1 e2 04             	shl    $0x4,%edx
f0124005:	81 c2 e0 52 96 f1    	add    $0xf19652e0,%edx
f012400b:	89 02                	mov    %eax,(%edx)
f012400d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0124010:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0124016:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0124019:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0124020:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0124023:	c1 e0 04             	shl    $0x4,%eax
f0124026:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f012402b:	8b 00                	mov    (%eax),%eax
f012402d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0124030:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0124033:	c1 e0 04             	shl    $0x4,%eax
f0124036:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f012403b:	89 10                	mov    %edx,(%eax)
        to_page_info((uint32) e)->num_of_free_blocks--;
f012403d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0124040:	83 ec 0c             	sub    $0xc,%esp
f0124043:	50                   	push   %eax
f0124044:	e8 a1 f9 ff ff       	call   f01239ea <to_page_info>
f0124049:	83 c4 10             	add    $0x10,%esp
f012404c:	89 c2                	mov    %eax,%edx
f012404e:	66 8b 42 0a          	mov    0xa(%edx),%ax
f0124052:	48                   	dec    %eax
f0124053:	66 89 42 0a          	mov    %ax,0xa(%edx)

        return (void *)e;
f0124057:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012405a:	e9 1a 01 00 00       	jmp    f0124179 <alloc_block+0x4f2>
    }

    // CASE 3
    for (int i = index + 1; i <= LOG2_MAX_SIZE - LOG2_MIN_SIZE; ++i) {
f012405f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0124062:	40                   	inc    %eax
f0124063:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0124066:	e9 ed 00 00 00       	jmp    f0124158 <alloc_block+0x4d1>
        if (!LIST_EMPTY(&freeBlockLists[i])) {
f012406b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012406e:	c1 e0 04             	shl    $0x4,%eax
f0124071:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f0124076:	8b 00                	mov    (%eax),%eax
f0124078:	85 c0                	test   %eax,%eax
f012407a:	0f 84 d5 00 00 00    	je     f0124155 <alloc_block+0x4ce>
            struct BlockElement *e = LIST_FIRST(&freeBlockLists[i]);
f0124080:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124083:	c1 e0 04             	shl    $0x4,%eax
f0124086:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f012408b:	8b 00                	mov    (%eax),%eax
f012408d:	89 45 cc             	mov    %eax,-0x34(%ebp)
            LIST_REMOVE(&freeBlockLists[i], e);
f0124090:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0124094:	75 17                	jne    f01240ad <alloc_block+0x426>
f0124096:	83 ec 04             	sub    $0x4,%esp
f0124099:	68 bd 0c 14 f0       	push   $0xf0140cbd
f012409e:	68 b8 00 00 00       	push   $0xb8
f01240a3:	68 23 0c 14 f0       	push   $0xf0140c23
f01240a8:	e8 02 ce fd ff       	call   f0100eaf <_panic>
f01240ad:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01240b0:	8b 00                	mov    (%eax),%eax
f01240b2:	85 c0                	test   %eax,%eax
f01240b4:	74 10                	je     f01240c6 <alloc_block+0x43f>
f01240b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01240b9:	8b 00                	mov    (%eax),%eax
f01240bb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01240be:	8b 52 04             	mov    0x4(%edx),%edx
f01240c1:	89 50 04             	mov    %edx,0x4(%eax)
f01240c4:	eb 14                	jmp    f01240da <alloc_block+0x453>
f01240c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01240c9:	8b 40 04             	mov    0x4(%eax),%eax
f01240cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01240cf:	c1 e2 04             	shl    $0x4,%edx
f01240d2:	81 c2 e4 52 96 f1    	add    $0xf19652e4,%edx
f01240d8:	89 02                	mov    %eax,(%edx)
f01240da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01240dd:	8b 40 04             	mov    0x4(%eax),%eax
f01240e0:	85 c0                	test   %eax,%eax
f01240e2:	74 0f                	je     f01240f3 <alloc_block+0x46c>
f01240e4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01240e7:	8b 40 04             	mov    0x4(%eax),%eax
f01240ea:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01240ed:	8b 12                	mov    (%edx),%edx
f01240ef:	89 10                	mov    %edx,(%eax)
f01240f1:	eb 13                	jmp    f0124106 <alloc_block+0x47f>
f01240f3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01240f6:	8b 00                	mov    (%eax),%eax
f01240f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01240fb:	c1 e2 04             	shl    $0x4,%edx
f01240fe:	81 c2 e0 52 96 f1    	add    $0xf19652e0,%edx
f0124104:	89 02                	mov    %eax,(%edx)
f0124106:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0124109:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012410f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0124112:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0124119:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012411c:	c1 e0 04             	shl    $0x4,%eax
f012411f:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0124124:	8b 00                	mov    (%eax),%eax
f0124126:	8d 50 ff             	lea    -0x1(%eax),%edx
f0124129:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012412c:	c1 e0 04             	shl    $0x4,%eax
f012412f:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0124134:	89 10                	mov    %edx,(%eax)
            to_page_info((uint32) e)->num_of_free_blocks--;
f0124136:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0124139:	83 ec 0c             	sub    $0xc,%esp
f012413c:	50                   	push   %eax
f012413d:	e8 a8 f8 ff ff       	call   f01239ea <to_page_info>
f0124142:	83 c4 10             	add    $0x10,%esp
f0124145:	89 c2                	mov    %eax,%edx
f0124147:	66 8b 42 0a          	mov    0xa(%edx),%ax
f012414b:	48                   	dec    %eax
f012414c:	66 89 42 0a          	mov    %ax,0xa(%edx)
            return (void *)e;
f0124150:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0124153:	eb 24                	jmp    f0124179 <alloc_block+0x4f2>

        return (void *)e;
    }

    // CASE 3
    for (int i = index + 1; i <= LOG2_MAX_SIZE - LOG2_MIN_SIZE; ++i) {
f0124155:	ff 45 f0             	incl   -0x10(%ebp)
f0124158:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
f012415c:	0f 8e 09 ff ff ff    	jle    f012406b <alloc_block+0x3e4>
            return (void *)e;
        }
    }

    // CASE 4:
    panic("...");
f0124162:	83 ec 04             	sub    $0x4,%esp
f0124165:	68 ff 0c 14 f0       	push   $0xf0140cff
f012416a:	68 bf 00 00 00       	push   $0xbf
f012416f:	68 23 0c 14 f0       	push   $0xf0140c23
f0124174:	e8 36 cd fd ff       	call   f0100eaf <_panic>

	//Comment the following line
	//panic("alloc_block() Not implemented yet");

	//TODO: [PROJECT'25.BONUS#1] DYNAMIC ALLOCATOR - block if no free block
}
f0124179:	c9                   	leave  
f012417a:	c3                   	ret    

f012417b <log2_ceil.1520>:
        x--;
        while (x >>= 1) power <<= 1;
        return power;
    }

    inline unsigned int log2_ceil(unsigned int x) {
f012417b:	55                   	push   %ebp
f012417c:	89 e5                	mov    %esp,%ebp
f012417e:	83 ec 14             	sub    $0x14,%esp
f0124181:	89 4d ec             	mov    %ecx,-0x14(%ebp)
        if (x == 0) return 0;
f0124184:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0124188:	75 07                	jne    f0124191 <log2_ceil.1520+0x16>
f012418a:	b8 00 00 00 00       	mov    $0x0,%eax
f012418f:	eb 1b                	jmp    f01241ac <log2_ceil.1520+0x31>
        int bits_cnt = 0;
f0124191:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        x--;
f0124198:	ff 4d 08             	decl   0x8(%ebp)
        while (x > 0) {
f012419b:	eb 06                	jmp    f01241a3 <log2_ceil.1520+0x28>
            x >>= 1;
f012419d:	d1 6d 08             	shrl   0x8(%ebp)
            bits_cnt++;
f01241a0:	ff 45 fc             	incl   -0x4(%ebp)

    inline unsigned int log2_ceil(unsigned int x) {
        if (x == 0) return 0;
        int bits_cnt = 0;
        x--;
        while (x > 0) {
f01241a3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01241a7:	75 f4                	jne    f012419d <log2_ceil.1520+0x22>
            x >>= 1;
            bits_cnt++;
        }
        return bits_cnt;
f01241a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    }
f01241ac:	c9                   	leave  
f01241ad:	c3                   	ret    

f01241ae <log2_ceil.1547>:
	//==================================================================================

	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #4 free_block
	//Your code is here

	inline unsigned int log2_ceil(unsigned int x) {
f01241ae:	55                   	push   %ebp
f01241af:	89 e5                	mov    %esp,%ebp
f01241b1:	83 ec 14             	sub    $0x14,%esp
f01241b4:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		if (x == 0) return 0;
f01241b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01241bb:	75 07                	jne    f01241c4 <log2_ceil.1547+0x16>
f01241bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01241c2:	eb 1b                	jmp    f01241df <log2_ceil.1547+0x31>
		int bits_cnt = 0;
f01241c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
		x--;
f01241cb:	ff 4d 08             	decl   0x8(%ebp)
		while (x > 0) {
f01241ce:	eb 06                	jmp    f01241d6 <log2_ceil.1547+0x28>
			x >>= 1;
f01241d0:	d1 6d 08             	shrl   0x8(%ebp)
			bits_cnt++;
f01241d3:	ff 45 fc             	incl   -0x4(%ebp)

	inline unsigned int log2_ceil(unsigned int x) {
		if (x == 0) return 0;
		int bits_cnt = 0;
		x--;
		while (x > 0) {
f01241d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01241da:	75 f4                	jne    f01241d0 <log2_ceil.1547+0x22>
			x >>= 1;
			bits_cnt++;
		}
		return bits_cnt;
f01241dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
	}
f01241df:	c9                   	leave  
f01241e0:	c3                   	ret    

f01241e1 <free_block>:

//===========================
// [4] FREE BLOCK:
//===========================
void free_block(void *va)
{
f01241e1:	55                   	push   %ebp
f01241e2:	89 e5                	mov    %esp,%ebp
f01241e4:	83 ec 38             	sub    $0x38,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert((uint32)va >= dynAllocStart && (uint32)va < dynAllocEnd);
f01241e7:	8b 55 08             	mov    0x8(%ebp),%edx
f01241ea:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f01241ef:	39 c2                	cmp    %eax,%edx
f01241f1:	72 0c                	jb     f01241ff <free_block+0x1e>
f01241f3:	8b 55 08             	mov    0x8(%ebp),%edx
f01241f6:	a1 e0 cb 94 f1       	mov    0xf194cbe0,%eax
f01241fb:	39 c2                	cmp    %eax,%edx
f01241fd:	72 19                	jb     f0124218 <free_block+0x37>
f01241ff:	68 04 0d 14 f0       	push   $0xf0140d04
f0124204:	68 86 0c 14 f0       	push   $0xf0140c86
f0124209:	68 d0 00 00 00       	push   $0xd0
f012420e:	68 23 0c 14 f0       	push   $0xf0140c23
f0124213:	e8 97 cc fd ff       	call   f0100eaf <_panic>
			bits_cnt++;
		}
		return bits_cnt;
	}

	if(va==NULL) return;
f0124218:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012421c:	0f 84 42 03 00 00    	je     f0124564 <free_block+0x383>

	if ((uint32)va < dynAllocStart || (uint32)va >= dynAllocEnd) {
f0124222:	8b 55 08             	mov    0x8(%ebp),%edx
f0124225:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f012422a:	39 c2                	cmp    %eax,%edx
f012422c:	72 0c                	jb     f012423a <free_block+0x59>
f012422e:	8b 55 08             	mov    0x8(%ebp),%edx
f0124231:	a1 e0 cb 94 f1       	mov    0xf194cbe0,%eax
f0124236:	39 c2                	cmp    %eax,%edx
f0124238:	72 17                	jb     f0124251 <free_block+0x70>
		panic("free_block: address outside dynamic allocator range");
f012423a:	83 ec 04             	sub    $0x4,%esp
f012423d:	68 3c 0d 14 f0       	push   $0xf0140d3c
f0124242:	68 e6 00 00 00       	push   $0xe6
f0124247:	68 23 0c 14 f0       	push   $0xf0140c23
f012424c:	e8 5e cc fd ff       	call   f0100eaf <_panic>
	}

	if (((uint32)va - dynAllocStart) % DYN_ALLOC_MIN_BLOCK_SIZE != 0) {
f0124251:	8b 55 08             	mov    0x8(%ebp),%edx
f0124254:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f0124259:	29 c2                	sub    %eax,%edx
f012425b:	89 d0                	mov    %edx,%eax
f012425d:	83 e0 07             	and    $0x7,%eax
f0124260:	85 c0                	test   %eax,%eax
f0124262:	74 17                	je     f012427b <free_block+0x9a>
		panic("free_block: address is not properly aligned");
f0124264:	83 ec 04             	sub    $0x4,%esp
f0124267:	68 70 0d 14 f0       	push   $0xf0140d70
f012426c:	68 ea 00 00 00       	push   $0xea
f0124271:	68 23 0c 14 f0       	push   $0xf0140c23
f0124276:	e8 34 cc fd ff       	call   f0100eaf <_panic>
	}

	struct PageInfoElement *page_info_e = to_page_info((uint32) va);
f012427b:	8b 45 08             	mov    0x8(%ebp),%eax
f012427e:	83 ec 0c             	sub    $0xc,%esp
f0124281:	50                   	push   %eax
f0124282:	e8 63 f7 ff ff       	call   f01239ea <to_page_info>
f0124287:	83 c4 10             	add    $0x10,%esp
f012428a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int size = get_block_size(va);
f012428d:	83 ec 0c             	sub    $0xc,%esp
f0124290:	ff 75 08             	pushl  0x8(%ebp)
f0124293:	e8 87 f9 ff ff       	call   f0123c1f <get_block_size>
f0124298:	83 c4 10             	add    $0x10,%esp
f012429b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (size == 0) {
f012429e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01242a2:	75 17                	jne    f01242bb <free_block+0xda>
		panic("free_block: attempting to free from unallocated page (double free detected)");
f01242a4:	83 ec 04             	sub    $0x4,%esp
f01242a7:	68 9c 0d 14 f0       	push   $0xf0140d9c
f01242ac:	68 f1 00 00 00       	push   $0xf1
f01242b1:	68 23 0c 14 f0       	push   $0xf0140c23
f01242b6:	e8 f4 cb fd ff       	call   f0100eaf <_panic>
	}

    int index = log2_ceil(size) - LOG2_MIN_SIZE;
f01242bb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01242be:	83 ec 0c             	sub    $0xc,%esp
f01242c1:	8d 45 d0             	lea    -0x30(%ebp),%eax
f01242c4:	52                   	push   %edx
f01242c5:	89 c1                	mov    %eax,%ecx
f01242c7:	e8 e2 fe ff ff       	call   f01241ae <log2_ceil.1547>
f01242cc:	83 c4 10             	add    $0x10,%esp
f01242cf:	83 e8 03             	sub    $0x3,%eax
f01242d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    struct BlockElement * block = (struct BlockElement *) va;
f01242d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01242d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    LIST_INSERT_HEAD(&freeBlockLists[index], block);
f01242db:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01242df:	75 17                	jne    f01242f8 <free_block+0x117>
f01242e1:	83 ec 04             	sub    $0x4,%esp
f01242e4:	68 e8 0d 14 f0       	push   $0xf0140de8
f01242e9:	68 f6 00 00 00       	push   $0xf6
f01242ee:	68 23 0c 14 f0       	push   $0xf0140c23
f01242f3:	e8 b7 cb fd ff       	call   f0100eaf <_panic>
f01242f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01242fb:	c1 e0 04             	shl    $0x4,%eax
f01242fe:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f0124303:	8b 10                	mov    (%eax),%edx
f0124305:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0124308:	89 10                	mov    %edx,(%eax)
f012430a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012430d:	8b 00                	mov    (%eax),%eax
f012430f:	85 c0                	test   %eax,%eax
f0124311:	74 15                	je     f0124328 <free_block+0x147>
f0124313:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0124316:	c1 e0 04             	shl    $0x4,%eax
f0124319:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f012431e:	8b 00                	mov    (%eax),%eax
f0124320:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0124323:	89 50 04             	mov    %edx,0x4(%eax)
f0124326:	eb 11                	jmp    f0124339 <free_block+0x158>
f0124328:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012432b:	c1 e0 04             	shl    $0x4,%eax
f012432e:	8d 90 e4 52 96 f1    	lea    -0xe69ad1c(%eax),%edx
f0124334:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0124337:	89 02                	mov    %eax,(%edx)
f0124339:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012433c:	c1 e0 04             	shl    $0x4,%eax
f012433f:	8d 90 e0 52 96 f1    	lea    -0xe69ad20(%eax),%edx
f0124345:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0124348:	89 02                	mov    %eax,(%edx)
f012434a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012434d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0124354:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0124357:	c1 e0 04             	shl    $0x4,%eax
f012435a:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f012435f:	8b 00                	mov    (%eax),%eax
f0124361:	8d 50 01             	lea    0x1(%eax),%edx
f0124364:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0124367:	c1 e0 04             	shl    $0x4,%eax
f012436a:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f012436f:	89 10                	mov    %edx,(%eax)
    page_info_e->num_of_free_blocks++;
f0124371:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0124374:	66 8b 40 0a          	mov    0xa(%eax),%ax
f0124378:	40                   	inc    %eax
f0124379:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012437c:	66 89 42 0a          	mov    %ax,0xa(%edx)

	uint32 page_index = ((uint32) va - dynAllocStart) / PAGE_SIZE;
f0124380:	8b 55 08             	mov    0x8(%ebp),%edx
f0124383:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f0124388:	29 c2                	sub    %eax,%edx
f012438a:	89 d0                	mov    %edx,%eax
f012438c:	c1 e8 0c             	shr    $0xc,%eax
f012438f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(page_info_e->num_of_free_blocks == PAGE_SIZE / size){
f0124392:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0124395:	66 8b 40 0a          	mov    0xa(%eax),%ax
f0124399:	0f b7 c8             	movzwl %ax,%ecx
f012439c:	b8 00 10 00 00       	mov    $0x1000,%eax
f01243a1:	99                   	cltd   
f01243a2:	f7 7d e8             	idivl  -0x18(%ebp)
f01243a5:	39 c1                	cmp    %eax,%ecx
f01243a7:	0f 85 b8 01 00 00    	jne    f0124565 <free_block+0x384>
    	uint32 blocks_removed = 0;
f01243ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    	 struct BlockElement *element = LIST_FIRST(&freeBlockLists[index]);
f01243b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01243b7:	c1 e0 04             	shl    $0x4,%eax
f01243ba:	05 e0 52 96 f1       	add    $0xf19652e0,%eax
f01243bf:	8b 00                	mov    (%eax),%eax
f01243c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    	 struct BlockElement *tmp;

    	 while(element != NULL){
f01243c4:	e9 d5 00 00 00       	jmp    f012449e <free_block+0x2bd>
		 tmp = LIST_NEXT(element);
f01243c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01243cc:	8b 00                	mov    (%eax),%eax
f01243ce:	89 45 d8             	mov    %eax,-0x28(%ebp)
		 uint32 page_indexB = ((uint32)element - dynAllocStart) / PAGE_SIZE;
f01243d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01243d4:	a1 bc 51 96 f1       	mov    0xf19651bc,%eax
f01243d9:	29 c2                	sub    %eax,%edx
f01243db:	89 d0                	mov    %edx,%eax
f01243dd:	c1 e8 0c             	shr    $0xc,%eax
f01243e0:	89 45 d4             	mov    %eax,-0x2c(%ebp)

		 if (page_indexB == page_index){
f01243e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01243e6:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01243e9:	0f 85 a9 00 00 00    	jne    f0124498 <free_block+0x2b7>
				 LIST_REMOVE(&freeBlockLists[index], element);
f01243ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01243f3:	75 17                	jne    f012440c <free_block+0x22b>
f01243f5:	83 ec 04             	sub    $0x4,%esp
f01243f8:	68 bd 0c 14 f0       	push   $0xf0140cbd
f01243fd:	68 04 01 00 00       	push   $0x104
f0124402:	68 23 0c 14 f0       	push   $0xf0140c23
f0124407:	e8 a3 ca fd ff       	call   f0100eaf <_panic>
f012440c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012440f:	8b 00                	mov    (%eax),%eax
f0124411:	85 c0                	test   %eax,%eax
f0124413:	74 10                	je     f0124425 <free_block+0x244>
f0124415:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124418:	8b 00                	mov    (%eax),%eax
f012441a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012441d:	8b 52 04             	mov    0x4(%edx),%edx
f0124420:	89 50 04             	mov    %edx,0x4(%eax)
f0124423:	eb 14                	jmp    f0124439 <free_block+0x258>
f0124425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124428:	8b 40 04             	mov    0x4(%eax),%eax
f012442b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012442e:	c1 e2 04             	shl    $0x4,%edx
f0124431:	81 c2 e4 52 96 f1    	add    $0xf19652e4,%edx
f0124437:	89 02                	mov    %eax,(%edx)
f0124439:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012443c:	8b 40 04             	mov    0x4(%eax),%eax
f012443f:	85 c0                	test   %eax,%eax
f0124441:	74 0f                	je     f0124452 <free_block+0x271>
f0124443:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124446:	8b 40 04             	mov    0x4(%eax),%eax
f0124449:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012444c:	8b 12                	mov    (%edx),%edx
f012444e:	89 10                	mov    %edx,(%eax)
f0124450:	eb 13                	jmp    f0124465 <free_block+0x284>
f0124452:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124455:	8b 00                	mov    (%eax),%eax
f0124457:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012445a:	c1 e2 04             	shl    $0x4,%edx
f012445d:	81 c2 e0 52 96 f1    	add    $0xf19652e0,%edx
f0124463:	89 02                	mov    %eax,(%edx)
f0124465:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124468:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012446e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0124471:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0124478:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012447b:	c1 e0 04             	shl    $0x4,%eax
f012447e:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0124483:	8b 00                	mov    (%eax),%eax
f0124485:	8d 50 ff             	lea    -0x1(%eax),%edx
f0124488:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012448b:	c1 e0 04             	shl    $0x4,%eax
f012448e:	05 ec 52 96 f1       	add    $0xf19652ec,%eax
f0124493:	89 10                	mov    %edx,(%eax)
				 blocks_removed++;
f0124495:	ff 45 f4             	incl   -0xc(%ebp)
			 }

		 	 element = tmp;
f0124498:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012449b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_info_e->num_of_free_blocks == PAGE_SIZE / size){
    	uint32 blocks_removed = 0;
    	 struct BlockElement *element = LIST_FIRST(&freeBlockLists[index]);
    	 struct BlockElement *tmp;

    	 while(element != NULL){
f012449e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01244a2:	0f 85 21 ff ff ff    	jne    f01243c9 <free_block+0x1e8>
			 }

		 	 element = tmp;
    	 }

    	 if (blocks_removed != PAGE_SIZE / size) {
f01244a8:	b8 00 10 00 00       	mov    $0x1000,%eax
f01244ad:	99                   	cltd   
f01244ae:	f7 7d e8             	idivl  -0x18(%ebp)
f01244b1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01244b4:	74 17                	je     f01244cd <free_block+0x2ec>
			panic("free_block: mismatch in number of blocks removed");
f01244b6:	83 ec 04             	sub    $0x4,%esp
f01244b9:	68 0c 0e 14 f0       	push   $0xf0140e0c
f01244be:	68 0c 01 00 00       	push   $0x10c
f01244c3:	68 23 0c 14 f0       	push   $0xf0140c23
f01244c8:	e8 e2 c9 fd ff       	call   f0100eaf <_panic>
		}

    	page_info_e->num_of_free_blocks = 0;
f01244cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01244d0:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
        page_info_e->block_size = 0;
f01244d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01244d9:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
        LIST_INSERT_TAIL(&freePagesList, page_info_e);
f01244df:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01244e3:	75 17                	jne    f01244fc <free_block+0x31b>
f01244e5:	83 ec 04             	sub    $0x4,%esp
f01244e8:	68 dc 0c 14 f0       	push   $0xf0140cdc
f01244ed:	68 11 01 00 00       	push   $0x111
f01244f2:	68 23 0c 14 f0       	push   $0xf0140c23
f01244f7:	e8 b3 c9 fd ff       	call   f0100eaf <_panic>
f01244fc:	8b 15 f8 ce 94 f1    	mov    0xf194cef8,%edx
f0124502:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0124505:	89 50 04             	mov    %edx,0x4(%eax)
f0124508:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012450b:	8b 40 04             	mov    0x4(%eax),%eax
f012450e:	85 c0                	test   %eax,%eax
f0124510:	74 0c                	je     f012451e <free_block+0x33d>
f0124512:	a1 f8 ce 94 f1       	mov    0xf194cef8,%eax
f0124517:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012451a:	89 10                	mov    %edx,(%eax)
f012451c:	eb 08                	jmp    f0124526 <free_block+0x345>
f012451e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0124521:	a3 f4 ce 94 f1       	mov    %eax,0xf194cef4
f0124526:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0124529:	a3 f8 ce 94 f1       	mov    %eax,0xf194cef8
f012452e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0124531:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0124537:	a1 00 cf 94 f1       	mov    0xf194cf00,%eax
f012453c:	40                   	inc    %eax
f012453d:	a3 00 cf 94 f1       	mov    %eax,0xf194cf00

        uint32 pp = to_page_va(page_info_e);
f0124542:	83 ec 0c             	sub    $0xc,%esp
f0124545:	ff 75 ec             	pushl  -0x14(%ebp)
f0124548:	e8 2b f4 ff ff       	call   f0123978 <to_page_va>
f012454d:	83 c4 10             	add    $0x10,%esp
f0124550:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return_page((void*) pp);
f0124553:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0124556:	83 ec 0c             	sub    $0xc,%esp
f0124559:	50                   	push   %eax
f012455a:	e8 19 69 fe ff       	call   f010ae78 <return_page>
f012455f:	83 c4 10             	add    $0x10,%esp
f0124562:	eb 01                	jmp    f0124565 <free_block+0x384>
			bits_cnt++;
		}
		return bits_cnt;
	}

	if(va==NULL) return;
f0124564:	90                   	nop
        return_page((void*) pp);
    }

	//Comment the following line
	//panic("free_block() Not implemented yet");
}
f0124565:	c9                   	leave  
f0124566:	c3                   	ret    

f0124567 <nearest_pow2_ceil.1572>:

  // Get current block size
  uint32 current_size = get_block_size(va);

  // If new size fits in current block (same power of 2), return same pointer
  inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0124567:	55                   	push   %ebp
f0124568:	89 e5                	mov    %esp,%ebp
f012456a:	83 ec 14             	sub    $0x14,%esp
f012456d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    if (x <= 1)
f0124570:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0124574:	77 07                	ja     f012457d <nearest_pow2_ceil.1572+0x16>
      return 1;
f0124576:	b8 01 00 00 00       	mov    $0x1,%eax
f012457b:	eb 20                	jmp    f012459d <nearest_pow2_ceil.1572+0x36>
    int power = 2;
f012457d:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
    x--;
f0124584:	ff 4d 08             	decl   0x8(%ebp)
    while (x >>= 1)
f0124587:	eb 08                	jmp    f0124591 <nearest_pow2_ceil.1572+0x2a>
      power <<= 1;
f0124589:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012458c:	01 c0                	add    %eax,%eax
f012458e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  inline unsigned int nearest_pow2_ceil(unsigned int x) {
    if (x <= 1)
      return 1;
    int power = 2;
    x--;
    while (x >>= 1)
f0124591:	d1 6d 08             	shrl   0x8(%ebp)
f0124594:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0124598:	75 ef                	jne    f0124589 <nearest_pow2_ceil.1572+0x22>
      power <<= 1;
    return power;
f012459a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
f012459d:	c9                   	leave  
f012459e:	c3                   	ret    

f012459f <realloc_block>:
//==================================================================================//

//===========================
// [1] REALLOCATE BLOCK:
//===========================
void *realloc_block(void *va, uint32 new_size) {
f012459f:	55                   	push   %ebp
f01245a0:	89 e5                	mov    %esp,%ebp
f01245a2:	83 ec 28             	sub    $0x28,%esp
  // TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - realloc_block
  // Your code is here

  // Handle special cases similar to standard realloc
  if (va == NULL) {
f01245a5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01245a9:	75 13                	jne    f01245be <realloc_block+0x1f>
    return alloc_block(new_size);
f01245ab:	83 ec 0c             	sub    $0xc,%esp
f01245ae:	ff 75 0c             	pushl  0xc(%ebp)
f01245b1:	e8 d1 f6 ff ff       	call   f0123c87 <alloc_block>
f01245b6:	83 c4 10             	add    $0x10,%esp
f01245b9:	e9 d9 00 00 00       	jmp    f0124697 <realloc_block+0xf8>
  }

  if (new_size == 0) {
f01245be:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01245c2:	75 18                	jne    f01245dc <realloc_block+0x3d>
    free_block(va);
f01245c4:	83 ec 0c             	sub    $0xc,%esp
f01245c7:	ff 75 08             	pushl  0x8(%ebp)
f01245ca:	e8 12 fc ff ff       	call   f01241e1 <free_block>
f01245cf:	83 c4 10             	add    $0x10,%esp
    return NULL;
f01245d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01245d7:	e9 bb 00 00 00       	jmp    f0124697 <realloc_block+0xf8>
  }

  // Get current block size
  uint32 current_size = get_block_size(va);
f01245dc:	83 ec 0c             	sub    $0xc,%esp
f01245df:	ff 75 08             	pushl  0x8(%ebp)
f01245e2:	e8 38 f6 ff ff       	call   f0123c1f <get_block_size>
f01245e7:	83 c4 10             	add    $0x10,%esp
f01245ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (x >>= 1)
      power <<= 1;
    return power;
  }

  uint32 min_block_size = 1 << LOG2_MIN_SIZE;
f01245ed:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
  if (new_size < min_block_size)
f01245f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01245f7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01245fa:	73 06                	jae    f0124602 <realloc_block+0x63>
    new_size = min_block_size;
f01245fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01245ff:	89 45 0c             	mov    %eax,0xc(%ebp)

  uint32 new_block_size = nearest_pow2_ceil(new_size);
f0124602:	83 ec 0c             	sub    $0xc,%esp
f0124605:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0124608:	ff 75 0c             	pushl  0xc(%ebp)
f012460b:	89 c1                	mov    %eax,%ecx
f012460d:	e8 55 ff ff ff       	call   f0124567 <nearest_pow2_ceil.1572>
f0124612:	83 c4 10             	add    $0x10,%esp
f0124615:	89 45 e8             	mov    %eax,-0x18(%ebp)

  // If block size doesn't change, return same pointer
  if (new_block_size == current_size) {
f0124618:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012461b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f012461e:	75 05                	jne    f0124625 <realloc_block+0x86>
    return va;
f0124620:	8b 45 08             	mov    0x8(%ebp),%eax
f0124623:	eb 72                	jmp    f0124697 <realloc_block+0xf8>
  }

  // Otherwise, allocate new block and copy data
  void *new_va = alloc_block(new_size);
f0124625:	83 ec 0c             	sub    $0xc,%esp
f0124628:	ff 75 0c             	pushl  0xc(%ebp)
f012462b:	e8 57 f6 ff ff       	call   f0123c87 <alloc_block>
f0124630:	83 c4 10             	add    $0x10,%esp
f0124633:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (new_va == NULL) {
f0124636:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012463a:	75 07                	jne    f0124643 <realloc_block+0xa4>
    return NULL;
f012463c:	b8 00 00 00 00       	mov    $0x0,%eax
f0124641:	eb 54                	jmp    f0124697 <realloc_block+0xf8>
  }

  // Copy data (copy minimum of old and new size)
  uint32 copy_size = (current_size < new_size) ? current_size : new_size;
f0124643:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0124646:	8b 45 0c             	mov    0xc(%ebp),%eax
f0124649:	39 d0                	cmp    %edx,%eax
f012464b:	76 02                	jbe    f012464f <realloc_block+0xb0>
f012464d:	89 d0                	mov    %edx,%eax
f012464f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  uint8 *src = (uint8 *)va;
f0124652:	8b 45 08             	mov    0x8(%ebp),%eax
f0124655:	89 45 dc             	mov    %eax,-0x24(%ebp)
  uint8 *dst = (uint8 *)new_va;
f0124658:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012465b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  for (uint32 i = 0; i < copy_size; i++) {
f012465e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0124665:	eb 17                	jmp    f012467e <realloc_block+0xdf>
    dst[i] = src[i];
f0124667:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012466a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012466d:	01 c2                	add    %eax,%edx
f012466f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0124672:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0124675:	01 c8                	add    %ecx,%eax
f0124677:	8a 00                	mov    (%eax),%al
f0124679:	88 02                	mov    %al,(%edx)

  // Copy data (copy minimum of old and new size)
  uint32 copy_size = (current_size < new_size) ? current_size : new_size;
  uint8 *src = (uint8 *)va;
  uint8 *dst = (uint8 *)new_va;
  for (uint32 i = 0; i < copy_size; i++) {
f012467b:	ff 45 f4             	incl   -0xc(%ebp)
f012467e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0124681:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0124684:	72 e1                	jb     f0124667 <realloc_block+0xc8>
    dst[i] = src[i];
  }

  // Free old block
  free_block(va);
f0124686:	83 ec 0c             	sub    $0xc,%esp
f0124689:	ff 75 08             	pushl  0x8(%ebp)
f012468c:	e8 50 fb ff ff       	call   f01241e1 <free_block>
f0124691:	83 c4 10             	add    $0x10,%esp

  return new_va;
f0124694:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0124697:	c9                   	leave  
f0124698:	c3                   	ret    
f0124699:	66 90                	xchg   %ax,%ax
f012469b:	90                   	nop

f012469c <__moddi3>:
f012469c:	55                   	push   %ebp
f012469d:	57                   	push   %edi
f012469e:	56                   	push   %esi
f012469f:	53                   	push   %ebx
f01246a0:	83 ec 2c             	sub    $0x2c,%esp
f01246a3:	8b 74 24 40          	mov    0x40(%esp),%esi
f01246a7:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01246ab:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f01246af:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01246b3:	89 d8                	mov    %ebx,%eax
f01246b5:	85 ff                	test   %edi,%edi
f01246b7:	0f 88 d3 00 00 00    	js     f0124790 <__moddi3+0xf4>
f01246bd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01246c4:	00 
f01246c5:	85 c0                	test   %eax,%eax
f01246c7:	0f 88 ab 00 00 00    	js     f0124778 <__moddi3+0xdc>
f01246cd:	89 0c 24             	mov    %ecx,(%esp)
f01246d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01246d4:	89 74 24 10          	mov    %esi,0x10(%esp)
f01246d8:	89 fb                	mov    %edi,%ebx
f01246da:	8b 14 24             	mov    (%esp),%edx
f01246dd:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01246e1:	89 d0                	mov    %edx,%eax
f01246e3:	89 54 24 18          	mov    %edx,0x18(%esp)
f01246e7:	89 ca                	mov    %ecx,%edx
f01246e9:	8b 0c 24             	mov    (%esp),%ecx
f01246ec:	89 34 24             	mov    %esi,(%esp)
f01246ef:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01246f3:	85 d2                	test   %edx,%edx
f01246f5:	75 15                	jne    f012470c <__moddi3+0x70>
f01246f7:	89 c7                	mov    %eax,%edi
f01246f9:	39 d8                	cmp    %ebx,%eax
f01246fb:	76 5b                	jbe    f0124758 <__moddi3+0xbc>
f01246fd:	89 f0                	mov    %esi,%eax
f01246ff:	89 da                	mov    %ebx,%edx
f0124701:	f7 f7                	div    %edi
f0124703:	89 d3                	mov    %edx,%ebx
f0124705:	89 d8                	mov    %ebx,%eax
f0124707:	31 d2                	xor    %edx,%edx
f0124709:	eb 09                	jmp    f0124714 <__moddi3+0x78>
f012470b:	90                   	nop
f012470c:	39 fa                	cmp    %edi,%edx
f012470e:	76 1c                	jbe    f012472c <__moddi3+0x90>
f0124710:	89 f0                	mov    %esi,%eax
f0124712:	89 fa                	mov    %edi,%edx
f0124714:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0124718:	85 c9                	test   %ecx,%ecx
f012471a:	74 07                	je     f0124723 <__moddi3+0x87>
f012471c:	f7 d8                	neg    %eax
f012471e:	83 d2 00             	adc    $0x0,%edx
f0124721:	f7 da                	neg    %edx
f0124723:	83 c4 2c             	add    $0x2c,%esp
f0124726:	5b                   	pop    %ebx
f0124727:	5e                   	pop    %esi
f0124728:	5f                   	pop    %edi
f0124729:	5d                   	pop    %ebp
f012472a:	c3                   	ret    
f012472b:	90                   	nop
f012472c:	0f bd c2             	bsr    %edx,%eax
f012472f:	83 f0 1f             	xor    $0x1f,%eax
f0124732:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0124736:	75 6c                	jne    f01247a4 <__moddi3+0x108>
f0124738:	39 fa                	cmp    %edi,%edx
f012473a:	72 05                	jb     f0124741 <__moddi3+0xa5>
f012473c:	3b 0c 24             	cmp    (%esp),%ecx
f012473f:	77 0e                	ja     f012474f <__moddi3+0xb3>
f0124741:	8b 34 24             	mov    (%esp),%esi
f0124744:	29 ce                	sub    %ecx,%esi
f0124746:	19 d3                	sbb    %edx,%ebx
f0124748:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f012474c:	89 34 24             	mov    %esi,(%esp)
f012474f:	8b 04 24             	mov    (%esp),%eax
f0124752:	8b 54 24 14          	mov    0x14(%esp),%edx
f0124756:	eb bc                	jmp    f0124714 <__moddi3+0x78>
f0124758:	85 c9                	test   %ecx,%ecx
f012475a:	75 0b                	jne    f0124767 <__moddi3+0xcb>
f012475c:	b8 01 00 00 00       	mov    $0x1,%eax
f0124761:	31 d2                	xor    %edx,%edx
f0124763:	f7 f1                	div    %ecx
f0124765:	89 c1                	mov    %eax,%ecx
f0124767:	89 d8                	mov    %ebx,%eax
f0124769:	31 d2                	xor    %edx,%edx
f012476b:	f7 f1                	div    %ecx
f012476d:	8b 04 24             	mov    (%esp),%eax
f0124770:	f7 f1                	div    %ecx
f0124772:	89 d3                	mov    %edx,%ebx
f0124774:	eb 8f                	jmp    f0124705 <__moddi3+0x69>
f0124776:	66 90                	xchg   %ax,%ax
f0124778:	89 c8                	mov    %ecx,%eax
f012477a:	89 da                	mov    %ebx,%edx
f012477c:	f7 d8                	neg    %eax
f012477e:	83 d2 00             	adc    $0x0,%edx
f0124781:	f7 da                	neg    %edx
f0124783:	89 04 24             	mov    %eax,(%esp)
f0124786:	89 54 24 04          	mov    %edx,0x4(%esp)
f012478a:	e9 45 ff ff ff       	jmp    f01246d4 <__moddi3+0x38>
f012478f:	90                   	nop
f0124790:	f7 de                	neg    %esi
f0124792:	83 d7 00             	adc    $0x0,%edi
f0124795:	f7 df                	neg    %edi
f0124797:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f012479e:	ff 
f012479f:	e9 21 ff ff ff       	jmp    f01246c5 <__moddi3+0x29>
f01247a4:	b8 20 00 00 00       	mov    $0x20,%eax
f01247a9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01247ad:	29 f8                	sub    %edi,%eax
f01247af:	89 c6                	mov    %eax,%esi
f01247b1:	89 44 24 14          	mov    %eax,0x14(%esp)
f01247b5:	89 f9                	mov    %edi,%ecx
f01247b7:	d3 e2                	shl    %cl,%edx
f01247b9:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01247bd:	89 e8                	mov    %ebp,%eax
f01247bf:	89 f1                	mov    %esi,%ecx
f01247c1:	d3 e8                	shr    %cl,%eax
f01247c3:	09 d0                	or     %edx,%eax
f01247c5:	89 04 24             	mov    %eax,(%esp)
f01247c8:	89 ea                	mov    %ebp,%edx
f01247ca:	89 f9                	mov    %edi,%ecx
f01247cc:	d3 e2                	shl    %cl,%edx
f01247ce:	89 d7                	mov    %edx,%edi
f01247d0:	89 da                	mov    %ebx,%edx
f01247d2:	d3 e2                	shl    %cl,%edx
f01247d4:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01247d8:	d3 e5                	shl    %cl,%ebp
f01247da:	8b 44 24 10          	mov    0x10(%esp),%eax
f01247de:	89 f1                	mov    %esi,%ecx
f01247e0:	d3 e8                	shr    %cl,%eax
f01247e2:	09 d0                	or     %edx,%eax
f01247e4:	d3 eb                	shr    %cl,%ebx
f01247e6:	89 da                	mov    %ebx,%edx
f01247e8:	f7 34 24             	divl   (%esp)
f01247eb:	89 d3                	mov    %edx,%ebx
f01247ed:	f7 e7                	mul    %edi
f01247ef:	89 c6                	mov    %eax,%esi
f01247f1:	89 d1                	mov    %edx,%ecx
f01247f3:	39 d3                	cmp    %edx,%ebx
f01247f5:	72 29                	jb     f0124820 <__moddi3+0x184>
f01247f7:	74 33                	je     f012482c <__moddi3+0x190>
f01247f9:	89 e8                	mov    %ebp,%eax
f01247fb:	29 f0                	sub    %esi,%eax
f01247fd:	19 cb                	sbb    %ecx,%ebx
f01247ff:	89 de                	mov    %ebx,%esi
f0124801:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0124805:	d3 e6                	shl    %cl,%esi
f0124807:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f012480b:	89 f9                	mov    %edi,%ecx
f012480d:	d3 e8                	shr    %cl,%eax
f012480f:	09 c6                	or     %eax,%esi
f0124811:	89 f0                	mov    %esi,%eax
f0124813:	89 f9                	mov    %edi,%ecx
f0124815:	d3 eb                	shr    %cl,%ebx
f0124817:	89 da                	mov    %ebx,%edx
f0124819:	e9 f6 fe ff ff       	jmp    f0124714 <__moddi3+0x78>
f012481e:	66 90                	xchg   %ax,%ax
f0124820:	29 f8                	sub    %edi,%eax
f0124822:	1b 14 24             	sbb    (%esp),%edx
f0124825:	89 d1                	mov    %edx,%ecx
f0124827:	89 c6                	mov    %eax,%esi
f0124829:	eb ce                	jmp    f01247f9 <__moddi3+0x15d>
f012482b:	90                   	nop
f012482c:	39 c5                	cmp    %eax,%ebp
f012482e:	72 f0                	jb     f0124820 <__moddi3+0x184>
f0124830:	89 d9                	mov    %ebx,%ecx
f0124832:	eb c5                	jmp    f01247f9 <__moddi3+0x15d>

f0124834 <__udivdi3>:
f0124834:	55                   	push   %ebp
f0124835:	57                   	push   %edi
f0124836:	56                   	push   %esi
f0124837:	53                   	push   %ebx
f0124838:	83 ec 1c             	sub    $0x1c,%esp
f012483b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012483f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0124843:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0124847:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012484b:	89 ca                	mov    %ecx,%edx
f012484d:	89 f8                	mov    %edi,%eax
f012484f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0124853:	85 f6                	test   %esi,%esi
f0124855:	75 2d                	jne    f0124884 <__udivdi3+0x50>
f0124857:	39 cf                	cmp    %ecx,%edi
f0124859:	77 65                	ja     f01248c0 <__udivdi3+0x8c>
f012485b:	89 fd                	mov    %edi,%ebp
f012485d:	85 ff                	test   %edi,%edi
f012485f:	75 0b                	jne    f012486c <__udivdi3+0x38>
f0124861:	b8 01 00 00 00       	mov    $0x1,%eax
f0124866:	31 d2                	xor    %edx,%edx
f0124868:	f7 f7                	div    %edi
f012486a:	89 c5                	mov    %eax,%ebp
f012486c:	31 d2                	xor    %edx,%edx
f012486e:	89 c8                	mov    %ecx,%eax
f0124870:	f7 f5                	div    %ebp
f0124872:	89 c1                	mov    %eax,%ecx
f0124874:	89 d8                	mov    %ebx,%eax
f0124876:	f7 f5                	div    %ebp
f0124878:	89 cf                	mov    %ecx,%edi
f012487a:	89 fa                	mov    %edi,%edx
f012487c:	83 c4 1c             	add    $0x1c,%esp
f012487f:	5b                   	pop    %ebx
f0124880:	5e                   	pop    %esi
f0124881:	5f                   	pop    %edi
f0124882:	5d                   	pop    %ebp
f0124883:	c3                   	ret    
f0124884:	39 ce                	cmp    %ecx,%esi
f0124886:	77 28                	ja     f01248b0 <__udivdi3+0x7c>
f0124888:	0f bd fe             	bsr    %esi,%edi
f012488b:	83 f7 1f             	xor    $0x1f,%edi
f012488e:	75 40                	jne    f01248d0 <__udivdi3+0x9c>
f0124890:	39 ce                	cmp    %ecx,%esi
f0124892:	72 0a                	jb     f012489e <__udivdi3+0x6a>
f0124894:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0124898:	0f 87 9e 00 00 00    	ja     f012493c <__udivdi3+0x108>
f012489e:	b8 01 00 00 00       	mov    $0x1,%eax
f01248a3:	89 fa                	mov    %edi,%edx
f01248a5:	83 c4 1c             	add    $0x1c,%esp
f01248a8:	5b                   	pop    %ebx
f01248a9:	5e                   	pop    %esi
f01248aa:	5f                   	pop    %edi
f01248ab:	5d                   	pop    %ebp
f01248ac:	c3                   	ret    
f01248ad:	8d 76 00             	lea    0x0(%esi),%esi
f01248b0:	31 ff                	xor    %edi,%edi
f01248b2:	31 c0                	xor    %eax,%eax
f01248b4:	89 fa                	mov    %edi,%edx
f01248b6:	83 c4 1c             	add    $0x1c,%esp
f01248b9:	5b                   	pop    %ebx
f01248ba:	5e                   	pop    %esi
f01248bb:	5f                   	pop    %edi
f01248bc:	5d                   	pop    %ebp
f01248bd:	c3                   	ret    
f01248be:	66 90                	xchg   %ax,%ax
f01248c0:	89 d8                	mov    %ebx,%eax
f01248c2:	f7 f7                	div    %edi
f01248c4:	31 ff                	xor    %edi,%edi
f01248c6:	89 fa                	mov    %edi,%edx
f01248c8:	83 c4 1c             	add    $0x1c,%esp
f01248cb:	5b                   	pop    %ebx
f01248cc:	5e                   	pop    %esi
f01248cd:	5f                   	pop    %edi
f01248ce:	5d                   	pop    %ebp
f01248cf:	c3                   	ret    
f01248d0:	bd 20 00 00 00       	mov    $0x20,%ebp
f01248d5:	89 eb                	mov    %ebp,%ebx
f01248d7:	29 fb                	sub    %edi,%ebx
f01248d9:	89 f9                	mov    %edi,%ecx
f01248db:	d3 e6                	shl    %cl,%esi
f01248dd:	89 c5                	mov    %eax,%ebp
f01248df:	88 d9                	mov    %bl,%cl
f01248e1:	d3 ed                	shr    %cl,%ebp
f01248e3:	89 e9                	mov    %ebp,%ecx
f01248e5:	09 f1                	or     %esi,%ecx
f01248e7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01248eb:	89 f9                	mov    %edi,%ecx
f01248ed:	d3 e0                	shl    %cl,%eax
f01248ef:	89 c5                	mov    %eax,%ebp
f01248f1:	89 d6                	mov    %edx,%esi
f01248f3:	88 d9                	mov    %bl,%cl
f01248f5:	d3 ee                	shr    %cl,%esi
f01248f7:	89 f9                	mov    %edi,%ecx
f01248f9:	d3 e2                	shl    %cl,%edx
f01248fb:	8b 44 24 08          	mov    0x8(%esp),%eax
f01248ff:	88 d9                	mov    %bl,%cl
f0124901:	d3 e8                	shr    %cl,%eax
f0124903:	09 c2                	or     %eax,%edx
f0124905:	89 d0                	mov    %edx,%eax
f0124907:	89 f2                	mov    %esi,%edx
f0124909:	f7 74 24 0c          	divl   0xc(%esp)
f012490d:	89 d6                	mov    %edx,%esi
f012490f:	89 c3                	mov    %eax,%ebx
f0124911:	f7 e5                	mul    %ebp
f0124913:	39 d6                	cmp    %edx,%esi
f0124915:	72 19                	jb     f0124930 <__udivdi3+0xfc>
f0124917:	74 0b                	je     f0124924 <__udivdi3+0xf0>
f0124919:	89 d8                	mov    %ebx,%eax
f012491b:	31 ff                	xor    %edi,%edi
f012491d:	e9 58 ff ff ff       	jmp    f012487a <__udivdi3+0x46>
f0124922:	66 90                	xchg   %ax,%ax
f0124924:	8b 54 24 08          	mov    0x8(%esp),%edx
f0124928:	89 f9                	mov    %edi,%ecx
f012492a:	d3 e2                	shl    %cl,%edx
f012492c:	39 c2                	cmp    %eax,%edx
f012492e:	73 e9                	jae    f0124919 <__udivdi3+0xe5>
f0124930:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0124933:	31 ff                	xor    %edi,%edi
f0124935:	e9 40 ff ff ff       	jmp    f012487a <__udivdi3+0x46>
f012493a:	66 90                	xchg   %ax,%ax
f012493c:	31 c0                	xor    %eax,%eax
f012493e:	e9 37 ff ff ff       	jmp    f012487a <__udivdi3+0x46>
f0124943:	90                   	nop

f0124944 <__umoddi3>:
f0124944:	55                   	push   %ebp
f0124945:	57                   	push   %edi
f0124946:	56                   	push   %esi
f0124947:	53                   	push   %ebx
f0124948:	83 ec 1c             	sub    $0x1c,%esp
f012494b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012494f:	8b 74 24 34          	mov    0x34(%esp),%esi
f0124953:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0124957:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f012495b:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012495f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0124963:	89 f3                	mov    %esi,%ebx
f0124965:	89 fa                	mov    %edi,%edx
f0124967:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012496b:	89 34 24             	mov    %esi,(%esp)
f012496e:	85 c0                	test   %eax,%eax
f0124970:	75 1a                	jne    f012498c <__umoddi3+0x48>
f0124972:	39 f7                	cmp    %esi,%edi
f0124974:	0f 86 a2 00 00 00    	jbe    f0124a1c <__umoddi3+0xd8>
f012497a:	89 c8                	mov    %ecx,%eax
f012497c:	89 f2                	mov    %esi,%edx
f012497e:	f7 f7                	div    %edi
f0124980:	89 d0                	mov    %edx,%eax
f0124982:	31 d2                	xor    %edx,%edx
f0124984:	83 c4 1c             	add    $0x1c,%esp
f0124987:	5b                   	pop    %ebx
f0124988:	5e                   	pop    %esi
f0124989:	5f                   	pop    %edi
f012498a:	5d                   	pop    %ebp
f012498b:	c3                   	ret    
f012498c:	39 f0                	cmp    %esi,%eax
f012498e:	0f 87 ac 00 00 00    	ja     f0124a40 <__umoddi3+0xfc>
f0124994:	0f bd e8             	bsr    %eax,%ebp
f0124997:	83 f5 1f             	xor    $0x1f,%ebp
f012499a:	0f 84 ac 00 00 00    	je     f0124a4c <__umoddi3+0x108>
f01249a0:	bf 20 00 00 00       	mov    $0x20,%edi
f01249a5:	29 ef                	sub    %ebp,%edi
f01249a7:	89 fe                	mov    %edi,%esi
f01249a9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f01249ad:	89 e9                	mov    %ebp,%ecx
f01249af:	d3 e0                	shl    %cl,%eax
f01249b1:	89 d7                	mov    %edx,%edi
f01249b3:	89 f1                	mov    %esi,%ecx
f01249b5:	d3 ef                	shr    %cl,%edi
f01249b7:	09 c7                	or     %eax,%edi
f01249b9:	89 e9                	mov    %ebp,%ecx
f01249bb:	d3 e2                	shl    %cl,%edx
f01249bd:	89 14 24             	mov    %edx,(%esp)
f01249c0:	89 d8                	mov    %ebx,%eax
f01249c2:	d3 e0                	shl    %cl,%eax
f01249c4:	89 c2                	mov    %eax,%edx
f01249c6:	8b 44 24 08          	mov    0x8(%esp),%eax
f01249ca:	d3 e0                	shl    %cl,%eax
f01249cc:	89 44 24 04          	mov    %eax,0x4(%esp)
f01249d0:	8b 44 24 08          	mov    0x8(%esp),%eax
f01249d4:	89 f1                	mov    %esi,%ecx
f01249d6:	d3 e8                	shr    %cl,%eax
f01249d8:	09 d0                	or     %edx,%eax
f01249da:	d3 eb                	shr    %cl,%ebx
f01249dc:	89 da                	mov    %ebx,%edx
f01249de:	f7 f7                	div    %edi
f01249e0:	89 d3                	mov    %edx,%ebx
f01249e2:	f7 24 24             	mull   (%esp)
f01249e5:	89 c6                	mov    %eax,%esi
f01249e7:	89 d1                	mov    %edx,%ecx
f01249e9:	39 d3                	cmp    %edx,%ebx
f01249eb:	0f 82 87 00 00 00    	jb     f0124a78 <__umoddi3+0x134>
f01249f1:	0f 84 91 00 00 00    	je     f0124a88 <__umoddi3+0x144>
f01249f7:	8b 54 24 04          	mov    0x4(%esp),%edx
f01249fb:	29 f2                	sub    %esi,%edx
f01249fd:	19 cb                	sbb    %ecx,%ebx
f01249ff:	89 d8                	mov    %ebx,%eax
f0124a01:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0124a05:	d3 e0                	shl    %cl,%eax
f0124a07:	89 e9                	mov    %ebp,%ecx
f0124a09:	d3 ea                	shr    %cl,%edx
f0124a0b:	09 d0                	or     %edx,%eax
f0124a0d:	89 e9                	mov    %ebp,%ecx
f0124a0f:	d3 eb                	shr    %cl,%ebx
f0124a11:	89 da                	mov    %ebx,%edx
f0124a13:	83 c4 1c             	add    $0x1c,%esp
f0124a16:	5b                   	pop    %ebx
f0124a17:	5e                   	pop    %esi
f0124a18:	5f                   	pop    %edi
f0124a19:	5d                   	pop    %ebp
f0124a1a:	c3                   	ret    
f0124a1b:	90                   	nop
f0124a1c:	89 fd                	mov    %edi,%ebp
f0124a1e:	85 ff                	test   %edi,%edi
f0124a20:	75 0b                	jne    f0124a2d <__umoddi3+0xe9>
f0124a22:	b8 01 00 00 00       	mov    $0x1,%eax
f0124a27:	31 d2                	xor    %edx,%edx
f0124a29:	f7 f7                	div    %edi
f0124a2b:	89 c5                	mov    %eax,%ebp
f0124a2d:	89 f0                	mov    %esi,%eax
f0124a2f:	31 d2                	xor    %edx,%edx
f0124a31:	f7 f5                	div    %ebp
f0124a33:	89 c8                	mov    %ecx,%eax
f0124a35:	f7 f5                	div    %ebp
f0124a37:	89 d0                	mov    %edx,%eax
f0124a39:	e9 44 ff ff ff       	jmp    f0124982 <__umoddi3+0x3e>
f0124a3e:	66 90                	xchg   %ax,%ax
f0124a40:	89 c8                	mov    %ecx,%eax
f0124a42:	89 f2                	mov    %esi,%edx
f0124a44:	83 c4 1c             	add    $0x1c,%esp
f0124a47:	5b                   	pop    %ebx
f0124a48:	5e                   	pop    %esi
f0124a49:	5f                   	pop    %edi
f0124a4a:	5d                   	pop    %ebp
f0124a4b:	c3                   	ret    
f0124a4c:	3b 04 24             	cmp    (%esp),%eax
f0124a4f:	72 06                	jb     f0124a57 <__umoddi3+0x113>
f0124a51:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0124a55:	77 0f                	ja     f0124a66 <__umoddi3+0x122>
f0124a57:	89 f2                	mov    %esi,%edx
f0124a59:	29 f9                	sub    %edi,%ecx
f0124a5b:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0124a5f:	89 14 24             	mov    %edx,(%esp)
f0124a62:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0124a66:	8b 44 24 04          	mov    0x4(%esp),%eax
f0124a6a:	8b 14 24             	mov    (%esp),%edx
f0124a6d:	83 c4 1c             	add    $0x1c,%esp
f0124a70:	5b                   	pop    %ebx
f0124a71:	5e                   	pop    %esi
f0124a72:	5f                   	pop    %edi
f0124a73:	5d                   	pop    %ebp
f0124a74:	c3                   	ret    
f0124a75:	8d 76 00             	lea    0x0(%esi),%esi
f0124a78:	2b 04 24             	sub    (%esp),%eax
f0124a7b:	19 fa                	sbb    %edi,%edx
f0124a7d:	89 d1                	mov    %edx,%ecx
f0124a7f:	89 c6                	mov    %eax,%esi
f0124a81:	e9 71 ff ff ff       	jmp    f01249f7 <__umoddi3+0xb3>
f0124a86:	66 90                	xchg   %ax,%ax
f0124a88:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0124a8c:	72 ea                	jb     f0124a78 <__umoddi3+0x134>
f0124a8e:	89 d9                	mov    %ebx,%ecx
f0124a90:	e9 62 ff ff ff       	jmp    f01249f7 <__umoddi3+0xb3>
